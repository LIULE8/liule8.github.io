<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java并发编程之原子类-原子类是如何利用 CAS 保证线程安全的？ | Leo's notes</title><meta name="keywords" content="Java,并发编程,线程"><meta name="author" content="Leo Liu"><meta name="copyright" content="Leo Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原子类是如何利用 CAS 保证线程安全的？什么是原子类？原子类有什么作用？要想回答这个问题，首先我们需要知道什么是原子类，以及它有什么作用。 在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。而 java.util.concurrent.atomic 下的类，就是具有原子性的类，可以原子性地执行添加、递增、递减等操作。比如之前多线程下的线程不安全的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程之原子类-原子类是如何利用 CAS 保证线程安全的？">
<meta property="og:url" content="https://liule8.github.io/post/7b46e5fa.html">
<meta property="og:site_name" content="Leo&#39;s notes">
<meta property="og:description" content="原子类是如何利用 CAS 保证线程安全的？什么是原子类？原子类有什么作用？要想回答这个问题，首先我们需要知道什么是原子类，以及它有什么作用。 在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。而 java.util.concurrent.atomic 下的类，就是具有原子性的类，可以原子性地执行添加、递增、递减等操作。比如之前多线程下的线程不安全的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-09-24T19:44:11.000Z">
<meta property="article:modified_time" content="2021-10-16T05:06:48.320Z">
<meta property="article:author" content="Leo Liu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liule8.github.io/post/7b46e5fa"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-16 05:06:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">351</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leo's notes</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java并发编程之原子类-原子类是如何利用 CAS 保证线程安全的？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-24T19:44:11.000Z" title="发表于 2021-09-24 19:44:11">2021-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-16T05:06:48.320Z" title="更新于 2021-10-16 05:06:48">2021-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程之原子类-原子类是如何利用 CAS 保证线程安全的？"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="原子类是如何利用-CAS-保证线程安全的？"><a href="#原子类是如何利用-CAS-保证线程安全的？" class="headerlink" title="原子类是如何利用 CAS 保证线程安全的？"></a>原子类是如何利用 CAS 保证线程安全的？</h1><h2 id="什么是原子类？原子类有什么作用？"><a href="#什么是原子类？原子类有什么作用？" class="headerlink" title="什么是原子类？原子类有什么作用？"></a>什么是原子类？原子类有什么作用？</h2><p>要想回答这个问题，首先我们需要知道什么是原子类，以及它有什么作用。</p>
<p>在编程领域里，原子性意味着“一组操作要么全都操作成功，要么全都失败，不能只操作成功其中的一部分”。而 <code>java.util.concurrent.atomic</code> 下的类，<strong>就是具有原子性的类，可以原子性地执行添加、递增、递减等操作</strong>。比如之前多线程下的线程不安全的 i++ 问题，到了原子类这里，就可以用功能相同且线程安全的 <code>getAndIncrement</code> 方法来优雅地解决。</p>
<p><strong>原子类的作用</strong>和锁有类似之处，是<strong>为了保证并发情况下线程安全</strong>。不过原子类相比于锁，有一定的优势：</p>
<ul>
<li><p>粒度更细：原子变量可以把竞争范围缩小到变量级别，通常情况下，锁的粒度都要大于原子变量的粒度。</p>
</li>
<li><p>效率更高：除了高度竞争的情况之外，使用原子类的效率通常会比使用同步互斥锁的效率更高，因为原子类底层利用了 CAS 操作，不会阻塞线程。</p>
</li>
</ul>
<h2 id="6-类原子类纵览"><a href="#6-类原子类纵览" class="headerlink" title="6 类原子类纵览"></a>6 类原子类纵览</h2><p>下面我们来看下一共有哪些原子类，原子类一共可以分为以下这 6 类，我们来逐一介绍：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">具体类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Atomic* 基本类型原子类</td>
<td align="center"><code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code></td>
</tr>
<tr>
<td align="center">Atomic*Array 数组类型原子类</td>
<td align="center"><code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code></td>
</tr>
<tr>
<td align="center">Atomic*Reference 引用类型原子类</td>
<td align="center"><code>AtomicReference</code>、<code>AtomicStampedReference</code>、<code>AtomicMarkableReference</code></td>
</tr>
<tr>
<td align="center">Atomic*FieldUpdater 升级类型原子类</td>
<td align="center"><code>AtomicIntegerfieldupdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code></td>
</tr>
<tr>
<td align="center">Adder 累加器</td>
<td align="center"><code>LongAdder</code>、<code>DoubleAdder</code></td>
</tr>
<tr>
<td align="center">Accumulator 积累器</td>
<td align="center"><code>LongAccumulator</code>、<code>DoubleAccumulator</code></td>
</tr>
</tbody></table>
<h3 id="Atomic-基本类型原子类"><a href="#Atomic-基本类型原子类" class="headerlink" title="Atomic\ 基本类型原子类"></a>Atomic\ 基本类型原子类</h3><p>首先看到第一类 Atomic*，我们把它称为基本类型原子类，它包括三种，分别是 <code>AtomicInteger</code>、<code>AtomicLong</code> 和 <code>AtomicBoolean</code>。</p>
<p>我们来介绍一下最为典型的 <code>AtomicInteger</code>。对于这个类型而言，它是对于 int 类型的封装，并且提供了原子性的访问和更新。也就是说，我们如果需要一个整型的变量，并且这个变量会被运用在并发场景之下，我们可以不用基本类型 int，也不使用包装类型 Integer，而是直接使用 <code>AtomicInteger</code>，这样一来就自动具备了原子能力，使用起来非常方便。</p>
<h4 id="AtomicInteger-类常用方法"><a href="#AtomicInteger-类常用方法" class="headerlink" title="AtomicInteger 类常用方法"></a>AtomicInteger 类常用方法</h4><p><code>AtomicInteger</code> 类有以下几个常用的方法：</p>
<ul>
<li>public final int get() //获取当前的值</li>
</ul>
<p>因为它本身是一个 Java 类，而不再是一个基本类型，所以要想获取值还是需要一些方法，比如通过 get 方法就可以获取到当前的值。</p>
<ul>
<li>public final int getAndSet(int newValue) //获取当前的值，并设置新的值</li>
</ul>
<p>接下来的几个方法和它平时的操作相关：</p>
<ul>
<li><p>public final int getAndIncrement() //获取当前的值，并自增</p>
</li>
<li><p>public final int getAndDecrement() //获取当前的值，并自减</p>
</li>
<li><p>public final int getAndAdd(int delta) //获取当前的值，并加上预期的值</p>
</li>
</ul>
<p>这个参数就是我想让当前这个原子类改变多少值，可以是正数也可以是负数，如果是正数就是增加，如果是负数就是减少。而刚才的 getAndIncrement 和 getAndDecrement 修改的数值默认为 +1 或 -1，如果不能满足需求，我们就可以使用  getAndAdd 方法来直接一次性地加减我们想要的数值。</p>
<ul>
<li>boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值更新为输入值（update）</li>
</ul>
<p>这个方法也是 CAS 的一个重要体现。</p>
<h3 id="Array-数组类型原子类"><a href="#Array-数组类型原子类" class="headerlink" title="Array 数组类型原子类"></a>Array 数组类型原子类</h3><p>下面我们来看第二大类 Atomic * Array 数组类型原子类，数组里的元素，都可以保证其原子性，比如 <code>AtomicIntegerArray</code> 相当于把 <code>AtomicInteger</code> 聚合起来，组合成一个数组。这样一来，我们如果想用一个每一个元素都具备原子性的数组的话， 就可以使用 Atomic*Array。</p>
<p>它一共分为 3 种，分别是：</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类；</li>
<li><code>AtomicLongArray</code>：长整形数组原子类；</li>
<li><code>AtomicReferenceArray</code> ：引用类型数组原子类。</li>
</ul>
<h3 id="Atomic-Reference-引用类型原子类"><a href="#Atomic-Reference-引用类型原子类" class="headerlink" title="Atomic\Reference 引用类型原子类"></a>Atomic\Reference 引用类型原子类</h3><p>下面我们介绍第三种 <code>AtomicReference</code> 引用类型原子类。<code>AtomicReference</code> 类的作用和<code>AtomicInteger</code> 并没有本质区别， <code>AtomicInteger</code> 可以让一个整数保证原子性，而<code>AtomicReference</code> 可以让一个对象保证原子性。这样一来，<code>AtomicReference</code> 的能力明显比 <code>AtomicInteger</code> 强，因为一个对象里可以包含很多属性。</p>
<p>在这个类别之下，除了 <code>AtomicReference</code> 之外，还有：</p>
<ul>
<li><code>AtomicStampedReference</code>：它是对 <code>AtomicReference</code> 的升级，在此基础上还加了时间戳，用于解决 CAS 的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code>：和 <code>AtomicReference</code> 类似，多了一个绑定的布尔值，可以用于表示该对象已删除等场景。</li>
</ul>
<h3 id="Atomic-FieldUpdater-原子更新器"><a href="#Atomic-FieldUpdater-原子更新器" class="headerlink" title="Atomic\FieldUpdater 原子更新器"></a>Atomic\FieldUpdater 原子更新器</h3><p>第四类我们将要介绍的是 Atomic\FieldUpdater，我们把它称为原子更新器，一共有三种，分别是。</p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形的更新器；</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形的更新器；</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用的更新器。</li>
</ul>
<p>如果我们之前已经有了一个变量，比如是整型的 int，实际它并不具备原子性。可是木已成舟，这个变量已经被定义好了，此时我们有没有办法可以让它拥有原子性呢？办法是有的，就是利用 Atomic*FieldUpdater，如果它是整型的，就使用 <code>AtomicIntegerFieldUpdater</code> 把已经声明的变量进行升级，这样一来这个变量就拥有了 CAS 操作的能力。</p>
<p>这里的非互斥同步手段，是把我们已经声明好的变量进行 CAS 操作以达到同步的目的。那么你可能会想，既然想让这个变量具备原子性，为什么不在一开始就声明为 <code>AtomicInteger</code>？这样也免去了升级的过程，难道是一开始设计的时候不合理吗？这里有以下几种情况：</p>
<p>第一种情况是出于历史原因考虑，那么如果出于历史原因的话，之前这个变量已经被声明过了而且被广泛运用，那么修改它成本很高，所以我们可以利用升级的原子类。</p>
<p>另外还有一个使用场景，如果我们在大部分情况下并不需要使用到它的原子性，只在少数情况，比如每天只有定时一两次需要原子操作的话，我们其实没有必要把原来的变量声明为原子类型的变量，因为 <code>AtomicInteger</code> 比普通的变量更加耗费资源。所以如果我们有成千上万个原子类的实例的话，它占用的内存也会远比我们成千上万个普通类型占用的内存高。所以在这种情况下，我们可以利用 <code>AtomicIntegerFieldUpdater</code> 进行合理升级，节约内存。</p>
<p>下面我们看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Score math;</span><br><span class="line">    <span class="keyword">static</span> Score computer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;Score&gt; scoreUpdater = AtomicIntegerFieldUpdater</span><br><span class="line">            .newUpdater(Score.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            computer.score++;</span><br><span class="line">            scoreUpdater.getAndIncrement(math);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Score</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        math = <span class="keyword">new</span> Score();</span><br><span class="line">        computer = <span class="keyword">new</span> Score();</span><br><span class="line">        AtomicIntegerFieldUpdaterDemo r = <span class="keyword">new</span> AtomicIntegerFieldUpdaterDemo();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;普通变量的结果：&quot;</span> + computer.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;升级后的结果：&quot;</span> + math.score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就演示了这个类的用法，比如说我们有两个类，它们都是 Score 类型的，Score 类型内部会有一个分数，也叫作 core，那么这两个分数的实例分别叫作数学 math 和计算机  computer，然后我们还声明了一个 <code>AtomicIntegerFieldUpdater</code>，在它构造的时候传入了两个参数，第一个是 <code>Score.class</code>，这是我们的类名，第二个是属性名，叫作 score。</p>
<p>接下来我们看一下 run 方法，run 方法里面会对这两个实例分别进行自加操作。</p>
<p>第一个是 computer，这里的 computer 我们调用的是它内部的 score，也就是说我们直接调用了 int 变量的自加操作，这在多线程下是线程非安全的。</p>
<p>第二个自加是利用了刚才声明的 scoreUpdater 并且使用了它的 getAndIncrement 方法并且传入了 math，这是一种正确使用<code>AtomicIntegerFieldUpdater</code> 的用法，这样可以线程安全地进行自加操作。</p>
<p>接下来我们看下 main 函数。在 main 函数中，我们首先把 math 和 computer 定义了出来，然后分别启动了两个线程，每个线程都去执行我们刚才所介绍过的 run 方法。这样一来，两个 score，也就是 math 和 computer 都会分别被加 2000 次，最后我们在 join 等待之后把结果打印了出来，这个程序的运行结果如下：</p>
<p>普通变量的结果：1993<br>升级后的结果：2000</p>
<p>可以看出，正如我们所预料的那样，普通变量由于不具备线程安全性，所以在多线程操作的情况下，它虽然看似进行了 2000 次操作，但有一些操作被冲突抵消了，所以最终结果小于 2000。可是使用 <code>AtomicIntegerFieldUpdater</code>  这个工具之后，就可以做到把一个普通类型的 score 变量进行原子的自加操作，最后的结果也和加的次数是一样的，也就是 2000。可以看出，这个类的功能还是非常强大的。</p>
<p>下面我们继续看最后两种原子类。</p>
<h3 id="Adder-加法器"><a href="#Adder-加法器" class="headerlink" title="Adder 加法器"></a>Adder 加法器</h3><p>它里面有两种加法器，分别叫作 <code>LongAdder</code> 和 <code>DoubleAdder</code>。</p>
<h3 id="Accumulator-积累器"><a href="#Accumulator-积累器" class="headerlink" title="Accumulator 积累器"></a>Accumulator 积累器</h3><p>最后一种叫 Accumulator 积累器，分别是 <code>LongAccumulator</code> 和 <code>DoubleAccumulator</code>。</p>
<h2 id="以-AtomicInteger-为例，分析在-Java-中如何利用-CAS-实现原子操作？"><a href="#以-AtomicInteger-为例，分析在-Java-中如何利用-CAS-实现原子操作？" class="headerlink" title="以 AtomicInteger 为例，分析在 Java 中如何利用 CAS 实现原子操作？"></a>以 AtomicInteger 为例，分析在 Java 中如何利用 CAS 实现原子操作？</h2><p>让我们回到标题中的问题，在充分了解了原子类的作用和种类之后，我们来看下  <code>AtomicInteger</code> 是如何通过 CAS 操作实现并发下的累加操作的，以其中一个重要方法 getAndAdd 方法为突破口。</p>
<h3 id="getAndAdd方法"><a href="#getAndAdd方法" class="headerlink" title="getAndAdd方法"></a>getAndAdd方法</h3><p>这个方法的代码在 Java 1.8 中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK  1.8实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，里面使用了 Unsafe 这个类，并且调用了 unsafe.getAndAddInt 方法。所以这里需要简要介绍一下 Unsafe 类。</p>
<h3 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h3><p><strong>Unsafe 类主要是用于和操作系统打交道的</strong>，因为大部分的 Java 代码自身无法直接操作内存，所以在必要的时候，可以利用 Unsafe 类来和操作系统进行交互，CAS 正是利用到了 Unsafe 类。</p>
<p>那么我们就来看一下 <code>AtomicInteger</code> 的一些重要代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  setup  to  use  Unsafe.compareAndSwapInt  for  updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                    (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在数据定义的部分，首先还获取了 Unsafe 实例，并且定义了 valueOffset。我们往下看到 static 代码块，这个代码块会在类加载的时候执行，执行时我们会调用 Unsafe 的 objectFieldOffset 方法，从而得到当前这个原子类的 value 的偏移量，并且赋给 valueOffset 变量，这样一来我们就获取到了 value 的偏移量，它的含义是在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的原值的，这样我们就能通过 Unsafe 来实现 CAS 了。</p>
<p>value 是用 volatile 修饰的，它就是我们原子类存储的值的变量，由于它被 volatile 修饰，我们就可以保证在多线程之间看到的 value 是同一份，保证了可见性。</p>
<p>接下来继续看 Unsafe 的 getAndAddInt 方法的实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们看一下结构，它是一个 do-while 循环，所以这是一个死循环，直到满足循环的退出条件时才可以退出。</p>
<p>那么我们来看一下 do 后面的这一行代码 <code>var5 = this.getIntVolatile(var1, var2)</code> 是什么意思。这是个 native 方法，作用就是<strong>获取在 var1 中的 var2 偏移处的值</strong>。</p>
<p>那传入的是什么呢？传入的两个参数，第一个就是当前原子类，第二个是我们最开始获取到的 offset，这样一来我们就可以获取到当前内存中偏移量的值，并且保存到 var5 里面。此时 var5 实际上代表当前时刻下的原子类的数值。</p>
<p>现在再来看 while 的退出条件，也就是 compareAndSwapInt 这个方法，它一共传入了 4 个参数，这 4 个参数是 var1、var2、var5、var5 + var4，为了方便理解，我们给它们取了新了变量名，分别 object、offset、expectedValue、newValue，具体含义如下：</p>
<ul>
<li><p>第一个参数 object 就是将要操作的对象，传入的是 this，也就是 atomicInteger 这个对象本身；</p>
</li>
<li><p>第二个参数是 offset，也就是偏移量，借助它就可以获取到 value 的数值；</p>
</li>
<li><p>第三个参数 expectedValue，代表“期望值”，传入的是刚才获取到的 var5；</p>
</li>
</ul>
<ul>
<li>而最后一个参数 newValue 是希望修改的数值 ，等于之前取到的数值 var5 再加上 var4，而 var4 就是我们之前所传入的 delta，delta 就是我们希望原子类所改变的数值，比如可以传入 +1，也可以传入 -1。</li>
</ul>
<p>所以 <code>compareAndSwapInt</code> 方法的作用就是，判断如果现在原子类里 value 的值和之前获取到的 var5 相等的话，那么就把计算出来的 var5 + var4 给更新上去，所以说这行代码就实现了 CAS 的过程。</p>
<p>一旦 CAS 操作成功，就会退出这个 while 循环，但是也有可能操作失败。如果操作失败就意味着在获取到 var5 之后，并且在 CAS 操作之前，value 的数值已经发生变化了，证明有其他线程修改过这个变量。</p>
<p>这样一来，就会再次执行循环体里面的代码，重新获取 var5 的值，也就是获取最新的原子变量的数值，并且再次利用 CAS 去尝试更新，直到更新成功为止，所以这是一个死循环。</p>
<p>我们总结一下，Unsafe 的 getAndAddInt 方法是通过 CAS 和 自旋去不停地尝试的方式来实现的，在此过程中，它会通过 compareAndSwapInt 方法来尝试更新 value 的值，如果更新失败就重新获取，然后再次尝试更新，直到更新成功。</p>
<blockquote>
<p>参考：占小狼<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fb6e91b013cc">https://www.jianshu.com/p/fb6e91b013cc</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liule8.github.io/post/7b46e5fa.html">https://liule8.github.io/post/7b46e5fa.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liule8.github.io" target="_blank">Leo's notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/a89bc4a9.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java并发编程之原子类-AtomicInteger 在高并发下性能不好，如何解决？为什么？</div></div></a></div><div class="next-post pull-right"><a href="/post/dc7732e8.html"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM 核心技术-调优分析与面试经验</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2a257066.html" title="Java并发编程之AQS框架-AQS 在 CountDownLatch 等类中的应用原理是什么？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-30</div><div class="title">Java并发编程之AQS框架-AQS 在 CountDownLatch 等类中的应用原理是什么？</div></div></a></div><div><a href="/post/4dc46dd1.html" title="Java并发编程之AQS框架-AQS 的内部原理是什么样的？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-30</div><div class="title">Java并发编程之AQS框架-AQS 的内部原理是什么样的？</div></div></a></div><div><a href="/post/d441b533.html" title="Java并发编程之AQS框架-为什么需要 AQS？AQS 的作用和重要性是什么？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-30</div><div class="title">Java并发编程之AQS框架-为什么需要 AQS？AQS 的作用和重要性是什么？</div></div></a></div><div><a href="/post/488d5376.html" title="Java并发编程之CAS-CAS 和乐观锁的关系，什么时候会用到 CAS？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-28</div><div class="title">Java并发编程之CAS-CAS 和乐观锁的关系，什么时候会用到 CAS？</div></div></a></div><div><a href="/post/648d6da1.html" title="Java并发编程之CAS-CAS 有什么缺点？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-28</div><div class="title">Java并发编程之CAS-CAS 有什么缺点？</div></div></a></div><div><a href="/post/fa8fc5b2.html" title="Java并发编程之CAS-你知道什么是 CAS 吗？"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-28</div><div class="title">Java并发编程之CAS-你知道什么是 CAS 吗？</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Leo Liu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">351</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liule8"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LIULE8" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:leo.liu.scau@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这里是公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-CAS-%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">原子类是如何利用 CAS 保证线程安全的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%9F%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是原子类？原子类有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%BA%B5%E8%A7%88"><span class="toc-number">1.2.</span> <span class="toc-text">6 类原子类纵览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">Atomic\ 基本类型原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">AtomicInteger 类常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">Array 数组类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-Reference-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">1.2.3.</span> <span class="toc-text">Atomic\Reference 引用类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic-FieldUpdater-%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">Atomic\FieldUpdater 原子更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Adder-%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">Adder 加法器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accumulator-%E7%A7%AF%E7%B4%AF%E5%99%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">Accumulator 积累器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5-AtomicInteger-%E4%B8%BA%E4%BE%8B%EF%BC%8C%E5%88%86%E6%9E%90%E5%9C%A8-Java-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8-CAS-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">以 AtomicInteger 为例，分析在 Java 中如何利用 CAS 实现原子操作？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#getAndAdd%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">getAndAdd方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">Unsafe 类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/744f530d.html" title="数据结构与算法之基础篇-排序(上)"><img src="/images/posts/cover/dataStructuresAndAlgorithms.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法之基础篇-排序(上)"/></a><div class="content"><a class="title" href="/post/744f530d.html" title="数据结构与算法之基础篇-排序(上)">数据结构与算法之基础篇-排序(上)</a><time datetime="2021-11-03T20:48:50.000Z" title="发表于 2021-11-03 20:48:50">2021-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d8f4be44.html" title="趣学设计模式之设计模式-代理模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-代理模式"/></a><div class="content"><a class="title" href="/post/d8f4be44.html" title="趣学设计模式之设计模式-代理模式">趣学设计模式之设计模式-代理模式</a><time datetime="2021-11-03T19:39:58.000Z" title="发表于 2021-11-03 19:39:58">2021-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/4238191e.html" title="趣学设计模式之设计模式-享元模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-享元模式"/></a><div class="content"><a class="title" href="/post/4238191e.html" title="趣学设计模式之设计模式-享元模式">趣学设计模式之设计模式-享元模式</a><time datetime="2021-11-03T19:21:49.000Z" title="发表于 2021-11-03 19:21:49">2021-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/5a088a81.html" title="趣学设计模式之设计模式-门面模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-门面模式"/></a><div class="content"><a class="title" href="/post/5a088a81.html" title="趣学设计模式之设计模式-门面模式">趣学设计模式之设计模式-门面模式</a><time datetime="2021-11-03T12:47:00.000Z" title="发表于 2021-11-03 12:47:00">2021-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/45d4b33f.html" title="趣学设计模式之设计模式-装饰模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-装饰模式"/></a><div class="content"><a class="title" href="/post/45d4b33f.html" title="趣学设计模式之设计模式-装饰模式">趣学设计模式之设计模式-装饰模式</a><time datetime="2021-11-02T20:26:16.000Z" title="发表于 2021-11-02 20:26:16">2021-11-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Leo Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>