<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Spring Boot响应式编程之响应式 Web 服务-RSocket | Leo's notes</title><meta name="keywords" content="Java,String"><meta name="author" content="Leo Liu"><meta name="copyright" content="Leo Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RSocket：一种新的高性能网络通信协议RSocket 是一款全新的协议，它基于响应式数据流，为我们提供了高性能的网络通信机制。 RSocket 协议在引入 RSocket 协议之前，我们先来讨论为什么需要这样一个协议。关于它的背景，让我从传统的请求-响应模式所存在的问题开始说起。 请求-响应模式的问题我们知道常用的 HTTP 协议的优势在于其广泛的适用性，有非常多的服务器和客户端实现工具的支持">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Boot响应式编程之响应式 Web 服务-RSocket">
<meta property="og:url" content="https://liule8.github.io/post/775b3361.html">
<meta property="og:site_name" content="Leo&#39;s notes">
<meta property="og:description" content="RSocket：一种新的高性能网络通信协议RSocket 是一款全新的协议，它基于响应式数据流，为我们提供了高性能的网络通信机制。 RSocket 协议在引入 RSocket 协议之前，我们先来讨论为什么需要这样一个协议。关于它的背景，让我从传统的请求-响应模式所存在的问题开始说起。 请求-响应模式的问题我们知道常用的 HTTP 协议的优势在于其广泛的适用性，有非常多的服务器和客户端实现工具的支持">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liule8.github.io/images/posts/cover/springWebflux.jpg">
<meta property="article:published_time" content="2021-10-07T08:44:14.000Z">
<meta property="article:modified_time" content="2021-10-28T11:20:49.974Z">
<meta property="article:author" content="Leo Liu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="String">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liule8.github.io/images/posts/cover/springWebflux.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liule8.github.io/post/775b3361"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-28 11:20:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">358</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/posts/cover/springWebflux.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leo's notes</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring Boot响应式编程之响应式 Web 服务-RSocket</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-07T08:44:14.000Z" title="发表于 2021-10-07 08:44:14">2021-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-28T11:20:49.974Z" title="更新于 2021-10-28 11:20:49">2021-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring-Boot/">Spring Boot</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring-Boot/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/">响应式编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring Boot响应式编程之响应式 Web 服务-RSocket"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RSocket：一种新的高性能网络通信协议"><a href="#RSocket：一种新的高性能网络通信协议" class="headerlink" title="RSocket：一种新的高性能网络通信协议"></a>RSocket：一种新的高性能网络通信协议</h1><p>RSocket 是一款全新的协议，它基于响应式数据流，为我们提供了高性能的网络通信机制。</p>
<h2 id="RSocket-协议"><a href="#RSocket-协议" class="headerlink" title="RSocket 协议"></a>RSocket 协议</h2><p>在引入 RSocket 协议之前，我们先来讨论为什么需要这样一个协议。关于它的背景，让我从传统的请求-响应模式所存在的问题开始说起。</p>
<h3 id="请求-响应模式的问题"><a href="#请求-响应模式的问题" class="headerlink" title="请求-响应模式的问题"></a>请求-响应模式的问题</h3><p>我们知道常用的 HTTP 协议的优势在于其广泛的适用性，有非常多的服务器和客户端实现工具的支持，但 HTTP 协议本身比较简单，只支持请求-响应模式。而这种模式对于很多应用场景来说是不合适的。</p>
<p>典型的例子就是消息推送，以 HTTP 协议为例，如果客户端需要获取最新的推送消息，就必须使用轮询。客户端不停地发送请求到服务器来检查更新，这无疑造成了大量的资源浪费。请求-响应模式的另外一个问题是，如果某个请求的响应时间过长，会阻塞之后的其他请求的处理。</p>
<p>虽然服务器发送事件（Server-Sent Events，SSE）可以用来推送消息，不过，SSE 是一个简单的文本协议，仅提供有限的功能。此外，WebSocket 可以进行双向数据传输，但长连接会造成服务之间的紧密耦合，WebSocket 的使用就不符合响应式系统要求，因为协议不提供控制背压的可能性，而背压是回弹性系统的重要组成部分。</p>
<p>事实上，响应式编程的实施目前主要有两个障碍，一个是<strong>关系型数据访问</strong>；而另一个就是<strong>网络协议</strong>。幸运的是，响应式流规范背后的开发团队理解了跨网络、异步、低延迟通信的必要性。2015 年，RSocket 协议就在这样的背景下诞生了。</p>
<h3 id="RSocket-协议与交互模式"><a href="#RSocket-协议与交互模式" class="headerlink" title="RSocket 协议与交互模式"></a>RSocket 协议与交互模式</h3><p>RSocket 是一种新的第 7 层语言无关的应用网络协议，用来解决单一的请求-响应模式以及现有网络传输协议所存在的问题，提供 Java、JavaScript、C++ 和 Kotlin 等多种语言的实现版本。</p>
<p>RSocket 是一个二进制的协议，以异步消息的方式提供 4 种交互模式，除了<strong>请求-响应（request/response）模式</strong>之外，还包括<strong>请求-响应流（request/stream）</strong>、<strong>即发-即忘（fire-and-forget）</strong>和<strong>通道（channel）</strong>这三种新的交互模式。这些模式的基本特性如下所示。</p>
<ul>
<li><p>请求-响应模式：这是最典型也最常见的模式。发送方在发送消息给接收方之后，等待与之对应的响应消息。</p>
</li>
<li><p>请求-响应流模式：发送方的每个请求消息，都对应于接收方的一个消息流作为响应。</p>
</li>
<li><p>即发-即忘模式：发送方的请求消息没有与之对应的响应。</p>
</li>
<li><p>通道模式：在发送方和接收方之间建立一个双向传输的通道。</p>
</li>
</ul>
<p>RSocket 专门设计用来与响应式风格应用程序进行配合使用，在使用 RSocket 协议时，背压和流量控制仍然有效。</p>
<p>为了更好地理解 RSocket 协议，让我们将它与 HTTP 协议做一些对比。之前提到过 Servlet 是基于 HTTP 协议之上的一套 Java API 规范，将 HTTP 请求转化为一个 ServletRequest 对象，并将处理结果封装成一个 ServletResponse 对象进行返回。<strong>HTTP 协议为了兼容各种应用方式，本身有一定的复杂性，性能一般</strong>。而 R<strong>Socket 采用的是自定义二进制协议，其本身的定位就是高性能通信协议，性能上比 HTTP 高出一个数量级</strong>。</p>
<p>在交互模式上，与 HTTP 的请求-响应这种单向的交互模式不同，<strong>RSocket 倡导的是对等通信</strong>，不再使用传统的客户端-服务器端单向通信模式，而是在两端之间可以自由地相互发送和处理请求。RSocket 协议在交互方式上可以参考下图。</p>
<p><img src="http://image.leonote.cn/20211009164558.png" alt="image-20211009164558026"></p>
<h2 id="使用-RSocket-实现远程交互"><a href="#使用-RSocket-实现远程交互" class="headerlink" title="使用 RSocket 实现远程交互"></a>使用 RSocket 实现远程交互</h2><p>想要在应用程序中使用 RSocket 协议，我们需要引入如下依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-transport-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里使用了 rsocket-transport-netty 包，该包的底层实现就是 Reactor Netty 组件，支持 TCP 和 WebSocket 协议。如果你想使用 UDP 协议，那么还可以引入 rsocket-transport-aeron 包。在引入这些包之后，就可以使用该协议中最核心的 RSocket 接口了，我们一起来看一下。</p>
<h4 id="RSocket-接口"><a href="#RSocket-接口" class="headerlink" title="RSocket 接口"></a>RSocket 接口</h4><p>RSocket 接口的定义如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.reactivestreams.Publisher;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RSocket</span> <span class="keyword">extends</span> <span class="title">Availability</span>, <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 推送元信息，数据可以自定义</span></span><br><span class="line">  <span class="function">Mono&lt;Void&gt; <span class="title">metadataPush</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求-响应模式，发送一个请求并接收一个响应。该协议也比 HTTP 更具优势，因为它是异步且多路复用的</span></span><br><span class="line">  <span class="function">Mono&lt;Payload&gt; <span class="title">requestResponse</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 即发-即忘模式，请求-响应的优化，在不需要响应时非常有用</span></span><br><span class="line">  <span class="function">Mono&lt;Void&gt; <span class="title">fireAndForget</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 请求-响应流模式，类似返回集合的请求/响应，集合将以流的方式返回，而不是等到查询完成</span></span><br><span class="line">  <span class="function">Flux&lt;Payload&gt; <span class="title">requestStream</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通道模式，允许任意交互模型的双向消息流</span></span><br><span class="line">  <span class="function">Flux&lt;Payload&gt; <span class="title">requestChannel</span><span class="params">(Publisher&lt;Payload&gt; payloads)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，RSocket 接口通过四个方法分别实现了它所提供的四种交互模式，其中 requestResponse 方法返回的是一个 <code>Mono&lt;Payload&gt;</code> 对象，这里的 Payload 代表的就是一种消息对象，它由两部分组成：元信息 metadata 和数据 data，类似常见的消息通信中的消息头和消息体的概念。</p>
<p>然后，我们发现 fireAndForget 方法返回的是一个 <code>Mono&lt;Void&gt;</code> 流，符合即发-即忘模式的语义。而 requestStream 作为请求-响应流模式的实现，与 requestResponse 的区别在于它的返回值是一个 Flux 流，而不是一个 Mono 对象。</p>
<p>最后，我们注意到这几个方法的输入都是一个 Payload 消息对象，而不是一个响应式流对象。但 requestChannel 方法就不一样了，它的输入同样是一个代表响应式流的 Publisher 对象，这意味着此种模式下的输入输出都是响应式流，也就是说可以进行客户端和服务器端之间的双向交互。</p>
<p>rsocket-core 包针对 RSocket 接口提供了一个抽象的实现类 <code>AbstractRSocket</code>，对上述方法做了简单的实现封装。在使用过程中，我们可以基于这个 AbstractRSocket 类来提供某一个交互模式的具体实现逻辑，而不需要完全实现 RSocket 接口中的所有方法。</p>
<h3 id="使用-RSocket-的交互模式"><a href="#使用-RSocket-的交互模式" class="headerlink" title="使用 RSocket 的交互模式"></a>使用 RSocket 的交互模式</h3><p>介绍完 RSocket 接口之后，我们来看看具体如何使用它所提供的四种交互模式。这里以最常见的请求-响应交互模式为例，给出使用 RSocket 协议的使用方法。与使用 HTTP 协议一样，这个过程需要构建服务器端和客户端，并通过客户端发起请求。</p>
<p>我们先来看如何构建 RSocket 服务器端，示例代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RSocketFactory.receive()</span><br><span class="line">    .acceptor(</span><br><span class="line">        ((setup, sendingSocket) -&gt;</span><br><span class="line">            Mono.just(</span><br><span class="line">                <span class="keyword">new</span> AbstractRSocket() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Mono&lt;Payload&gt; <span class="title">requestResponse</span><span class="params">(Payload payload)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Mono.just(DefaultPayload.create(<span class="string">&quot;Hello: &quot;</span> + payload.getDataUtf8()));</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)))</span><br><span class="line">    .transport(TcpServerTransport.create(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>))</span><br><span class="line">    .start()</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure>

<p>这里的 RSocketFactory.receive() 方法返回用来创建服务器的 <code>ServerRSocketFactory</code> 类的对象。ServerRSocketFactory 的 acceptor() 方法的输入参数是 SocketAcceptor 接口。</p>
<p>上述代码中，我们用到了前面介绍的 RSocket 抽象实现类 AbstractRSocket，重写了其中的 requestResponse() 方法，对输入的参数前面添加一个 “Hello: “ 前缀并返回；接下来的 transport() 方法指定 <code>ServerTransport</code> 接口的实现类 <code>TcpServerTransport</code> 作为 RSocket 底层的传输层实现，通过该方法，服务器端就启动了本地 7000 端口并监听来自客户端的请求；最后，我们通过 start().subscribe() 来触发整个启动过程。</p>
<p>构建完服务器端，我们来构建客户端组件，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSocket socket =</span><br><span class="line">    RSocketFactory.connect()</span><br><span class="line">        .transport(TcpClientTransport.create(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>))</span><br><span class="line">        .start()</span><br><span class="line">        .block();</span><br></pre></td></tr></table></figure>

<p>RSocketFactory.connect() 方法用来创建 <strong>RSocket 客户端</strong>，返回 ClientRSocketFactory 类的实例对象；接下来的 transport() 方法指定传输层 <code>ClientTransport</code> 实现；和服务器端组件 TcpServerTransport 对应，这里使用的是 <code>TcpClientTransport</code> 来连接本地服务器上的 7000 端口；最后调用 start().block() 方法等待客户端启动并返回 RSocket 对象。</p>
<p>现在，我们就可以使用 RSocket 的 requestResponse() 方法来发送请求并获取响应了，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket</span><br><span class="line">    .requestResponse(DefaultPayload.create(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">    .map(Payload::getDataUtf8)</span><br><span class="line">    .doOnNext(System.out::println)</span><br><span class="line">    .doFinally(signalType -&gt; socket.dispose())</span><br><span class="line">    .then()</span><br><span class="line">    .block();</span><br></pre></td></tr></table></figure>

<p>我们可以使用 DefaultPayload.create() 方法来简单地创建 Payload 对象，然后通过 RSocket 类的 dispose() 方法用来销毁客户端对象。这样，整个调用过程就结束了。执行这次请求，我们会在控制台上获取“Hello: World”。</p>
<h2 id="RSocket-与框架集成"><a href="#RSocket-与框架集成" class="headerlink" title="RSocket 与框架集成"></a>RSocket 与框架集成</h2><p>通常，我们不会直接使用 RSocket 原生开发库进行应用程序的开发，而是借助特定的开发框架。在 Java 领域中，Spring Boot、Spring Cloud 以及 Dubbo 等主流开发框架都集成了 RSocket 协议。下面我就分别为你说明。</p>
<h3 id="集成-RSocket-与-Spring-框架"><a href="#集成-RSocket-与-Spring-框架" class="headerlink" title="集成 RSocket 与 Spring 框架"></a>集成 RSocket 与 Spring 框架</h3><p>想要在 Spring Boot 中使用 RSocket 协议，我们需要引入如下依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-rsocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后，我们同样先来构建一个请求-响应式交互方式。我们可以构建如下所示一个简单 Controller：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@MessageMapping(&quot;hello&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">hello</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(<span class="string">&quot;Hello: &quot;</span> + input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以注意到，这里我引入了一个新的注解 <code>@MessageMapping</code>。跟 @RequestMapping 注解类似，<code>@MessageMapping</code> 是 Spring 提供的一个注解，用来指定 WebSocket、RSocket 等协议中消息处理的目的地。然后，我们输入了一个 String 类型的参数并返回一个 Mono 对象，符合请求-响应交互模式的定义。</p>
<p>为了访问这个 RSocket 端点，我们需要构建一个 <code>RSocketRequester</code> 对象，构建方式如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> RSocketRequester.Builder builder;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSocketRequester requester =</span><br><span class="line">    builder</span><br><span class="line">        .dataMimeType(MimeTypeUtils.TEXT_PLAIN)</span><br><span class="line">        .connect(TcpClientTransport.create(<span class="number">7000</span>))</span><br><span class="line">        .block();</span><br></pre></td></tr></table></figure>


<p>基于这个 RSocketRequester 对象，我们就可以通过它的 route 方法路由到前面通过 @MessageMapping 注解构建的 “hello” 端点，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; response = </span><br><span class="line">	requester.route(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">			 .data(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">			 .retrieveMono(String.class);</span><br></pre></td></tr></table></figure>

<p>我们再来看一个请求-响应流的示例，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MessageMapping(&quot;stream&quot;)</span></span><br><span class="line"><span class="function">Flux&lt;Message&gt; <span class="title">stream</span><span class="params">(Message request)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Flux.interval(Duration.ofSeconds(<span class="number">1</span>)).map(index -&gt; <span class="keyword">new</span> Message(request.getParam, index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里根据输入的 Message 对象，返回一个 Flux 流，每一秒发送一个添加了 Index 的新 Message 对象。</p>
<h3 id="集成-RSocket-与其他框架"><a href="#集成-RSocket-与其他框架" class="headerlink" title="集成 RSocket 与其他框架"></a>集成 RSocket 与其他框架</h3><p>针对其他开发框架，Dubbo 在 3.0.0-SNAPSHOT 版本里基于 RSocket 对响应式编程提供了支持，开发人员可以非常方便地使用 RSocket 的 API。而随着 Spring 框架的持续升级，5.2 版本中也把 RSocket 作为缺省的通信协议。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>你知道 RSocket 提供了哪四种交互模式，各自与响应式流是怎么整合的？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liule8.github.io/post/775b3361.html">https://liule8.github.io/post/775b3361.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liule8.github.io" target="_blank">Leo's notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/String/">String</a></div><div class="post_share"><div class="social-share" data-image="/images/posts/cover/springWebflux.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/70d60696.html"><img class="prev-cover" src="/images/posts/cover/springWebflux.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring Boot响应式编程之响应式数据访问-响应式全栈</div></div></a></div><div class="next-post pull-right"><a href="/post/53058f25.html"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM 核心技术-GC总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/670830f.html" title="Spring Boot响应式编程之响应式 Web 服务-WebFlux函数式开发"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-06</div><div class="title">Spring Boot响应式编程之响应式 Web 服务-WebFlux函数式开发</div></div></a></div><div><a href="/post/91e85e6d.html" title="Spring Boot响应式编程之响应式 Web 服务-WebFlux注解开发"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-06</div><div class="title">Spring Boot响应式编程之响应式 Web 服务-WebFlux注解开发</div></div></a></div><div><a href="/post/f95c85af.html" title="Spring Boot响应式编程之响应式 Web 服务-框架升级"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-05</div><div class="title">Spring Boot响应式编程之响应式 Web 服务-框架升级</div></div></a></div><div><a href="/post/56f26128.html" title="Spring Boot响应式编程之响应式数据访问-MongoDB 集成"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-07</div><div class="title">Spring Boot响应式编程之响应式数据访问-MongoDB 集成</div></div></a></div><div><a href="/post/12ec0295.html" title="Spring Boot响应式编程之响应式数据访问-R2DBC"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-07</div><div class="title">Spring Boot响应式编程之响应式数据访问-R2DBC</div></div></a></div><div><a href="/post/70d60696.html" title="Spring Boot响应式编程之响应式数据访问-响应式全栈"><img class="cover" src="/images/posts/cover/springWebflux.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-07</div><div class="title">Spring Boot响应式编程之响应式数据访问-响应式全栈</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Leo Liu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">358</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liule8"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LIULE8" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:leo.liu.scau@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这里是公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RSocket%EF%BC%9A%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">RSocket：一种新的高性能网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RSocket-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.</span> <span class="toc-text">RSocket 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">请求-响应模式的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSocket-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.2.</span> <span class="toc-text">RSocket 协议与交互模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RSocket-%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E4%BA%A4%E4%BA%92"><span class="toc-number">1.2.</span> <span class="toc-text">使用 RSocket 实现远程交互</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSocket-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">RSocket 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RSocket-%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用 RSocket 的交互模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RSocket-%E4%B8%8E%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">RSocket 与框架集成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90-RSocket-%E4%B8%8E-Spring-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">集成 RSocket 与 Spring 框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90-RSocket-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">集成 RSocket 与其他框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">思考题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/eadb1b45.html" title="趣学设计模式之设计模式-备忘录模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-备忘录模式"/></a><div class="content"><a class="title" href="/post/eadb1b45.html" title="趣学设计模式之设计模式-备忘录模式">趣学设计模式之设计模式-备忘录模式</a><time datetime="2021-11-05T21:06:52.000Z" title="发表于 2021-11-05 21:06:52">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/b3e81d06.html" title="趣学设计模式之设计模式-观察者模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-观察者模式"/></a><div class="content"><a class="title" href="/post/b3e81d06.html" title="趣学设计模式之设计模式-观察者模式">趣学设计模式之设计模式-观察者模式</a><time datetime="2021-11-05T20:30:17.000Z" title="发表于 2021-11-05 20:30:17">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/296ea922.html" title="趣学设计模式之设计模式-状态模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-状态模式"/></a><div class="content"><a class="title" href="/post/296ea922.html" title="趣学设计模式之设计模式-状态模式">趣学设计模式之设计模式-状态模式</a><time datetime="2021-11-05T12:55:38.000Z" title="发表于 2021-11-05 12:55:38">2021-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/d1460625.html" title="趣学设计模式之设计模式-策略模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-策略模式"/></a><div class="content"><a class="title" href="/post/d1460625.html" title="趣学设计模式之设计模式-策略模式">趣学设计模式之设计模式-策略模式</a><time datetime="2021-11-04T21:06:21.000Z" title="发表于 2021-11-04 21:06:21">2021-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/6d54624c.html" title="数据结构与算法之基础篇-排序(下)"><img src="/images/posts/cover/dataStructuresAndAlgorithms.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构与算法之基础篇-排序(下)"/></a><div class="content"><a class="title" href="/post/6d54624c.html" title="数据结构与算法之基础篇-排序(下)">数据结构与算法之基础篇-排序(下)</a><time datetime="2021-11-04T19:21:30.000Z" title="发表于 2021-11-04 19:21:30">2021-11-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Leo Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>