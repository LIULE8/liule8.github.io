<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL实战宝典之索引调优-索引出错 | Leo's notes</title><meta name="keywords" content="MySQL"><meta name="author" content="Leo Liu"><meta name="copyright" content="Leo Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="索引出错：请理解 CBO 的工作原理在实际工作中，我也经常会遇到一些同学提出这样的问题：MySQL 并没有按照自己的预想来选择索引，比如创建了索引但是选择了全表扫描，这肯定是 MySQL 数据库的 Bug，或者是索引出错了。 当然不是！ 这主要因为索引中的数据犯了错。 为什么这么说呢？要理解该问题，要理解 MySQL 数据库中的优化器是怎么执行的，然后才能明白为什么最终优化器没有选择你预想的索引。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL实战宝典之索引调优-索引出错">
<meta property="og:url" content="https://liule8.github.io/post/849c93b3.html">
<meta property="og:site_name" content="Leo&#39;s notes">
<meta property="og:description" content="索引出错：请理解 CBO 的工作原理在实际工作中，我也经常会遇到一些同学提出这样的问题：MySQL 并没有按照自己的预想来选择索引，比如创建了索引但是选择了全表扫描，这肯定是 MySQL 数据库的 Bug，或者是索引出错了。 当然不是！ 这主要因为索引中的数据犯了错。 为什么这么说呢？要理解该问题，要理解 MySQL 数据库中的优化器是怎么执行的，然后才能明白为什么最终优化器没有选择你预想的索引。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-09-01T12:49:18.000Z">
<meta property="article:modified_time" content="2021-10-16T05:06:48.339Z">
<meta property="article:author" content="Leo Liu">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liule8.github.io/post/849c93b3"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-16 05:06:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">347</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Leo's notes</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL实战宝典之索引调优-索引出错</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-01T12:49:18.000Z" title="发表于 2021-09-01 12:49:18">2021-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-16T05:06:48.339Z" title="更新于 2021-10-16 05:06:48">2021-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL实战宝典之索引调优-索引出错"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="索引出错：请理解-CBO-的工作原理"><a href="#索引出错：请理解-CBO-的工作原理" class="headerlink" title="索引出错：请理解 CBO 的工作原理"></a>索引出错：请理解 CBO 的工作原理</h1><p>在实际工作中，我也经常会遇到一些同学提出这样的问题：MySQL 并没有按照自己的预想来选择索引，比如创建了索引但是选择了全表扫描，这肯定是 MySQL 数据库的 Bug，或者是索引出错了。</p>
<p><strong>当然不是！</strong> 这主要因为索引中的数据犯了错。</p>
<p>为什么这么说呢？要理解该问题，要理解 MySQL 数据库中的优化器是怎么执行的，然后才能明白为什么最终优化器没有选择你预想的索引。</p>
<p>接下来，我们就来理解 MySQL 数据库是怎么选择索引的。</p>
<h2 id="MySQL是如何选择索引的？"><a href="#MySQL是如何选择索引的？" class="headerlink" title="MySQL是如何选择索引的？"></a>MySQL是如何选择索引的？</h2><p>在前面的表 orders 中，对于字段 o_custkey 已经创建了相关的 3 个索引，所以现在表 orders 的情况如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE &#96;orders&#96; (</span><br><span class="line">  &#96;O_ORDERKEY&#96; int NOT NULL,</span><br><span class="line">  &#96;O_CUSTKEY&#96; int NOT NULL,</span><br><span class="line">  &#96;O_ORDERSTATUS&#96; char(1) NOT NULL,</span><br><span class="line">  &#96;O_TOTALPRICE&#96; decimal(15,2) NOT NULL,</span><br><span class="line">  &#96;O_ORDERDATE&#96; date NOT NULL,</span><br><span class="line">  &#96;O_ORDERPRIORITY&#96; char(15) NOT NULL,</span><br><span class="line">  &#96;O_CLERK&#96; char(15) NOT NULL,</span><br><span class="line">  &#96;O_SHIPPRIORITY&#96; int NOT NULL,</span><br><span class="line">  &#96;O_COMMENT&#96; varchar(79) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;O_ORDERKEY&#96;),</span><br><span class="line">  KEY &#96;idx_custkey_orderdate&#96; (&#96;O_CUSTKEY&#96;,&#96;O_ORDERDATE&#96;),</span><br><span class="line">  KEY &#96;ORDERS_FK1&#96; (&#96;O_CUSTKEY&#96;),</span><br><span class="line">  KEY &#96;idx_custkey_orderdate_totalprice&#96; (&#96;O_CUSTKEY&#96;,&#96;O_ORDERDATE&#96;,&#96;O_TOTALPRICE&#96;),</span><br><span class="line">  CONSTRAINT &#96;orders_ibfk_1&#96; FOREIGN KEY (&#96;O_CUSTKEY&#96;) REFERENCES &#96;customer&#96; (&#96;C_CUSTKEY&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>在查询字段 o_custkey 时，理论上可以使用三个相关的索引：ORDERS_FK1、idx_custkey_orderdate、idx_custkey_orderdate_totalprice。<strong>那 MySQL 优化器是怎么从这三个索引中进行选择的呢？</strong></p>
<p>在关系型数据库中，B+ 树索引只是存储的一种数据结构，具体怎么使用，还要依赖数据库的优化器，优化器决定了具体某一索引的选择，也就是常说的执行计划。</p>
<p><strong>而优化器的选择是基于成本（cost），哪个索引的成本越低，优先使用哪个索引。</strong></p>
<p><img src="http://image.leonote.cn/20210923160818.png" alt="image-20210923160818608"></p>
<p>如上图所示，MySQL 数据库由 Server 层和 Engine 层组成：</p>
<ul>
<li>Server 层有 SQL 分析器、SQL优化器、SQL 执行器，用于负责 SQL 语句的具体执行过程；</li>
<li>Engine 层负责存储具体的数据，如最常使用的 InnoDB 存储引擎，还有用于在内存中存储临时结果集的 TempTable 引擎。</li>
</ul>
<p>SQL 优化器会分析所有可能的执行计划，选择成本最低的执行，这种优化器称之为：CBO（Cost-based Optimizer，基于成本的优化器）。</p>
<p>而在 MySQL中，<strong>一条 SQL 的计算成本计算如下所示：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cost  &#x3D; Server Cost + Engine Cost</span><br><span class="line">      &#x3D; CPU Cost + IO Cost</span><br></pre></td></tr></table></figure>

<p>其中，CPU Cost 表示计算的开销，比如索引键值的比较、记录值的比较、结果集的排序……这些操作都在 Server 层完成；</p>
<p>IO Cost 表示引擎层 IO 的开销，MySQL 8.0 可以通过区分一张表的数据是否在内存中，分别计算读取内存 IO 开销以及读取磁盘 IO 的开销。</p>
<p>数据库 mysql 下的表 server_cost、engine_cost 则记录了对于各种成本的计算，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM mysql.server_cost</span><br><span class="line">+-----------------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">|           cost_name               | cost_value  |     last_update     |   comment   |   default_value    |  </span><br><span class="line">+-----------------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">|    disk_temptable_create_cost     |     NULL    | 2021-02-15 16:40:22 |     NULL    |              20    | </span><br><span class="line">|    disk_temptable_row_cost        |     NULL    | 2021-02-15 16:40:22 |     NULL    |             0.5    |</span><br><span class="line">|    key_compare_cost               |     NULL    | 2021-02-15 16:40:22 |     NULL    |            0.05    |</span><br><span class="line">|    memory_temptable_create_cost   |     NULL    | 2021-02-15 16:40:22 |     NULL    |               1    |</span><br><span class="line">|    memory_temptable_row_cost      |     NULL    | 2021-02-15 16:40:22 |     NULL    |             0.1    |</span><br><span class="line">|    row_evaluate_cost              |     NULL    | 2021-02-15 16:40:22 |     NULL    |             0.1    |</span><br><span class="line">+-----------------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM mysql.engine_cost</span><br><span class="line">+--------------+--------------+-------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">| engine_name  | device-type  | cost_name               | cost_value  |     last_update     |   comment   |   default_value    |  </span><br><span class="line">+--------------+--------------+-------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">|    default   |           0  | io_block_read_cost      |     NULL    | 2021-02-15 16:40:22 |     NULL    |                  1 | </span><br><span class="line">|    default   |           0  | memory_block_read_cost  |     NULL    | 2021-02-15 16:40:22 |     NULL    |               0.25 |</span><br><span class="line">+--------------+--------------+-------------------------+-------------+---------------------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>表 server_cost 记录了 Server 层优化器各种操作的成本，这里面包括了所有 CPU Cost，其具体含义如下。</p>
<ul>
<li>disk_temptable_create_cost：创建磁盘临时表的成本，默认为20。</li>
<li>disk_temptable_row_cost：磁盘临时表中每条记录的成本，默认为0.5。</li>
<li>key_compare_cost：索引键值比较的成本，默认为0.05，成本最小。</li>
<li>memory_temptable_create_cost：创建内存临时表的成本：默认为1。</li>
<li>memory_temptable_row_cost：内存临时表中每条记录的成本，默认为0.1。</li>
<li>row_evaluate_cost：记录间的比较成本，默认为0.1。</li>
</ul>
<p><strong>可以看到，</strong> MySQL 优化器认为如果一条 SQL 需要创建基于磁盘的临时表，则这时的成本是最大的，其成本是基于内存临时表的 20 倍。而索引键值的比较、记录之间的比较，其实开销是非常低的，但如果要比较的记录数非常多，则成本会变得非常大。</p>
<p>而表 engine_cost 记录了存储引擎层各种操作的成本，这里包含了所有的 IO Cost，具体含义如下。</p>
<ul>
<li>io_block_read_cost：从磁盘读取一个页的成本，默认值为1。</li>
<li>memory_block_read_cost：从内存读取一个页的成本，默认值为0.25。</li>
</ul>
<p><strong>也就是说，</strong> MySQL 优化器认为从磁盘读取的开销是内存开销的 4 倍。</p>
<p>不过，上述所有的成本都是可以修改的，比如如果数据库使用是传统的 HDD 盘，性能较差，其随机读取性能要比内存读取慢 50 倍，那你可以通过下面的 SQL 修改成本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO </span><br><span class="line">engine_cost(engine_name,device_type,cost_name,cost_value,last_update,comment) </span><br><span class="line">VALUES (&#39;InnoDB&#39;,0,&#39;io_block_read_cost&#39;,12.5,CURRENT_TIMESTAMP,&#39;Using HDD for InnoDB&#39;);</span><br><span class="line"></span><br><span class="line">FLUSH OPTIMIZER_COSTS;</span><br></pre></td></tr></table></figure>

<p>再来看一下  GROUP BY SQL 语句，这时通过命令 EXPLAIN的FORMAT=json 来查看各成本的值，为的是让你进一步了解优化的工作原理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT&#x3D;json </span><br><span class="line">SELECT o_custkey,SUM(o_totalprice) </span><br><span class="line">FROM orders GROUP BY o_custkey</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"> EXPLAIN: &#123;</span><br><span class="line">   &quot;query_block&quot;: &#123;</span><br><span class="line">     &quot;select_id&quot;: 1,</span><br><span class="line">     &quot;cost_info&quot;: &#123;</span><br><span class="line">       &quot;query_cost&quot;: &quot;626899.50&quot; # 总成本</span><br><span class="line">     &#125;,</span><br><span class="line">     &quot;grouping_operation&quot;: &#123;</span><br><span class="line">       &quot;using_filesort&quot;: false,</span><br><span class="line">       &quot;table&quot;: &#123;</span><br><span class="line">         &quot;table_name&quot;: &quot;orders&quot;,</span><br><span class="line">         &quot;access_type&quot;: &quot;index&quot;,</span><br><span class="line">         &quot;possible_keys&quot;: [</span><br><span class="line">           &quot;idx_custkey_orderdate&quot;,</span><br><span class="line">           &quot;ORDERS_FK1&quot;,</span><br><span class="line">           &quot;idx_custkey_orderdate_totalprice&quot;</span><br><span class="line">         ],</span><br><span class="line">         &quot;key&quot;: &quot;idx_custkey_orderdate_totalprice&quot;,</span><br><span class="line">         &quot;used_key_parts&quot;: [</span><br><span class="line">           &quot;O_CUSTKEY&quot;,</span><br><span class="line">           &quot;O_ORDERDATE&quot;,</span><br><span class="line">           &quot;O_TOTALPRICE&quot;</span><br><span class="line">         ],</span><br><span class="line">         &quot;key_length&quot;: &quot;14&quot;,</span><br><span class="line">         &quot;rows_examined_per_scan&quot;: 5778755,</span><br><span class="line">         &quot;rows_produced_per_join&quot;: 5778755,</span><br><span class="line">         &quot;filtered&quot;: &quot;100.00&quot;,</span><br><span class="line">         &quot;using_index&quot;: true,</span><br><span class="line">         &quot;cost_info&quot;: &#123;</span><br><span class="line">           &quot;read_cost&quot;: &quot;49024.00&quot;, # IO Cost(Engine Cost)</span><br><span class="line">           &quot;eval_cost&quot;: &quot;577875.50&quot;, # CPU Cost(Server Cost)</span><br><span class="line">           &quot;prefix_cost&quot;: &quot;626899.50&quot;, # 总成本</span><br><span class="line">           &quot;data_read_per_join&quot;: &quot;2G&quot; # 总的读取记录字节数</span><br><span class="line">         &#125;,</span><br><span class="line">         &quot;used_columns&quot;: [</span><br><span class="line">           &quot;O_ORDERKEY&quot;,</span><br><span class="line">           &quot;O_CUSTKEY&quot;,</span><br><span class="line">           &quot;O_TOTALPRICE&quot;</span><br><span class="line">         ]</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从第 33 行开始，其中：</p>
<ul>
<li>read_cost 表示就是从 InnoDB 存储引擎读取的开销；</li>
<li>eval_cost 表示 Server 层的 CPU 成本；</li>
<li>prefix_cost 表示这条 SQL 的总成本；</li>
<li>data_read_per_join 表示总的读取记录的字节数。</li>
</ul>
<p>在知道 MySQL 索引选择是基于 SQL 执行成本之后，接下来，就能分析一些索引出错问题到底是怎么回事了。</p>
<h2 id="MySQL索引出错案例分析"><a href="#MySQL索引出错案例分析" class="headerlink" title="MySQL索引出错案例分析"></a>MySQL索引出错案例分析</h2><h3 id="案例1：未能使用创建的索引"><a href="#案例1：未能使用创建的索引" class="headerlink" title="案例1：未能使用创建的索引"></a>案例1：未能使用创建的索引</h3><p>经常听到有同学反馈 MySQL 优化器不准，不稳定，一直在变。</p>
<p>但是，我想告诉你的是，MySQL 优化器永远是根据成本，选择出最优的执行计划。哪怕是同一条 SQL 语句，只要范围不同，优化器的选择也可能不同。</p>
<p>如下面这两条 SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orders</span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-01-01&#39; and o_orderdate &lt; &#39;1994-12-31&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM orders </span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-02-01&#39; and o_orderdate &lt; &#39;1994-12-31&#39;;</span><br></pre></td></tr></table></figure>

<p>上面这两条 SQL 都是通过索引字段 o_orderdate 进行查询，然而第一条 SQL 语句的执行计划并未使用索引 idx_orderdate，而是使用了如下的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM orders </span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-01-01&#39; </span><br><span class="line">AND o_orderdate &lt; &#39;1994-12-31&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: idx_orderdate</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5799601</span><br><span class="line">     filtered: 32.35</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<p>从上述执行计划中可以发现，优化器已经通过 possible_keys 识别出可以使用索引 idx_orderdate，<strong>但最终却使用全表扫描的方式取出结果。</strong> 最为根本的原因在于：优化器认为使用通过主键进行全表扫描的成本比通过二级索引 idx_orderdate 的成本要低，可以通过 FORMAT=tree 观察得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT&#x3D;tree </span><br><span class="line">SELECT * FROM orders </span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-01-01&#39; </span><br><span class="line">AND o_orderdate &lt; &#39;1994-12-31&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Filter: ((orders.O_ORDERDATE &gt; DATE&#39;1994-01-01&#39;) and (orders.O_ORDERDATE &lt; DATE&#39;1994-12-31&#39;))  (cost&#x3D;592267.11 rows&#x3D;1876082)</span><br><span class="line">    -&gt; Table scan on orders  (cost&#x3D;592267.11 rows&#x3D;5799601)</span><br><span class="line"></span><br><span class="line">EXPLAIN FORMAT&#x3D;tree </span><br><span class="line">SELECT * FROM orders FORCE INDEX(idx_orderdate)</span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-01-01&#39; </span><br><span class="line">AND o_orderdate &lt; &#39;1994-12-31&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">EXPLAIN: -&gt; Index range scan on orders using idx_orderdate, with index condition: ((orders.O_ORDERDATE &gt; DATE&#39;1994-01-01&#39;) and (orders.O_ORDERDATE &lt; DATE&#39;1994-12-31&#39;))  (cost&#x3D;844351.87 rows&#x3D;1876082)</span><br></pre></td></tr></table></figure>

<p>可以看到，MySQL 认为全表扫描，然后再通过 WHERE 条件过滤的成本为 592267.11，对比强制使用二级索引 idx_orderdate 的成本为 844351.87。</p>
<p>成本上看，全表扫描低于使用二级索引。故，MySQL 优化器没有使用二级索引 idx_orderdate。</p>
<p><strong>为什么全表扫描比二级索引查询快呢？</strong> 因为二级索引需要回表，当回表的记录数非常大时，成本就会比直接扫描要慢，因此这取决于回表的记录数。</p>
<p>所以，第二条 SQL 语句，只是时间范围发生了变化，但是 MySQL 优化器就会自动使用二级索引 idx_orderdate了，这时我们再观察执行计划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM orders </span><br><span class="line">WHERE o_orderdate &gt; &#39;1994-02-01&#39; </span><br><span class="line">AND o_orderdate &lt; &#39;1994-12-31&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: idx_orderdate</span><br><span class="line">          key: idx_orderdate</span><br><span class="line">      key_len: 3</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1633884</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br></pre></td></tr></table></figure>

<p>再次强调，并不是 MySQL 选择索引出错，<strong>而是 MySQL 会根据成本计算得到最优的执行计划，</strong> 根据不同条件选择最优执行计划，而不是同一类型一成不变的执行过程，这才是优秀的优化器该有的样子。</p>
<h3 id="案例2：索引创建在有限状态上"><a href="#案例2：索引创建在有限状态上" class="headerlink" title="案例2：索引创建在有限状态上"></a>案例2：索引创建在有限状态上</h3><p>B+ 树索引通常要建立在高选择性的字段或字段组合上，如性别、订单 ID、日期等，因为这样每个字段值大多并不相同。</p>
<p>但是对于性别这样的字段，其值只有男和女两种，哪怕记录数再多，也只有两种值，这是低选择性的字段，因此无须在性别字段上创建索引。</p>
<p>但在有些低选择性的列上，是有必要创建索引的。比如电商的核心业务表 orders，其有字段 o_orderstatus，表示当前的状态。</p>
<p>在电商业务中会有一个这样的逻辑：即会定期扫描字段 o_orderstatus 为支付中的订单，然后强制让其关闭，从而释放库存，给其他有需求的买家进行购买。</p>
<p>但字段 o_orderstatus 的状态是有限的，一般仅为已完成、支付中、超时已关闭这几种。</p>
<p>通常订单状态绝大部分都是已完成，只有绝少部分因为系统故障原因，会在 15 分钟后还没有完成订单，<strong>因此订单状态是存在数据倾斜的。</strong></p>
<p>这时，虽然订单状态是低选择性的，但是由于其有数据倾斜，且我们只是从索引查询少量数据，因此可以对订单状态创建索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE orders </span><br><span class="line">ADD INDEX idx_orderstatus(o_orderstatus)</span><br></pre></td></tr></table></figure>

<p>但这时根据下面的这条 SQL，优化器的选择可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM orders </span><br><span class="line">WHERE o_orderstatus &#x3D; &#39;P&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5799601</span><br><span class="line">     filtered: 50.00</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<p>由于字段 o_orderstatus 仅有三个值，分别为 ‘O’、’P’、’F’。但 MySQL 并不知道这三个列的分布情况，认为这三个值是平均分布的，但其实是这三个值存在严重倾斜：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT o_orderstatus,count(1) </span><br><span class="line">FROM orders GROUP BY o_orderstatus;</span><br><span class="line">+---------------+----------+</span><br><span class="line">| o_orderstatus | count(1) |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| F             |  2923619 |</span><br><span class="line">| O             |  2923597 |</span><br><span class="line">| P             |   152784 |</span><br><span class="line">+---------------+----------+</span><br></pre></td></tr></table></figure>

<p>因此，优化器会认为订单状态为 P 的订单占用 1/3 的数据，使用全表扫描，避免二级索引回表的效率会更高。</p>
<p>然而，由于数据倾斜，订单状态为 P 的数据非常少，根据索引 idx_orderstatus 查询的效率会更高。这种情况下，我们可以利用 MySQL 8.0 的直方图功能，创建一个直方图，让优化器知道数据的分布，从而更好地选择执行计划。直方图的创建命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE TABLE orders </span><br><span class="line">UPDATE HISTOGRAM ON o_orderstatus;</span><br></pre></td></tr></table></figure>

<p>在创建完直方图后，MySQL会收集到字段 o_orderstatus 的数值分布，可以通过下面的命令查询得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">v value, </span><br><span class="line">CONCAT(round((c - LAG(c, 1, 0) over()) * 100,1), &#39;%&#39;) ratio</span><br><span class="line">FROM information_schema.column_statistics, </span><br><span class="line">JSON_TABLE(histogram-&gt;&#39;$.buckets&#39;,&#39;$[*]&#39; COLUMNS(v VARCHAR(60) PATH &#39;$[0]&#39;, c double PATH &#39;$[1]&#39;)) hist</span><br><span class="line">WHERE column_name &#x3D; &#39;o_orderstatus&#39;;</span><br><span class="line"></span><br><span class="line">+-------+-------+</span><br><span class="line">| value | ratio |</span><br><span class="line">+-------+-------+</span><br><span class="line">| F     | 49%   |</span><br><span class="line">| O     | 48.5% |</span><br><span class="line">| P     | 2.5%  |</span><br><span class="line">+-------+-------+</span><br></pre></td></tr></table></figure>

<p>可以看到，现在 MySQL 知道状态为 P 的订单只占 2.5%，因此再去查询状态为 P 的订单时，就会使用到索引 idx_orderstatus了，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM orders </span><br><span class="line">WHERE o_orderstatus &#x3D; &#39;P&#39;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: orders</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_orderstatus</span><br><span class="line">          key: idx_orderstatus</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 306212</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们知道了 MySQL 优化器是 CBO，即一种基于成本的优化器。其会判单每个索引的执行成本，从中选择出最优的执行计划。总结来说：</p>
<ul>
<li>MySQL 优化器是 CBO 的；</li>
<li>MySQL 会选择成本最低的执行计划，可以通过 EXPLAIN 命令查看每个 SQL 的成本；</li>
<li>一般只对高选择度的字段和字段组合创建索引，低选择度的字段如性别，不创建索引；</li>
<li>低选择性，但是数据存在倾斜，通过索引找出少部分数据，可以考虑创建索引；</li>
<li>若数据存在倾斜，可以创建直方图，让优化器知道索引中数据的分布，进一步校准执行计划。</li>
</ul>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>字段 o_orderstatus 上创建索引虽然能解决问题，但是成本非常大的，需要维护索引idx_orderstatus 的各种变更，性能会受到一定影响。有什么其他更好的方法来判断还处在支付过程中的订单吗？</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Leo Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://liule8.github.io/post/849c93b3.html">https://liule8.github.io/post/849c93b3.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://liule8.github.io" target="_blank">Leo's notes</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/833dc0fb.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL实战宝典之索引调优-子查询</div></div></a></div><div class="next-post pull-right"><a href="/post/9ef9f1b1.html"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL实战宝典之索引调优-索引组织表</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/d432a4f3.html" title="MySQL实战宝典之分布式架构-分布式事务"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-09</div><div class="title">MySQL实战宝典之分布式架构-分布式事务</div></div></a></div><div><a href="/post/7ab30575.html" title="MySQL实战宝典之分布式架构-分布式数据库架构"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-07</div><div class="title">MySQL实战宝典之分布式架构-分布式数据库架构</div></div></a></div><div><a href="/post/5e11524d.html" title="MySQL实战宝典之分布式架构-分布式数据库架构选型"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">MySQL实战宝典之分布式架构-分布式数据库架构选型</div></div></a></div><div><a href="/post/18c1c8d9.html" title="MySQL实战宝典之分布式架构-分布式数据库索引设计"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">MySQL实战宝典之分布式架构-分布式数据库索引设计</div></div></a></div><div><a href="/post/a943c20f.html" title="MySQL实战宝典之分布式架构-分布式数据库表结构设计"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">MySQL实战宝典之分布式架构-分布式数据库表结构设计</div></div></a></div><div><a href="/post/d35cee5.html" title="MySQL实战宝典之分布式架构-分布式设计之禅"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-09</div><div class="title">MySQL实战宝典之分布式架构-分布式设计之禅</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Leo Liu</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">347</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">82</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">46</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/liule8"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/LIULE8" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:leo.liu.scau@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">这里是公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99%EF%BC%9A%E8%AF%B7%E7%90%86%E8%A7%A3-CBO-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">索引出错：请理解 CBO 的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E7%B4%A2%E5%BC%95%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL是如何选择索引的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E5%87%BA%E9%94%99%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">MySQL索引出错案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E6%9C%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">案例1：未能使用创建的索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%9C%A8%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E4%B8%8A"><span class="toc-number">1.2.2.</span> <span class="toc-text">案例2：索引创建在有限状态上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.3.1.</span> <span class="toc-text">思考题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/45d4b33f.html" title="趣学设计模式之设计模式-装饰模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-装饰模式"/></a><div class="content"><a class="title" href="/post/45d4b33f.html" title="趣学设计模式之设计模式-装饰模式">趣学设计模式之设计模式-装饰模式</a><time datetime="2021-11-02T20:26:16.000Z" title="发表于 2021-11-02 20:26:16">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/7c2227c6.html" title="趣学设计模式之设计模式-组合模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-组合模式"/></a><div class="content"><a class="title" href="/post/7c2227c6.html" title="趣学设计模式之设计模式-组合模式">趣学设计模式之设计模式-组合模式</a><time datetime="2021-11-02T19:38:06.000Z" title="发表于 2021-11-02 19:38:06">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/f597d888.html" title="趣学设计模式之设计模式-桥接模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-桥接模式"/></a><div class="content"><a class="title" href="/post/f597d888.html" title="趣学设计模式之设计模式-桥接模式">趣学设计模式之设计模式-桥接模式</a><time datetime="2021-11-02T19:11:14.000Z" title="发表于 2021-11-02 19:11:14">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/dc094afa.html" title="趣学设计模式之设计模式-适配器模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-适配器模式"/></a><div class="content"><a class="title" href="/post/dc094afa.html" title="趣学设计模式之设计模式-适配器模式">趣学设计模式之设计模式-适配器模式</a><time datetime="2021-11-01T20:29:55.000Z" title="发表于 2021-11-01 20:29:55">2021-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/32082cb7.html" title="趣学设计模式之设计模式-原型模式"><img src="/images/posts/cover/designPatterns.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="趣学设计模式之设计模式-原型模式"/></a><div class="content"><a class="title" href="/post/32082cb7.html" title="趣学设计模式之设计模式-原型模式">趣学设计模式之设计模式-原型模式</a><time datetime="2021-11-01T20:09:58.000Z" title="发表于 2021-11-01 20:09:58">2021-11-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Leo Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>