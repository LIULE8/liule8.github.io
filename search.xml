<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CAS</title>
    <url>/2020/09/06/CAS%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><ul>
<li>CAS 全称 compare and swap (比较并替换)，是用在线程并发算法里常见的一种思想</li>
<li>CAS 是原子操作，保证并发安全，但不保证并发同步</li>
</ul>
<h2 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2><p>CAS 就是将内存值更新为需要的值时，设置一个条件，内存值必须与期望值相同</p>
<blockquote>
<p>期望值 E、内存值M、更新值U，当E == M的时候将M更新为U</p>
</blockquote>
<h2 id="CAS应用"><a href="#CAS应用" class="headerlink" title="CAS应用"></a>CAS应用</h2><ol>
<li>数据库常见的乐观锁实现方式，使用版本号version</li>
<li>JAVA里的原子类</li>
</ol>
<h2 id="CAS优缺点"><a href="#CAS优缺点" class="headerlink" title="CAS优缺点"></a>CAS优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>用来实现非阻塞的轻量级的乐观锁，通过CPU指令实现，在资源竞争不激烈的情况下性能高</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li><p>ABA 问题：线程C、D，线程D将A修改为B后又修改为A，此时C线程以为A没有改变过</p>
<p>JAVA的原子类AtomicStampedReference，通过<strong>控制变量值的版本</strong>来保证CAS的正确性（其他情况也可以通过增加版本号来解决ABA问题）</p>
</li>
<li><p>自旋时间过长(一直不能更新)，<strong>消耗CPU资源</strong>， 如果资源竞争激烈，多线程自旋长时间消耗资源</p>
</li>
</ol>
]]></content>
      <categories>
        <category>锁</category>
        <category>乐观锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK 内置注解</title>
    <url>/2020/09/08/JDK%20%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h1><p><strong>范围</strong>：类、字段、方法、参数、构造方法，以及局部变量上。</p>
<p><strong>作用</strong>：告诉编译器忽略指定的警告，不用在编译完成后出现警告信息。</p>
<p><strong>参数</strong>：</p>
<ol>
<li>deprecation：忽略过时</li>
<li>rawtypes：忽略类型安全</li>
<li>unused：忽略不使用</li>
<li>unchecked：忽略安全检查</li>
<li>null：忽略空指针</li>
<li>all：忽略所有</li>
</ol>
<p><strong>例子</strong>：<code>@SuppressWarnings(&quot;unchecked&quot;, &quot;deprecation&quot;)</code></p>
]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 核心技术</title>
    <url>/2020/10/19/JVM%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="JVM-基础知识"><a href="#JVM-基础知识" class="headerlink" title="JVM 基础知识"></a>JVM 基础知识</h1><h2 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h2><p>JVM 是 Java Virtual Machine（ Java 虚拟机）的缩写，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。由<strong>一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域等</strong>组成。JVM 屏蔽了与操作系统平台相关的信息，使得 Java 程序只需要生成在 Java 虚拟机上运行的目标代码（字节码），就可在多种平台上不加修改的运行，这也是 Java 能够“<strong>一次编译，到处运行的</strong>”原因。</p>
<h2 id="JRE、JDK-和-JVM-的关系"><a href="#JRE、JDK-和-JVM-的关系" class="headerlink" title="JRE、JDK 和 JVM 的关系"></a>JRE、JDK 和 JVM 的关系</h2><ul>
<li><p><strong>JVM（ Java Virtual Machine， Java 虚拟机）</strong>是 JRE 的一部分。JVM 主要工作是解释自己的指令集（即字节码）并映射到本地的CPU指令集和OS的系统调用。Java 语言是跨平台运行的，不同的操作系统会有不同的 JVM 映射规则，使之与操作系统无关，完成跨平台性。</p>
</li>
<li><p><strong>JRE（ Java Runtime Environment， Java 运行环境）</strong>：在 Java 平台，所有的程序都要在 JRE 下才能够运行。包括 JVM 和 Java 核心类库和支持文件。</p>
</li>
<li><p><strong>JDK（ Java Development Kit，Java 开发工具包）</strong>：是用来编译、调试 Java 程序的开发工具包，包括 Java 工具（ javac/java/jdb 等）和 Java 基础的类库。</p>
</li>
</ul>
<blockquote>
<p>📌 包含关系：JVM &lt; JRE &lt; JDK</p>
</blockquote>
<h2 id="JVM-原理"><a href="#JVM-原理" class="headerlink" title="JVM 原理"></a>JVM 原理</h2><h3 id="Java-体系结构介绍"><a href="#Java-体系结构介绍" class="headerlink" title="Java 体系结构介绍"></a>Java 体系结构介绍</h3><p><img src="http://image.leonote.cn/20201030134056.png" alt=""></p>
<ul>
<li>Class Loader（类加载器）：用于装载 .class 文件。</li>
<li>Execution Engine（执行引擎）：用于执行字节码或者本地方法。</li>
<li>运行时数据区：方法区、堆、java 栈、pc 寄存器、本地方法栈。</li>
</ul>
<h3 id="JVM-生命周期介绍"><a href="#JVM-生命周期介绍" class="headerlink" title="JVM 生命周期介绍"></a>JVM 生命周期介绍</h3><p>Java 实例对应一个独立运行的 Java 程序（<strong>进程级别</strong>）</p>
<ol>
<li><p><strong>启动</strong></p>
<p>启动一个 Java 程序，一个 JVM 实例就产生。拥有 </p>
<p><code>public static void main(String[] args)</code> 函数的 class 可以作为 JVM 实例运行的起点。</p>
</li>
<li><p><strong>运行</strong></p>
<p>main() 作为程序初始线程的起点，任何其他线程均可由该线程启动。</p>
<p>JVM 内部有两种线程：守护线程和非守护线程，main() 属于非守护线程，守护线程通常由 JVM 使用，程序可以指定创建的线程为守护线程。</p>
</li>
<li><p><strong>消亡</strong></p>
<p>当程序中的所有非守护线程都终止时，JVM 才退出；若安全管理器允许，程序也可以使用 Runtime 类或者 <code>System.exit()</code> 来退出。</p>
</li>
</ol>
<p>JVM 执行引擎实例则对应了属于用户运行程序线程，它是线程级别的。</p>
<h2 id="JVM-类加载器"><a href="#JVM-类加载器" class="headerlink" title="JVM 类加载器"></a>JVM 类加载器</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844904114543919111">类加载器</a></p>
<h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="http://image.leonote.cn/20201030162432.png" alt=""></p>
<ol>
<li><p><strong>装载（loading）</strong>：</p>
<p>负责找到 Class 文件并加载至 JVM 中，JVM 通过类名、类所在的包名、ClassLoader完成类的加载。因此，标识一个被加载了的类：类名 + 包名 + ClassLoader 实例 ID。</p>
</li>
<li><p><strong>链接（linking）</strong>：</p>
<ol>
<li><p>验证（Verifying）：验证 Class 文件的格式以及依赖，保证 JVM 能够执行</p>
</li>
<li><p>准备（Preparing）：为由 static 修饰的成员变量分配内存，并设置默认的初始值</p>
<p>默认初始值如下：</p>
<ul>
<li>八种基本数据类型默认的初始值是0</li>
<li>引用类型默认的初始值是 null</li>
<li>有 static final 修饰的会直接赋值</li>
</ul>
</li>
<li><p>解析（Resolving）：把常量池中的符号引用转换为直接引用。</p>
<p>即 JVM 会将所有的类或接口名、字段名、方法名转换为具体的内存地址</p>
</li>
</ol>
</li>
<li><p><strong>初始化（Initializing）</strong>：</p>
<p>负责将类中的静态变量（类变量）赋值的过程，即只有 static 修饰的才能被初始化。</p>
<blockquote>
<p>执行顺序：父类静态域或着静态代码块，然后是子类静态域或者子类静态代码块</p>
</blockquote>
</li>
<li><p><strong>使用（Using）</strong>： </p>
<ol>
<li><p>对象实例化：执行类中构造函数的内容</p>
<p>如果存在父类，JVM 会通过显示或者隐示的方式先执行父类的构造函数，在堆内存中为父类的实例变量开辟空间，并赋予默认的初始值，然后在根据构造函数的代码内容将真正的值赋予实例变量本身，然后，引用变量获取对象的首地址，通过操作对象来调用实例变量和方法</p>
</li>
<li><p>垃圾收集：当对象不再被引用的时候，就会被虚拟机标上特别的垃圾记号，在堆中等待 GC 回收</p>
</li>
<li><p>对象终结：对象被 GC 回收后，对象就不再存在，对象的生命也就走到了尽头</p>
</li>
</ol>
</li>
<li><p><strong>卸载（Unloading）</strong>：</p>
<p>即类的生命周期走到了最后一步，程序中不再有该类的引用，该类也就会被 JVM 执行垃圾回收，从此生命结束…</p>
</li>
</ol>
<h3 id="类初始化顺序"><a href="#类初始化顺序" class="headerlink" title="类初始化顺序"></a>类初始化顺序</h3><blockquote>
<p>类初始化的一些规则：</p>
<ol>
<li>类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化 </li>
<li>超类早于子类和衍生类的初始化 </li>
<li>如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的</li>
<li>初始化即使静态域被子类或子接口或者它的实现类所引用 </li>
<li>接口初始化不会导致父接口的初始化</li>
<li>静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前</li>
<li>非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类</li>
</ol>
</blockquote>
<h3 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h3><ol>
<li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化； </li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化， 会 触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用 要么是已经有实例了，要么是静态方法，都需要初始化；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ol>
<h3 id="不会初始化（可能会加载）"><a href="#不会初始化（可能会加载）" class="headerlink" title="不会初始化（可能会加载）"></a>不会初始化（可能会加载）</h3><h3 id="三类加载器"><a href="#三类加载器" class="headerlink" title="三类加载器"></a>三类加载器</h3><h3 id="显示当前-ClassLoader-加载了哪些-Jar"><a href="#显示当前-ClassLoader-加载了哪些-Jar" class="headerlink" title="显示当前 ClassLoader 加载了哪些 Jar?"></a>显示当前 ClassLoader 加载了哪些 Jar?</h3><h3 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h3><h3 id="添加引用类的几种方式"><a href="#添加引用类的几种方式" class="headerlink" title="添加引用类的几种方式"></a>添加引用类的几种方式</h3><h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h3><h3 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h3><h3 id="JVM-栈内存结构"><a href="#JVM-栈内存结构" class="headerlink" title="JVM 栈内存结构"></a>JVM 栈内存结构</h3><h3 id="JVM队内存结构"><a href="#JVM队内存结构" class="headerlink" title="JVM队内存结构"></a>JVM队内存结构</h3><h3 id="CPU与内存行为"><a href="#CPU与内存行为" class="headerlink" title="CPU与内存行为"></a>CPU与内存行为</h3><h3 id="小结：什么是-JMM"><a href="#小结：什么是-JMM" class="headerlink" title="小结：什么是 JMM ?"></a>小结：什么是 JMM ?</h3><h2 id="JAVA-字节码"><a href="#JAVA-字节码" class="headerlink" title="JAVA 字节码"></a>JAVA 字节码</h2><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/6844903939112976391">JAVA字节码的探秘</a></p>
<p><a href="https://juejin.im/post/6844903588716609543">轻松看懂JAVA字节码</a></p>
<h3 id="什么是字节码？"><a href="#什么是字节码？" class="headerlink" title="什么是字节码？"></a>什么是字节码？</h3><p>字节码由单字节的指令组成，理论上最多支持256个操作码（opcode），实际上Java只使用了200左右的操作码，还有一些操作码则保留给调试操作</p>
<p>根据指令的性质，主要分为四个大类：</p>
<ol>
<li>栈操作指令，包括与局部变量交互的指令</li>
<li>程序流程控制指令</li>
<li>对象操作指令，包括方法调用指令</li>
<li>算术运算以及类型转换指令</li>
</ol>
<h3 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h3><h3 id="最简单的字节码"><a href="#最简单的字节码" class="headerlink" title="最简单的字节码"></a>最简单的字节码</h3><h3 id="复杂点的例子"><a href="#复杂点的例子" class="headerlink" title="复杂点的例子"></a>复杂点的例子</h3><h3 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h3><h3 id="从助记符到二进制"><a href="#从助记符到二进制" class="headerlink" title="从助记符到二进制"></a>从助记符到二进制</h3><h3 id="四则运行的例子"><a href="#四则运行的例子" class="headerlink" title="四则运行的例子"></a>四则运行的例子</h3><h3 id="数值处理与本地变量表"><a href="#数值处理与本地变量表" class="headerlink" title="数值处理与本地变量表"></a>数值处理与本地变量表</h3><h3 id="算数操作与类型转换"><a href="#算数操作与类型转换" class="headerlink" title="算数操作与类型转换"></a>算数操作与类型转换</h3><h3 id="一个完整的循环控制"><a href="#一个完整的循环控制" class="headerlink" title="一个完整的循环控制"></a>一个完整的循环控制</h3><h3 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a>方法调用的指令</h3><ul>
<li>invokestatic：顾名思义，这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个。</li>
<li>invokespecial：用来调用构造函数，但也可以用于调用同一个类中的 private 方法, 以及可见的超类方法。 </li>
<li>invokevirtual：如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和 package 级的私有方法。 </li>
<li>invokeinterface：当通过接口引用来调用方法时，将会编译为 invokeinterface 指令。</li>
<li>invokedynamic：JDK7 新增加的指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改进，同时也是 JDK8 以后支持 lambda 表达式的实现基础。</li>
</ul>
<h3 id="一个动态例子"><a href="#一个动态例子" class="headerlink" title="一个动态例子"></a>一个动态例子</h3><h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><h3 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h3><h3 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h3><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><h3 id="GC相关"><a href="#GC相关" class="headerlink" title="GC相关"></a>GC相关</h3><h3 id="分析诊断"><a href="#分析诊断" class="headerlink" title="分析诊断"></a>分析诊断</h3><h3 id="JavaAgents"><a href="#JavaAgents" class="headerlink" title="JavaAgents"></a>JavaAgents</h3>]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/10/13/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h1><p><a href="https://mvnrepository.com/artifact/org.apache.commons/commons-collections4">Apache Commons Collections</a> 使操作集合时，代码更加简洁</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p>元素不为null时，向集合添加元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.addIgnoreNull(targetList, targetObject);</span><br></pre></td></tr></table></figure>

<p>将两个已排序的集合a和b合并为一个已排序的列表，保留元素的自然顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br></pre></td></tr></table></figure>

<p>将两个已排序的集合a和b合并到一个已排序的列表中，根据比较器顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br></pre></td></tr></table></figure>

<p>如果参数是null，则返回不可变的空集合（<code>new EmptyList&lt;&gt;()</code>），否则返回参数本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br></pre></td></tr></table></figure>

<p>空安全检查指定的集合是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br></pre></td></tr></table></figure>

<p>反转给定数组的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.reverseArray(Object[] array)</span><br></pre></td></tr></table></figure>

<p>差集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br></pre></td></tr></table></figure>

<p>并集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br></pre></td></tr></table></figure>

<p>交集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br></pre></td></tr></table></figure>

<p>交集的补集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Future 类详解</title>
    <url>/2021/04/17/Java%20Future%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java-Future-类详解"><a href="#Java-Future-类详解" class="headerlink" title="Java Future 类详解"></a>Java Future 类详解</h1><h2 id="生活中的-Future-模式"><a href="#生活中的-Future-模式" class="headerlink" title="生活中的 Future 模式"></a>生活中的 Future 模式</h2><p><strong>场景1</strong></p>
<p>午饭时间到了，要去吃饭了，小王下楼，走了20分钟，来到了肯德基，点餐，排队，吃饭一共花了20分钟，又花了20分钟走回公司继续工作，合计1小时。</p>
<p><strong>场景2</strong></p>
<p>午饭时间到了，同学们要去吃饭了，小王点了个肯德基外卖，很快，它就拿到了一个订单（虽然订单不能当饭吃，但是有了订单，还怕吃不上饭嘛）。接着小王可以继续干活，30分钟后，外卖到了，接着小王花了10分钟吃饭，接着又可以继续工作了，成功的卷到了隔壁的小王。</p>
<p><img src="http://image.leonote.cn//20210417140641.jfif" alt=""></p>
<p>在这两个场景中，场景2的小王工作时间更加紧凑，特别是那些排队的时间都可以让外卖员去干，因此可以更加专注于自己的本职工作。</p>
<p>场景1就是典型的函数同步调用，而场景2是典型的异步调用。</p>
<p>而场景2的异步调用，还有一个特点，就是它拥有一个返回值，这个返回值就是我们的订单。这个订单很重要，凭借着这个订单，才能够取得当前这个调用所对应的结果。</p>
<p>这里的订单就如同Future模式中的Future，这是一个合约，一份承诺。虽然订单不能吃，但是手握订单，不怕没吃的，虽然Future不是我们想要的结果，但是拿着Future就能在将来得到我们想要的结果。</p>
<p>因此，<strong><em>Future模式很好的解决了那些需要返回值的异步调用</em></strong>。</p>
<h3 id="Future-模式中的主要角色"><a href="#Future-模式中的主要角色" class="headerlink" title="Future 模式中的主要角色"></a>Future 模式中的主要角色</h3><p>一个典型的Future模式由以下几个部分组成：</p>
<ul>
<li><p>Main：系统启动，调用Client发出请求；</p>
</li>
<li><p>Client：返回Data对象，立即返回 Future Data，并开启 Client Thread 线程装配 Real Data；</p>
</li>
<li><p>Data：返回数据的接口；</p>
</li>
<li><p>Future Data： Future 数据，构造很快，但是是一个虚拟的数据，需要装配 Real Data，好比一个订单；</p>
</li>
<li><p>Real Data：真实数据，其构造是比较慢的，好比上面例子中的肯德基午餐。</p>
<p>它们之间的相互关系如下图：</p>
</li>
</ul>
<p><img src="http://image.leonote.cn//20210417141035.jfif" alt=""></p>
<p>其中，值得注意是 Data，Real Data 和 Future Data。这是一组典型的代理模式：</p>
<ul>
<li>Data 接口表示对外数据；</li>
<li>Real Data表示真实的数据，就好比午餐，获得它的成本比较高，需要很多时间；</li>
<li>Future Data 作为 Real Data 的代理，类似于一个订单/契约，通过 Future Data，可以在将来获得 Real Data。</li>
</ul>
<p>因此，<strong><em>Future模式本质上是代理模式的一种实际应用</em></strong>。</p>
<h3 id="实现一个简单的-Future-模式"><a href="#实现一个简单的-Future-模式" class="headerlink" title="实现一个简单的 Future 模式"></a>实现一个简单的 Future 模式</h3><h4 id="Data-接口"><a href="#Data-接口" class="headerlink" title="Data 接口"></a>Data 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">getResult</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Future-Data-类"><a href="#Future-Data-类" class="headerlink" title="Future Data 类"></a>Future Data 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 内部需要维护 RealData</span></span><br><span class="line">  <span class="keyword">protected</span> RealData realdata = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realdata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReady) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>.realdata = realdata;</span><br><span class="line">    isReady = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// RealData 已经被注入，通知 getResult()</span></span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 会等待 RealData 构造完成</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isReady) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 一直等待，直到RealData被注入</span></span><br><span class="line">        wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 真正需要的数据从RealData获取</span></span><br><span class="line">    <span class="keyword">return</span> realdata.getResult();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Real-Data-类"><a href="#Real-Data-类" class="headerlink" title="Real Data 类"></a>Real Data 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String result;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String query)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 假设这里实际业务花费时间很长，构造 RealData 不容易</span></span><br><span class="line">      sb.append(query);</span><br><span class="line">      TimeUnit.MINUTES.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    result = sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Client-类"><a href="#Client-类" class="headerlink" title="Client 类"></a>Client 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这是一个异步方法，返回的 Data接口 是一个 Future</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line">    <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="comment">// RealData 的构建很慢，所以在单独的线程中进行</span></span><br><span class="line">              RealData realdata = <span class="keyword">new</span> RealData(queryStr);</span><br><span class="line">              <span class="comment">// setRealData() 的时候会 notify() 等待在这个 future 上的对象</span></span><br><span class="line">              future.setRealData(realdata);</span><br><span class="line">            &#125;)</span><br><span class="line">        .start();</span><br><span class="line">    <span class="comment">// FutureData 会被立即返回，不会等待 RealData 被构造完</span></span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Test-类"><a href="#Test-类" class="headerlink" title="Test 类"></a>Test 类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Client client = <span class="keyword">new</span> Client();</span><br><span class="line">    <span class="comment">// 这里会立即返回，因为得到的是 FutureData 而不是 RealData</span></span><br><span class="line">    Data data = client.request(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;请求完毕&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里可以用一个sleep代替了对其他业务逻辑的处理</span></span><br><span class="line">      <span class="comment">// 在处理这些业务逻辑的过程中，RealData被创建，从而充分利用了等待时间</span></span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用真实的数据，如果到这里数据还没有准备好，getResult()会等待数据准备完，再返回</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数据 = &quot;</span> + data.getResult());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-中的-Future-模式"><a href="#Java-中的-Future-模式" class="headerlink" title="Java 中的 Future 模式"></a>Java 中的 Future 模式</h2><p>JDK 内部的 Future 实现：</p>
<p><img src="http://image.leonote.cn//20210417143205.jfif" alt=""></p>
<p>首先，JDK 内部有一个 Future 接口，这就是类似前面提到的订单，当然了，作为一个完整的商业化产品，这里的 Future 的功能更加丰富了，除了 get() 方法来获得真实数据以外，还提供一组辅助方法，比如：</p>
<ul>
<li>cancel()：如果等太久，可以直接取消这个任务；</li>
<li>isCancelled()：任务是不是已经取消了；</li>
<li>isDone()：任务是不是已经完成了；</li>
<li>get()：不带参数的表示无穷等待，或者指定等待时间。</li>
</ul>
<p>下面代码演示了这个Future的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 异步操作 可以用一个线程池</span></span><br><span class="line">      ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 执行 FutureTask，相当于上例中的 client.request(&quot;name&quot;) 发送请求</span></span><br><span class="line">      <span class="comment">// 在这里开启线程进行 RealData 的 call() 执行</span></span><br><span class="line">      Future&lt;String&gt; future = executor.submit(() -&gt; <span class="keyword">new</span> RealData(<span class="string">&quot;name&quot;</span>).getResult());</span><br><span class="line">      System.out.println(<span class="string">&quot;请求完毕，数据准备中&quot;</span>);</span><br><span class="line">      <span class="comment">// 这里依然可以做额外的数据操作，这里使用sleep代替其他业务逻辑的处理</span></span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="comment">// 如果此时call()方法没有执行完成，则依然会等待</span></span><br><span class="line">      System.out.println(<span class="string">&quot;数据 = &quot;</span> + future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个使用过程非常简单，下面来分析一下 <code>executor.submit()</code> 里面究竟发生了什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 根据 Callable 对象，创建一个 RunnableFuture，这里其实就是 FutureTask</span></span><br><span class="line">  RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">  <span class="comment">// 将 ftask 推送到线程池</span></span><br><span class="line">  <span class="comment">// 在新线程中执行的，就是 run() 方法，在下面的代码中有给出</span></span><br><span class="line">  execute(ftask);</span><br><span class="line">  <span class="comment">// 返回这个 Future，将来通过这个 Future 就可以得到执行的结果</span></span><br><span class="line">  <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最关键的部分在下面，<code>FutureTask</code> 作为一个线程单独执行时，会将结果保存到 outcome 中，并设置任务的状态,下面是<code>FutureTask</code>的 run() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务是新的才会执行，已经完成的任务不会再执行了</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用Callable的call()方法，就是真正干活的地方</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里的set()方法就是把result放到outcome里保存</span></span><br><span class="line">            <span class="comment">//同时设置任务状态为NORMAL，表示已完成</span></span><br><span class="line">            <span class="comment">//最后，还会通知等待在这个Future上的所有的线程，unpark这些线程</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>FutureTask</code>中获得结果的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">//如果没有完成就等待，回到用park()方法阻塞线程</span></span><br><span class="line">    <span class="comment">//同时，所有等待线程会在FutureTask的waiters字段中排队等待</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns result or throws exception for completed task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s completed state value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//outcome里保存的就是最终的计算结果</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">         <span class="comment">//正常完成，就返回outcome</span></span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">     <span class="comment">//如果没有正常完成， 比如被用户取消了，或者有异常了，就抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future-高阶版本——-CompletableFuture"><a href="#Future-高阶版本——-CompletableFuture" class="headerlink" title="Future 高阶版本—— CompletableFuture"></a>Future 高阶版本—— CompletableFuture</h2><p>Future模式虽然好用，但也有一个问题，那就是将任务提交给线程后，调用线程并不知道这个任务什么时候执行完，如果执行调用get()方法或者isDone()方法判断，可能会进行不必要的等待，那么系统的吞吐量很难提高。</p>
<p>为了解决这个问题，JDK 对Future模式又进行了加强，创建了一个<code>CompletableFuture</code>，它可以理解为Future模式的升级版本，它最大的作用是<strong><em>提供了一个回调机制</em></strong>，可以在任务完成后，自动回调一些后续的处理，这样，整个程序可以把“结果等待”完全给移除了。</p>
<p>下面来看一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建异步执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  CompletableFuture.supplyAsync(Test::getPrice)</span><br><span class="line">      <span class="comment">// 当 getPrice()执行完成后，会自动回调thenAccept()中的函数</span></span><br><span class="line">      .thenAccept(result -&gt; System.out.println(<span class="string">&quot;price: &quot;</span> + result))</span><br><span class="line">      <span class="comment">// 当出现异常时，会自动回调exceptionally()里的函数</span></span><br><span class="line">      .exceptionally(</span><br><span class="line">          e -&gt; &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 模拟一个异常</span></span><br><span class="line">  <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Error when get Price&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Math.random() * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先以 getPrice() 为基础创建一个异步调用，接着，使用 thenAccept() 方法，设置了一个后续的操作，也就是当 getPrice() 执行完成后的后续处理。</p>
<p>不难看到，<code>CompletableFuture</code> 比一般的Future更具有实用性，因为它可以在Future执行成功后，自动回调进行下一步的操作，因此整个程序不会有任何阻塞的地方（也就是说你不用去到处等待Future的执行，而是让Future执行成功后，自动来告诉你）。</p>
<p>以上面的代码为例，<code>CompletableFuture</code>之所有会有那么神奇的功能，完全得益于<code>AsyncSupply</code>类（由上述代码中的 supplyAsync() 方法创建）。</p>
<p><code>AsyncSupply</code> 在执行时，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;T&gt; d; Supplier&lt;T&gt; f;</span><br><span class="line">    <span class="keyword">if</span> ((d = dep) != <span class="keyword">null</span> &amp;&amp; (f = fn) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dep = <span class="keyword">null</span>; fn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//这里就是要执行的异步方法</span></span><br><span class="line">                <span class="comment">//结果会被保存下来，放到d.result字段中</span></span><br><span class="line">                d.completeValue(f.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                d.completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行成功进行后续处理，在这个后续处理中，就会调用thenAccept()中的消费者</span></span><br><span class="line">        <span class="comment">//这里就相当于Future完成后的通知</span></span><br><span class="line">        d.postComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 d.postComplete()，这里会调用后续一系列操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops and tries to trigger all reachable dependents.  Call only</span></span><br><span class="line"><span class="comment"> * when known to be done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On each step, variable f holds current dependents to pop</span></span><br><span class="line"><span class="comment">     * and run.  It is extended along only one path at a time,</span></span><br><span class="line"><span class="comment">     * pushing others to avoid unbounded recursion.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CompletableFuture&lt;?&gt; f = <span class="keyword">this</span>; Completion h;</span><br><span class="line">    <span class="keyword">while</span> ((h = f.stack) != <span class="keyword">null</span> ||</span><br><span class="line">           (f != <span class="keyword">this</span> &amp;&amp; (h = (f = <span class="keyword">this</span>).stack) != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        CompletableFuture&lt;?&gt; d; Completion t;</span><br><span class="line">        <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">this</span>) &#123;</span><br><span class="line">                    pushStack(h);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h.next = <span class="keyword">null</span>;    <span class="comment">// detach</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在tryFire()里，真正触发了后续的调用，也就是thenAccept()中的部分</span></span><br><span class="line">            f = (d = h.tryFire(NESTED)) == <span class="keyword">null</span> ? <span class="keyword">this</span> : d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript for循环写法</title>
    <url>/2020/11/10/JavaScript%20for%E5%BE%AA%E7%8E%AF%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h1 id="JavaScript-for循环写法"><a href="#JavaScript-for循环写法" class="headerlink" title="JavaScript for循环写法"></a>JavaScript for循环写法</h1><h2 id="简单-for-循环"><a href="#简单-for-循环" class="headerlink" title="简单 for 循环"></a>简单 for 循环</h2><p>下面先来看看大家最常见的一种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i　&lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率，下面是改进的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h2><p>通常情况下，我们可以用 for-in 来遍历一遍数组的内容，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;arr[&quot;</span> + index + <span class="string">&quot;] = &quot;</span> + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下，运行结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但这么做往往会出现问题。</p>
<p><strong>for-in 的真相</strong></p>
<p>for-in 循环遍历的是对象的属性，而不是数组的索引。因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    fname: <span class="string">&quot;san&quot;</span>,</span><br><span class="line">    lname: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> info;</span><br><span class="line"><span class="keyword">for</span>(info <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;person[&quot;</span> + info + <span class="string">&quot;] = &quot;</span> + person[info]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person[fname] = san</span><br><span class="line">person[lname] = zhang</span><br><span class="line">person[age] = <span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是， for-in 遍历属性的顺序并不确定，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</p>
<p><strong>Array 的真相</strong></p>
<p>Array 在 JavaScript 中是一个对象， Array 的索引是属性名。事实上， JavaScript 中的 “array” 有些误导性， JavaScript 中的 Array 并不像大部分其他语言的数组。首先， JavaScript 中的 Array 在内存上并不连续，其次， Array 的索引并不是指偏移量。实际上， Array 的索引也不是 Number 类型，而是 String 类型的。我们可以正确使用如 arr[0] 的写法的原因是语言可以自动将 Number 类型的 0 转换成 String 类型的 “0″ 。所以，在 JavaScript 中从来就没有 Array 的索引，而只有类似 “0″ 、 “1″ 等等的属性。有趣的是，每个 Array 对象都有一个 length 的属性，导致其表现地更像其他语言的数组。但为什么在遍历 Array 对象的时候没有输出 length 这一条属性呢？那是因为 for-in 只能遍历“可枚举的属性”， length 属于不可枚举属性，实际上， Array 对象还有许多其他不可枚举的属性。</p>
<p>现在，我们再回过头来看看用 for-in 来循环数组的例子，我们修改一下前面遍历数组的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.name = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;arr[&quot;</span> + index + <span class="string">&quot;] = &quot;</span> + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">arr[name] = Hello world</span><br></pre></td></tr></table></figure>

<p>我们看到 for-in 循环访问了我们新增的 “name” 属性，因为 for-in 遍历了对象的所有属性，而不仅仅是“索引”。同时需要注意的是，此处输出的索引值，即 “0″、 “1″、 “2″不是 Number 类型的，而是 String 类型的，因为其就是作为属性输出，而不是索引。那是不是说不在我们的 Array 对象中添加新的属性，我们就可以只输出数组中的内容了呢？答案是否定的。因为 for-in 不仅仅遍历 array 自身的属性，其还遍历 array 原型链上的所有可枚举的属性。下面我们看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.fatherName = <span class="string">&quot;Father&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.name = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> index;</span><br><span class="line"><span class="keyword">for</span>(index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;arr[&quot;</span> + index + <span class="string">&quot;] = &quot;</span> + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">arr[name] = Hello world</span><br><span class="line">arr[fatherName] = Father</span><br></pre></td></tr></table></figure>

<p>写到这里，我们可以发现 for-in 并不适合用来遍历 Array 中的元素，其更适合遍历对象中的属性，这也是其被创造出来的初衷。却有一种情况例外，就是稀疏数组。考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key;</span><br><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">arr[<span class="number">100</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">arr[<span class="number">10000</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.hasOwnProperty(key)  &amp;&amp;    </span><br><span class="line">        /^<span class="number">0</span>$|^[<span class="number">1</span>-<span class="number">9</span>]\d*$/.test(key) &amp;&amp;    </span><br><span class="line">        key &lt;= <span class="number">4294967294</span>               </span><br><span class="line">        ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-in 只会遍历存在的实体，上面的例子中， for-in 遍历了3次（遍历属性分别为”0″、 “100″、 “10000″的元素，普通 for 循环则会遍历 10001 次）。所以，只要处理得当， for-in 在遍历 Array 中元素也能发挥巨大作用。</p>
<p>为了避免重复劳动，我们可以包装一下上面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayHasOwnIndex</span>(<span class="params">array, prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.hasOwnProperty(prop) &amp;&amp; </span><br><span class="line">        /^<span class="number">0</span>$|^[<span class="number">1</span>-<span class="number">9</span>]\d*$/.test(prop) &amp;&amp; </span><br><span class="line">        prop &lt;= <span class="number">4294967294</span>; <span class="comment">// 2^32 - 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arrayHasOwnIndex(arr, key)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for-in 性能</strong></p>
<p>正如上面所说，每次迭代操作会同时搜索实例或者原型属性， for-in 循环的每次迭代都会产生更多开销，因此要比其他循环类型慢，一般速度为其他类型循环的 1/7。因此，除非明确需要迭代一个属性数量未知的对象，否则应避免使用 for-in 循环。如果需要遍历一个数量有限的已知属性列表，使用其他循环会更快，比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;prop1&quot;</span>: <span class="string">&quot;value1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prop2&quot;</span>: <span class="string">&quot;value2&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = [<span class="string">&quot;prop1&quot;</span>, <span class="string">&quot;prop2&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[props[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，将对象的属性都存入一个数组中，相对于 for-in 查找每一个属性，该代码只关注给定的属性，节省了循环的开销和时间。</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>在 ES5 中，引入了新的循环，即 forEach 循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>forEach 方法为数组中含有有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（不包括那些值为 undefined 或 null 的项）。 callback 函数会被依次传入三个参数：</p>
<ul>
<li>数组当前项的值；</li>
<li>数组当前项的索引；</li>
<li>数组对象本身；</li>
</ul>
<p>需要注意的是，forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">arr[<span class="number">10</span>] = <span class="string">&quot;c&quot;</span>;</span><br><span class="line">arr.name = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">data, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data, index, array);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a <span class="number">0</span> [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>: <span class="string">&quot;b&quot;</span>, <span class="number">10</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Hello world&quot;</span>]</span><br><span class="line">b <span class="number">3</span> [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>: <span class="string">&quot;b&quot;</span>, <span class="number">10</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Hello world&quot;</span>]</span><br><span class="line">c <span class="number">10</span> [<span class="string">&quot;a&quot;</span>, <span class="number">3</span>: <span class="string">&quot;b&quot;</span>, <span class="number">10</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;Hello world&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里的 index 是 Number 类型，并且也不会像 for-in 一样遍历原型链上的属性。</p>
<p>所以，使用 forEach 时，我们不需要专门地声明 index 和遍历的元素，因为这些都作为回调函数的参数。</p>
<p>另外，forEach 将会遍历数组中的所有元素，但是 ES5 定义了一些其他有用的方法，下面是一部分：</p>
<ul>
<li>every: 循环在第一次 return false 后返回</li>
<li>some: 循环在第一次 return true 后返回</li>
<li>filter: 返回一个新的数组，该数组内的元素满足回调函数</li>
<li>map: 将原数组中的元素处理后再返回</li>
<li>reduce: 对数组中的元素依次处理，将上次处理结果作为下次处理的输入，最后得到最终结果。</li>
</ul>
<p><strong>forEach 性能</strong></p>
<p>在不同浏览器下测试的结果都是 forEach 的速度不如 for。如果大家把测试代码放在控制台的话，可能会得到不一样的结果，主要原因是控制台的执行环境与真实的代码执行环境有所区别。</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h2><p>先来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> data <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><strong>为什么要引进 for-of？</strong></p>
<p>要回答这个问题，我们先来看看ES6之前的 3 种 for 循环有什么缺陷：</p>
<ul>
<li>forEach 不能 break 和 return；</li>
<li>for-in 缺点更加明显，它不仅遍历数组中的元素，还会遍历自定义的属性，甚至原型链上的属性都被访问到。而且，遍历数组元素的顺序可能是随机的。</li>
</ul>
<p>所以，鉴于以上种种缺陷，我们需要改进原先的 for 循环。但 ES6 不会破坏你已经写好的 JS 代码。目前，成千上万的 Web 网站依赖 for-in 循环，其中一些网站甚至将其用于数组遍历。如果想通过修正 for-in 循环增加数组遍历支持会让这一切变得更加混乱，因此，标准委员会在 ES6 中增加了一种新的循环语法来解决目前的问题，即 for-of 。</p>
<p>那 for-of 到底可以干什么呢？</p>
<ul>
<li>跟 forEach 相比，可以正确响应 break, continue, return。</li>
<li>for-of 循环不仅支持数组，还支持大多数类数组对象，例如 DOM nodelist 对象。</li>
<li>for-of 循环也支持字符串遍历，它将字符串视为一系列 Unicode 字符来进行遍历。</li>
<li>for-of 也支持 Map 和 Set （两者均为 ES6 中新增的类型）对象遍历。</li>
</ul>
<p>总结一下，for-of 循环有以下几个特征：</p>
<ul>
<li>这是最简洁、最直接的遍历数组元素的语法。</li>
<li>这个方法避开了 for-in 循环的所有缺陷。</li>
<li>与 forEach 不同的是，它可以正确响应 break、continue 和 return 语句。</li>
<li>其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li>
</ul>
<p>但需要注意的是，for-of循环不支持普通对象，但如果你想迭代一个对象的属性，你可以用 for-in 循环（这也是它的本职工作）。</p>
<p>最后要说的是，ES6 引进的另一个方式也能实现遍历数组的值，那就是 Iterator。上个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的一些常用SQL</title>
    <url>/2020/11/05/Oracle%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8SQL/</url>
    <content><![CDATA[<h1 id="Oracle的一些常用SQL"><a href="#Oracle的一些常用SQL" class="headerlink" title="Oracle的一些常用SQL"></a>Oracle的一些常用SQL</h1><h2 id="查外键建在哪个表上"><a href="#查外键建在哪个表上" class="headerlink" title="查外键建在哪个表上"></a>查外键建在哪个表上</h2><p>有时候删除某张表记录的时候，会报错外键约束不能删除。</p>
<p>如果不了解表之间的关系，可以通过以下语句查询到外键是建在哪张表上的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_constraints <span class="keyword">where</span> constraint_name<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span> <span class="keyword">and</span> constraint_type <span class="operator">=</span> <span class="string">&#x27;R&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h2 id="在垃圾桶查被删除的表"><a href="#在垃圾桶查被删除的表" class="headerlink" title="在垃圾桶查被删除的表"></a>在垃圾桶查被删除的表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_name, original_name, partition_name, type, ts_name, createtime, droptime</span><br><span class="line"><span class="keyword">from</span> recyclebin</span><br><span class="line"><span class="comment">-- where original_name = &#x27;extra_charge_detail&#x27;</span></span><br><span class="line"><span class="keyword">where</span> to_date(droptime, <span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>) <span class="operator">&gt;=</span> sysdate <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">and</span> type <span class="operator">=</span> <span class="string">&#x27;table&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> droptime <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<h3 id="回滚被删除的表"><a href="#回滚被删除的表" class="headerlink" title="回滚被删除的表"></a>回滚被删除的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;BIN$l5cbNm6DbqDgU54w3gpQfA==$0&quot;;</span><br><span class="line">FLASHBACK <span class="keyword">TABLE</span> &quot;BIN$l5l+JWZRPQ7gU54w3goSNw==$0&quot; <span class="keyword">TO</span> BEFORE <span class="keyword">DROP</span>;</span><br><span class="line">FLASHBACK <span class="keyword">TABLE</span> user2 <span class="keyword">TO</span> BEFORE <span class="keyword">DROP</span> rename <span class="keyword">to</span> user2_v2; <span class="comment">-- 重命名 如果已经新建了同名表</span></span><br></pre></td></tr></table></figure>





<h2 id="将Clob转成字符串"><a href="#将Clob转成字符串" class="headerlink" title="将Clob转成字符串"></a>将Clob转成字符串</h2><p>WM_CONCAT 函数出来的数据是clob类型的，组合成的数据自动用<code>&#39;,&#39;</code>分割</p>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>to_char 函数 长度只能到4000，超出会截取</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> O.UUID, O.SOURCE, TO_CHAR(WM_CONCAT(OI.REQ_NO)) <span class="keyword">AS</span> REQNOS</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">ORDER</span> O</span><br><span class="line">         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ORDER_DETAIL OI <span class="keyword">ON</span> O.UUID <span class="operator">=</span> OI.ORDER_UUID</span><br><span class="line"><span class="keyword">WHERE</span> OI.REQ_NO <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> O.UUID, O.SOURCE;</span><br></pre></td></tr></table></figure>

<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>dbms_lob.substr 函数 可以指定长度，超出会截取</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> O.UUID, O.SOURCE, DBMS_LOB.SUBSTR((WM_CONCAT(OI.REQ_NO), <span class="number">8000</span>)) <span class="keyword">AS</span> REQNOS</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">ORDER</span> O</span><br><span class="line">         <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> ORDER_DETAIL OI <span class="keyword">ON</span> O.UUID <span class="operator">=</span> OI.ORDER_UUID</span><br><span class="line"><span class="keyword">WHERE</span> OI.REQ_NO <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> O.UUID, O.SOURCE;</span><br></pre></td></tr></table></figure>

<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>用代码转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  Reader is = ((Clob)tuple[i]).getCharacterStream();<span class="comment">// 得到流</span></span><br><span class="line">  BufferedReader br = <span class="keyword">new</span> BufferedReader(is);</span><br><span class="line">  String s = br.readLine();</span><br><span class="line">  StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">// 执行循环将字符串全部取出付值给StringBuffer由StringBuffer转成STRING</span></span><br><span class="line">  <span class="keyword">while</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sb.append(s);</span><br><span class="line">    s = br.readLine();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA用法</title>
    <url>/2020/09/06/JPA%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="查询用法"><a href="#查询用法" class="headerlink" title="查询用法"></a>查询用法</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 拥有级联维护的一方，参考http://westerly-lzh.github.io/cn/2014/12/JPA-CascadeType-Explaining/</span></span><br><span class="line">    <span class="meta">@OneToOne(cascade = CascadeType.ALL)</span> </span><br><span class="line">    <span class="meta">@JoinColumn(foreignKey = @ForeignKey(name = &quot;none&quot;, value = ConstraintMode.NO_CONSTRAINT))</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDetail detail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManyToOne(fetch = FetchType.LAZY)</span> </span><br><span class="line">    <span class="comment">// 设置外键的问题，参考http://mario1412.github.io/2016/06/27/JPA%E4%B8%AD%E5%B1%8F%E8%94%BD%E5%AE%9E%E4%BD%93%E9%97%B4%E5%A4%96%E9%94%AE/</span></span><br><span class="line">    <span class="meta">@JoinColumn(name = &quot;jobId&quot;, foreignKey = @ForeignKey(name = &quot;none&quot;, value = ConstraintMode.NO_CONSTRAINT))</span></span><br><span class="line">    <span class="keyword">private</span> Job job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDetail</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mappedBy 只有在双向关联的时候设置，表示关系维护的一端，否则会生成中间表A_B</span></span><br><span class="line">    <span class="meta">@OneToMany(targetEntity = Employee.class, mappedBy = &quot;job&quot;)</span> </span><br><span class="line">    <span class="comment">// 注意这里不能使用 @JoinColumn 中的 @ForeignKey 不然会生成外键</span></span><br><span class="line">    <span class="meta">@org</span>.hibernate.annotations.ForeignKey(name = <span class="string">&quot;none&quot;</span>) </span><br><span class="line">    <span class="keyword">private</span> Set&lt;Employee&gt; employees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Specification-复杂查询"><a href="#Specification-复杂查询" class="headerlink" title="Specification 复杂查询"></a>Specification 复杂查询</h2><p>JPA复杂查询接口 <code>JpaSpecificationExecutor</code> 接口，可以完成各种复杂查询，配合 JAVA 8的新特性，使用起来特别的方便，一般用于单表的复杂查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param search   查询属性</span></span><br><span class="line"><span class="comment"> * @param pageable 分页和排序</span></span><br><span class="line"><span class="comment"> * @return 分页数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Employee&gt; <span class="title">pageBySearch</span><span class="params">(EmployeeSearch search, Pageable pageable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeDao.findAll((Specification&lt;Employee&gt;) (root, criteriaQuery, criteriaBuilder) -&gt; &#123;</span><br><span class="line">        List&lt;Predicate&gt; predicates = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Optional&lt;EmployeeSearch&gt; optional = Optional.ofNullable(search);</span><br><span class="line">        <span class="comment">// 根据 employee id 查询</span></span><br><span class="line">        optional.map(EmployeeSearch::getEmployeeId).ifPresent(id -&gt; &#123;</span><br><span class="line">            predicates.add(criteriaBuilder.equal(root.get(Employee_.id), id));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 根据 employee detail name 模糊查询</span></span><br><span class="line">        optional.map(EmployeeSearch::getEmployeeName).ifPresent(name -&gt; &#123;</span><br><span class="line">            Join&lt;Employee, EmployeeDetail&gt; join = root.join(Employee_.detail, JoinType.LEFT);</span><br><span class="line">            predicates.add(criteriaBuilder.like(join.get(EmployeeDetail_.name),</span><br><span class="line">                    <span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 根据职位名查询</span></span><br><span class="line">        optional.map(EmployeeSearch::getJobName).ifPresent(name -&gt; &#123;</span><br><span class="line">            Join&lt;Employee, Job&gt; join = root.join(Employee_.job, JoinType.LEFT);</span><br><span class="line">            predicates.add(criteriaBuilder.equal(join.get(Job_.name), name));</span><br><span class="line">        &#125;);</span><br><span class="line">        Predicate[] array = <span class="keyword">new</span> Predicate[predicates.size()];</span><br><span class="line">        <span class="keyword">return</span> criteriaBuilder.and(predicates.toArray(array));</span><br><span class="line">    &#125;, pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>针对有外键关联的表的查询条件，需要使用左联接；如上面的 employee detail name 模糊查询</li>
<li>如果直接 <code>get(Employee_.detail).get(EmployeeDetail_.name)</code> ，就是无条件内联，相当于 cross join，会产生笛卡尔积</li>
</ol>
</blockquote>
<h2 id="Criteria-查询"><a href="#Criteria-查询" class="headerlink" title="Criteria 查询"></a>Criteria 查询</h2><h3 id="普通的查询"><a href="#普通的查询" class="headerlink" title="普通的查询"></a>普通的查询</h3><p>返回结果类型：entity / Object[] / tuple / DTO</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line"><span class="keyword">private</span> EntityManager em;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Search age gt or eq the parameter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">listByAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">    CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class="line">    CriteriaQuery&lt;Employee&gt; query = cb.createQuery(Employee.class);</span><br><span class="line">    <span class="comment">// 设置查询根，可以根据查询的类型设置不同的 就是 Form 语句 后面的 entity</span></span><br><span class="line">    Root&lt;Employee&gt; root = query.from(Employee.class); </span><br><span class="line">    List&lt;Predicate&gt; predicates = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 连表查询使用左连接</span></span><br><span class="line">    Join&lt;Employee, EmployeeDetail&gt; join = root.join(Employee_.detail, JoinType.LEFT);</span><br><span class="line">    predicates.add(cb.gt(join.get(EmployeeDetail_.age), age));</span><br><span class="line">    predicates.add(cb.equal(join.get(EmployeeDetail_.age), age));</span><br><span class="line">    <span class="comment">// 设置排序规则</span></span><br><span class="line">    query.orderBy(cb.asc(root.get(Employee_.id)));</span><br><span class="line">    query.where(predicates.toArray(<span class="keyword">new</span> Predicate[predicates.size()]));</span><br><span class="line">    <span class="keyword">return</span> em.createQuery(query).getResultList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回DTO对象"><a href="#返回DTO对象" class="headerlink" title="返回DTO对象"></a>返回DTO对象</h4><p>因为不是一个Entity，则需要做一些特殊的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 构造函数 装载查询出来的数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;EmployeeResult&gt; <span class="title">findEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class="line">    CriteriaQuery&lt;EmployeeResult&gt; query = cb.createQuery(EmployeeResult.class);</span><br><span class="line">    <span class="comment">// 设置查询根，可以根据查询的类型设置不同的</span></span><br><span class="line">    Root&lt;Employee&gt; root = query.from(Employee.class); </span><br><span class="line">    Join&lt;Employee, EmployeeDetail&gt; join = root.join(Employee_.detail, JoinType.LEFT);</span><br><span class="line">    <span class="comment">// 使用构造函数 CriteriaBuilder.construct 来完成装载数据</span></span><br><span class="line">    query.select(cb.construct(EmployeeResult.class, join.get(EmployeeDetail_.name), join.get(EmployeeDetail_.age)));</span><br><span class="line">    <span class="comment">// 设置排序规则</span></span><br><span class="line">    Order order = cb.asc(root.get(Employee_.id));</span><br><span class="line">    query.orderBy(order);</span><br><span class="line">    TypedQuery typedQuery = em.createQuery(query); <span class="comment">// TypedQuery执行查询与获取元模型实例</span></span><br><span class="line">    <span class="keyword">return</span> typedQuery.getResultList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>query.select(CriteriaBuilder.construct())</code> 这种方式</p>
<p> 就相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query.mutipleSelect(</span><br><span class="line">      join.get(EmployeeDetail_.name), </span><br><span class="line">      join.get(EmployeeDetail_.age));</span><br></pre></td></tr></table></figure>

<p>而且顺序必须和DTO的构造方法的参数顺序一致才行</p>
</blockquote>
<h4 id="返回Object"><a href="#返回Object" class="headerlink" title="返回Object[]"></a>返回Object[]</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">criteriaQuery.select(criteriaBuilder.array(root.get(xxx),join.get(xxx)));</span><br></pre></td></tr></table></figure>



<h3 id="元模型查询"><a href="#元模型查询" class="headerlink" title="元模型查询"></a>元模型查询</h3><p>元模型实例通过调用 <code>EntityManager.getMetamodel</code> 方法获得，<code>EntityType&lt;Employee&gt;</code>的元模型实例通过调用<code>Metamodel.entity(Employee.class)</code>而获得，其被传入 <code>CriteriaQuery.from</code> 获得查询根</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Metamodel metamodel = em.getMetamodel();</span><br><span class="line">EntityType&lt;Employee&gt; Employee_ = metamodel.entity(Employee.class);</span><br><span class="line">Root&lt;Employee&gt; empRoot = criteriaQuery.from(Employee_);</span><br></pre></td></tr></table></figure>

<h3 id="Tuple查询"><a href="#Tuple查询" class="headerlink" title="Tuple查询"></a>Tuple查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分组统计重名数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Tuple&gt; <span class="title">groupByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class="line">    CriteriaQuery&lt;Tuple&gt; query = cb.createTupleQuery();</span><br><span class="line">    Root&lt;Employee&gt; root = query.from(Employee.class);</span><br><span class="line">    Join&lt;Employee, EmployeeDetail&gt; join = root.join(Employee_.detail, JoinType.LEFT);</span><br><span class="line">    query.groupBy(join.get(EmployeeDetail_.name));</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">        query.having(cb.like(join.get(EmployeeDetail_.name), <span class="string">&quot;%&quot;</span> + name + <span class="string">&quot;%&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    query.select(cb.tuple(join.get(EmployeeDetail_.name), cb.count(root)));</span><br><span class="line">    <span class="keyword">return</span> em.createQuery(query).getResultList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>描述：对于BigDecimal这种对象在HQL里没有构造方法的。可以使用查询Object再强转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">findRemainRefundableAmount</span><span class="params">(String orderNo)</span> </span>&#123;</span><br><span class="line">   CriteriaBuilder builder = entityManager.getCriteriaBuilder();</span><br><span class="line">    <span class="comment">// 返回值类型设置为Object</span></span><br><span class="line">   CriteriaQuery&lt;Object&gt; query = builder.createQuery(Object.class);</span><br><span class="line">   Root&lt;Account&gt; root = query.from(Account.class);</span><br><span class="line">    <span class="comment">// 查询的时候再进行强转</span></span><br><span class="line">   <span class="keyword">return</span> (BigDecimal) entityManager.createQuery(query).getSingleResult();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>写法1：这种写法优点是，可以排其他表的字段（userRoot -&gt;  accountRoot ）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">criteriaQuery.orderBy(builder.desc(userRoot.get(<span class="string">&quot;createTime&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>写法2：这种优点，可以将直接将参数的Pageable里面的sort对象之间排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">criteriaQuery.orderBy(QueryUtils.toOrders(pageable.getSort(), userRoot, builder));</span><br></pre></td></tr></table></figure>

<p>写法3：最常用的写法，对多个字段排序<code>List&lt;Order&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">criteriaQuery.orderBy(orderList);</span><br></pre></td></tr></table></figure>



<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.wuwii.com/jpa-specification.html">JPA 使用 Specification 复杂查询和 Criteria 查询</a></p>
]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>Spring Data</tag>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Pageable分页</title>
    <url>/2020/08/19/Pageable/</url>
    <content><![CDATA[<p>JpaRepository提供了两个和分页和排序有关的查询</p>
<p><code>List findAll(Sort sort)</code>: 按照指定顺序排序返回所有实体</p>
<p><code>List findAll(Pageable pageable)</code>: 分页查询</p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>Sort 对象用来指示排序，默认采用升序排序</p>
<p><code>Sort sort = new Sort(&quot;id&quot;);</code> // id 是 属性名</p>
<p><code>Sort sort = new Sort(Direction.DESC,&quot;id&quot;);</code></p>
<h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><p>Page接口可以获得</p>
<ol>
<li><p>当前页面的记录</p>
</li>
<li><p>总页数</p>
</li>
<li><p>总记录数</p>
</li>
<li><p>是否有上一页或下一页等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span> 总的页数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span> 返回总数</span></span><br><span class="line"><span class="function">List <span class="title">getContent</span><span class="params">()</span> 返回此次查询的结果集</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Spring Data 分页查询总是返回Page对象</p>
<h2 id="Pageable"><a href="#Pageable" class="headerlink" title="Pageable"></a>Pageable</h2><p>Pageable 接口用于构造翻页查询，PageRequest 是其实现类，它不仅仅支持分页，还支持排序(单字段/多字段均支持)</p>
<p><code>public static PageRequest of(int page, int size);</code></p>
<p><code>public static PageRequest of(int page, int size, Sort sort);</code></p>
<blockquote>
<p>page: 起始页，从0开始</p>
<p>size: 页大小，一页的行数</p>
</blockquote>
<h2 id="PageableDefault"><a href="#PageableDefault" class="headerlink" title="@PageableDefault"></a>@PageableDefault</h2><p>Controller层可以直接使用Pageable接收参数，如果要设置默认参数，可以使用</p>
<p><code>@PageableDefault</code>注解</p>
<p>参数例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PageableDefault(page = 0, value = 6, sort = &#123;&quot;createdTime&quot;&#125;, direction = Sort.Direction.DESC)</span> Pageable pageable</span><br></pre></td></tr></table></figure>

<p>RESTful接口的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8882&#x2F;api&#x2F;v1&#x2F;questionBanks&#x2F;byEnterprise?sort&#x3D;id%2Cdesc&amp;page&#x3D;0&amp;size&#x3D;2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：</p>
<p>api接口排序字段后面传的是[,asc/desc]</p>
<p>例如要排序的是id属性，则 id,desc</p>
<p>如果是升序的话，可以直接写属性名。</p>
</blockquote>
<h2 id="Order和Sort的转换"><a href="#Order和Sort的转换" class="headerlink" title="Order和Sort的转换"></a>Order和Sort的转换</h2><p>用EntityManager查询的时候，排序的类型是<code>javax.persistence.criteria.Order</code></p>
<p>所以需要将Sort对象转成Order对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;javax.persistence.criteria.Order&gt; QueryUtils.toOrders(Sort, Root, CriteriaBuilder)</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>Spring的web Pageable分页，页大小记录默认只支持2000，如果要超过这个限制，需要在配置文件中配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">pageable:</span></span><br><span class="line">        <span class="attr">max-page-size:</span> <span class="number">10000</span> <span class="comment"># 设置页大小</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>pageable</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security (二) WebSecurityConfigurer和filter的配置</title>
    <url>/2020/05/30/Spring%20Security%20(%E4%BA%8C)%20WebSecurityConfigurer%E5%92%8Cfilter%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>【转载】</p>
<p>作者：Ccww</p>
<p>链接：<a href="https://juejin.im/post/5d0b1eb35188252f921b1535">https://juejin.im/post/5d0b1eb35188252f921b1535</a></p>
</blockquote>
<h1 id="Spring-Security（二）–WebSecurityConfigurer配置以及filter顺序"><a href="#Spring-Security（二）–WebSecurityConfigurer配置以及filter顺序" class="headerlink" title="Spring Security（二）–WebSecurityConfigurer配置以及filter顺序"></a>Spring Security（二）–WebSecurityConfigurer配置以及filter顺序</h1><pre><code>在认证过程和访问授权前必须了解spring Security如何知道我们要求所有用户都经过身份验证？ Spring Security如何知道我们想要支持基于表单的身份验证？因此必须了解WebSecurityConfigurerAdapter配置类如何工作的。而且也必须了解清楚filter的顺序，才能更好了解其调用工作流程。</code></pre><h2 id="WebSecurityConfigurerAdapter"><a href="#WebSecurityConfigurerAdapter" class="headerlink" title="WebSecurityConfigurerAdapter"></a>WebSecurityConfigurerAdapter</h2><pre><code>在使用 `WebSecurityConfigurerAdapter` 前，先了解 Spring security config。
Spring security config 具有三个模块，一共有3个 builder，认证相关的 `AuthenticationManagerBuilder` 和web相关的 `WebSecurity`、`HttpSecurity`。</code></pre><ol>
<li><p><code>AuthenticationManagerBuilder</code>：用来配置全局的认证相关的信息，其实就是<code>AuthenticationProvider</code>和<code>UserDetailsService</code>，前者是认证服务提供商，后者是用户详情查询服务；</p>
</li>
<li><p><code>WebSecurity</code>： 全局请求忽略规则配置（比如说静态文件，比如说注册页面）、全局<code>HttpFirewall</code>配置、是否debug配置、全局<code>SecurityFilterChain</code>配置、<code>privilegeEvaluator</code>、<code>expressionHandler</code>、<code>securityInterceptor</code>；</p>
</li>
<li><p><code>HttpSecurity</code>：具体的权限控制规则配置。一个这个配置相当于xml配置中的一个标签。各种具体的认证机制的相关配置，<code>OpenIDLoginConfigurer</code>、<code>AnonymousConfigurer</code>、<code>FormLoginConfigurer</code>、<code>HttpBasicConfigurer</code>等。</p>
<pre><code>`WebSecurityConfigurerAdapter`提供了简洁方式来创建`WebSecurityConfigurer`，其作为基类，可通过实现该类自定义配置类，主要重写这三个方法：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<pre><code>而且其自动从`SpringFactoriesLoader`查找`AbstractHttpConfigurer`让我们去扩展，想要实现必须创建一个`AbstractHttpConfigurer`的扩展类，并在classpath路径下创建一个文件META-INF/spring.factories。例如：</code></pre><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer</span> = <span class="string">sample.MyClassThatExtendsAbstractHttpConfigurer</span></span><br></pre></td></tr></table></figure>

<p>其源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.init初始化：获取HttpSecurity和配置FilterSecurityInterceptor拦截器到WebSecurity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> WebSecurity web)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">//获取HttpSecurity</span></span><br><span class="line">   <span class="keyword">final</span> HttpSecurity http = getHttp();</span><br><span class="line">   <span class="comment">//配置FilterSecurityInterceptor拦截器到WebSecurity</span></span><br><span class="line">   web.addSecurityFilterChainBuilder(http).postBuildAction(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       FilterSecurityInterceptor securityInterceptor = http</span><br><span class="line">               .getSharedObject(FilterSecurityInterceptor.class);</span><br><span class="line">       web.securityInterceptor(securityInterceptor);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">   .....</span><br><span class="line"><span class="comment">//2.获取HttpSecurity的过程</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (http != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> http;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   DefaultAuthenticationEventPublisher eventPublisher = objectPostProcessor</span><br><span class="line">           .postProcess(<span class="keyword">new</span> DefaultAuthenticationEventPublisher());</span><br><span class="line">   localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line"></span><br><span class="line">   AuthenticationManager authenticationManager = authenticationManager();</span><br><span class="line">   authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">   Map&lt;Class&lt;? extends Object&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class="line"></span><br><span class="line">   http = <span class="keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">           sharedObjects);</span><br><span class="line">   <span class="keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line">     <span class="comment">// 默认的HttpSecurity的配置</span></span><br><span class="line">     http</span><br><span class="line">             <span class="comment">//添加 CSRF 支持，使用WebSecurityConfigurerAdapter时，默认启用，禁用csrf().disable()</span></span><br><span class="line">             .csrf().and()</span><br><span class="line">             <span class="comment">//添加WebAsyncManagerIntegrationFilter</span></span><br><span class="line">             .addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter())</span><br><span class="line">             <span class="comment">//允许配置异常处理</span></span><br><span class="line">             .exceptionHandling().and()</span><br><span class="line">             <span class="comment">//将安全标头添加到响应</span></span><br><span class="line">             .headers().and()</span><br><span class="line">             <span class="comment">//允许配置会话管理</span></span><br><span class="line">             .sessionManagement().and()</span><br><span class="line">             <span class="comment">//HttpServletRequest之间的SecurityContextHolder创建securityContext管理</span></span><br><span class="line">             .securityContext().and()</span><br><span class="line">             <span class="comment">//允许配置请求缓存</span></span><br><span class="line">             .requestCache().and()</span><br><span class="line">             <span class="comment">//允许配置匿名用户</span></span><br><span class="line">             .anonymous().and()</span><br><span class="line">             <span class="comment">//HttpServletRequestd的方法和属性注册在SecurityContext中</span></span><br><span class="line">             .servletApi().and()</span><br><span class="line">             <span class="comment">//使用默认登录页面</span></span><br><span class="line">             .apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()</span><br><span class="line">             <span class="comment">//提供注销支持</span></span><br><span class="line">             .logout();</span><br><span class="line">     <span class="comment">// @formatter:on</span></span><br><span class="line">     ClassLoader classLoader = <span class="keyword">this</span>.context.getClassLoader();</span><br><span class="line">     List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class="line">             SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class="line">       http.apply(configurer);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   configure(http);</span><br><span class="line">   <span class="keyword">return</span> http;</span><br><span class="line"> &#125;</span><br><span class="line">   .....</span><br><span class="line"> <span class="comment">//3.可重写方法实现自定义的HttpSecurity   </span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity).&quot;</span>);</span><br><span class="line"></span><br><span class="line">   http</span><br><span class="line">           .authorizeRequests()</span><br><span class="line">           .anyRequest().authenticated()</span><br><span class="line">           .and()</span><br><span class="line">           .formLogin().and()</span><br><span class="line">           .httpBasic();</span><br><span class="line"> &#125;</span><br><span class="line">   .....</span><br></pre></td></tr></table></figure>

<pre><code>从源码init初始化模块中的“获取`HttpSecurity`”和“配置`FilterSecurityInterceptor`拦截器到`WebSecurity`”中可以看出，想要spring Security如何知道我们要求所有用户都经过身份验证？ Spring Security如何知道我们想要支持基于表单的身份验证？只要重写`protected void configure(HttpSecurity http) throws Exception`方法即可。因此我们需要理解`HttpSecurity`的方法的作用，如何进行配置。下一节来讨论`HttpSecurity`。</code></pre><h2 id="HttpSecurity"><a href="#HttpSecurity" class="headerlink" title="HttpSecurity"></a>HttpSecurity</h2><pre><code>`HttpSecurity`基于Web的安全性允许为特定的http请求进行配置。其有很多方法，列举一些常用的如下表：</code></pre><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
<th align="left">使用案例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">csrf()</td>
<td align="left">添加 CSRF 支持，使用WebSecurityConfigurerAdapter时，默认启用</td>
<td align="left">禁用：csrf().disable()</td>
</tr>
<tr>
<td align="left">openidLogin()</td>
<td align="left">用于基于 OpenId 的验证</td>
<td align="left">openidLogin().permitAll();</td>
</tr>
<tr>
<td align="left">authorizeRequests()</td>
<td align="left">开启使用HttpServletRequest请求的访问限制</td>
<td align="left">authorizeRequests().anyRequest().authenticated()</td>
</tr>
<tr>
<td align="left">formLogin()</td>
<td align="left">开启表单的身份验证，如果未指定FormLoginConfigurer#loginPage(String)，则将生成默认登录页面</td>
<td align="left">formLogin().loginPage(“/authentication/login”).failureUrl(“/authentication/login?failed”)</td>
</tr>
<tr>
<td align="left">oauth2Login()</td>
<td align="left">开启OAuth 2.0或OpenID Connect 1.0身份验证</td>
<td align="left">authorizeRequests()..anyRequest().authenticated()..and().oauth2Login()</td>
</tr>
<tr>
<td align="left">rememberMe()</td>
<td align="left">开启配置“记住我”的验证</td>
<td align="left">authorizeRequests().antMatchers(“/**”).hasRole(“USER”).and().formLogin().permitAll().and().rememberMe()</td>
</tr>
<tr>
<td align="left">addFilter()</td>
<td align="left">添加自定义的filter</td>
<td align="left">addFilter(new CustomFilter())</td>
</tr>
<tr>
<td align="left">addFilterAt()</td>
<td align="left">在指定filter相同位置上添加自定义filter</td>
<td align="left">addFilterAt(new CustomFilter(), UsernamePasswordAuthenticationFilter.class)</td>
</tr>
<tr>
<td align="left">addFilterAfter()</td>
<td align="left">在指定filter位置后添加自定义filter</td>
<td align="left">addFilterAfter(new CustomFilter(), UsernamePasswordAuthenticationFilter.class)</td>
</tr>
<tr>
<td align="left">requestMatchers()</td>
<td align="left">开启配置HttpSecurity，仅当RequestMatcher相匹配时开启</td>
<td align="left">requestMatchers().antMatchers(“/api/**”)</td>
</tr>
<tr>
<td align="left">antMatchers()</td>
<td align="left">其可以与authorizeRequests()、RequestMatcher匹配，如：requestMatchers().antMatchers(“/api/**”)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">logout()</td>
<td align="left">添加退出登录支持。当使用WebSecurityConfigurerAdapter时，这将自动应用。默认情况是，访问URL”/ logout”，使HTTP Session无效来清除用户，清除已配置的任何#rememberMe()身份验证，清除SecurityContextHolder，然后重定向到”/login?success”</td>
<td align="left">logout().deleteCookies(“remove”).invalidateHttpSession(false).logoutUrl(“/custom-logout”).logoutSuccessUrl(“/logout-success”);</td>
</tr>
</tbody></table>
<p><code>HttpSecurity</code>还有很多方法供我们使用，去配置<code>HttpSecurity</code>。由于太多这边就不一一说明，有兴趣可去研究。</p>
<h2 id="WebSecurityConfigurerAdapter-使用"><a href="#WebSecurityConfigurerAdapter-使用" class="headerlink" title="WebSecurityConfigurerAdapter 使用"></a>WebSecurityConfigurerAdapter 使用</h2><p><code>WebSecurityConfigurerAdapter</code>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="keyword">private</span> MyFilterSecurityInterceptor myFilterSecurityInterceptor;</span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;    </span><br><span class="line">     http</span><br><span class="line">     <span class="comment">//request 设置</span></span><br><span class="line">     .authorizeRequests()   <span class="comment">//http.authorizeRequests() 方法中的自定义匹配</span></span><br><span class="line">     .antMatchers(<span class="string">&quot;/resources/**&quot;</span>, <span class="string">&quot;/signup&quot;</span>, <span class="string">&quot;/about&quot;</span>).permitAll() <span class="comment">// 指定所有用户进行访问指定的url          </span></span><br><span class="line">     .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)  <span class="comment">//指定具有特定权限的用户才能访问特定目录，hasRole()方法指定用户权限，且不需前缀 “ROLE_“  </span></span><br><span class="line">     .antMatchers(<span class="string">&quot;/db/**&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) and hasRole(&#x27;DBA&#x27;)&quot;</span>)<span class="comment">//          </span></span><br><span class="line">     .anyRequest().authenticated()  <span class="comment">//任何请求没匹配的都需要进行验证                                           </span></span><br><span class="line">     .and()        <span class="comment">//login设置  自定义登录页面且允许所有用户登录</span></span><br><span class="line">     .formLogin()      </span><br><span class="line">     .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">//The updated configuration specifies the location of the log in page  指定自定义登录页面</span></span><br><span class="line">     .permitAll(); <span class="comment">// 允许所有用户访问登录页面. The formLogin().permitAll() 方法</span></span><br><span class="line">     .and </span><br><span class="line">     .logout()  <span class="comment">//logouts 设置                                                              </span></span><br><span class="line">     .logoutUrl(<span class="string">&quot;/my/logout&quot;</span>)  <span class="comment">// 指定注销路径                                              </span></span><br><span class="line">     .logoutSuccessUrl(<span class="string">&quot;/my/index&quot;</span>) <span class="comment">//指定成功注销后跳转到指定的页面                                        </span></span><br><span class="line">     .logoutSuccessHandler(logoutSuccessHandler)  <span class="comment">//指定成功注销后处理类 如果使用了logoutSuccessHandler()的话， logoutSuccessUrl()就会失效                                </span></span><br><span class="line">     .invalidateHttpSession(<span class="keyword">true</span>)  <span class="comment">// httpSession是否有效时间，如果使用了 SecurityContextLogoutHandler，其将被覆盖                                        </span></span><br><span class="line">     .addLogoutHandler(logoutHandler)  <span class="comment">//在最后增加默认的注销处理类LogoutHandler                </span></span><br><span class="line">     .deleteCookies(cookieNamesToClear);<span class="comment">//指定注销成功后remove cookies</span></span><br><span class="line">     <span class="comment">//增加在FilterSecurityInterceptor前添加自定义的myFilterSecurityInterceptor</span></span><br><span class="line">     http.addFilterBefore(myFilterSecurityInterceptor, FilterSecurityInterceptor.class);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NOTE：此示例只供参考</p>
</blockquote>
<h2 id="filter-顺序"><a href="#filter-顺序" class="headerlink" title="filter 顺序"></a>filter 顺序</h2><p>Spring Security filter顺序：</p>
<table>
<thead>
<tr>
<th align="left">Filter Class</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ChannelProcessingFilter</td>
<td align="left">访问协议控制过滤器，可能会将我们重新定向到另外一种协议,从http转换成https</td>
</tr>
<tr>
<td align="left">SecurityContextPersistenceFilter</td>
<td align="left">创建SecurityContext安全上下文信息和request结束时清空SecurityContextHolder</td>
</tr>
<tr>
<td align="left">ConcurrentSessionFilter</td>
<td align="left">并发访问控制过滤器,主要功能：SessionRegistry中获取SessionInformation来判断session是否过期，从而实现并发访问控制。</td>
</tr>
<tr>
<td align="left">HeaderWriterFilter</td>
<td align="left">给http response添加一些Header</td>
</tr>
<tr>
<td align="left">CsrfFilter</td>
<td align="left">跨域过滤器，跨站请求伪造保护Filter</td>
</tr>
<tr>
<td align="left">LogoutFilter</td>
<td align="left">处理退出登录的Filter</td>
</tr>
<tr>
<td align="left">X509AuthenticationFilter</td>
<td align="left">添加X509预授权处理机制支持</td>
</tr>
<tr>
<td align="left">CasAuthenticationFilter</td>
<td align="left">认证filter，经过这些过滤器后SecurityContextHolder中将包含一个完全组装好的Authentication对象，从而使后续鉴权能正常执行</td>
</tr>
<tr>
<td align="left">UsernamePasswordAuthenticationFilter</td>
<td align="left">认证的filter，经过这些过滤器后SecurityContextHolder中将包含一个完全组装好的Authentication对象，从而使后续鉴权能正常执行。表单认证是最常用的一个认证方式。</td>
</tr>
<tr>
<td align="left">BasicAuthenticationFilter</td>
<td align="left">认证filter，经过这些过滤器后SecurityContextHolder中将包含一个完全组装好的Authentication对象，从而使后续鉴权能正常执行</td>
</tr>
<tr>
<td align="left">SecurityContextHolderAwareRequestFilter</td>
<td align="left">此过滤器对ServletRequest进行了一次包装，使得request具有更加丰富的API</td>
</tr>
<tr>
<td align="left">JaasApiIntegrationFilter</td>
<td align="left">(JAAS)认证方式filter</td>
</tr>
<tr>
<td align="left">RememberMeAuthenticationFilter</td>
<td align="left">记忆认证处理过滤器，即是如果前面认证过滤器没有对当前的请求进行处理，启用了RememberMe功能，会从cookie中解析出用户，并进行认证处理，之后在SecurityContextHolder中存入一个Authentication对象。</td>
</tr>
<tr>
<td align="left">AnonymousAuthenticationFilter</td>
<td align="left">匿名认证处理过滤器，当SecurityContextHolder中认证信息为空,则会创建一个匿名用户存入到SecurityContextHolder中</td>
</tr>
<tr>
<td align="left">SessionManagementFilter</td>
<td align="left">会话管理Filter，持久化用户登录信息，可以保存到session中，也可以保存到cookie或者redis中</td>
</tr>
<tr>
<td align="left">ExceptionTranslationFilter</td>
<td align="left">异常处理过滤器，主要拦截后续过滤器（FilterSecurityInterceptor）操作中抛出的异常。</td>
</tr>
<tr>
<td align="left">FilterSecurityInterceptor</td>
<td align="left">安全拦截过滤器类，获取当前请求url对应的ConfigAttribute，并调用accessDecisionManager进行访问授权决策。</td>
</tr>
</tbody></table>
<p><strong>spring security的默认filter链:</strong></p>
<blockquote>
<p> SecurityContextPersistenceFilter<br>-&gt;HeaderWriterFilter<br>-&gt;LogoutFilter<br>-&gt;UsernamePasswordAuthenticationFilter<br>-&gt;RequestCacheAwareFilter<br>-&gt;SecurityContextHolderAwareRequestFilter<br>-&gt;SessionManagementFilter<br>-&gt;ExceptionTranslationFilter<br>-&gt;FilterSecurityInterceptor</p>
</blockquote>
<p>在上节我们已分析了核心的filter源码以及功能。可回看上节源码分析更加深入的了解各个filter工作原理。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><pre><code>在认证和访问授权过程前，首先必须进行WebSecurityConfigurer符合自身应用的security Configurer，也要清楚filter链的先后顺序，才能更好理解spring security的工作原理以及在项目中出现的问题定位。</code></pre>]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>RestTemplate接收泛型参数</title>
    <url>/2019/09/28/RestTemplate%E6%8E%A5%E6%94%B6%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>使用restTemplate的postForObject等方法不能正确接收除了String的其他泛型的参数</p>
<blockquote>
<p>如：Map&lt;String, UserDTO&gt;；List&lt;UserDTO&gt;中的UserDTO会自动用LinkedHashMap接收，从而变成 Map&lt;String, LinkedHashMap&gt; 和 List&lt;LinkedHashMap&gt;，导致接收端不能正确接收参数</p>
</blockquote>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>使用ParameterizedTypeReference&lt;T&gt;指定泛型，就可以正确接收数据了</p>
<h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParameterizedTypeReference&lt;Map&lt;String, UserDTO&gt;&gt; typeRef = <span class="keyword">new</span> ParameterizedTypeReference&lt;Map&lt;String, UserDTO&gt;&gt;() &#123;&#125;;</span><br><span class="line">    ResponseEntity&lt;Map&lt;String, UserDTO&gt;&gt; responseEntity = restTemplate.exchange(requestUrl, HttpMethod.POST, <span class="keyword">new</span> HttpEntity&lt;&gt;(params), typeRef);</span><br><span class="line">    Map&lt;String, UserDTO&gt; list = responseEntity.getBody();</span><br></pre></td></tr></table></figure>



<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ParameterizedTypeReference&lt;List&lt;UserDTO&gt;&gt; typeRef = <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;UserDTO&gt;&gt;() &#123;&#125;;</span><br><span class="line">  ResponseEntity&lt;List&lt;UserDTO&gt;&gt; responseEntity = restTemplate.exchange(requestUrl, HttpMethod.POST, <span class="keyword">new</span> HttpEntity&lt;&gt;(params), typeRef);</span><br><span class="line">  List&lt;UserDTO&gt; list = responseEntity.getBody();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 什么是 Spring Data Rest</title>
    <url>/2021/01/30/SpringDataJpa%E4%B9%8BSpringDataRest/</url>
    <content><![CDATA[<h1 id="Spring-Data-Rest-是什么-和-JPA-是什么关系"><a href="#Spring-Data-Rest-是什么-和-JPA-是什么关系" class="headerlink" title="Spring Data Rest 是什么 和 JPA 是什么关系?"></a>Spring Data Rest 是什么 和 JPA 是什么关系?</h1><h2 id="Spring-Data-Rest-Demo"><a href="#Spring-Data-Rest-Demo" class="headerlink" title="Spring Data Rest Demo"></a>Spring Data Rest Demo</h2><p>通过以下四个步骤演示一下 Spring Data Rest 的效果。</p>
<p><strong>第一步：通过 gradle 引入相关的 jar 依赖</strong>，代码如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;</span></span><br><span class="line"><span class="comment">// spring data rest的依赖，由于使用的是spring boot，所以只需要添加starter即可</span></span><br><span class="line">implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-data-rest&quot;</span>)</span><br><span class="line"><span class="comment">//添加swagger方便看得出来，生成了哪些api接口</span></span><br><span class="line">implementation <span class="string">&#x27;io.springfox:springfox-boot-starter:3.0.0&#x27;</span></span><br><span class="line"><span class="comment">// swagger 对spring data rest支持需要添加 springfox-data-rest</span></span><br><span class="line">implementation <span class="string">&#x27;io.springfox:springfox-data-rest:3.0.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>添加完依赖之后，可以通过 gradle 的依赖视图看一下都用了哪些 jar 包。</p>
<p><img src="http://image.leonote.cn//20210130165502.jpg" alt=""></p>
<p>通过上图可以很清晰地看到 spring-data-rest 的 jar 包引入情况，以及依赖的 spring-data-jpa 和 Swagger。</p>
<p><strong>第二步：在项目里面添加 SpringFoxConfiguration 开启 Swagger</strong>，代码如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringFoxConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：通过 application.properties 指定一个 base-path，以方便和自己的 api 进行区分</strong>，代码如下所示。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以通过spring data rest里面提供的配置项，指定bast-path</span></span><br><span class="line"><span class="meta">spring.data.rest.base-path</span>=<span class="string">api/rest/v2</span></span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20210130165729.jpg" alt=""></p>
<p>这时打开 Swagger 看一下：<a href="http://127.0.0.1:8087/swagger-ui/">http://127.0.0.1:8087/swagger-ui/</a></p>
<p><img src="http://image.leonote.cn//20210130165856.jpg" alt=""></p>
<p>由于 Demo 的项目结构是下图所示这样的。</p>
<p><img src="http://image.leonote.cn//20210130165941.jpg" alt=""></p>
<p>你会发现有几个 Repository 会生成几个对应的 Rest 协议的 API，除了基本的 CRUD，例如 UserInfoRespository 自定义的方法它们也会帮我们展示出来。而 Room 实体因为没有对应的 Repository，所以不会有对应的 Rest 风格 API 生成。</p>
<p>通过这个 Demo 可以想象一下，如果要做一个 Rest 风格的 Server API 项目，只需要把对应的 Entity 和 Repository 建好，就可以直接拥有了所有的 CRUD 的 API 了，这样可以大大提高我们的开发效率。</p>
<h2 id="Spring-Data-Rest-基本用法"><a href="#Spring-Data-Rest-基本用法" class="headerlink" title="Spring Data Rest 基本用法"></a>Spring Data Rest 基本用法</h2><p>通过 Demo 可以看得出来，Spring Data Rest 的核心功能就是把 Spring Data Resositories 里对外暴露的方法生成对应的 API，如上面的 <code>AddressRepository</code>，里面对应的实体是 Address，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>它帮我们生成的 API 有下图所示的这些。</p>
<p><img src="http://image.leonote.cn//20210130170309.jpg" alt=""></p>
<p>从 swagger 可以看到 Spring Data Rest 的几点用法。</p>
<h3 id="语义化的方法"><a href="#语义化的方法" class="headerlink" title="语义化的方法"></a>语义化的方法</h3><p>把实体转化成复数的形式，生成基本的 PATCH、GET、PUT、POST、DELETE 带有语义的 Rest 相应的方法，包括的子资源有如下几个。</p>
<ul>
<li><p>GET：返回单个实体</p>
</li>
<li><p>PUT：更新资源</p>
</li>
<li><p>PATCH：与 PUT 类似，但部分是更新资源状态</p>
</li>
<li><p>DELETE：删除暴露的资源</p>
</li>
<li><p>POST：从给定的请求正文创建一个新的实体</p>
</li>
</ul>
<h3 id="默认的状态码的支持"><a href="#默认的状态码的支持" class="headerlink" title="默认的状态码的支持"></a>默认的状态码的支持</h3><ul>
<li><p>200 OK：适用于纯粹的 GET 请求</p>
</li>
<li><p>201 Created：针对创建新资源的 POST 和 PUT 请求</p>
</li>
<li><p>204 No Content：对于 PUT、PATCH 和 DELETE 请求</p>
</li>
<li><p>401 没有认证</p>
</li>
<li><p>403 没有权限，拒绝访问</p>
</li>
<li><p>404 没有找到对应的资源</p>
</li>
</ul>
<h3 id="分页支持"><a href="#分页支持" class="headerlink" title="分页支持"></a>分页支持</h3><p>通过 Swagger，可以看到其完全对分页和排序进行支持，完全兼容 Spring Data JPA 的分页和排序的参数，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130170639.jpg" alt=""></p>
<h3 id="通过-RepositoryRestResource-改变资源的-metaData"><a href="#通过-RepositoryRestResource-改变资源的-metaData" class="headerlink" title="通过 @RepositoryRestResource 改变资源的 metaData"></a>通过 @RepositoryRestResource 改变资源的 metaData</h3><p>代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource(</span></span><br><span class="line"><span class="meta">      exported = true, //资源是否暴露，默认true</span></span><br><span class="line"><span class="meta">      path = &quot;users&quot;,//资源暴露的path访问路径，默认实体名字+s</span></span><br><span class="line"><span class="meta">      collectionResourceRel = &quot;userInfo&quot;,//资源名字，默认实体名字</span></span><br><span class="line"><span class="meta">      collectionResourceDescription = @Description(&quot;用户基本信息资源&quot;),//资源描述</span></span><br><span class="line"><span class="meta">      itemResourceRel = &quot;userDetail&quot;,//取资源详情的Item名字</span></span><br><span class="line"><span class="meta">      itemResourceDescription = @Description(&quot;用户详情&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>将其放置在 UserInfoRepository 上面测试一下，代码变更如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepositoryRestResource(</span></span><br><span class="line"><span class="meta">      exported = true,</span></span><br><span class="line"><span class="meta">      path = &quot;users&quot;,</span></span><br><span class="line"><span class="meta">      collectionResourceRel = &quot;userInfo&quot;,</span></span><br><span class="line"><span class="meta">      collectionResourceDescription = @Description(&quot;用户资源&quot;),</span></span><br><span class="line"><span class="meta">      itemResourceRel = &quot;userDetail&quot;,</span></span><br><span class="line"><span class="meta">      itemResourceDescription = @Description(&quot;用户详情&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这时通过 Swagger 可以看到，url 的 path 上面变成了 users，而 body 里面的资源名字变成了 userInfo，取 itemResource 的 URL 描述变成了 userDetail，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130171017.jpg" alt=""></p>
<p>@RepositoryRestResource 是使用在 Repository 类上面的全局设置，也可以针对具体的 Repsitory 里面的每个方法进行单独设置，这就是另外一个注解：@RestResource。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestResource(</span></span><br><span class="line"><span class="meta">      exported = true,//是否暴露给Search</span></span><br><span class="line"><span class="meta">      path = &quot;findCities&quot;,//Search后面的path路径</span></span><br><span class="line"><span class="meta">      rel = &quot;cities&quot;//资源名字</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure>

<p>可以将其用于 ***Repository 的方法中和 @Entity 的实体关系上，那么在 address 的 findByAddress 方法上面做一个测试，看看会变成什么样，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@RestResource(</span></span><br><span class="line"><span class="meta">            exported = true,//是否暴露给Search</span></span><br><span class="line"><span class="meta">            path = &quot;findCities&quot;,//Search后面的path路径</span></span><br><span class="line"><span class="meta">            rel = &quot;cities&quot;//资源名字</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function">Page&lt;Address&gt; <span class="title">findByAddress</span><span class="params">(<span class="meta">@Param(&quot;address&quot;)</span> String address, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开 Swagger 看一下结果，会发现 search 后面的 path 路径被自定义了，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130171243.jpg" alt=""></p>
<p>同时这个注解也可以配置在关联关系上，如 @OneToMany 等。如果不想某些方法暴露成 RestAPI，就直接添加 @RestResource(exported = false) 这一注解即可，例如一些删除方法等。</p>
<h3 id="spring-data-rest-的配置项支持"><a href="#spring-data-rest-的配置项支持" class="headerlink" title="spring data rest 的配置项支持"></a>spring data rest 的配置项支持</h3><p>这个可以直接在 application.properties 里面配置，在 IDEA 里面输入前缀的时候，就会有如下提示。</p>
<p><img src="http://image.leonote.cn//20210130171536.jpg" alt=""></p>
<p>对应的描述如下表所示。</p>
<p><img src="http://image.leonote.cn//20210130171651.jpg" alt=""></p>
<h2 id="返回结果对-Jackson-的支持"><a href="#返回结果对-Jackson-的支持" class="headerlink" title="返回结果对 Jackson 的支持"></a>返回结果对 Jackson 的支持</h2><p>通过 jackson 的注解，可以改变 rest api 的属性的名字，或者忽略具体的某个属性。在 address 的实体里面，改变一下属性 city 的名字，同时忽略 address 属性，代码会变成如下所示的样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@JsonProperty(&quot;myCity&quot;)</span> <span class="comment">//改变JSON响应的属性名字</span></span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="meta">@JsonIgnore</span> <span class="comment">//JSON解析的时候忽略某个属性</span></span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Swagger 里面的 Description 可以看到，当前的资源的描述发生了变化，字段名变成了 myCity，address 属性没有了，具体如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130171841.jpg" alt=""></p>
<p>Spring Data Rest 返回 ResponseBody 的原理和接收 RequestBody 的原理都是基于 JSON 格式的</p>
<h2 id="Spring-Data-Rest-和-Spring-Data-JPA-的关系"><a href="#Spring-Data-Rest-和-Spring-Data-JPA-的关系" class="headerlink" title="Spring Data Rest 和 Spring Data JPA 的关系"></a>Spring Data Rest 和 Spring Data JPA 的关系</h2><ol>
<li><p>Spring Data JPA 基于 JPA 协议提供了一套标准的 Repository 的操作统一接口，方法名和 @Query 都是有固定语法和约定的规则的。</p>
</li>
<li><p>Spring Data Rest 利用 JPA 的约定和语法，利用 Java 反射、动态代理等机制，很容易可以生成一套标准的 rest 风格的 API 协议操作。</p>
</li>
<li><p>也就是说 JPA 制定协议和标准，Spring Data Rest 基于这套协议生成 rest 风格的 Controller。</p>
</li>
</ol>
<blockquote>
<p>🎯JPA 的应用领域其实有很多，在写一些基于实体的框架时就可以参考 Spring Data Rest 的做法。例如 <a href="https://jsonapi.org/format/">yahoo 团队设计的 JSONAPI 协议</a>，以及 <a href="https://github.com/yahoo/elide/blob/master/translations/zh/README.md">Elide 的实现</a>，也是基于 JPA 的实体注解来实现的。</p>
<p>甚至 Spring 在研究的 graph QL，也可以基于约定的实体来做很多事情。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 乐观锁与重试机制</title>
    <url>/2020/11/10/SpringDataJpa%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-乐观锁与重试机制"><a href="#Spring-Data-Jpa-乐观锁与重试机制" class="headerlink" title="Spring Data Jpa 乐观锁与重试机制"></a>Spring Data Jpa 乐观锁与重试机制</h1><h2 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h2><p>乐观锁在实际开发过程中很常用，它没有加锁、没有阻塞，在多线程环境以及高并发的情况下 CPU 的利用率是最高的，吞吐量也是最大的。</p>
<p>而 Java Persistence API 协议也对乐观锁的操作做了规定：通过指定 <code>@Version</code> 字段对数据增加版本号控制，进而在更新的时候判断版本号是否有变化。如果没有变化就直接更新；如果有变化，就会更新失败并抛出“OptimisticLockException”异常。我们用 SQL 表示一下乐观锁的做法，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> uid, name, version <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;jack&#x27;</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> version<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>假设本次查询的 version=1，在更新操作时，加上这次查出来的 Version，这样和我们上一个版本相同，就会更新成功，并且不会出现互相覆盖的问题，保证了数据的原子性。</p>
<p>这就是乐观锁在数据库里面的应用。</p>
<h2 id="乐观锁的实现方法"><a href="#乐观锁的实现方法" class="headerlink" title="乐观锁的实现方法"></a>乐观锁的实现方法</h2><p>JPA 协议规定，想要实现乐观锁可以通过 <code>@Version</code> 注解标注在某个字段上面，并且可以持久化到 DB 即可。其支持的类型有如下四种：</p>
<ul>
<li><p>Integer</p>
</li>
<li><p>Short</p>
</li>
<li><p>Long</p>
</li>
<li><p>java.sql.Timestamp</p>
</li>
</ul>
<p>这样就可以完成乐观锁的操作。我比较推荐使用 Integer 类型的字段，因为这样语义比较清晰、简单。</p>
<blockquote>
<p>注意：Spring Data JPA 里面有两个 <code>@Version</code> 注解</p>
<p>请使用 @javax.persistence.Version</p>
<p>而不是 @org.springframework.data.annotation.Version</p>
</blockquote>
<h3 id="Version-的用法"><a href="#Version-的用法" class="headerlink" title="@Version 的用法"></a>@Version 的用法</h3><p><strong>1. 实体里面添加带 <code>@Version</code> 注解的持久化字段</strong></p>
<p>直接在这个 BaseEntity 基类里面添加 <code>@Version</code> 即可，当然也可以把这个字段放在 sub-class-entity 里面。推荐放在基类里面，因为这段逻辑是公共的字段。改动完之后我们看看会发生什么变化，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="meta">@Version</span></span><br><span class="line">   <span class="keyword">private</span> Integer version;</span><br><span class="line">   <span class="comment">//......当然也可以用上一课时讲解的 auditing 字段，这里我们先省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 用 UserInfo 实体继承 BaseEntity</strong>，就可以实现 <code>@Version</code> 的效果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建 UserInfoRepository</strong>，方便进行 DB 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 创建 UserInfoService 和 UserInfoServiceImpl</strong>，用来模拟 Service 的复杂业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据 UserId 产生的一些业务计算逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">UserInfo <span class="title">calculate</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据 UserId 产生的一些业务计算逻辑</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span>   </span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">calculate</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      UserInfo userInfo = userInfoRepository.getOne(userId);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//模拟复杂的业务计算逻辑耗时操作；</span></span><br><span class="line">         Thread.sleep(<span class="number">500</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      userInfo.setAges(userInfo.getAges()+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> userInfoRepository.saveAndFlush(userInfo);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，我们通过 <code>@Transactional</code> 开启事务，并且在查询方法后面模拟复杂业务逻辑，用来呈现多线程的并发问题。</p>
<p><strong>5. 测试用例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses=UserInfoServiceImpl.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//加一条数据</span></span><br><span class="line">      UserInfo userInfo = userInfoRepository.save(UserInfo.builder().ages(<span class="number">20</span>).telephone(<span class="string">&quot;1233456&quot;</span>).build());</span><br><span class="line">      <span class="comment">//验证一下数据库里面的值</span></span><br><span class="line">      Assertions.assertEquals(<span class="number">0</span>, userInfo.getVersion());</span><br><span class="line">      Assertions.assertEquals(<span class="number">20</span>, userInfo.getAges());</span><br><span class="line">      userInfoService.calculate(<span class="number">1L</span>);</span><br><span class="line">      <span class="comment">//验证一下更新成功的值</span></span><br><span class="line">      UserInfo u2 =  userInfoRepository.getOne(<span class="number">1L</span>);</span><br><span class="line">      Assertions.assertEquals(<span class="number">1</span>, u2.getVersion());</span><br><span class="line">      Assertions.assertEquals(<span class="number">21</span>, u2.getAges());</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Rollback(false)</span></span><br><span class="line">   <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVersionException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//加一条数据</span></span><br><span class="line">  userInfoRepository.saveAndFlush(UserInfo.builder().ages(<span class="number">20</span>).telephone(<span class="string">&quot;1233456&quot;</span>).build());</span><br><span class="line">      <span class="comment">//模拟多线程执行两次</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; userInfoService.calculate(<span class="number">1L</span>)).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">10L</span>);<span class="comment">//</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果两个线程同时执行会发生乐观锁异常；</span></span><br><span class="line">      Exception exception = Assertions.assertThrows(ObjectOptimisticLockingFailureException.class, () -&gt; &#123;</span><br><span class="line">         userInfoService.calculate(<span class="number">1L</span>);</span><br><span class="line">         <span class="comment">//模拟多线程执行两次</span></span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(exception);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的测试得到的结果中，我们执行 testVersion()，会发现在 save 的时候， Version 会自动 +1，第一次初始化为 0；update 的时候也会附带 Version 条件。通过下图的 SQL，也可以看到 Version 的变化。</p>
<p><img src="http://image.leonote.cn/20201110160559.png" alt=""></p>
<p>而当面我们调用 testVersionException() 测试方法的时候，利用多线程模拟两个并发情况，会发现两个线程同时取到了历史数据，并在稍后都对历史数据进行了更新。</p>
<p>由此你会发现，第二次测试的结果是乐观锁异常，更新不成功。请看一下测试的日志。</p>
<p><img src="http://image.leonote.cn/20201110160714.png" alt=""></p>
<p>通过日志又会发现，两个 SQL 同时更新的时候，Version 是一样的，是它导致了乐观锁异常。</p>
<blockquote>
<p>📌注意：乐观锁异常不仅仅是同一个方法多线程才会出现的问题，我们只是为了方便测试而采用同一个方法；不同的方法、不同的项目，都有可能导致乐观锁异常。乐观锁的本质是 SQL 层面发生的，和使用的框架、技术没有关系。</p>
</blockquote>
<h3 id="Version-对-Save-方法的影响"><a href="#Version-对-Save-方法的影响" class="headerlink" title="@Version 对 Save 方法的影响"></a>@Version 对 Save 方法的影响</h3><p>通过上面的实例发现，<code>@Version</code> 底层实现逻辑和 <code>@EntityListeners</code> 一点关系没有，底层是通过 Hibernate 判断实体里面是否有 <code>@Version</code> 的持久化字段，利用乐观锁机制来创建和使用 Version 的值。</p>
<p>因此，还是那句话：Java Persistence API 负责制定协议，Hibernate 负责实现逻辑，Spring Data JPA 负责封装和使用。那么我们来看下 Save 对象的时候，如何判断是新增的还是 merge 的逻辑呢？</p>
<p><strong>isNew 判断的逻辑</strong><br>通过断点，我们可以进入 SimpleJpaRepository.class 的 Save 方法中，看到如下图显示的界面：</p>
<p><img src="http://image.leonote.cn/20201110161206.png" alt=""></p>
<p>然后，我们进入 JpaMetamodelEntityInformation.class 的 isNew 方法中，又会看到下图显示的界面：</p>
<p><img src="http://image.leonote.cn/20201110161539.png" alt=""></p>
<p>其中，第一段逻辑，判断其中是否有 <code>@Version</code> 标注的属性，并且该属性是否为基础类型。如果不满足条件，调用 <code>super.isNew(entity)</code> 方法，而 super.isNew 里面只判断了 ID 字段是否有值。</p>
<p>第二段逻辑，如果有 <code>@Version</code> 字段，那么看看这个字段是否有值，如果没有就返回 true，如果有值则返回 false。</p>
<blockquote>
<p>🎯 结论：如果有 <code>@Version</code> 注解的字段，就以 <code>@Version</code> 字段来判断 save / update；如果没有，就以 <code>@ID</code> 字段是否有值来判断 save / update。</p>
</blockquote>
<p>注意：虽然看到的是 merge 方法，但是不一定会执行 update 操作，merge 方法会判断对象是否为游离状态，以及有无 ID 值。它会先触发一条 select 语句，并根据 ID 查一下这条记录是否存在，如果不存在，虽然 ID 和 Version 字段都有值，但也只是执行 insert 语句；如果本条 ID 记录存在，才会执行 update 的 sql。至于这个具体的 insert 和 update 的 sql、传递的参数是什么。</p>
<p>总之，如果使用纯粹的 saveOrUpdate 方法，那么完全不需要自己写这一段逻辑，只要保证 ID 和 Version 存在该有的值就可以了，JPA 会帮我们实现剩下的逻辑。</p>
<p>实际工作中，特别是分布式更新的时候，很容易碰到乐观锁，这时候还要结合重试机制才能完美解决我们的问题。</p>
<p>先了解一下 Spring 支持的重试机制是什么样的。</p>
<h2 id="重试机制详解"><a href="#重试机制详解" class="headerlink" title="重试机制详解"></a>重试机制详解</h2><p>Spring 全家桶里面提供了<code>@Retryable</code> 的注解，会帮我们进行重试。下面看一个 <code>@Retryable</code> 的例子。</p>
<p>第一步：利用 gradle 引入 spring-retry 的依赖 jar，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;org.springframework.retry:spring-retry&#39;</span><br></pre></td></tr></table></figure>

<p>第二步：在 UserInfoServiceImpl 的方法中添加 <code>@Retryable</code> 注解，就可以实现重试的机制了，代码如下：</p>
<p><img src="http://image.leonote.cn/20201111084449.png" alt=""></p>
<p>第三步：新增一个 RetryConfiguration 并添加 <code>@EnableRetry</code> 注解，是为了开启重试机制，使 <code>@Retryable</code> 生效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：测试用例测试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses=UserInfoServiceImpl.class)</span></span><br><span class="line"><span class="meta">@Import(RetryConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceRetryTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="meta">@Rollback(false)</span></span><br><span class="line">   <span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRetryable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//加一条数据</span></span><br><span class="line">    userInfoRepository.saveAndFlush(UserInfo.builder().ages(<span class="number">20</span>).telephone(<span class="string">&quot;1233456&quot;</span>).build());</span><br><span class="line">      <span class="comment">//模拟多线程执行两次</span></span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; userInfoService.calculate(<span class="number">1L</span>)).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">10L</span>);<span class="comment">//</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//模拟多线程执行两次，由于加了@EnableRetry，所以这次也会成功</span></span><br><span class="line">      UserInfo userInfo = userInfoService.calculate(<span class="number">1L</span>);</span><br><span class="line">      <span class="comment">//经过了两次计算，年龄变成了 22</span></span><br><span class="line">      Assertions.assertEquals(<span class="number">22</span>,userInfo.getAges());</span><br><span class="line">      Assertions.assertEquals(<span class="number">2</span>,userInfo.getVersion());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试用例里面执行 <code>@Import(RetryConfiguration.class)</code>，这样就开启了重试机制，然后继续在里面模拟了两次线程调用，发现第二次发生了乐观锁异常之后依然成功了。为什么呢？我们通过日志可以看到，它是失败了一次之后又进行了重试，所以第二次成功了。</p>
<p>通过案例发现 Retry 的逻辑其实很简单，只需要利用 <code>@Retryable</code> 注解即可</p>
<h3 id="Retryable-详细用法"><a href="#Retryable-详细用法" class="headerlink" title="@Retryable 详细用法"></a>@Retryable 详细用法</h3><p>其源码里面提供了很多方法，看下面这个图片。</p>
<p><img src="http://image.leonote.cn/20201111085808.png" alt=""></p>
<p>下面对常用的 <code>@Retryable</code> 注解中的参数做一下说明：</p>
<ul>
<li><p>maxAttempts：最大重试次数，默认为 3，如果要设置的重试次数为 3，可以不写；</p>
</li>
<li><p>value：抛出指定异常才会重试；</p>
</li>
<li><p>include：和 value 一样，默认为空，当 exclude 也为空时，默认异常；</p>
</li>
<li><p>exclude：指定不处理的异常；</p>
</li>
<li><p>backoff：重试等待策略，默认使用 <code>@Backoff</code> 的 value，默认为 1s，请看下面这个图。</p>
<p><img src="http://image.leonote.cn/20201111090105.png" alt=""></p>
<p>其中：</p>
<ul>
<li>value=delay：隔多少毫秒后重试，默认为 1000L，单位是毫秒；</li>
<li>multiplier（指定延迟倍数）默认为 0，表示固定暂停 1 秒后进行重试，如果把 multiplier 设置为 1.5，则第一次重试为 1.5 秒，第二次为 3 秒，第三次为 4.5 秒。</li>
</ul>
</li>
</ul>
<p>下面是一个关于 @Retryable 扩展的使用例子，具体看一下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Retryable( value = SQLException.class,</span></span><br><span class="line"><span class="meta">        maxAttempts = 2, backoff = @Backoff(delay = 100))</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryServiceWithCustomization</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里明确指定 <code>SQLException.class</code> 异常的时候需要重试两次，每次中间间隔 100 毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyService</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Retryable( value = SQLException.class, maxAttemptsExpression = &quot;$&#123;retry.maxAttempts&#125;&quot;,</span></span><br><span class="line"><span class="meta">            backoff = @Backoff(delayExpression = &quot;$&#123;retry.maxDelay&#125;&quot;))</span> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">retryServiceWithExternalizedConfiguration</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，你也可以利用 SpEL 表达式读取配置文件里面的值。</p>
<p>如果你遇到更复杂的场景，可以到 GitHub 中看一下官方的  <a href="https://github.com/spring-projects/spring-retry">Retryable文档</a>。</p>
<h2 id="乐观锁-重试机制的最佳实践"><a href="#乐观锁-重试机制的最佳实践" class="headerlink" title="乐观锁+重试机制的最佳实践"></a>乐观锁+重试机制的最佳实践</h2><p>建议使用如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retryable(value = ObjectOptimisticLockingFailureException.class, </span></span><br><span class="line"><span class="meta">           backoff = @Backoff(multiplier = 1.5, random = true))</span></span><br></pre></td></tr></table></figure>


<p>这里明确指定 <code>ObjectOptimisticLockingFailureException.class</code> 等乐观锁异常要进行重试，如果引起其他异常的话，重试也会失败，没有意义；而 backoff 采用随机 +1.5 倍的系数，这样基本很少会出现连续 3 次乐观锁异常的情况，并且也很难发生<strong>重试风暴</strong>而引起<strong>系统重试崩溃</strong>的问题。</p>
<h2 id="悲观锁的类型怎么实现？-不推荐使用"><a href="#悲观锁的类型怎么实现？-不推荐使用" class="headerlink" title="悲观锁的类型怎么实现？(不推荐使用)"></a>悲观锁的类型怎么实现？(不推荐使用)</h2><p>Java Persistence API 2.0 协议里面有一个 LockModeType 枚举值，里面包含了所有它支持的乐观锁和悲观锁的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">LockModeType</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//等同于OPTIMISTIC，默认，用来兼容2.0之前的协议</span></span><br><span class="line">    READ,</span><br><span class="line">    <span class="comment">//等同于OPTIMISTIC_FORCE_INCREMENT，用来兼容2.0之前的协议</span></span><br><span class="line">    WRITE,</span><br><span class="line">    <span class="comment">//乐观锁，默认，2.0协议新增</span></span><br><span class="line">    OPTIMISTIC,</span><br><span class="line">    <span class="comment">//乐观写锁，强制version加1，2.0协议新增</span></span><br><span class="line">    OPTIMISTIC_FORCE_INCREMENT,</span><br><span class="line">    <span class="comment">//悲观读锁 2.0协议新增</span></span><br><span class="line">    PESSIMISTIC_READ,</span><br><span class="line">    <span class="comment">//悲观写锁，version不变，2.0协议新增</span></span><br><span class="line">    PESSIMISTIC_WRITE,</span><br><span class="line">    <span class="comment">//悲观写锁，version会新增，2.0协议新增</span></span><br><span class="line">    PESSIMISTIC_FORCE_INCREMENT,</span><br><span class="line">    <span class="comment">//2.0协议新增无锁状态</span></span><br><span class="line">    NONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要在自己的 Repository 里面覆盖父类的 Repository 方法，然后添加 <code>@Lock</code> 注解并指定 LockModeType 即可支持悲观锁，请看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Lock(LockModeType.PESSIMISTIC_WRITE)</span></span><br><span class="line">    <span class="function">Optional&lt;UserInfo&gt; <span class="title">findById</span><span class="params">(Long userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserInfoRepository 里面覆盖了父类的 findById 方法，并指定锁的类型为悲观锁。如果将 service 改调用为悲观锁的方法，会发生什么变化呢？如下图所示：</p>
<p><img src="http://image.leonote.cn/20201111091507.png" alt=""></p>
<p>然后再执行上面测试中 testRetryable 的方法，跑完测试用例的结果依然是通过的，我们看下日志。</p>
<p><img src="http://image.leonote.cn/20201111091615.png" alt=""></p>
<p>刚才的串行操作完全变成了并行操作。所以少了一次 Retry 的过程，结果还是一样的。</p>
<blockquote>
<p>在生产环境中要慎用悲观锁，因为它是阻塞的，一旦发生服务异常，可能会造成死锁的现象。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>乐观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>spring data jpa 如何实现动态部分更新</title>
    <url>/2019/12/08/SpringDataJpa%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%83%A8%E5%88%86%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>创建表 <code>contact</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `contact` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `mobile` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address` <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    `create_time` datetime,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>创建实体 <code>Contact</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity(name = &quot;contact&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name = &quot;create_time&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>假设前端修改了某个用户的<strong><em>联系电话</em></strong>，需要更新数据库中某个用户的联系电话：</p>
<p>前端的 <code>json</code> ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;mobile&quot;</span>: <span class="string">&quot;13522222222&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;address&quot;</span>: <span class="string">&quot;广东省&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台执行的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(contact.getId() != <span class="keyword">null</span>)&#123;</span><br><span class="line">  contactRepository.save(contact);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接执行这段代码，会把之前的<code>create_time</code>信息置为<code>null</code></p>
</blockquote>
<p>原因：<code>Spring Data Jpa</code> 对Entity的更新是对主键以外的所有字段更新，而不是传的参数更新，执行的<code>sql</code>是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update contact <span class="keyword">set</span> name<span class="operator">=</span>?, mobile<span class="operator">=</span>?, address<span class="operator">=</span>?, create_time<span class="operator">=</span>? <span class="keyword">where</span> id<span class="operator">=</span>?</span><br></pre></td></tr></table></figure>



<p><code>Spring Data Jpa</code> save方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (entityInformation.isNew(entity)) &#123;</span><br><span class="line">			em.persist(entity);</span><br><span class="line">			<span class="keyword">return</span> entity;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> em.merge(entity);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><code>Spring Data Jpa</code> 会依据主键先执行一边查询，如果不存在这条记录则执行插入，如果存在则执行覆盖操作。</p>
<blockquote>
<p>但是这里就有问题了，<code>Spring Data Jpa</code> 无法理解开发者的意图，</p>
<p>即开发者到底是想用<code>NULL</code>值覆盖原值，还是想遇到<code>NULL</code>值而忽略。</p>
</blockquote>
<p>对于部分字段更新，可以使用<code>@Query</code>和<code>@Modify</code>注解手写<code>sql</code>来进行部分更新，</p>
<p>但是动态更新无法做到。</p>
<blockquote>
<p><strong>什么是动态更新?</strong></p>
<p>不是对数据记录的所有字段整体更新，而是直到运行时才确定哪个或者哪些字段会被更新</p>
<p>如：</p>
<ol>
<li>只更改了<code>mobile</code>，执行的是：<code>update contact set mobile=? where id=?</code></li>
<li>更改了<code>mobile</code>和<code>address</code>，执行的是：<code>update contact set mobile=?, address=? where id=?</code></li>
</ol>
</blockquote>
<p>使用<code>@DynamicUpdate</code> </p>
<p>在实体类上使用注解<code>@DynamicUpdate</code>注解，这个注解是由hibernate提供的</p>
<p>这时就可以实现动态更新了，在运行时修改哪些字段，会动态生成对应的<code>sql</code>，但是仍然存在无法理解开发者对于<code>NULL</code>值的意图。默认是如果原值不为 <code>NULL</code> , 则用<code>NULL</code>值覆盖，如果想要实现不覆盖原值，需要自行实现接口或者工具类。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Transaction</title>
    <url>/2020/09/08/Spring%20Transaction/</url>
    <content><![CDATA[<h1 id="只读事务设置"><a href="#只读事务设置" class="headerlink" title="只读事务设置"></a>只读事务设置</h1><ol>
<li><p>JDBC 指定只读事务的设置：<code>connection.setReadOnly(true)</code></p>
</li>
<li><p>Hibernate 只读事务的设置：<code>session.setFlushMode(FlushMode.NEVER)</code></p>
</li>
<li><p>Spring 只读事务设置：</p>
<p><code>@Transactional(readOnly = true)</code></p>
<p><code>&lt;tx:method name=&quot;search*&quot; read-only=&quot;true&quot; /&gt;</code> </p>
</li>
</ol>
<blockquote>
<p>read-only 并不是所有数据库都支持的，不同的数据库下会有不同的结果（例如：对 Mysql 生效，对 Oracle 不生效）。</p>
<p>设置了read-only 后，connection 都会被赋予 read-only（希望数据库驱动开启只读优化，不一定生效） ，不应该把 read-only作为打开只读事务的判断。</p>
<p>在ORM框架中，设置了read-only会赋予一些额外的优化，例如在 Hibernate 中，会被禁止 flush 等。</p>
</blockquote>
<p>Oracle 11.2 的<a href="https://docs.oracle.com/cd/B19306_01/java.102/b14355/apxtips.htm#i1007231">文档</a>中表明Oracle JDBC Driver 不支持 read-only connections</p>
<p><img src="http://image.leonote.cn/image-20200908104224212.png" alt="image-20200908104224212"></p>
]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle的基础知识</title>
    <url>/2020/09/22/Oracle%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Oracle-的基础知识"><a href="#Oracle-的基础知识" class="headerlink" title="Oracle 的基础知识"></a>Oracle 的基础知识</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><blockquote>
<p> 数据库设计是画出数据库的ER图，通过ER图生成 sql 建库代码(DDL)</p>
<p> 生成的建库代码的约束都是追加的，方便到时删除</p>
</blockquote>
<h2 id="SQL类型"><a href="#SQL类型" class="headerlink" title="SQL类型"></a>SQL类型</h2><ul>
<li>DQL：数据查询语言，关键字 select， 功能：查询</li>
<li>DML：数据操作语言，关键字 insert、delete、update，功能：操作数据</li>
<li>DDL：数据定义语言，关键字 create、drop、alter，功能：操作数据库对象</li>
<li>DCL：数据控制语言，关键字 grant、revoke，功能：用户授权撤权</li>
<li>TCL：事务控制语言，关键字 commit、rollback、savepoint，功能：事务处理</li>
</ul>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select [distinct]&#123;* | &lt;字段名&gt; | 表名.*&#125; from &lt;表名&gt;</span><br><span class="line"><span class="comment">-- 1. 给表一个别名</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp e;</span><br><span class="line"><span class="comment">-- 2. 给返回字段一个别名</span></span><br><span class="line"><span class="keyword">select</span> emp.ename <span class="keyword">as</span> 员工名 <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>where 关键字</p>
<h4 id="查询运算符"><a href="#查询运算符" class="headerlink" title="查询运算符"></a>查询运算符</h4><h5 id="对比运算符"><a href="#对比运算符" class="headerlink" title="对比运算符"></a>对比运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等号；oracle 里面的赋值语句是=:</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于，也可以用 !=</td>
</tr>
<tr>
<td>is</td>
<td>一般用于判空 is null，is not null</td>
</tr>
<tr>
<td>in</td>
<td>集合</td>
</tr>
<tr>
<td>between ..and ..</td>
<td>在..之间</td>
</tr>
<tr>
<td>like</td>
<td>模糊查询</td>
</tr>
</tbody></table>
<blockquote>
<p><code>&lt;&gt;</code> 是标准 sql 的不等于，任何关系型数据库都支持，<code>!=</code> 只有部分数据库支持</p>
</blockquote>
<h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>与</td>
</tr>
<tr>
<td>or</td>
<td>或</td>
</tr>
<tr>
<td>not</td>
<td>非</td>
</tr>
</tbody></table>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><ol>
<li><p>查询员工的名字有 A 或者 E 的员工</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;%A%&#x27;</span> <span class="keyword">or</span> ename <span class="keyword">like</span> <span class="string">&#x27;%E%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询第三个字符是 A 的员工</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;__A%&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工名有 _ 的员工，需要转义；escape 是一个定义转义字符的意思</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> ename <span class="keyword">like</span> <span class="string">&#x27;%\_%&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>以某个字段作为分类的条件统计需求，有条件就需要用到 having 筛选</p>
<p>查询语句的关键字的优先级别问题：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="operator">&gt;</span> <span class="keyword">where</span> <span class="operator">&gt;</span> <span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&gt;</span> <span class="keyword">having</span> <span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">&gt;</span> <span class="keyword">order</span> <span class="keyword">by</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：</p>
<p>分组前：确定的条件使用 where，</p>
<p>分组后：确定的条件使用 having</p>
<p>原因就是 where 的优先级大于 group by</p>
</blockquote>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><blockquote>
<p>笛卡尔积是两个集合X和Y的直积，表示为X*Y；</p>
<p>X集合的每个元素和Y集合的每个元素所形成的有序对集合就是X和Y的笛卡尔积</p>
</blockquote>
<h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p>当条件为“=”的连接为等值连接，是连接属性值相等的那些元组；</p>
<p>其结果是连接的表的所有列，包括重复列，相当于<strong>内连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> emp, dept</span><br><span class="line"><span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br></pre></td></tr></table></figure>

<h4 id="不等值连接"><a href="#不等值连接" class="headerlink" title="不等值连接"></a>不等值连接</h4><p>两个表中相关的两列进行不等连接；</p>
<p>比较符号一般为 &lt;&gt;、&gt;、&lt;、&gt;=、&lt;=、LIKE、IN、BETWEEN…AND</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> emp <span class="keyword">inner</span> <span class="keyword">join</span> dept</span><br><span class="line"><span class="keyword">on</span> emp.deptno <span class="operator">=</span> dept.deptno;</span><br></pre></td></tr></table></figure>

<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接就是连接两个表，根据左外还是右外连接，基表的字段会全部显示；</p>
<p>如果字段不对应，非基表的表所有的字段值会设为null</p>
<h5 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h5><p>左边的表作为基表，右表如有左表不对应的字段则设为null</p>
<h5 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h5><p>右边的表作为基表，左表如有右表不对应的字段则设为null</p>
<blockquote>
<p>Oracle 外连接的特殊写法（鸡肋）</p>
<p> 等值查询的条件上加一个(+)表示不是基表，则不加(+)才是基表</p>
<p><strong>右外连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>, dept.dname</span><br><span class="line"><span class="keyword">from</span> emp,dept</span><br><span class="line"><span class="keyword">where</span> emp.deptno(<span class="operator">+</span>) <span class="operator">=</span> dept.deptno;</span><br></pre></td></tr></table></figure>

<p> <strong>左外连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp.<span class="operator">*</span>, dept.dname</span><br><span class="line"><span class="keyword">from</span> emp,dept</span><br><span class="line"><span class="keyword">where</span> emp.deptno <span class="operator">=</span> dept.deptno(<span class="operator">+</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="operator">|</span> 字段 </span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>字段<span class="number">1</span>, 字段<span class="number">2</span><span class="operator">&gt;</span> <span class="keyword">desc</span> <span class="operator">|</span> <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li><p>查询员工的信息，按部门编号排序，再按工资排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> deptno, sal;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询员工的信息，按部门编号排序(正序)后，再按工资排序(倒序)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> deptno, sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>按员工的奖金排序，倒序的时候，null 放在后面</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> comm <span class="keyword">desc</span> nulls <span class="keyword">first</span>; <span class="comment">-- 将null值放在最前</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> comm <span class="keyword">desc</span> nulls <span class="keyword">last</span>; <span class="comment">-- 将null值放在最后</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><h4 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h4><h6 id="四舍五入函数"><a href="#四舍五入函数" class="headerlink" title="四舍五入函数"></a>四舍五入函数</h6><blockquote>
<p>round(原值, 精度)</p>
</blockquote>
<p>求员工的平均工资，保留两位小数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果精度是正数，精确的是小数从小数点第一位开始，往右移</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(sal), <span class="number">2</span>) <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>如：平均工资 = 2073.214</p>
<p>​       round(平均工资, 2) = 2073.21  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果精度是负数，精确的是从个位开始，往左移</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(sal), <span class="number">-1</span>), <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>如：平均工资 = 2073.214</p>
<p>​        round(平均工资, -1) = 2070</p>
<p>​        round(平均工资, -2) = 2100</p>
<p>​        round(平均工资, -3) = 2000</p>
<p>​        round(平均工资, -4) = 0</p>
<h6 id="截取函数"><a href="#截取函数" class="headerlink" title="截取函数"></a>截取函数</h6><blockquote>
<p> trunc(原值, 精度)  </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 和四舍五入差不多区别就是不会向上进位，就是截取精度的位置</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="built_in">avg</span>(sal), <span class="number">2</span>) <span class="built_in">avg</span>(sal) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h4 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h4><p>查询员工的姓名，格式为 ‘员工名:姓名’</p>
<p>方式一：使用 || 连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;员工名:&#x27;</span> <span class="operator">||</span> ename <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>方式二：使用 concat 函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;员工名:&#x27;</span>, ename) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h5 id="长度函数"><a href="#长度函数" class="headerlink" title="长度函数"></a>长度函数</h5><blockquote>
<p>length(原值)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, length(ename) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<h5 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h5><blockquote>
<p>replace(c1, c2, c3)</p>
<ul>
<li>c1：原值</li>
<li>c2：需要替换的值</li>
<li>c3：新值</li>
</ul>
</blockquote>
<p>将 my name is leo 的 my 修改为 your</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> replace(<span class="string">&#x27;my name is leo&#x27;</span>, <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;your&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为这个修改没有表，所以给它一个临时表 dual</p>
</blockquote>
<h4 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h4><p>获取系统当前时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sysdate <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="月份对比函数"><a href="#月份对比函数" class="headerlink" title="月份对比函数"></a>月份对比函数</h5><blockquote>
<p>months_between(d1, d2)</p>
<ul>
<li>d1 &lt; d2，返回负数</li>
<li>d1 = d2，返回 0</li>
<li>d1 &gt; d2，返回正数</li>
<li>返回值：两个日期的月份间隔</li>
<li>作用：<ul>
<li>用于计算两个日期间隔的月份数</li>
<li>对比两个日期的大小</li>
</ul>
</li>
</ul>
</blockquote>
<p>2018-06-26 与 2020-09-22 相隔多少个月</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> months_between( </span><br><span class="line">    		to_date(<span class="string">&#x27;2018-06-26&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>),</span><br><span class="line">    		to_date(<span class="string">&#x27;2020-09-22&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>)) </span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="月份增加函数"><a href="#月份增加函数" class="headerlink" title="月份增加函数"></a>月份增加函数</h5><blockquote>
<p>add_months(原值, 增加的月份数)</p>
</blockquote>
<p>给当前日期加三个月</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> add_months(sysdate, <span class="number">3</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>给当前日期减三个月</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> add_months(sysdate, <span class="number">-3</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="日期截取函数"><a href="#日期截取函数" class="headerlink" title="日期截取函数"></a>日期截取函数</h5><blockquote>
<p>extract( 类型 from 时间|日期)</p>
<p>类型包括：</p>
<ul>
<li>year</li>
<li>month</li>
<li>day</li>
<li>hour</li>
<li>minute</li>
<li>second</li>
</ul>
</blockquote>
<p>截取年</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> sysdate) <span class="keyword">from</span> dual;           </span><br></pre></td></tr></table></figure>

<p> 截取月</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> sysdate);</span><br></pre></td></tr></table></figure>

<p>截取日</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> sysdate);</span><br></pre></td></tr></table></figure>

<p>截取时</p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> </span><br><span class="line">               to_timestamp(<span class="string">&#x27;2020-09-22 13:12:20&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>))</span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="type">timestamp</span><span class="string">&#x27;2020-09-22 13:12:20&#x27;</span>) </span><br><span class="line"><span class="keyword">from</span> dual; </span><br></pre></td></tr></table></figure>

<p>截取分</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> <span class="type">timestamp</span><span class="string">&#x27;2020-09-22 13:12:20)</span></span><br><span class="line"><span class="string">from dual;</span></span><br></pre></td></tr></table></figure>

<p>截取秒</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> <span class="type">timestamp</span><span class="string">&#x27;2020-09-22 13:12:20)</span></span><br><span class="line"><span class="string">from dual;</span></span><br></pre></td></tr></table></figure>

<p>查询 1981 年入职的员工</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> <span class="built_in">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> HIRE_DATE) <span class="operator">=</span> <span class="number">1981</span>;</span><br></pre></td></tr></table></figure>

<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><h5 id="字符串转成日期"><a href="#字符串转成日期" class="headerlink" title="字符串转成日期"></a>字符串转成日期</h5><blockquote>
<p>to_date(原值, ‘格式’);</p>
<p>年：yyyy<br>月：mm<br>日：dd<br>时：hh 表示使用12小时制，hh24 表示使用24小时制<br>分：mi<br>秒：ss</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020-09-22&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">from</span> dual;       </span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;2020/09/22&#x27;</span>, <span class="string">&#x27;yyyy/mm/dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_date(<span class="string">&#x27;09/22/2020&#x27;</span>, <span class="string">&#x27;mm/dd/yyyy&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h5><blockquote>
<p>to_timestamp(原值, ‘格式’)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_timestamp(<span class="string">&#x27;2020-09-22 13:12:20&#x27;</span>, <span class="string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="其他数据类型转成字符"><a href="#其他数据类型转成字符" class="headerlink" title="其他数据类型转成字符"></a>其他数据类型转成字符</h5><blockquote>
<p>to_char(原值, ‘格式’)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_char(sysdate, <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">select</span> to_char(sysdate, <span class="string">&#x27;yyyy/mm/dd&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="将字符格式转成数值格式"><a href="#将字符格式转成数值格式" class="headerlink" title="将字符格式转成数值格式"></a>将字符格式转成数值格式</h5><blockquote>
<p>to_number(原值, 格式)</p>
<p>oracle里面，数值占位符使用9</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">to</span> number(<span class="string">&#x27;$8,898,765&#x27;</span>, <span class="string">&#x27;$9,999,999&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h4 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h4><h5 id="空处理函数"><a href="#空处理函数" class="headerlink" title="空处理函数"></a>空处理函数</h5><blockquote>
<p>nvl(原值, 替换值)</p>
<p>如果原值为null，那么就自动转成替换值，替换值的类型必须和数据表字段声明的兼容</p>
</blockquote>
<p>查询员工的奖金，如果奖金为 null，那么修改为 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, bonus, nvl(bonus, <span class="number">0</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nvl2(原值, 替换值1, 替换值2)</p>
<p>如果原值不为空，替换成替换值1，否则替换成替换值2</p>
</blockquote>
<p>查询员工的奖金，如果奖金为 null ，那么修改为 0，使用 nvl2 实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename, bonus, nvl2(bonus, bonus, <span class="number">0</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h5 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h5><blockquote>
<p>decode(原值, ‘值1’, ‘翻译值1’, ‘值2’, ‘翻译值2’, ‘默认值’)</p>
<p>一个根据值来判断输出的信息；类似于 if / else</p>
</blockquote>
<p>查询员工的姓名和员工的部门编号；</p>
<p>如果编号为10，返回综合部，如果编号为20，返回研发部，如果编号为30，返回销售部，其他返回，人力资源部</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ename decode(deptno, <span class="number">10</span>, <span class="string">&#x27;综合部&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;研发部&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;人力资源部&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>查询员工的奖金，如果奖金为 null，那么修改为 ‘没奖金’</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> decode(comm, <span class="string">&#x27;null&#x27;</span>, <span class="string">&#x27;没奖金&#x27;</span>, bonus);</span><br></pre></td></tr></table></figure>

<h3 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h3><blockquote>
<p>多行函数也叫<strong>聚合函数</strong></p>
<ul>
<li>max()：最大值</li>
<li>min()：最小值</li>
<li>avg()：平均值</li>
<li>count()：统计个数</li>
<li>sum()：求和</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 用户认证</title>
    <url>/2021/07/15/SpringSecurity%E4%B9%8B%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<h1 id="用户认证：如何使用-Spring-Security-构建用户认证体系？"><a href="#用户认证：如何使用-Spring-Security-构建用户认证体系？" class="headerlink" title="用户认证：如何使用 Spring Security 构建用户认证体系？"></a>用户认证：如何使用 Spring Security 构建用户认证体系？</h1><blockquote>
<p>用户认证涉及用户账户体系的构建，也是实现授权管理的前提。</p>
</blockquote>
<p>在 Spring Security 中，实现用户认证的方式有很多，结合框架提供的配置体系进行梳理。</p>
<h2 id="Spring-Security-配置体系"><a href="#Spring-Security-配置体系" class="headerlink" title="Spring Security 配置体系"></a>Spring Security 配置体系</h2><p>在 Spring Security 中，因为认证和授权等功能通常都不止有一种实现方法，所以框架开发了一套完整的配置体系来对这些功能进行灵活设置。开发人员在使用认证和授权等功能时就依赖于如何合理利用和扩展这套配置体系。</p>
<p>例如，针对用户账户存储这个切入点，就可以设计出多种不同的策略。我们可以把用户名和密码保存在内存中，作为一种轻量级的实现方式。更常见的，也可以把这些认证信息存储在关系型数据库中。当然，如果使用了 LDAP 协议，那么文件系统也是一种不错的存储媒介。</p>
<p>显然，针对这些可选择的实现方式，需要为开发人员提供一种机制以便他们能够根据自身的需求进行灵活的设置，这就是配置体系的作用。</p>
<p>同时，在没有进行任何的配置也能让 Spring Security 发挥作用，这就说明框架内部的功能采用了特定的默认配置。就用户认证这一场景而言，Spring Security 内部就初始化了一个默认的用户名“user”并且在应用程序启动时自动生成一个密码。当然，通过这种方式自动生成的密码在每次启动应用时都会发生变化，并不适合面向正式的应用。</p>
<p>可以通过翻阅 <a href="https://github.com/spring-projects/spring-security">Spring Security 源代码</a>来进一步理解 Spring Security 中的一些默认配置。在 Spring Security 中，初始化用户信息依赖的配置类是 <code>WebSecurityConfigurer</code> 接口，该接口实际上是一个空接口，继承了更为基础的 <code>SecurityConfigurer</code> 接口。</p>
<p>在日常开发中，通常不需要自己实现这个接口，而是使用 <code>WebSecurityConfigurerAdapter</code> 类来简化该配置类的使用方式。而在 <code>WebSecurityConfigurerAdapter</code> 中有如下所示的 configure 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http</span><br><span class="line">     .authorizeRequests()</span><br><span class="line">     .anyRequest().authenticated()</span><br><span class="line">     .and()</span><br><span class="line">     .formLogin().and()</span><br><span class="line">     .httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码就是 Spring Security 中作用于用户认证和访问授权的默认实现，这里用到了多个常见的配置方法。一旦在代码类路径中引入 Spring Security 框架之后，访问任何端点时就会弹出一个登录界面用来完成用户认证。认证是授权的前置流程，认证结束之后就可以进入到授权环节。</p>
<p>结合这些配置方法，来简单分析一下这种默认效果是如何实现的：</p>
<ul>
<li><p>首先，通过 <code>HttpSecurity</code> 类的 <code>authorizeRequests()</code> 方法对所有访问 HTTP 端点的 <code>HttpServletRequest</code> 进行限制；</p>
</li>
<li><p>然后，<code>anyRequest().authenticated()</code> 语句指定了对于所有请求都需要执行认证，也就是说没有通过认证的用户就无法访问任何端点；</p>
</li>
<li><p>接着，<code>formLogin()</code> 语句用于指定使用表单登录作为认证方式，也就是会弹出一个登录界面；</p>
</li>
<li><p>最后，<code>httpBasic()</code> 语句表示可以使用 HTTP 基础认证（Basic Authentication）方法来完成认证。</p>
</li>
</ul>
<p>在日常开发过程中，可以继承 <code>WebSecurityConfigurerAdapter</code> 类并且覆写上述的 configure() 方法来完成配置工作。而在 Spring Security 中，存在一批类似于 <code>WebSecurityConfigurerAdapter</code> 的配置类。</p>
<p><strong>配置体系是开发人员使用 Spring Security 框架的主要手段之一</strong>。</p>
<h3 id="实现-HTTP-基础认证和表单登录认证"><a href="#实现-HTTP-基础认证和表单登录认证" class="headerlink" title="实现 HTTP 基础认证和表单登录认证"></a>实现 HTTP 基础认证和表单登录认证</h3><p>上面提到了 <code>httpBasic()</code> 和 <code>formLogin()</code> 这两种用于控制用户认证的实现手段，分别代表了HTTP 基础认证和表单登录认证。在构建 Web 应用程序时，也可以在 Spring Security 提供的认证机制的基础上进行扩展，以满足日常开发需求。</p>
<h4 id="HTTP-基础认证"><a href="#HTTP-基础认证" class="headerlink" title="HTTP 基础认证"></a>HTTP 基础认证</h4><p>HTTP 基础认证的原理比较简单，只需通过 HTTP 协议的消息头携带用户名和密码进行登录验证。之前已经通过浏览器简单验证了用户登录操作。现在用 Postman 来对登录的请求和响应过程做进一步分析。</p>
<p>在 Postman 中，直接访问<a href="http://localhost:8080/hello端点，会得到如下所示的响应：">http://localhost:8080/hello端点，会得到如下所示的响应：</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span>: <span class="string">&quot;2021-02-08T03:45:21.512+00:00&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="number">401</span>,</span><br><span class="line">    <span class="attr">&quot;error&quot;</span>: <span class="string">&quot;Unauthorized&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，响应码 401 告诉没有访问该地址的权限。同时，在响应中出现了一个“WWW-Authenticate”消息头，其值为“Basic realm=”Realm””，这里的 Realm 表示 Web 服务器中受保护资源的安全域。</p>
<p>现在，来执行 HTTP 基础认证，可以通过设置认证类型为“Basic Auth”并输入对应的用户名和密码来完成对 HTTP 端点的访问，设置界面如下所示：</p>
<p>// 图片</p>
<p>查看 HTTP 请求，可以看到 Request Header 中添加了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Authorization?fileGuid=xxQTRXtVcqtHK6j8">Authorization</a> 标头，格式为：Authorization:<code>&lt;type&gt;</code> <code>&lt;credentials&gt;</code>。这里的 type 就是“Basic”，而 credentials 则是这样一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dXNlcjo5YjE5MWMwNC1lNWMzLTQ0YzctOGE3ZS0yNWNkMjY3MmVmMzk&#x3D;</span><br></pre></td></tr></table></figure>

<p>这个字符串就是<strong>将用户名和密码组合在一起，再经过 Base64 编码得到的结果</strong>。而 Base64 只是一种编码方式，并没有集成加密机制，所以本质上传输的还是<strong>明文形式</strong>。</p>
<p>想要在应用程序中启用 HTTP 基础认证还是比较简单的，只需要在 <code>WebSecurityConfigurerAdapter</code> 的 configure 方法中添加如下配置即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   http.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HTTP 基础认证比较简单，没有定制的登录页面，所以单独使用的场景比较有限。在使用 Spring Security 时，<strong>一般会把 HTTP 基础认证和表单登录认证结合起来</strong>一起使用。</p>
<h4 id="表单登录认证"><a href="#表单登录认证" class="headerlink" title="表单登录认证"></a>表单登录认证</h4><p>在 <code>WebSecurityConfigurerAdapter</code> 的 configure 方法中，一旦配置了 <code>HttpSecurity</code> 的 <code>formLogin()</code> 方法，就启动了表单登录认证，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.formLogin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>formLogin()</code> 方法的执行效果就是提供了一个默认的登录界面，如下所示：</p>
<p>// 图片</p>
<p>对于登录操作而言，这个登录界面通常都是定制化的，同时，也需要对登录的过程和结果进行细化控制。此时，就可以通过如下所示的配置内容来修改系统的默认配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">        .formLogin()        </span><br><span class="line">        .loginPage(<span class="string">&quot;/login.html&quot;</span>)<span class="comment">//自定义登录页面</span></span><br><span class="line">        .loginProcessingUrl(<span class="string">&quot;/action&quot;</span>)<span class="comment">//登录表单提交时的处理地址</span></span><br><span class="line">        .defaultSuccessUrl(<span class="string">&quot;/index&quot;</span>);<span class="comment">//登录认证成功后的跳转页面        </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-Spring-Security-用户认证体系"><a href="#配置-Spring-Security-用户认证体系" class="headerlink" title="配置 Spring Security 用户认证体系"></a>配置 Spring Security 用户认证体系</h3><p>讲完配置体系，现在回到用户认证场景。因为 Spring Security 默认提供的用户名是固定的，而密码会随着每次应用程序的启动而变化，所以很不灵活。在 Spring Boot 中，可以通过在 application.yml 配置文件中添加如下所示的配置项来改变这种默认行为：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">spring</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">spring_password</span></span><br></pre></td></tr></table></figure>

<p>重启应用，就可以使用上述用户名和密码完成登录。基于配置文件的用户信息存储方案简单直接，但显然也<strong>缺乏灵活性</strong>，因为无法在系统运行时<strong>动态加载对应的用户名和密码</strong>。因此，在现实中，主要还是通过使用 <code>WebSecurityConfigurerAdapter</code> 配置类来改变默认的配置行为。</p>
<p>通过前面的内容中，已经知道可以通过 <code>WebSecurityConfigurerAdapter</code> 类的 configure(HttpSecurity http) 方法来完成认证。认证过程涉及 Spring Security 中用户信息的交互，可以通过继承 <code>WebSecurityConfigurerAdapter</code> 类并且覆写其中的 configure(AuthenticationManagerBuilder auth) 的方法来完成对用户信息的配置工作。请注意<strong>这是两个不同的 configure() 方法</strong>。</p>
<p>针对 <code>WebSecurityConfigurer</code> 配置类，首先需要明确配置的内容。实际上，初始化用户信息非常简单，只需要指定用户名（Username）、密码（Password）和角色（Role）这三项数据即可。在 Spring Security 中，基于 <code>AuthenticationManagerBuilder</code> 工具类为开发人员提供了<strong>基于内存、JDBC、LDAP 等多种验证方案</strong>。</p>
<p>接下来，就围绕 <code>AuthenticationManagerBuilder</code> 提供的功能来实现多种用户信息存储方案。</p>
<h4 id="使用基于内存的用户信息存储方案"><a href="#使用基于内存的用户信息存储方案" class="headerlink" title="使用基于内存的用户信息存储方案"></a>使用基于内存的用户信息存储方案</h4><p>先来看如何使用 <code>AuthenticationManagerBuilder</code> 完成基于内存的用户信息存储方案。实现方法就是调用 <code>AuthenticationManagerBuilder</code> 的 inMemoryAuthentication 方法，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    builder.inMemoryAuthentication()</span><br><span class="line">        .withUser(<span class="string">&quot;spring_user&quot;</span>).password(<span class="string">&quot;password1&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">        .and()</span><br><span class="line">        .withUser(<span class="string">&quot;spring_admin&quot;</span>).password(<span class="string">&quot;password2&quot;</span>).roles(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;ADMIN&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，可以看到系统中存在“spring_user”和“spring_admin”这两个用户，其密码分别是”password1”和”password2”，在角色上也分别代表着普通用户 USER 以及管理员 ADMIN。</p>
<blockquote>
<p>注意，这里的 roles() 方法背后使用的还是<strong>authorities() 方法</strong>。</p>
<p>通过 roles() 方法，Spring Security 会在每个角色名称前自动添加“ROLE_”前缀。</p>
</blockquote>
<p>也可以通过如下所示的代码实现同样的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    builder.inMemoryAuthentication()</span><br><span class="line">         .withUser(<span class="string">&quot;spring_user&quot;</span>).password(<span class="string">&quot;password1&quot;</span>).authorities(<span class="string">&quot;ROLE_USER&quot;</span>)</span><br><span class="line">         .and()</span><br><span class="line">         .withUser(<span class="string">&quot;spring_admin&quot;</span>).password(<span class="string">&quot;password2&quot;</span>).authorities(<span class="string">&quot;ROLE_USER&quot;</span>, <span class="string">&quot;ROLE_ADMIN&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，基于内存的用户信息存储方案实现也比较简单，但同样缺乏灵活性，因为用户信息是写死在代码里的。所以，接下来就要引出另一种更为常见的用户信息存储方案——数据库存储。</p>
<h4 id="使用基于数据库的用户信息存储方案"><a href="#使用基于数据库的用户信息存储方案" class="headerlink" title="使用基于数据库的用户信息存储方案"></a>使用基于数据库的用户信息存储方案</h4><p>既然是将用户信息存储在数据库中，势必需要<strong>创建表结构</strong>。可以在 Spring Security 的源文件（org/springframework/security/core/userdetails/jdbc/users.ddl）中找到对应的 SQL 语句，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    <span class="function">username <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span> primary key,</span></span><br><span class="line"><span class="function">    password <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">500</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    enabled  <span class="keyword">boolean</span> not <span class="keyword">null</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">create table authorities</span><br><span class="line">(</span><br><span class="line">    <span class="function">username  <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    authority <span class="title">varchar_ignorecase</span><span class="params">(<span class="number">50</span>)</span> not <span class="keyword">null</span>,</span></span><br><span class="line"><span class="function">    constraint fk_authorities_users foreign <span class="title">key</span> <span class="params">(username)</span> references <span class="title">users</span> <span class="params">(username)</span></span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">create unique index ix_auth_username on <span class="title">authorities</span> <span class="params">(username, authority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一旦在自己的数据库中创建了这两张表，并添加了相应的数据，就可以直接通过注入一个 <code>DataSource</code> 对象进行用户数据的查询，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.jdbcAuthentication().dataSource(dataSource)</span><br><span class="line">               .usersByUsernameQuery(<span class="string">&quot;select username, password, enabled from Users where username=?&quot;</span>)</span><br><span class="line">               .authoritiesByUsernameQuery(<span class="string">&quot;select username, authority from UserAuthorities where username=?&quot;</span>)</span><br><span class="line">               .passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了 <code>AuthenticationManagerBuilder</code> 的 jdbcAuthentication 方法来配置数据库认证方式，内部则使用了 <code>JdbcUserDetailsManager</code> 这个工具类。在该类中，就定义了各种用于数据库查询的 SQL 语句，以及使用 <code>JdbcTemplate</code> 完成数据库访问的具体实现方法。</p>
<blockquote>
<p>注意，这里用到了一个<strong>passwordEncoder() 方法</strong>，这是 Spring Security 中提供的一个<strong>密码加解密器</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security 简介</title>
    <url>/2021/07/13/SpringSecurity%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Spring-Security-简介"><a href="#Spring-Security-简介" class="headerlink" title="Spring Security 简介"></a>Spring Security 简介</h1><h2 id="初识-Spring-Security"><a href="#初识-Spring-Security" class="headerlink" title="初识 Spring Security"></a>初识 Spring Security</h2><p>其实在 Spring Boot 出现之前，Spring Security 就已经诞生多年了。但 Spring Security 的发展一直都不是很顺利，主要问题在于应用程序中集成和配置 Spring Security 框架的过程比较复杂。但是随着 Spring Boot 的兴起，基于 Spring Boot 所提供的针对 Spring Security 的自动配置方案，开发人员可以零配置使用 Spring Security。如果想要在 Spring Boot 应用程序中使用 Spring Security，只需要在 Maven 工程的 pom 文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下来，构建一个简单的 HTTP 端点，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123; </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，启动这个 Spring Boot 应用程序，然后通过浏览器访问”/hello”端点。你可能希望得到的是”Hello World!”这个输出结果，但事实上，浏览器会跳转到一个如下所示的登录界面：</p>
<p><img src="http://image.leonote.cn/20210714222255.jpg" alt=""></p>
<p>添加了 spring-boot-starter-security 依赖之后，Spring Security 为应用程序自动嵌入了用户认证机制。就会弹出这个登录界面。</p>
<p>接下来，针对这个登录场景，分析如何获取登录所需的用户名和密码。在 Spring Boot 的控制台启动日志中，出现了如下所示的一行日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Using generated security password: 707d7469-631f-4d92-ab71-3809620fe0dc</span><br></pre></td></tr></table></figure>

<p>这行日志就是 Spring Security 生成的一个密码，而用户名则是系统默认的“user”。通过输入正确的用户名和密码，浏览器就会输出”Hello World!”这个响应结果。</p>
<p>上述过程演示的就是 Spring Security 提供的认证功能，也是 Spring Security 众多功能中的一项基础功能。</p>
<h2 id="Spring-Security-功能体系"><a href="#Spring-Security-功能体系" class="headerlink" title="Spring Security 功能体系"></a>Spring Security 功能体系</h2><p>Spring Security 提供的是一整套完整的安全性解决方案。面向不同的业务需求和应用场景，Spring Security 分别提供了对应的安全性功能，在接下来的内容中，将从单体应用、微服务架构以及响应式系统这三个维度对这些功能展开讨论。</p>
<h3 id="Spring-Security-与单体应用"><a href="#Spring-Security-与单体应用" class="headerlink" title="Spring Security 与单体应用"></a>Spring Security 与单体应用</h3><p>在软件系统中，可以把需要访问的内容定义为是一种资源（Resource），而安全性设计的核心目标就是对这些资源进行保护，确保对它们的访问是安全可控的。例如，在一个 Web 应用程序中，对外暴露的 HTTP 端点就可以被理解为是资源。对于资源的安全性访问，业界也存在一些常见的技术体系。在讲解这些技术体系之前，先来理解在安全领域中非常常见但又容易混淆的两个概念，即认证（Authentication）和授权（Authorization）。</p>
<p>首先需要明确，所谓认证，解决的是“你是谁”这一个问题，也就是说对于每一次访问请求，系统都能判断出访问者是否具有合法的身份标识。</p>
<p>一旦明确 “你是谁”，下一步就可以判断“你能做什么”，这个步骤就是授权。通用的授权模型大多基于权限管理体系，即对资源、权限、角色和用户的一种组合处理。</p>
<p>如果将认证和授权结合起来，就构成了对系统中的资源进行安全性管理的最常见解决方案，即先判断资源访问者的有效身份，再来确定其是否有对这个资源进行访问的合法权限，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210714222411.jpg" alt=""></p>
<p>上图代表的是一种通用方案，而不同的应用场景和技术体系下可以衍生出很多具体的实现策略。Web 应用系统中的认证和授权模型与上图类似，但在具体设计和实现过程中也有其特殊性。</p>
<ul>
<li><p>针对认证：这部分的需求相对比较明确。显然需要构建一套完整的存储体系来保存和维护用户信息，并且确保这些用户信息在处理请求的过程中能够得到合理的利用。</p>
</li>
<li><p>针对授权：情况可能会比较复杂。对于某一个特定的 Web 应用程序而言，面临的第一个问题是如何判断一个 HTTP 请求是否具备访问自己的权限。更进一步，就算这个请求具备访问该应用程序的权限，但并不意味着该请求能够访问应用程序所有的 HTTP 端点。某些核心功能需要具备较高的权限才能访问，而有些则不需要。这就是需要解决的第二个问题，如何对访问的权限进行精细化管理？如下图所示：</p>
</li>
</ul>
<p><img src="http://image.leonote.cn/20210714222446.jpg" alt=""></p>
<p>在上图中，假设该请求具备对应用程序中端点 2、3、4 的访问权限，但不具备访问端点 1 的权限。想要达到这种效果，一般的做法是引入角色体系。针对不同的用户设置不同等级的角色，角色等级不同对应的访问权限也不同。而每一个请求都可以绑定到某一个角色，也就具备了访问权限。</p>
<p>接下来，把认证和授权结合起来，梳理出 Web 应用程序访问场景下的安全性实现方案，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210714222522.jpg" alt=""></p>
<p>结合示意图可以看到，通过请求传递用户凭证完成用户认证，然后根据该用户信息中具备的角色信息获取访问权限，并最终完成对 HTTP 端点的访问授权。</p>
<p>围绕认证和授权，还需要一系列的额外功能确保整个流程得以实现。这些功能包括用于密码保护的加解密机制、用于实现方法级的安全访问，以及支持跨域等。</p>
<h3 id="Spring-Security-与微服务架构"><a href="#Spring-Security-与微服务架构" class="headerlink" title="Spring Security 与微服务架构"></a>Spring Security 与微服务架构</h3><p>微服务架构的情况要比单体应用复杂很多，因为涉及了服务与服务之间的调用关系。继续沿用“资源”这个概念，对应到微服务系统中，服务提供者充当的角色就是资源的服务器，而服务消费者就是客户端。所以各个服务本身既可以是客户端，也可以作为资源服务器，或者两者兼之。</p>
<p>接下来，把认证和授权结合起来，梳理出微服务访问场景下的安全性实现方案，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210714222624.jpg" alt=""></p>
<p>可以看到，与单体应用相比，在微服务架构中需要把认证和授权的过程进行集中化管理，所以在上图中出现了一个授权中心。 授权中心会获取客户端请求中所带有的身份凭证信息，然后基于凭证信息生成一个 Token，这个 Token 中就包含了权限范围和有效期。</p>
<p>客户端获取 Token 之后就可以基于这个 Token 发起对微服务的访问。这个时候，服务的提供者需要对这个 Token 进行认证，并根据 Token 的权限范围和有效期从授权中心获取该请求能够访问的特定资源。在微服务系统中，对外的资源表现形式同样可以理解为一个个 HTTP 端点。</p>
<p>上图中关键点就在于构建用于生成和验证 Token 的授权中心，为此需要引入OAuth2 协议。OAuth2 协议为我们在客户端程序和资源服务器之间设置了一个授权层，并确保 Token 能够在各个微服务中进行有效传递，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210714222719.jpg" alt=""></p>
<p>OAuth2 是一个相对复杂的协议，综合应用摘要认证、签名认证、HTTPS 等安全性手段，需要提供 Token 生成和校验以及公私钥管理等功能，同时需要开发者入驻并进行权限粒度控制。一般应该避免自行实现这类复杂的协议，倾向于借助于特定工具以免重复造轮子。而 Spring Security 提供了实现这一协议的完整解决方案，可以使用该框架完成适用于微服务系统中的认证授权机制。</p>
<h3 id="Spring-Security-与响应式系统"><a href="#Spring-Security-与响应式系统" class="headerlink" title="Spring Security 与响应式系统"></a>Spring Security 与响应式系统</h3><p>随着 Spring 5 的发布，迎来了响应式编程（Reactive Programming）的全新发展时期。响应式编程是 Spring 5 最核心的新功能，也是 Spring 家族目前重点推广的技术体系。Spring 5 的响应式编程模型以 Project Reactor 库为基础，后者则实现了响应式流规范。</p>
<p>事实上，Spring Boot 从 2.x 版本开始也全面依赖 Spring 5。同样，在 Spring Security 中，用户账户体系的建立、用户认证和授权、方法级别的安全访问、OAuth2 协议等传统开发模式下具备的安全性功能都具备对应的响应式版本。</p>
<blockquote>
<p>🎯思考</p>
<p>单体应用架构和微服务架构，各自的认证和授权机制流程</p>
<p>单体应用架构：用户登录后，只需要对用户调用某个接口时进行鉴权即可。</p>
<p>微服务架构：能够访问资源的对象，用户和上游服务，和单体应用架构相比，增加了对上游服务的鉴权</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot开启Gizp压缩</title>
    <url>/2021/01/02/Springboot%E5%BC%80%E5%90%AFGizp%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h1 id="Springboot开启Gizp压缩"><a href="#Springboot开启Gizp压缩" class="headerlink" title="Springboot开启Gizp压缩"></a>Springboot开启Gizp压缩</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>在优化接口时间的过程中，发现很多接口的<code>Content Download</code>时间较长，除了网络问题，就是接口请求的数据太大了，有的达到了几百kb。控制返回参数收效甚微，这时开启 Gzip 就非常有用了，可以压缩接口请求的数据，一般的<code>json</code>文本压缩比率很大，开启之后接口时间大幅下降！</p>
</blockquote>
<h2 id="启用步骤"><a href="#启用步骤" class="headerlink" title="启用步骤"></a>启用步骤</h2><p>Spring boot 项目配置比较简单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>默认只压缩 Http <strong>body **超过</strong>2KB**的数据，可以通过一下配置修改默认属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">min-response-size:</span> <span class="string">1KB</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，只有在响应内容类型为以下内容时才会压缩响应</p>
<ul>
<li><code>text/html</code></li>
<li><code>text/xml</code></li>
<li><code>text/plain</code></li>
<li><code>text/css</code></li>
</ul>
<p>接口返回的是 json 数据，所以修改下面的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">mime-types:</span> <span class="string">application/json</span></span><br></pre></td></tr></table></figure>

<h3 id="如何查看-Gzip-是否开启成功"><a href="#如何查看-Gzip-是否开启成功" class="headerlink" title="如何查看 Gzip 是否开启成功"></a>如何查看 Gzip 是否开启成功</h3><p>Google 浏览器打开F12，切换到 NetWork 下，右键表头选择 Response Headers 下的<code>Content-Encoding</code>，如果开启了Gzip，对应接口中的<code>Content-Encoding</code>中会有显示。</p>
<blockquote>
<p><strong>注意：</strong> 在同时开启 https 和 http 的工程中，Gzip 配置只对主端口生效！</p>
</blockquote>
<h3 id="启用后的效果"><a href="#启用后的效果" class="headerlink" title="启用后的效果"></a>启用后的效果</h3><p>开启前：数据 Size 为 511KB，右侧时间蓝色部分（Content Download）较长</p>
<p><img src="http://image.leonote.cn/20210104111107.png" alt=""></p>
<p>开启前：数据 Size 为 21.3KB，Content-Encoding 中显示 Gzip，右侧时间蓝色部分消失</p>
<p><img src="http://image.leonote.cn/20210104111124.png" alt=""></p>
<p>对比效果非常明显，接口时间由<code>1.03s</code>降到<code>164ms</code>，完美！</p>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot的@Conditional注解</title>
    <url>/2019/09/20/Springboot%E7%9A%84@Conditional%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a><code>@Conditional</code></h1><blockquote>
<p>官方文档定义：“Indicates that a component is only eligible for registration when all specified conditions match”，意思是只有满足一些列条件之后才创建bean。</p>
<p>所以Springboot利用<code>@Conditional</code>注解来确定是否要加载该实例</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">	Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用的位置:</p>
<ol>
<li>类级别可以放在注标识有<code>@Component</code>（包含<code>@Configuration</code>）的类上</li>
<li>作为一个<code>meta-annotation</code>，组成自定义注解</li>
<li>方法级别可以放在标识由<code>@Bean</code>的方法上</li>
</ol>
</blockquote>
<h1 id="Conditional拓展注解"><a href="#Conditional拓展注解" class="headerlink" title="@Conditional拓展注解"></a><code>@Conditional</code>拓展注解</h1><ol>
<li><code>@ConditionalOnBean</code>: 当且仅当Springboot容器存在指定的bean classes and/or bean names，才创建注解所修饰的实例。</li>
<li><code>@ConditionalOnMissingBean</code>: 当且仅当Springboot容器不存在指定的bean classes and/or bean names，才创建注解所修饰的实例</li>
<li><code>@ConditionalOnClass</code>：和<code>@ConditionalOnBean</code>类似，当classpath中存在指定的class或className</li>
<li><code>@ConditionalOnMissingClass</code>：和<code>@ConditionalOnMissingBean</code>类似，当classpath中存在指定的class或className</li>
<li><code>@ConditionalOnProperty</code>：当且仅当application.properties/application.yml存在指定的配置项时，才创建注解所修饰的实例</li>
<li><code>@ConditionalOnJava</code>：指定JDK的版本</li>
<li><code>@ConditionalOnExpression</code>：表达式用${..}=false等来表示</li>
<li><code>@ConditionalOnJndi</code>：JNDI存在该项时创建</li>
<li><code>@ConditionalOnResource</code>：在classpath下存在指定的resource时创建</li>
<li><code>@ConditionalOnSingleCandidate</code> 当容器中指定的class仅存在一个bean的时候，才创建注解所修饰的实例</li>
<li><code>@ConditionalOnWebApplication</code>：在web环境下创建</li>
</ol>
]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring缓存注解</title>
    <url>/2019/12/04/Spring%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Spring 3.1 引入了基于注解的缓存技术，本质是一个对缓存使用的抽象，通过在既有代码中添加少量它定义的各种注解，就能够达到缓存方法的返回对象的效果。</p>
<p>Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案。</p>
</blockquote>
<h1 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>注解</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>Spring</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring自定义注解</title>
    <url>/2019/09/05/Spring%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><blockquote>
<p>在业务开发过程中我们会使用很多的注解，但是框架自有的注解并不是总能满足我们复杂的业务需求，所以我们一般会自定义注解来满足需求。根据注解使用的位置，分成字段注解、方法、类注解来介绍如何自定义注解。</p>
</blockquote>
<h1 id="字段注解"><a href="#字段注解" class="headerlink" title="字段注解"></a>字段注解</h1><blockquote>
<p>字段注解一般是用于校验字段是否满足要求，其中hibernate-validate依赖就提供了很多常用的校验注解 ，如<code>@NotNull</code>、<code>@Range</code>等，可以解决常见的业务场景。然而如果想要校验跟业务强相关的需求，那么已有的注解就不满足了。例如：传入的参数需要判断是否在指定的String集合中（业务枚举集合也可）。</p>
</blockquote>
<h3 id="自定义注解-Check"><a href="#自定义注解-Check" class="headerlink" title="自定义注解@Check"></a>自定义注解<code>@Check</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只允许用在类的字段上</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.FIELD&#125;)</span> </span><br><span class="line"><span class="comment">//注解保留在程序运行期间，此时可以通过反射获得定义在某个类上的所有注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="comment">//指定与注解关联的验证器</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = ParamConstraintValidated.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合法的参数值</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    String[] paramValues();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示信息</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> &quot;参数不为指定值&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>@Target</code> 定义注解的使用位置，用来说明该注解可以被声明在那些元素上。</strong></p>
<ul>
<li><code>ElementType.TYPE</code>：说明该注解只能被声明在一个<strong><em>类</em></strong>上。</li>
<li><code>ElementType.FIELD</code>：说明该注解只能被声明在一个<strong><em>类的字段</em></strong>上。</li>
<li><code>ElementType.METHOD</code>：说明该注解只能被声明在一个<strong><em>类的方法</em></strong>上。</li>
<li><code>ElementType.PARAMETER</code>：说明该注解只能被声明在一个<strong><em>方法参数</em></strong>上。</li>
<li><code>ElementType.CONSTRUCTOR</code>：说明该注解只能声明在一个<strong><em>类的构造方法</em></strong>上。</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：说明该注解只能声明在一个<strong><em>局部变量</em></strong>上。</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：说明该注解只能声明在一个<strong><em>注解类型</em></strong>上。</li>
<li><code>ElementType.PACKAGE</code>：说明该注解只能声明在一个<strong><em>包名</em></strong>上</li>
</ul>
<p><strong><code>@Constraint</code> 通过使用<code>validatedBy</code>来指定与注解关联的验证器</strong></p>
<p><strong><code>@Retention</code>用来说明该注解类的生命周期。</strong></p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>: 注解只保留在<strong><em>源文件</em></strong>中</li>
<li><code>RetentionPolicy.CLASS</code> : 注解保留在<strong><em>class文件</em></strong>中，在加载到JVM虚拟机时丢弃</li>
<li><code>RetentionPolicy.RUNTIME</code>: 注解保留<strong><em>在程序运行期间</em></strong>，此时可以通过反射获得定义在某个类上的所有注解。</li>
</ul>
</blockquote>
<h3 id="定义处理-Check的验证器类"><a href="#定义处理-Check的验证器类" class="headerlink" title="定义处理@Check的验证器类"></a>定义处理<code>@Check</code>的验证器类</h3><p>验证器类需要实现<code>ConstraintValidator</code>泛型接口</p>
<blockquote>
<p>第一个泛型参数类型：校验的注解。</p>
<p>第二个泛型参数Object：校验字段类型。</p>
<p>需要实现<code>initialize</code>和<code>isValid</code>方法，<code>isValid</code>方法为校验逻辑，<code>initialize</code>方法初始化工作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamConstraintValidated</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">Check</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合法的参数值，从注解中获取</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; paramValues;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Check constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化时获取注解上的值</span></span><br><span class="line">        paramValues = Arrays.asList(constraintAnnotation.paramValues());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Object o, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (paramValues.contains(o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不在指定的参数列表中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>定义一个实体类，对sex字段加校验，其值必须为woman或者man</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别 man or women</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Check(paramValues = &#123;&quot;man&quot;, &quot;woman&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在需要检验的对象上加上<code>@Validated</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController(&quot;/api/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="方法、类注解"><a href="#方法、类注解" class="headerlink" title="方法、类注解"></a>方法、类注解</h1><blockquote>
<p>在开发过程中遇到过这样的需求，如只有有权限的用户的才能访问这个类中的方法或某个具体的方法、查找数据的时候先不从数据库查找，先从<code>guava cache</code>中查找，在从<code>redis</code>查找，最后查找<code>mysql</code>（多级缓存）。</p>
<p>这时候我们可以自定义注解去完成这个要求：</p>
<ul>
<li><p>第一个场景：定义类似<code>Spring Security</code>下的<code>@PreAuthorize</code>一样的功能的权限校验的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span> </span><br><span class="line">- <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;ADMIN&#x27;)&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个场景：定义类似<code>Spring-data-redis</code>下的<code>@Cacheable</code>的注解</p>
</li>
</ul>
</blockquote>
<h2 id="权限注解"><a href="#权限注解" class="headerlink" title="权限注解"></a>权限注解</h2><h3 id="自定义注解-PermissionCheck"><a href="#自定义注解-PermissionCheck" class="headerlink" title="自定义注解@PermissionCheck"></a>自定义注解<code>@PermissionCheck</code></h3><p>该注解的作用范围为类或者方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PermissionCheck &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源key</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">String <span class="title">resourceKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义处理-PermissionCheck的拦截器类"><a href="#定义处理-PermissionCheck的拦截器类" class="headerlink" title="定义处理@PermissionCheck的拦截器类"></a>定义处理<code>@PermissionCheck</code>的拦截器类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionCheckInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器处理之前调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HandlerMethod handlerMethod = (HandlerMethod)handler;</span><br><span class="line">        PermissionCheck permission = findPermissionCheck(handlerMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有添加权限注解则直接跳过允许访问</span></span><br><span class="line">        <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注解中的值</span></span><br><span class="line">        String resourceKey = permission.resourceKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 权限校验一般需要获取用户信息，通过查询数据库进行权限校验</span></span><br><span class="line">        <span class="comment">//TODO 这里只进行简单演示，如果resourceKey为testKey则校验通过，否则不通过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;testKey&quot;</span>.equals(resourceKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据handlerMethod返回注解信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handlerMethod 方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PermissionCheck注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PermissionCheck <span class="title">findPermissionCheck</span><span class="params">(HandlerMethod handlerMethod)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在方法上寻找注解</span></span><br><span class="line">        PermissionCheck permission = handlerMethod.getMethodAnnotation(PermissionCheck.class);</span><br><span class="line">        <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//在类上寻找注解</span></span><br><span class="line">            permission = handlerMethod.getBeanType().getAnnotation(PermissionCheck.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> permission;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/test&quot;)</span></span><br><span class="line"><span class="meta">@PermissionCheck(resourceKey = &quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">testPermissionCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h2><h3 id="自定义注解-CustomCache"><a href="#自定义注解-CustomCache" class="headerlink" title="自定义注解@CustomCache"></a>自定义注解<code>@CustomCache</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomCache &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的key值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义处理-CustomCache的切面类"><a href="#定义处理-CustomCache的切面类" class="headerlink" title="定义处理 @CustomCache的切面类"></a>定义处理 <code>@CustomCache</code>的切面类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCacheAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在方法执行之前对注解进行处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pjd</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> customCache 注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回中的值</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(com.test.annotation.CustomCache)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">dealProcess</span><span class="params">(ProceedingJoinPoint pjd, CustomCache customCache)</span> </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (customCache.key() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//TODO throw error</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 业务场景会比这个复杂的多，会涉及参数的解析如key可能是#&#123;id&#125;这些，数据查询</span></span><br><span class="line">        <span class="comment">//TODO 这里做简单演示，如果key为testKey则返回hello world</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;testKey&quot;</span>.equals(customCache.key())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = pjd.proceed();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为缓存注解需要在方法执行之前有返回值，所以没有通过拦截器处理这个注解，而是通过使用切面在执行方法之前对注解进行处理。如果注解没有返回值，将会返回方法中的值。</p>
</blockquote>
<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/api/cache&quot;)</span></span><br><span class="line"><span class="meta">@CustomCache(key = &quot;test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">testCustomCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;don&#x27;t hit cache&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>注解</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>注解</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>String.join()</title>
    <url>/2020/09/10/StringJoiner/</url>
    <content><![CDATA[<h1 id="String-join"><a href="#String-join" class="headerlink" title="String.join()"></a>String.join()</h1><blockquote>
<p>JDK8 重载了join方法</p>
</blockquote>
<p><img src="http://image.leonote.cn/image-20200911103925509.png" alt="image-20200911103925509"></p>
<h1 id="SpringJoiner"><a href="#SpringJoiner" class="headerlink" title="SpringJoiner"></a>SpringJoiner</h1><h2 id="构造函数详细信息"><a href="#构造函数详细信息" class="headerlink" title="构造函数详细信息"></a>构造函数详细信息</h2><p><code>public StringJoiner (CharSequence  delimiter, CharSequence  prefix，CharSequence  suffix )</code></p>
<p>参数：</p>
<ol>
<li><p>delimiter - 添加到的每个元素之间要使用的字符序列</p>
</li>
<li><p>prefix - 开头使用的字符序列</p>
</li>
<li><p>suffix - 最后使用的字符序列</p>
<p>如果 prefix，delimiter 或 suffix  是 null,  则抛出空指针异常。</p>
</li>
</ol>
<p>举例：字符串<code>&quot;[George:Sally:Fred]&quot;</code>可以构造如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">sj.add(<span class="string">&quot;George&quot;</span>).add(<span class="string">&quot;Sally&quot;</span>).add(<span class="string">&quot;Fred&quot;</span>);</span><br><span class="line">String desiredString = sj.toString();</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JDK</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Join</tag>
      </tags>
  </entry>
  <entry>
    <title>String的常见问题</title>
    <url>/2019/09/06/String%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="双引号和构造器两种形式创建字符串的区别"><a href="#双引号和构造器两种形式创建字符串的区别" class="headerlink" title="双引号和构造器两种形式创建字符串的区别"></a>双引号和构造器两种形式创建字符串的区别</h1><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">System.out.println(a == b);  <span class="comment">// True</span></span><br><span class="line">System.out.println(a.equals(b)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>a == b</code> 结果为 true，是因为 a 和 b 都指向 <strong>方法区(method area)</strong> 同一个字符串文字，内存引用是同一个。</p>
<p>当多次创建相同的字符串文字时，只存储每个不同字符串值的一个副本。这个叫做<strong>字符串留驻/留用</strong>，Java 中所有编译期字符串常量都会被自动留驻。</p>
</blockquote>
<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">System.out.println(c == d);  <span class="comment">// False</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>c==d</code> 结果为 false，因为 c 和 d 的引用指向<strong>堆</strong>中不同的对象，<code>不同的对象肯定有不同的内存引用</code></p>
</blockquote>
<p>上述两种情况，用图形来理解的话是：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-09-05_16-16-45.png" alt=""></p>
<blockquote>
<p>一个是在<code>方法区</code>，一个是在<code>堆</code>中， 这是JVM模型的两个不同的区域。</p>
<p>JVM模型的图：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-09-05_16-21-11.png" alt=""></p>
<p>所有new的对象都在Heap中。</p>
</blockquote>
<h2 id="运行期字符串留驻"><a href="#运行期字符串留驻" class="headerlink" title="运行期字符串留驻"></a>运行期字符串留驻</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String c = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>).intern();</span><br><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>).intern();</span><br><span class="line">System.out.println(c == d);  <span class="comment">// True</span></span><br><span class="line">System.out.println(c.equals(d)); <span class="comment">// True</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>c == d</code> 结果为 true， intern (英文有拘留，软禁的意思)的作用了，通过调用 intern()方法，就好比把创建的字符串拘留在方法区一样了</p>
</blockquote>
<p>在面试时甚至还会问你下面代码创建了几个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String d = <span class="keyword">new</span> String(<span class="string">&quot;abcd&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>如果方法区里有<code>&quot;abcd&quot;</code>， 则只创建一个new String对象</li>
<li>如果方法区里没有<code>&quot;abcd&quot;</code>，则创建两个字符串对象<ul>
<li>一个是方法区的<code>&quot;abcd&quot;</code></li>
<li>一个是堆的<code>new String(&quot;abcd&quot;)</code></li>
</ul>
</li>
</ol>
</blockquote>
<p>所以，<strong>正常情况</strong>下没必要使用构造器创建对象，因为这很可能会产生一个额外的没用的对象。</p>
<p>但是也有例外：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">s = s.concat(<span class="string">&quot;ef&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn/Snipaste_2019-09-05_16-32-07.png" alt=""></p>
<p>当在字符串 s 后面拼接字符串<code>&quot;ef&quot;</code>时，会在堆中创建一个新的对象，并将 s 的引用指向新创建的对象，由于 String 创建的是不可变对象，所以 <strong>String 类中的所有方法都不会改变它自身，而是返回一个新的字符串(快打开你的 IDE，看看是否每个操作String 的方法最后都是返回有 return new String 字样)</strong>，到这里你应该理解了一个道理:</p>
<blockquote>
<p>如果需要一个字符串被修改，我们最好使用 <code>StringBuffer</code> 或者 <code>StringBuilder</code>，否则，由于每次操作字符串都会创建一个新的对象，而旧的对象不会有引用指向它，这样我们会浪费很多垃圾回收的时间</p>
</blockquote>
<h1 id="为什么-String-类被-final-修饰"><a href="#为什么-String-类被-final-修饰" class="headerlink" title="为什么 String 类被 final 修饰"></a>为什么 String 类被 final 修饰</h1><h2 id="字符串池的需求"><a href="#字符串池的需求" class="headerlink" title="字符串池的需求"></a>字符串池的需求</h2><p>字符串池(String intern pool) 是<strong><em>方法区</em></strong>中的一个特殊存储区域。当创建一个字符串时，如果该字符串已经存在于池中，那么返回现有字符串的引用，而不是创建一个新对象。所以说，如果一个字符串是可变的，那么改变一个引用的值，将导致原本指向该值的引用获取到错误的值。</p>
<h2 id="缓存-hashcode"><a href="#缓存-hashcode" class="headerlink" title="缓存 hashcode"></a>缓存 <code>hashcode</code></h2><p>字符串的<code>hashcode</code>在Java中经常使用。例如，在<code>HashMap</code>或<code>HashSet</code>中。不可变保证<code>hashcode</code>始终是相同的，这样就可以在不担心更改的情况下兑现它。这意味着，不需要每次使用<code>hashcode</code>时都计算它。这样更有效率。所以你会在 String 类中看到下面的成员变量的定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure>

<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>String被广泛用作许多java类的参数，例如网络连接、打开文件等。如果字符串不是不可变的，连接或文件将被更改，这可能导致严重的安全威胁。该方法认为它连接到一台机器上，但实际上并没有。<strong>可变字符串也可能导致反射中的安全问题，因为参数是字符串</strong>。</p>
<h2 id="不可变对象天生是线程安全的"><a href="#不可变对象天生是线程安全的" class="headerlink" title="不可变对象天生是线程安全的"></a>不可变对象天生是线程安全的</h2><p>由于不可变对象不能被更改，所以它们可以在多个线程之间自由共享。这消除了同步的需求。</p>
<p>总之，出于效率和安全性的考虑，String 被设计为不可变的。这也是为什么在一般情况下，不可变类是首选的原因。</p>
<h1 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h1><p>关于不可变对象和不可变引用总是搞不清楚</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>

<p>上面的代码指的是 user 引用不能被更改指向内存的其他地址，但是由于 User 是可变对象，我们可以调用 user 的 setter 方法修改其属性</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Time 相关的类</title>
    <url>/2020/11/05/Time%20Class/</url>
    <content><![CDATA[<h2 id="Time相关类"><a href="#Time相关类" class="headerlink" title="Time相关类"></a>Time相关类</h2><p>​    java.time包中的是类是<strong>不可变且线程安全</strong>的。新的时间及日期API位于java.time中</p>
<ul>
<li>Instant——它代表的是时间戳</li>
<li>LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。</li>
<li>LocalTime——它代表的是不含日期的时间</li>
<li>LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。</li>
<li>ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。</li>
</ul>
<h2 id="JDK8是如何处理时间及日期的"><a href="#JDK8是如何处理时间及日期的" class="headerlink" title="JDK8是如何处理时间及日期的"></a>JDK8是如何处理时间及日期的</h2><h3 id="1-处理日期"><a href="#1-处理日期" class="headerlink" title="1. 处理日期"></a>1. 处理日期</h3><p>​    LocalDate类，能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。</p>
<p>​    MonthDay类，这个类由月日组合，不包含年信息，可以用来代表每年重复出现的一些日期或其他组合。是不可变且线程安全的，并且它还是一个值类（value class）。</p>
<p>​    YearMonth类，这个类有年月组合，不包含日信息，可以用来查找这个月在某一年里有多少天。</p>
<p>​    Period类，计算两个日期之间包含多少天、周、月、年。</p>
<h4 id="1-1-获取当天的日期"><a href="#1-1-获取当天的日期" class="headerlink" title="1.1 获取当天的日期"></a>1.1 获取当天的日期</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期是：&quot;</span> + today);</span><br><span class="line"><span class="comment">// 今天的日期是：2019-01-15</span></span><br></pre></td></tr></table></figure>

<p>​    创建的日期不包含时间信息，并且格式化了日期。</p>
<h4 id="1-2-获取当前的年月日"><a href="#1-2-获取当前的年月日" class="headerlink" title="1.2 获取当前的年月日"></a>1.2 获取当前的年月日</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="keyword">int</span> year = today.getYear();</span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue();</span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth();</span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + year + <span class="string">&quot;\n月：&quot;</span> + month + <span class="string">&quot;\n日：&quot;</span> + day);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 年：2019</span></span><br><span class="line"><span class="comment"> * 月：1</span></span><br><span class="line"><span class="comment"> * 日：15</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-获取某个特定的日期"><a href="#1-3-获取某个特定的日期" class="headerlink" title="1.3 获取某个特定的日期"></a>1.3 获取某个特定的日期</h4><p>​    通过 of 方法，可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。</p>
<p>​    在这个方法里，需要的日期你填写什么就是什么，不像之前的API中月份必须从0开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.of(<span class="number">2018</span>,<span class="number">12</span>,<span class="number">15</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;你输入的日期是：&quot;</span> + today);</span><br><span class="line"><span class="comment">// 你输入的日期是：2018-12-15</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-检查两个日期是否相等"><a href="#1-4-检查两个日期是否相等" class="headerlink" title="1.4 检查两个日期是否相等"></a>1.4 检查两个日期是否相等</h4><p>​    LocalDate重写了equals方法来进行日期的比较，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.of(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">15</span>);</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期是2019-1-15吗：&quot;</span> + today.equals(now));</span><br><span class="line"><span class="comment">// 今天的日期是2019-1-15吗：true</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-如何检查重复事件，比如生日"><a href="#1-5-如何检查重复事件，比如生日" class="headerlink" title="1.5 如何检查重复事件，比如生日"></a>1.5 如何检查重复事件，比如生日</h4><p>在java中还有一个与时间日期相关的任务就是检查重复事件，比如每月的账单日</p>
<p>使用MonthDay类判断是否是某个节日或者重复事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate dateOfBirth = LocalDate.of(<span class="number">1997</span>,<span class="number">4</span>,<span class="number">13</span>);</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">MonthDay birthDay = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">MonthDay currentMonthDay = MonthDay.from(now);</span><br><span class="line"><span class="keyword">if</span> (currentMonthDay.equals(birthDay))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;今天是你的生日&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;对不起，今天不是你的生日&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对不起，今天不是你的生日</span></span><br></pre></td></tr></table></figure>

<p>​    MonthDay只存储了月日，对比两个日期的月日即可知道是否重复</p>
<h4 id="1-6-获取1周后的日期"><a href="#1-6-获取1周后的日期" class="headerlink" title="1.6 获取1周后的日期"></a>1.6 获取1周后的日期</h4><p>​    这个与使用LocalTime获取2小时后的时间的例子很相似，这里我们获取的是1周后的日期。</p>
<p>​    LocalDate是用来表示无时间的日期，他有一个plus()方法可以用来增加日，星期，月。</p>
<p>​    ChronoUnit则用来表示时间单位，LocalDate也是不可变的，因此任何修改操作都会返回一个新的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期是：&quot;</span> + today);</span><br><span class="line">LocalDate oneToDay = today.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line">System.out.println(<span class="string">&quot;一周后的日期是：&quot;</span> + oneToDay);</span><br><span class="line"><span class="comment">//今天的日期是：2019-01-15</span></span><br><span class="line"><span class="comment">//一周后的日期是：2019-01-22</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以用这个方法来增加一个月，一年，一小时，一分等等</p>
</blockquote>
<h4 id="1-7-一年前的日期"><a href="#1-7-一年前的日期" class="headerlink" title="1.7 一年前的日期"></a>1.7 一年前的日期</h4><p>​    使用LocalDate的plus()方法来给日期增加日周月，</p>
<p>​    现在我们用minus()方法来给日期减少日周月，往前找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期是：&quot;</span> + today);</span><br><span class="line">LocalDate previousYear = today.minus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">System.out.println(<span class="string">&quot;一年前的日期是：&quot;</span> + previousYear);</span><br><span class="line"><span class="comment">//今天的日期是：2019-01-15</span></span><br><span class="line"><span class="comment">//一年前的日期是：2018-01-15</span></span><br></pre></td></tr></table></figure>

<h4 id="1-8-如何判断某个日期在另一个日期的前面还是后面"><a href="#1-8-如何判断某个日期在另一个日期的前面还是后面" class="headerlink" title="1.8 如何判断某个日期在另一个日期的前面还是后面"></a>1.8 如何判断某个日期在另一个日期的前面还是后面</h4><p>​     LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期。</p>
<p>​    如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。</p>
<p>​    如果调用方法的那个日期比给定的日期要晚的话，isAfter()方法会返回true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天的日期是：&quot;</span> + today);</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">System.out.println(<span class="string">&quot;明天的日期是：&quot;</span> + tomorrow);</span><br><span class="line">System.out.println(<span class="string">&quot;日期：&quot;</span> + tomorrow + <span class="string">&quot;是否在日期：&quot;</span> + today + <span class="string">&quot;之后：&quot;</span> + tomorrow.isAfter(today));</span><br><span class="line">System.out.println(<span class="string">&quot;日期：&quot;</span> + tomorrow + <span class="string">&quot;是否在日期：&quot;</span> + today + <span class="string">&quot;之前：&quot;</span> + tomorrow.isBefore(today));</span><br><span class="line"><span class="comment">//今天的日期是：2019-01-15</span></span><br><span class="line"><span class="comment">//明天的日期是：2019-01-16</span></span><br><span class="line"><span class="comment">//日期：2019-01-16是否在日期：2019-01-15之后：true</span></span><br><span class="line"><span class="comment">//日期：2019-01-16是否在日期：2019-01-15之前：false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>java8中比较日期非常简单，不再需要使用Calendar这样另外的类来完成类似的任务了</p>
</blockquote>
<h4 id="1-9-如何表示固定的日期，比如信用卡过期时间"><a href="#1-9-如何表示固定的日期，比如信用卡过期时间" class="headerlink" title="1.9 如何表示固定的日期，比如信用卡过期时间"></a>1.9 如何表示固定的日期，比如信用卡过期时间</h4><p>正如MonthDay表示的是某个重复出现的日子，YearMonth是另外一个组合，代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类找出这个月有多少天，LengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月是否润2月很有用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">YearMonth currentYearMonth = YearMonth.now();</span><br><span class="line">System.out.printf(<span class="string">&quot;今年这个月 %s: 有 %d 天%n&quot;</span>, currentYearMonth, currentYearMonth.lengthOfMonth());</span><br><span class="line">YearMonth creditCardExpiry = YearMonth.of(<span class="number">2018</span>, Month.FEBRUARY);</span><br><span class="line">System.out.printf(<span class="string">&quot;你输入的日期是 %s %n&quot;</span>, creditCardExpiry);</span><br><span class="line"><span class="comment">//今年这个月 2019-01: 有 31 天</span></span><br><span class="line"><span class="comment">//你输入的日期是 2018-02 </span></span><br></pre></td></tr></table></figure>

<h4 id="1-10-如何在java8中检查闰年"><a href="#1-10-如何在java8中检查闰年" class="headerlink" title="1.10 如何在java8中检查闰年"></a>1.10 如何在java8中检查闰年</h4><p>​    LocalDate类由一个isLeapYear()方法来返回当前LocalDate对应的那年是否是闰年</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">&quot;今天是不是闰年：&quot;</span> + now.isLeapYear());</span><br><span class="line"><span class="comment">//今天是不是闰年：false</span></span><br></pre></td></tr></table></figure>

<h4 id="1-11-两个日期之间包含多少天，多少月"><a href="#1-11-两个日期之间包含多少天，多少月" class="headerlink" title="1.11 两个日期之间包含多少天，多少月"></a>1.11 两个日期之间包含多少天，多少月</h4><p>计算两个日期之间包含多少天、周、月、年。</p>
<p>可以用java.time.Period类完成该功能。</p>
<p>下面例子中将计算日期与将来的日期之间一共有几个月</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2018</span>, Month.MARCH, <span class="number">14</span>);</span><br><span class="line">Period periodToNextJavaRelease = Period.between(today, date);</span><br><span class="line">System.out.printf(<span class="string">&quot;日期%s和日期%s相差%s月 &quot;</span>, today, date, periodToNextJavaRelease.getMonths());</span><br><span class="line"><span class="comment">//日期2019-01-15和日期2018-03-14相差-10月 </span></span><br></pre></td></tr></table></figure>



<h3 id="2-处理时间"><a href="#2-处理时间" class="headerlink" title="2. 处理时间"></a>2. 处理时间</h3><p>​    LocalTime类，默认的格式是hh:mm:ss:nnn，这个时间是不包含日期的</p>
<h4 id="2-1-获取当前时间"><a href="#2-1-获取当前时间" class="headerlink" title="2.1 获取当前时间"></a>2.1 获取当前时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">System.out.println(localTime);</span><br><span class="line"><span class="comment">// 15:18:30.974</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-增加时间里面的小时数"><a href="#2-2-增加时间里面的小时数" class="headerlink" title="2.2 增加时间里面的小时数"></a>2.2 增加时间里面的小时数</h4><p>​    很多时候需要对时间进行操作，比如加一个小时来计算之后的时间，java8提供了更方便的方法 如plusHours，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">&quot;现在的时间是：&quot;</span> + localTime);</span><br><span class="line">LocalTime two = localTime.plusHours(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;两个小时后的时间是：&quot;</span> + two);</span><br><span class="line">System.out.println(<span class="string">&quot;这是相同的对象：&quot;</span> + localTime.equals(two));</span><br><span class="line"><span class="comment">//现在的时间是：15:21:42.518</span></span><br><span class="line"><span class="comment">//两个小时后的时间是：17:21:42.518</span></span><br><span class="line"><span class="comment">//这是相同的对象：false</span></span><br></pre></td></tr></table></figure>



<h3 id="3-处理时区"><a href="#3-处理时区" class="headerlink" title="3. 处理时区"></a>3. 处理时区</h3><p>​    java8中不仅将日期和时间进行了分离，同时还有时区。比如ZonId代表的是某个特定时区，ZonedDateTime代表带时区的时间，等同于以前的GregorianCalendar类。使用该类，可以将本地时间转换成另一个时区中的对应时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZoneId darWin = ZoneId.of(ZoneId.SHORT_IDS.get(<span class="string">&quot;ACT&quot;</span>));</span><br><span class="line">ZonedDateTime dateTimeInDarwin = ZonedDateTime.of(localDateTime, darWin);</span><br><span class="line">System.out.println(<span class="string">&quot;现在时区的时间和特定时区的时间：&quot;</span> + dateTimeInDarwin);</span><br><span class="line"><span class="comment">//现在时区的时间和特定时区的时间：2019-01-15T15:58:31.859+09:30[Australia/Darwin]</span></span><br></pre></td></tr></table></figure>



<h3 id="4-获取时间戳"><a href="#4-获取时间戳" class="headerlink" title="4. 获取时间戳"></a>4. 获取时间戳</h3><p>Instant类由一个静态的工厂方法now()可以返回当前时间戳</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">System.out.println(<span class="string">&quot;当前的时间戳是：&quot;</span> + timestamp);</span><br><span class="line"><span class="comment">//当前的时间戳是：2019-01-15T08:27:59.561Z</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前时间戳是包含日期和时间的，与java.util.Date很类似，事实上Instant就是java8以前的Date，可以使用这个两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而Date。toInstant()就是将Date转换成Instant的</p>
</blockquote>
<h3 id="5-全新的日期时间格式器DateTimeFormatter"><a href="#5-全新的日期时间格式器DateTimeFormatter" class="headerlink" title="5.全新的日期时间格式器DateTimeFormatter"></a>5.全新的日期时间格式器DateTimeFormatter</h3><p>​    在java8之前，时间日期的格式化非常麻烦，经常使用SimpleDateFormat来进行格式化，但是SimpleDateFormat并不是线程安全的。</p>
<p>​    在java8中，引入了一个全新的<strong>线程安全的日期与时间格式器==DateTimeFormatter==</strong>。并且预定义好了格式。</p>
<h4 id="5-1-预置的格式器来格式化日期"><a href="#5-1-预置的格式器来格式化日期" class="headerlink" title="5.1 预置的格式器来格式化日期"></a>5.1 预置的格式器来格式化日期</h4><p>​    本例中使用的BASICISODATE格式会将20160414格式化成2016-04-14</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String dayAfterTomorrow = <span class="string">&quot;20180116&quot;</span>;</span><br><span class="line">LocalDate formatted = LocalDate.parse(dayAfterTomorrow, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">System.out.printf(<span class="string">&quot;字符 %s 格式化后的日期格式是 %s %n&quot;</span>,dayAfterTomorrow,formatted);</span><br><span class="line"><span class="comment">//字符 20180116 格式化后的日期格式是 2018-01-16 </span></span><br></pre></td></tr></table></figure>



<h4 id="5-2-自定义格式器来解析日期"><a href="#5-2-自定义格式器来解析日期" class="headerlink" title="5.2 自定义格式器来解析日期"></a>5.2 自定义格式器来解析日期</h4><p>​    我们使用了预置的时间日期格式器来解析日期字符串了，但是有时预置的不能满足的时候就需要我们自定义日期格式器了，下面的例子中的日期格式是”MM dd yyyy”.你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如M代表月，m仍代表分，无效的模式会抛异常DateTimeParseException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String day = <span class="string">&quot;01 15 2019&quot;</span>;</span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;MM dd yyyy&quot;</span>);</span><br><span class="line">LocalDate holiday = LocalDate.parse(day, formatter);</span><br><span class="line">System.out.printf(<span class="string">&quot;字符 %s 转换成功后的日期是 %s%n&quot;</span>, day, holiday);</span><br><span class="line"><span class="comment">//字符 01 15 2019 转换成功后的日期是 2019-01-15</span></span><br></pre></td></tr></table></figure>



<p>20、对日期进行格式化，转换成字符串</p>
<p>​    我们主要是对日期字符串来进行解析转换成日期，在这个例子我们相反，是把日期转换成字符。这里我们有个LocalDateTime类的实例，我们要把他转换成一个格式化好的日期串，与前例相同的是，我们仍需要制定模式串去创建一个DateTimeFormatter类的实例，但调用的是LocalDate.format()。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中定义好的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime arrivalDate = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">&quot;MM dd yyyy HH:mm a&quot;</span>);</span><br><span class="line">String format = arrivalDate.format(dateTimeFormatter);</span><br><span class="line">System.out.println(<span class="string">&quot;转换后的日期:&quot;</span> + format);</span><br><span class="line"><span class="comment">//转换后的日期:01 15 2019 17:30 PM</span></span><br></pre></td></tr></table></figure>



<h2 id="java8中日期与时间API的几个关键点"><a href="#java8中日期与时间API的几个关键点" class="headerlink" title="java8中日期与时间API的几个关键点"></a>java8中日期与时间API的几个关键点</h2><p>回顾一下</p>
<p>●它提供了javax.time.ZoneId用来处理时区。</p>
<p>●它提供了LocalDate与LocalTime类</p>
<p>●Java 8中新的时间与日期API中的所有类都是不可变且线程安全的，这与之前的Date与Calendar API中的恰好相反，那里面像java.util.Date以及SimpleDateFormat这些关键的类都不是线程安全的。</p>
<p>●新的时间与日期API中很重要的一点是它定义清楚了基本的时间与日期的概念，比方说，瞬时时间，持续时间，日期，时间，时区以及时间段。它们都是基于ISO日历体系的。</p>
<p><strong>每个Java开发人员都应该至少了解这套新的API中的这五个类：</strong></p>
<p>●Instant 它代表的是时间戳，比如2016-04-14T14:20:13.592Z，这可以从java.time.Clock类中获取，像这样： Instant current = Clock.system(ZoneId.of(“Asia/Tokyo”)).instant();</p>
<p>●LocalDate 它表示的是不带时间的日期，比如2016-04-14。它可以用来存储生日，周年纪念日，入职日期等。</p>
<p>●LocalTime - 它表示的是不带日期的时间</p>
<p>●LocalDateTime - 它包含了时间与日期，不过没有带时区的偏移量</p>
<p>●ZonedDateTime - 这是一个带时区的完整时间，它根据UTC/格林威治时间来进行时区调整</p>
<p>●这个库的主包是java.time，里面包含了代表日期，时间，瞬时以及持续时间的类。它有两个子package，一个是java.time.foramt，这个是什么用途就很明显了，还有一个是java.time.temporal，它能从更低层面对各个字段进行访问。</p>
<p>●时区指的是地球上共享同一标准时间的地区。每个时区都有一个唯一标识符，同时还有一个地区/城市(Asia/Tokyo)的格式以及从格林威治时间开始的一个偏移时间。比如说，东京的偏移时间就是+09:00。</p>
<p>●OffsetDateTime类实际上包含了LocalDateTime与ZoneOffset。它用来表示一个包含格林威治时间偏移量（+/-小时：分，比如+06:00或者 -08：00）的完整的日期（年月日）及时间（时分秒，纳秒）。</p>
<p>●DateTimeFormatter类用于在Java中进行日期的格式化与解析。与SimpleDateFormat不同，它是不可变且线程安全的，如果需要的话，可以赋值给一个静态变量。DateTimeFormatter类提供了许多预定义的格式器，你也可以自定义自己想要的格式。当然了，根据约定，它还有一个parse()方法是用于将字符串转换成日期的，如果转换期间出现任何错误，它会抛出DateTimeParseException异常。类似的，DateFormatter类也有一个用于格式化日期的format()方法，它出错的话则会抛出DateTimeException异常。</p>
<p>●再说一句，“MMM d yyyy”与“MMm dd yyyy”这两个日期格式也略有不同，前者能识别出”Jan 2 2014”与”Jan 14 2014”这两个串，而后者如果传进来的是”Jan 2 2014”则会报错，因为它期望月份处传进来的是两个字符。为了解决这个问题，在天为个位数的情况下，你得在前面补0，比如”Jan 2 2014”应该改为”Jan 02 2014”。</p>
]]></content>
      <categories>
        <category>JDK</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>Time</tag>
      </tags>
  </entry>
  <entry>
    <title>统一建模语言(UML)</title>
    <url>/2020/09/19/UML/</url>
    <content><![CDATA[<h1 id="统一建模语言-UML"><a href="#统一建模语言-UML" class="headerlink" title="统一建模语言(UML)"></a>统一建模语言(UML)</h1><h2 id="什么是模型"><a href="#什么是模型" class="headerlink" title="什么是模型"></a>什么是模型</h2><p>模型是一个系统的完整的抽象。人们对某个领域特定问题的求解及解决方案，对它们的理解和认识都蕴含在模型中。通常，开发一个计算机系统是为了解决某个领域特定问题，问题的求解过程，就是从领域问题到计算机系统的映射。</p>
<p><img src="http://image.leonote.cn//20200919102631.png" alt=""></p>
<h2 id="为什么要建造模型"><a href="#为什么要建造模型" class="headerlink" title="为什么要建造模型"></a>为什么要建造模型</h2><ol>
<li>建造传统模型的目的<ul>
<li>为了证明某件事物能否工作</li>
<li>前提：建造模型的成本远远低于建造实物的成本<ul>
<li>造飞机</li>
<li>造高楼</li>
</ul>
</li>
</ul>
</li>
<li>建造软件模型的目的<ul>
<li>为了与他人沟通</li>
<li>为了保存软件设计的最终成果</li>
<li>前提：除非模型比代码更说明问题</li>
</ul>
</li>
</ol>
<h2 id="通用模型元素"><a href="#通用模型元素" class="headerlink" title="通用模型元素"></a>通用模型元素</h2><p>模型元素是UML构造系统的各种元素，是UML构建模型的基本单位。</p>
<h3 id="基元素"><a href="#基元素" class="headerlink" title="基元素"></a>基元素</h3><p>是由UML定义的模型元素，如：类、结点、构件、注释、关联、依赖和泛化(继承)等</p>
<p>关联关系分类：</p>
<p><img src="http://image.leonote.cn//20200919105246.png" alt=""></p>
<ul>
<li>泛化(继承) - 类与类，接口与接口的关系</li>
<li>实现 - 是一种类与接口的关系</li>
<li>组合 - 是整体与部分，是“has-a”关系，但部分<strong>不能离开</strong>整体而单独存在<ul>
<li>公司和部门是整体和部分的关系，没有公司就不存在部门</li>
<li>也是一种关联关系，比聚合更强关联</li>
</ul>
</li>
<li>聚合 - 是整体与部分，是“contains-a”关系，且部分<strong>可以离开</strong>整体而单独存在<ul>
<li>车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在</li>
<li>也是一种关联关系，是强关联</li>
</ul>
</li>
<li>关联 - 是一种拥有的关系，它使一个类知道另一个类的属性和方法，<ul>
<li>[代码表现] 成员变量</li>
</ul>
</li>
<li>依赖 - 是一种使用的关系，即一个类的实现需要另一个类的协助，尽量不要双向依赖<ul>
<li>[代码表现] 局部变量、方法的参数或者对静态方法的调用</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>各种关系的强弱顺序：</strong> 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
</blockquote>
<h3 id="构造型元素"><a href="#构造型元素" class="headerlink" title="构造型元素"></a>构造型元素</h3><p>在基元素的基础上增加了新的定义而构造的新的模型元素，允许用户自定义</p>
<p>构造型元素用括在双尖括号《 》中的字符串表示</p>
<p>目前UML提供了40多个预定义的构造型元素，如包含《include》、扩展《 Extend 》</p>
<h2 id="什么是UML"><a href="#什么是UML" class="headerlink" title="什么是UML"></a>什么是UML</h2><p>是一种对软件系统(架构)进行==可视化建模==的语言，以图形的方式描述了软件的概念。</p>
<h2 id="UML有什么作用"><a href="#UML有什么作用" class="headerlink" title="UML有什么作用"></a>UML有什么作用</h2><ol>
<li>描述某个问题领域</li>
<li>描述构思中的软件设计</li>
<li>描述已经完成的软件实现</li>
</ol>
<h2 id="UML图的分类"><a href="#UML图的分类" class="headerlink" title="UML图的分类"></a>UML图的分类</h2><h3 id="静态图"><a href="#静态图" class="headerlink" title="静态图"></a>静态图</h3><blockquote>
<p>通过描述类、对象和数据结构以及它们之间存在的关系，来描述软件要素中不变的逻辑结构。</p>
</blockquote>
<h4 id="用例图（Use-Case-Diagrams）"><a href="#用例图（Use-Case-Diagrams）" class="headerlink" title="用例图（Use Case Diagrams）"></a>用例图（Use Case Diagrams）</h4><h4 id="对象图（Object-Diagrams）"><a href="#对象图（Object-Diagrams）" class="headerlink" title="对象图（Object Diagrams）"></a>对象图（Object Diagrams）</h4><h4 id="类图（Class-Diagrams）"><a href="#类图（Class-Diagrams）" class="headerlink" title="类图（Class Diagrams）"></a>类图（Class Diagrams）</h4><h4 id="组件图（Component-Diagrams）"><a href="#组件图（Component-Diagrams）" class="headerlink" title="组件图（Component Diagrams）"></a>组件图（Component Diagrams）</h4><h4 id="包图（Package-Diagrams）"><a href="#包图（Package-Diagrams）" class="headerlink" title="包图（Package Diagrams）"></a>包图（Package Diagrams）</h4><h4 id="部署图（Deployment-Diagrams）"><a href="#部署图（Deployment-Diagrams）" class="headerlink" title="部署图（Deployment Diagrams）"></a>部署图（Deployment Diagrams）</h4><h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><blockquote>
<p>通过描绘执行流程或者实体状态变化的方式，来展示软件实体在执行过程中的变化过程。</p>
</blockquote>
<h4 id="协作图（Collaboration-Diagrams）"><a href="#协作图（Collaboration-Diagrams）" class="headerlink" title="协作图（Collaboration Diagrams）"></a>协作图（Collaboration Diagrams）</h4><h4 id="序列图（Sequence-Diagrams）"><a href="#序列图（Sequence-Diagrams）" class="headerlink" title="序列图（Sequence Diagrams）"></a>序列图（Sequence Diagrams）</h4><h4 id="活动图（Activity-Diagrams）"><a href="#活动图（Activity-Diagrams）" class="headerlink" title="活动图（Activity Diagrams）"></a>活动图（Activity Diagrams）</h4><h4 id="状态图（State-Diagrams）"><a href="#状态图（State-Diagrams）" class="headerlink" title="状态图（State Diagrams）"></a>状态图（State Diagrams）</h4>]]></content>
      <categories>
        <category>架构</category>
        <category>UML</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue created 与 mounted</title>
    <url>/2020/11/09/Vue%20created%20%E4%B8%8E%20mounted/</url>
    <content><![CDATA[<h1 id="Vue-created-与-mounted-区别"><a href="#Vue-created-与-mounted-区别" class="headerlink" title="Vue created 与 mounted 区别"></a>Vue created 与 mounted 区别</h1><table>
<thead>
<tr>
<th align="center">生命周期</th>
<th align="center">是否获取dom节点</th>
<th align="center">是否可以获取data</th>
<th align="center">是否获取methods</th>
</tr>
</thead>
<tbody><tr>
<td align="center">beforeCreate</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">beforeMount</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">mounted</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
</tbody></table>
<ul>
<li>created：在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>mounted：在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的dom 节点进行一些需要的操作。</li>
</ul>
<p>如果要类似 <code>let ctx = document.getElementById(ID)</code>获取 dom 元素，只能等这个html 渲染完后才可以进行，那么就用 mounted ，如果不需要 created 即可。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Mixin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/11/28/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p><code>npm install hexo -g</code> </p>
<h4 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h4><p> <code>npm update hexo -g</code></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>hexo init</code></p>
<h1 id="命令-amp-简写"><a href="#命令-amp-简写" class="headerlink" title="命令&amp;简写"></a>命令&amp;简写</h1><h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p><code>hexo new &quot;&lt;title&gt;&quot;</code>      ===          <code>hexo n &quot;&lt;title&gt;&quot;</code> </p>
<h4 id="新建草稿"><a href="#新建草稿" class="headerlink" title="新建草稿"></a>新建草稿</h4><p><code>hexo new draft &quot;&lt;title&gt;&quot;</code> ===  <code>hexo n draft &quot;&lt;title&gt;&quot;</code></p>
<blockquote>
<p>草稿相当于“私密文章”功能。</p>
<ol>
<li>会在<code>source/_drafts</code>目录下生成一个草稿的markdown文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到<code>_drafts</code>目录之中。</li>
<li>如果你希望强行预览草稿，更改配置文件：<code>render_drafts: true</code></li>
<li>或者本地预览的命令加参数：<code>hexo server --drafts</code></li>
</ol>
</blockquote>
<h4 id="将草稿发布成文章"><a href="#将草稿发布成文章" class="headerlink" title="将草稿发布成文章"></a>将草稿发布成文章</h4><p><code>hexo publish &quot;&lt;title&gt;&quot;</code>   ===       <code>hexo p &quot;&lt;title&gt;&quot;</code> </p>
<h4 id="生成静态网页"><a href="#生成静态网页" class="headerlink" title="生成静态网页"></a>生成静态网页</h4><p> <code>hexo generate</code> ===   <code>hexo g</code>  </p>
<h4 id="清除页面缓存"><a href="#清除页面缓存" class="headerlink" title="清除页面缓存"></a>清除页面缓存</h4><p><code>hexo clean</code></p>
<h4 id="本地启动hexo服务预览，修改内容会更新页面"><a href="#本地启动hexo服务预览，修改内容会更新页面" class="headerlink" title="本地启动hexo服务预览，修改内容会更新页面"></a>本地启动hexo服务预览，修改内容会更新页面</h4><p><code>hexo server</code>  ===  <code>hexo s</code></p>
<blockquote>
<ol>
<li><code>hexo server -s</code> #静态模式</li>
<li><code>hexo server -p 5000</code> #更改端口</li>
<li><code>hexo server -i 192.168.1.1</code> #自定义 IP </li>
</ol>
</blockquote>
<h4 id="部署到线上"><a href="#部署到线上" class="headerlink" title="部署到线上"></a>部署到线上</h4><p><code>hexo deploy</code> ===  <code>hexo d</code></p>
<h4 id="组合命令，可以配置在package-json上"><a href="#组合命令，可以配置在package-json上" class="headerlink" title="组合命令，可以配置在package.json上"></a>组合命令，可以配置在package.json上</h4><blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;localStart&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s &quot;,</span><br><span class="line">   &quot;blogDeployee&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue Mixin</title>
    <url>/2020/08/25/Vue%20Mixin/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/c054835f86bb">参考连接</a></p>
<h2 id="局部-mixin"><a href="#局部-mixin" class="headerlink" title="局部 mixin"></a>局部 mixin</h2><p>当多个组件都需要用到相同得到方法或者data有相同的属性，就可以使用mixin进行封装</p>
<p>需要封装的方法和属性 –&gt; <code>mixin.js</code> （名字根据业务定义）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	name: <span class="string">&#x27;Mixin&#x27;</span>,</span><br><span class="line">	 <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	   <span class="keyword">return</span> &#123;</span><br><span class="line">         message: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">	 &#125;,</span><br><span class="line">     <span class="comment">//可以添加钩子函数</span></span><br><span class="line">     <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;我是 mixins 中的 created&#x27;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">	 methods: &#123;</span><br><span class="line">	    <span class="function"><span class="title">show</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(num)  <span class="comment">// mixins的函数可以接收组件传的参数。</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">conflicting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&#x27;from mixin&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要使用mixin.js里面的方法和属性的vue文件 –&gt; <code>test.vue</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import mixin from &#39;..&#x2F;mixins&#x2F;mixin&#39;</span><br><span class="line">    </span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Test&#39;,</span><br><span class="line">  mixins: [mixin], &#x2F;&#x2F; 这里引入mixin.js</span><br><span class="line">  data() &#123;</span><br><span class="line">	return &#123;</span><br><span class="line"> 	  title: &#39;def&#39;,</span><br><span class="line">      message: &#39;goodbye&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">   created() &#123;</span><br><span class="line">      console.log(&#39;我是Vue中的created&#39;)</span><br><span class="line">      console.log(this.$data)</span><br><span class="line">      this.show(50); &#x2F;&#x2F;可通过函数传参,把组件中需要的参数传给mixins进行使用。</span><br><span class="line">   &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">	   bar() &#123;</span><br><span class="line">          console.log(&#39;bar&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        conflicting() &#123;</span><br><span class="line">          console.log(&#39;from self&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>组件 –&gt; test.vue</p>
<p>混入对象 –&gt; mixin.js</p>
</blockquote>
<ol>
<li><p>当组件和混入对象含有同名选项（属性/方法）时，这些选项将以恰当的方式混合。</p>
<blockquote>
<p>比如，数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。</p>
<p>上述例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">   <span class="keyword">return</span>: &#123;</span><br><span class="line">      title: <span class="string">&#x27;def&#x27;</span>, <span class="comment">// mixin.js属性装进组件里面</span></span><br><span class="line">      message: <span class="string">&#x27;goodbye&#x27;</span> <span class="comment">// 与mixin.js同名，组件优先</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params">num</span>)</span> &#123; <span class="comment">// mixin.js方法装进组件里面</span></span><br><span class="line">      <span class="built_in">console</span>.log(num)  </span><br><span class="line">   &#125;, </span><br><span class="line">   <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 与mixin.js同名，组件优先</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="function"><span class="title">conflicting</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 与mixin.js同名，组件优先</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;from self&#x27;</span>)</span><br><span class="line">   &#125;,   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>同名钩子函数将混合为一个数组，都会被调用。</p>
<blockquote>
<p>混入对象的钩子将在组件自身钩子之前调用。</p>
</blockquote>
</li>
<li><p>值为对象的选项，例如 <code>methods</code>, <code>components</code> 和 <code>directives</code>，将被混合为同一个对象。</p>
<blockquote>
<p>两个对象键名冲突时，取组件对象的键值对。</p>
</blockquote>
</li>
</ol>
<h2 id="全局-mixin"><a href="#全局-mixin" class="headerlink" title="全局 mixin"></a>全局 mixin</h2><blockquote>
<p>慎用:  一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Mixin</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装nvm管理node和npm</title>
    <url>/2019/08/24/windows%E5%AE%89%E8%A3%85nvm%E7%AE%A1%E7%90%86node%E5%92%8Cnpm/</url>
    <content><![CDATA[<h1 id="什么是nvm"><a href="#什么是nvm" class="headerlink" title="什么是nvm"></a>什么是nvm</h1><blockquote>
<p>nvm是nodeJS的版本管理器，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件。</p>
</blockquote>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://github.com/coreybutler/nvm-windows/releases">nvm-windows下载地址</a> </p>
<p>如图所示：</p>
<p><img src="http://image.leonote.cn/snipaste_20190824_152817.png" alt=""></p>
<ul>
<li>nvm-noinstall.zip： 免安装版本，但是使用之前需要配置环境变量</li>
<li>nvm-setup.zip：安装包，下载之后点击安装，无需配置就可以使用。</li>
<li>Source code(zip)：zip压缩的源码</li>
<li>Sourc code(tar.gz)：tar.gz的源码，一般用于Unix系统</li>
</ul>
<h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><p>检查是否安装成功，打开命令行窗口中输入nvm</p>
<ul>
<li>如果出现nvm版本号和一系列帮助指令，则说明nvm安装成功。</li>
<li>否则，可能会提示<code>nvm: command not found</code></li>
</ul>
<p><img src="http://image.leonote.cn/snipaste_20190824_135949.png" alt=""></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>nvm for windows是一个命令行工具，在控制台输入<code>nvm</code>,就可以看到它的命令用法。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul>
<li><code>nvm arch [32|64]</code> ： 显示node是运行在32位还是64位模式。参数可指定32或64来覆盖默认体系结构。</li>
<li><code>nvm install &lt;version&gt; [arch]</code>： 该可以是node.js版本或最新稳定版本<code>latest</code>。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为<code>all</code>以安装32和64位版本。在命令后面添加<code>--insecure</code> ，可以绕过远端下载服务器的SSL验证。</li>
<li><code>nvm list [available]</code>： 列出已经安装的node.js版本。可选的available，显示可下载版本的部分列表。这个命令可以简写为<code>nvm ls [available]</code>。</li>
<li><code>nvm on</code>： 启用node.js版本管理。</li>
<li><code>nvm off</code>： 禁用node.js版本管理(不卸载任何东西)</li>
<li><code>nvm proxy [url]</code>： 设置用于下载的代理。留<code>[url]</code>空白，以查看当前的代理。设置<code>[url]</code>为<code>none</code>删除代理。</li>
<li><code>nvm node_mirror [url]</code>：设置node镜像，默认为<code>https://nodejs.org/dist/.</code>。我建议设置为淘宝的镜像<em><a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a></em></li>
<li><code>nvm npm_mirror [url]</code>：设置npm镜像，默认为<code>https://github.com/npm/npm/archive/</code>。我建议设置为淘宝的镜像<em><a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></em></li>
<li><code>nvm uninstall &lt;version&gt;</code>： 卸载指定版本的nodejs。</li>
<li><code>nvm use [version] [arch]</code>： 切换到使用指定的nodejs版本。可以指定32/64位[arch]。<code>nvm use &lt;arch&gt;</code>将继续使用所选版本，但根据提供的值切换到32/64位模式的<code>&lt;arch&gt;</code></li>
<li><code>nvm root [path]</code>： 设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。</li>
<li><code>nvm version</code>： 显示当前运行的nvm版本，可以简写为<code>nvm v</code></li>
</ul>
<h2 id="安装某个版本的node"><a href="#安装某个版本的node" class="headerlink" title="安装某个版本的node"></a>安装某个版本的node</h2><p>这里我安装的是v12.9.0</p>
<p><code>nvm install 12.9.0</code></p>
<p><code>nvm use 12.9.0</code></p>
<p><img src="http://image.leonote.cn/snipaste_20190824_140027.png" alt=""></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>根据安装nvm时，选择的node的地址，复制到系统Path路径下</p>
<p><img src="http://image.leonote.cn/snipaste_20190824_155504.png" alt=""></p>
<p>方便可以在全局使用，以及在git bash中使用</p>
<blockquote>
<p>注意： 安装完后，git bash可能会提示</p>
<p><code>node: command not found</code> 或者 <code>npm: command not found</code> </p>
<p>重启一下就好了。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>nvm</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/2020/09/06/%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><blockquote>
<p>所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的工作单位。</p>
<p>事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
</blockquote>
<h2 id="事务的四个特性"><a href="#事务的四个特性" class="headerlink" title="事务的四个特性"></a>事务的四个特性</h2><h3 id="Atomic-原子性"><a href="#Atomic-原子性" class="headerlink" title="Atomic 原子性"></a>Atomic 原子性</h3><p>不同对象之间对于原子性定义不同：</p>
<ul>
<li><p>事务性数据库(ACID语境下)：<strong>原子性是指一组对数据库的改变，要么最终成功执行完成，要不就全部回滚。</strong>这就要求数据库系统要实现某种==回滚的机制==，比如redo/undo log。    </p>
</li>
<li><p>对于支持并发的编程语言(Java、C++等)：原子性是指<strong><em>一组指令被执行时，不受其他指令的干扰</em></strong>。比如”给一个整型变量赋值是原子的“等等。</p>
</li>
<li><p>一些<code>NoSQL</code>的数据库(<code>Redis</code>)： 事务的原子性的意思更接近于<strong><em>“一组指令被执行时，不受其他指令的干扰”</em></strong>，而不是“可以回滚”。</p>
</li>
</ul>
<h3 id="Consistency-一致性"><a href="#Consistency-一致性" class="headerlink" title="Consistency 一致性"></a>Consistency 一致性</h3><p>不同的环境下有着不同的含义：</p>
<ol>
<li>多副本的一致性</li>
<li>一致性hash</li>
<li>CAP理论的一致性</li>
<li>ACID里的一致性</li>
</ol>
<h4 id="ACID语境下的一致性"><a href="#ACID语境下的一致性" class="headerlink" title="ACID语境下的一致性"></a>ACID语境下的一致性</h4><p>AID 都是数据库的特征，也就是依赖数据库的具体实现。但是唯独C不一样，<strong>它需要依赖于应用层，也就是依赖于开发者的具体实现。</strong> <strong>这里的一致性是指系统从一个正确的状态，迁移到另一个正确的状态。</strong></p>
<p><strong>正确的状态：就是当前的状态满足预定的约束（业务上的要求）就叫做正确的状态。</strong></p>
<blockquote>
<p>业务的数据一致性一般用<strong>正确的业务代码</strong> + <strong>定时任务</strong> + <strong>数据库自身的简单合法性防护（事务的AID、锁等）</strong>一起实现。</p>
</blockquote>
<h3 id="Isolation-隔离性"><a href="#Isolation-隔离性" class="headerlink" title="Isolation 隔离性"></a>Isolation 隔离性</h3><p>一组对数据库的并发修改互相不影响。</p>
<ol>
<li>并发修改的是互不相干的数据，本身就满足隔离的条件</li>
<li>并发修改的是相关联的，或者就是同一份数据，就必然会相互影响。</li>
</ol>
<p>保证隔离性的主要问题不在于隔离本身：而在于<strong>如果将读取作为对数据修改的前提条件，之后在对数据进行修改的一刹那，读取时的前提条件还是否满足</strong>。毕竟读取和写入是两个分开的指令，而在这两个指令中间可能夹杂其他事务对数据的修改。（如：找到可用的库存，有则扣减，没有则提示缺货）</p>
<p>保持隔离性做法：保证对关联数据的修改串行化(<code>SERIALIZABLE</code>) ，如：加锁，但是锁对数据库并发的性能负面影响很大，所以出现了几种弱一些的隔离性保证</p>
<ol>
<li><code>READ UNCOMMITTED</code></li>
<li><code>READ COMMITTED</code></li>
<li><code>REPEATABLE READ</code></li>
</ol>
<h3 id="Durability-持久性"><a href="#Durability-持久性" class="headerlink" title="Durability 持久性"></a>Durability 持久性</h3><p>是指对数据的修改，一旦完成，该结果就应当永远不丢失。</p>
<p>在现实当中，</p>
<ul>
<li>一般通过持久性存储设备（比如磁盘/SSD）写入并刷新来保证数据的持久性。</li>
<li>如果觉得一个节点不靠谱，可以增加多个副本（replica）一起来保证持久；</li>
<li>如果觉得这样还不够靠谱，可以在不同的地理位置的另一个数据中心做备份。</li>
</ul>
<p>实际上<strong><em>绝对的持久性是不存在的</em></strong>，因为整个存储层面有很多不确定因素，比如文件系统本身<code>fsync指令</code>实现有bug，磁盘的固件有bug，供电出现问题造成数据错乱，异步的数据复制没有生效等等。</p>
<p>所以在现实当中的数据库，只能在当前成本和技术限制的约束下，尽量维持一定程度的持久性。</p>
<blockquote>
<p>总结：事务性数据库实现的是</p>
<ul>
<li>支持未完成的数据修改回滚的机制，对应“原子性”</li>
<li>力所能及的数据合法性检查，对应“一致性”</li>
<li>保证数据并发的修改的规则，对应“隔离性”</li>
<li>使用基于持久化存储（磁盘、SSD）的方式对数据进行存储，对应“持久性”</li>
</ul>
</blockquote>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul>
<li><code>Read uncommitted</code>：即使一个事务的更新语句没有提交，但是别的事务可以读到这个改变，鸡肋一般的存在。</li>
<li><code>Read committed</code>：一个事务能看到另外一个事务对一条数据记录已经提交的修改。</li>
<li><code>Repeatable read</code>：一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的。</li>
<li><code>Serializable</code>：事务串行执行，不允许并发执行。</li>
</ul>
<h3 id="Repeatable-read-示例"><a href="#Repeatable-read-示例" class="headerlink" title="Repeatable read 示例"></a>Repeatable read 示例</h3><p>Repeatable Read 的直观感觉仿佛是给事务做一个整个数据库做了一个快照， 所以很多时候这种隔离级别又被称为<strong>Snapshot Isolation</strong>。</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>get x (得到0)</td>
<td></td>
</tr>
<tr>
<td></td>
<td>set x = 1</td>
</tr>
<tr>
<td></td>
<td>commit</td>
</tr>
<tr>
<td>get x (得到0)</td>
<td></td>
</tr>
<tr>
<td>commit</td>
<td></td>
</tr>
</tbody></table>
<p>“快照”的功能在一些场景下非常重要，如：</p>
<ul>
<li><p><strong>数据备份</strong>：例如数据库S从数据库M中复制数据，但是同时M数据库又被持续修改。S需要拿到一个M的数据快照，但是又不能真的把M给停了。</p>
</li>
<li><p><strong>数据合法性检查</strong>：例如有两张数据表，一张记录了当时的交易总额，另外一张表记录了每个交易的金额。</p>
</li>
</ul>
<p>==那么在读取数据时，如果没有快照的存在，交易金额的总和可能与当时的交易总额对不上，==</p>
<p>==因为随着检查事务的进行，新的交易记录数据会被提交。这些新的提交会被检查事务看到。==</p>
<blockquote>
<p>注意：</p>
<p>如果是基于<code>MVCC</code>的实现，<code>Repeatable Read</code>可以完全避免幻读。</p>
<p>无论<code>MySQL</code>还是<code>PostgreSQL</code>在<code>Repeatable Read</code>隔离级别都不会出现幻读。</p>
</blockquote>
<h3 id="数据库并发操作产生的问题"><a href="#数据库并发操作产生的问题" class="headerlink" title="数据库并发操作产生的问题"></a>数据库并发操作产生的问题</h3><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><h5 id="第一类丢失更新问题"><a href="#第一类丢失更新问题" class="headerlink" title="第一类丢失更新问题"></a>第一类丢失更新问题</h5><p>此种更新丢失是因为回滚的原因，所以也叫==回滚丢失==。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>取款事务A</th>
<th>转账事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>汇入100元把余额改为1100元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>取出100元把余额改为900元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>撤销事务，余额恢复为1000 元（丢失更新）</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意： A事务在撤销时，将B事务已经转入账户的金额给抹去了，此时余额为1000元。</p>
</blockquote>
<h5 id="第二类丢失更新问题"><a href="#第二类丢失更新问题" class="headerlink" title="第二类丢失更新问题"></a>第二类丢失更新问题</h5><p>此种更新丢失是因为更新被其他事务给覆盖了，也可以叫==覆盖丢失==。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>转账事务A</th>
<th>取款事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>查询账户余额为1000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为1000元</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>取出100元把余额改为900元</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T7</td>
<td>汇入100元</td>
<td></td>
</tr>
<tr>
<td>T8</td>
<td>提交事务，把余额改为1100 元（丢失更新）</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>注意：A事务把B事务的金额修改了，此时余额为1100元。</p>
</blockquote>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>员工事务A</th>
<th>老板事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>给员工账户转账5000元</td>
</tr>
<tr>
<td>T4</td>
<td>查询账户余额为5000元(脏读)</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>撤销事务</td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T8</td>
<td></td>
<td>给员工账户转账2000元</td>
</tr>
<tr>
<td>T9</td>
<td></td>
<td>提交事务</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>解释</strong></p>
<p>​    公司发工资了，领导把5000元打到员工的账号上，但是该事务并未提交，而员工正好去查看账户，发现5000元工资到账。但是不幸的是，领导发现发给员工的发的工资金额不对，是2000元，于是回滚了事务，修改为2000后，将事务提交，最后员工实际的工资是只有 2000元。</p>
</blockquote>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>是指在A事务内，多次读同一数据，但是两次读到的数据内容不一样。（即不能读到相同的数据内容）</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>员工事务A</th>
<th>员工老婆事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>准备付款，查询账户余额为2000元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>网上转账2000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T6</td>
<td>付款，查询账户余额为0元，付款失败</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>解释</strong></p>
<p>员工拿着工资卡去消费，系统读取到卡里确实有2000元，而此时他老婆也正好在网上转账，把工资卡的2000元转到另一账户， 并在员工之前提交了事务，当员工进行扣款时，系统检查到员工的工资卡已经没有钱，扣款失败。</p>
</blockquote>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>是指当事务不是独立执行时发生的一种现象，A事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B事务也修改这个表中的数据，这种修改是向表中插入或删除一行数据。那么，操作A事务的用户会发现表中还有尚未被修改的数据行，就好像发生了幻觉一样。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>员工老婆事务A</th>
<th>员工事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>T3</td>
<td>查询信用卡的消费记录总额为80元</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>客户应酬，信用卡付款1000元</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T6</td>
<td>打印信用卡账单，总额为1080元（幻读）</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>解释</strong>    </p>
<p>员工老婆时常查看员工的信用卡消费记录。有一天，她正在查询到员工当月信用卡的总消费金额 </p>
<p>（<code>select sum(amount) from transaction where month = 本月</code>）为80元，而员工此时正好应酬完后在收银台买单，消费了1000元，即新增了一条1000元的消费记录（<code>insert transaction ...</code> ），并提交事务，随后员工老婆打印当月信用卡章法，却发现消费总额为1080元，员工老婆很诧异，以为出现了幻觉，幻读就这样产生了。</p>
</blockquote>
<p><strong>幻读和不可重复读强调的维度不一样:</strong></p>
<ol>
<li><strong>不可重复读是指A操作数据时，B可以修改该行数据。</strong></li>
<li><strong>幻读是指A操作数据时，B可以新增/删除一条数据（是对总记录数有影响的）。</strong></li>
</ol>
<h3 id="隔离级别对异常的控制能力"><a href="#隔离级别对异常的控制能力" class="headerlink" title="隔离级别对异常的控制能力"></a>隔离级别对异常的控制能力</h3><table>
<thead>
<tr>
<th><strong>隔离级别\并发问题</strong></th>
<th><strong>第一类更新丢失</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>第二类丢失更新</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>Read uncommitted</code></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td><code>Read committed</code></td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y（<code>MVVC</code>-&gt; N）</td>
</tr>
<tr>
<td><code>Repeatable read</code></td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y（<code>MVVC</code>-&gt; N）</td>
</tr>
<tr>
<td><code>Serializable</code></td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h1 id="写前提困境"><a href="#写前提困境" class="headerlink" title="写前提困境"></a>写前提困境</h1><p>业务代码一般是这样的：</p>
<ol>
<li>先读取一段现有的数据；</li>
<li>在这个数据的基础上做逻辑判断或者计算；</li>
<li>将计算的结果写回数据库；</li>
</ol>
<p>第三步的写入会<strong>依赖</strong>第一步的读取。而且在1和3之间，不管业务代码离得有多近，都无法避免其他事务的并发修改。即：在当前事务读取这段数据后，又有另一个事务修改了这个数据，而当前事务将结果写回数据库，会造成另一个事务的修改丢失。</p>
<blockquote>
<p>这个问题就是<strong>在修改的事务在提交时，无法确保这个修改的前提是否还可靠</strong>。这种问题称之为<strong>写前提困境</strong>。</p>
</blockquote>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul>
<li>事务隔离级别用<code>Serializable</code>；</li>
<li>加悲观锁；写入较多的情况</li>
<li>加乐观锁；读取较多的情况</li>
</ul>
]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装常用软件</title>
    <url>/2019/12/07/docker%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="docker-安装常用软件"><a href="#docker-安装常用软件" class="headerlink" title="docker 安装常用软件"></a>docker 安装常用软件</h1><blockquote>
<p>如果配置开机启动：后面加 <code>--restart=always</code></p>
</blockquote>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><ol>
<li>下载: <code>docker pull nginx</code></li>
<li>运行: <code>docker run --name nginx -p 80:80 -d docker.io/nginx</code> </li>
</ol>
<h3 id="配置-nginx-conf"><a href="#配置-nginx-conf" class="headerlink" title="配置 nginx.conf"></a>配置 nginx.conf</h3><ol>
<li><p>进入 nginx 容器: <code>docker exec -it nginx /bin/bash</code></p>
</li>
<li><p>进入 /etc/nginx 目录: <code>cd /etc/nginx</code></p>
</li>
<li><p>vi或者vim编辑: <code>vim nginx.conf</code></p>
</li>
<li><blockquote>
<p>PS：因为nginx里面没有自带vim或者vi，所以需要自行安装</p>
<p>在/etc/nginx目录下：</p>
<p><code>apt-get update</code>  更新</p>
<p><code>apt-get install vim</code>  下载 vim</p>
</blockquote>
</li>
</ol>
<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><ol>
<li>下载: <code>docker pull redis:latest</code></li>
<li>运行: <code>docker run -itd --name redis -p 6379:6379 redis</code> + <code>--requirepass &quot;******&quot;</code> (运行时就设置密码)</li>
<li>进入redis容器里面(可选): <code>docker exec -it redis /bin/bash</code></li>
<li>连接redis(可选): <code>redis-cli</code></li>
<li>查看是否有设置密码(可选):  <code>config get requirepass</code></li>
<li>设置密码(可选): <code>config set requirepass ****</code></li>
</ol>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><ol>
<li>下载: <code>docker pull mysql:latest</code></li>
<li>运行: <code>docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></li>
</ol>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><h3 id="单机版-1"><a href="#单机版-1" class="headerlink" title="单机版"></a>单机版</h3><ol>
<li>下载: <code>docker pull zookeeper:latest</code></li>
<li>运行: <code>docker run -d --name zookeeper -p 2181:2181 zookeeper</code></li>
<li>进入zookeeper容器里面(可选): <code>docker exec -it zookeeper /bin/bash</code></li>
</ol>
<h2 id="kafuka"><a href="#kafuka" class="headerlink" title="kafuka"></a>kafuka</h2><h3 id="单机版-2"><a href="#单机版-2" class="headerlink" title="单机版"></a>单机版</h3><ol>
<li><p>下载: <code>docker pull wurstmeister/kafka</code></p>
</li>
<li><p>运行:  </p>
<ul>
<li><p>先运行zookeeper <code>docker run -d --name zookeeper -p 2181:2181 zookeeper</code></p>
</li>
<li><p>再启动kafuka</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=192.168.1.100:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.1.100:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释：</p>
<p>上面的命令，主要设置四个参数</p>
<p>KAFKA_BROKER_ID=0<br>KAFKA_ZOOKEEPER_CONNECT=192.168.1.100:2181<br>KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.1.100:9092<br>KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092<br>中间两个参数的192.168.1.100改为宿主机器的IP地址，如果不这么设置，可能会导致在别的机器上访问不到kafka。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>测试kafuka: </p>
<ul>
<li>进入容器: <code>docker exec -it kafka /bin/bash</code></li>
<li>进入kafka所在目录: <code>cd opt/kafka_2.11-2.5.0/</code></li>
<li>启动消息发送方: <code>./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka</code></li>
<li>克隆会话 进入kafka所在目录: <code>cd opt/kafka_2.11-2.5.0/</code></li>
<li>启动消息接收方: <code>./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic mykafka --from-beginning</code></li>
</ul>
</li>
</ol>
<h2 id="mongo"><a href="#mongo" class="headerlink" title="mongo"></a>mongo</h2><ol>
<li><p>下载并运行: <code>docker run -itd --name mongo -v /data/mongo/data:/data/db -p 27017:27017 mongo --auth</code></p>
<blockquote>
<p><strong>注意</strong>：默认数据是存在容器系统的<code>/data/db</code>目录下的 –auth是开启认证</p>
</blockquote>
</li>
<li><p>设置密码</p>
<ul>
<li>进入容器: <code>docker exec -it mongo bash</code></li>
<li>连接到mongo: <code>mongo</code></li>
<li>查看当前版本: <code>db.version()</code></li>
<li>切换到admin库: <code>use admin</code></li>
<li>创建管理员权限用户: <code>db.createUser(&#123; user:&#39;admin&#39;,pwd:&#39;123456&#39;,roles:[ &#123; role:&#39;userAdminAnyDatabase&#39;, db: &#39;admin&#39;&#125;]&#125;);</code></li>
<li>认证: <code>db.auth(&#39;admin&#39;,&#39;123456&#39;);</code></li>
<li>创建普通读写 并指定库用户: <code>db.createUser(&#123; user:&#39;user&#39;,pwd:&#39;123456&#39;,roles:[ &#123; role:&#39;readWrite&#39;, db: &#39;testdb&#39;&#125;]&#125;);</code></li>
<li>必须要在admin库认证: <code>db.auth(&#39;user&#39;,&#39;123456&#39;)</code></li>
<li>切换到testdb库: <code>use testdb</code></li>
<li>插入一条数据到person集合中: <code>db.person.insert(&#123;name:&#39;libai-go&#39;,age:18&#125;)</code></li>
<li>查找person集合所有数据: <code>db.person.find(&#123;&#125;)</code></li>
</ul>
</li>
</ol>
<h2 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h2><ol>
<li><p>创建一个网络，同一个网络的内的容器，可以通过localhost:port 通信，方便kibana访问es:</p>
<p><code>docker network create somenetwork</code></p>
</li>
<li><p>下载并运行: <code>docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch</code></p>
</li>
</ol>
<h2 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h2><ol>
<li>下载并运行: <code>docker run -d --name kibana --net somenetwork -p 5601:5601 kibana:7.6.2</code></li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式Collectors.toMap当value为null时报错</title>
    <url>/2019/08/26/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8FCollectors-toMap%E5%BD%93value%E4%B8%BAnull%E6%97%B6%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><blockquote>
<p>Map.merge方法合并时，merge不允许value为null导致的</p>
</blockquote>
<h2 id="源码如下"><a href="#源码如下" class="headerlink" title="源码如下"></a>源码如下</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(K key, V value, </span></span></span><br><span class="line"><span class="function"><span class="params">                BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value : remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="解决的办法"><a href="#解决的办法" class="headerlink" title="解决的办法"></a>解决的办法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fundsSerials.stream()</span><br><span class="line">    .collect(</span><br><span class="line">        Collectors.toMap(</span><br><span class="line">            FundsSerial::getSerialNo,</span><br><span class="line">            fundsSerial -&gt; Optional.of(fundsSerial).map(FundsSerial::getOrderNo).orElse(<span class="string">&quot;&quot;</span>),</span><br><span class="line">            (k1, k2) -&gt; k2));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>使用：<code>Optional.of(fundsSerial)</code> 或者 <code>Optional.ofNullable(fundsSerial)</code> 转成 <code>optional</code> 对象，</p>
<p>然后使用<code>orElse()</code>，换成默认值。</p>
</blockquote>
]]></content>
      <categories>
        <category>JDK</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-分布式Redis实战</title>
    <url>/2021/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8FRedis%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="分布式Redis实战"><a href="#分布式Redis实战" class="headerlink" title="分布式Redis实战"></a>分布式Redis实战</h1><h2 id="Redis-复制原理"><a href="#Redis-复制原理" class="headerlink" title="Redis 复制原理"></a>Redis 复制原理</h2><p>为了避免单点故障，数据存储需要进行多副本构建。同时由于 Redis 的核心操作是单线程模型的，单个 Redis 实例能处理的请求 TPS 有限。因此 Redis 自面世起，基本就提供了复制功能，而且对复制策略不断进行优化。</p>
<p><img src="http://image.leonote.cn/20210714221629.png" alt=""></p>
<p>通过数据复制，Redis 的一个 master 可以挂载多个 slave，而 slave 下还可以挂载多个 slave，形成多层嵌套结构。所有写操作都在 master 实例中进行，master 执行完毕后，将写指令分发给挂在自己下面的 slave 节点。slave 节点下如果有嵌套的 slave，会将收到的写指令进一步分发给挂在自己下面的 slave。通过多个 slave，Redis 的节点数据就可以实现多副本保存，任何一个节点异常都不会导致数据丢失，同时多 slave 可以 N 倍提升读性能。master 只写不读，这样整个 master-slave 组合，读写能力都可以得到大幅提升。</p>
<p>master 在分发写请求时，同时会将写指令复制一份存入复制积压缓冲，这样当 slave 短时间断开重连时，只要 slave 的复制位置点仍然在复制积压缓冲，则可以从之前的复制位置点之后继续进行复制，提升复制效率。</p>
<p><img src="http://image.leonote.cn/20210714221643.png" alt=""></p>
<p>主库 master 和从库 slave 之间通过复制 id 进行匹配，避免 slave 挂到错误的 master。Redis 的复制分为全量同步和增量同步。Redis 在进行全量同步时，master 会将内存数据通过 bgsave 落地到 rdb，同时，将构建 内存快照期间 的写指令，存放到复制缓冲中，当 rdb 快照构建完毕后，master 将 rdb 和复制缓冲队列中的数据全部发送给 slave，slave 完全重新创建一份数据。这个过程，对 master 的性能损耗较大，slave 构建数据的时间也比较长，而且传递 rdb 时还会占用大量带宽，对整个系统的性能和资源的访问影响都比较大。而增量复制，master 只发送 slave 上次复制位置之后的写指令，不用构建 rdb，而且传输内容非常有限，对 master、slave 的负荷影响很小，对带宽的影响可以忽略，整个系统受影响非常小。</p>
<p>在 Redis 2.8 之前，Redis 基本只支持全量复制。在 slave 与 master 断开连接，或 slave 重启后，都需要进行全量复制。在 2.8 版本之后，Redis 引入 psync，增加了一个复制积压缓冲，在将写指令同步给 slave 时，会同时在复制积压缓冲中也写一份。在 slave 短时断开重连后，上报master runid 及复制偏移量。如果 runid 与 master 一致，且偏移量仍然在 master 的复制缓冲积压中，则 master 进行增量同步。</p>
<p>但如果 slave 重启后，master runid 会丢失，或者切换 master 后，runid 会变化，仍然需要全量同步。因此 Redis 自 4.0 强化了 psync，引入了 psync2。在 pysnc2 中，主从复制不再使用 runid，而使用 replid（即复制id） 来作为复制判断依据。同时 Redis 实例在构建 rdb 时，会将 replid 作为 aux 辅助信息存入 rbd。重启时，加载 rdb 时即可得到 master 的复制 id。从而在 slave 重启后仍然可以增量同步。</p>
<p>在 psync2 中，Redis 每个实例除了会有一个复制 id 即 replid 外，还有一个 replid2。Redis 启动后，会创建一个长度为 40 的随机字符串，作为 replid 的初值，在建立主从连接后，会用 master的 replid 替换自己的 replid。同时会用 replid2 存储上次 master 主库的 replid。这样切主时，即便 slave 汇报的复制 id 与新 master 的 replid 不同，但和新 master 的 replid2 相同，同时复制偏移仍然在复制积压缓冲区内，仍然可以实现增量复制。</p>
<h2 id="Redis-复制分析"><a href="#Redis-复制分析" class="headerlink" title="Redis 复制分析"></a>Redis 复制分析</h2><p>在设置 master、slave 时，首先通过配置或者命令 slaveof no one 将节点设置为主库。然后其他各个从库节点，通过 slaveof $master_ip $master_port，将其他从库挂在到 master 上。同样方法，还可以将 slave 节点挂载到已有的 slave 节点上。在准备开始数据复制时，slave 首先会主动与 master 创建连接，并上报信息。具体流程如下。</p>
<p><img src="http://image.leonote.cn/20210714221659.png" alt=""><br>slave 创建与 master 的连接后，首先发送 ping 指令，如果 master 没有返回异常，而是返回 pong，则说明 master 可用。如果 Redis 设置了密码，slave 会发送 auth $masterauth 指令，进行鉴权。当鉴权完毕，从库就通过 replconf 发送自己的端口及 IP 给 master。接下来，slave 继续通过 replconf 发送 capa eof capa psync2 进行复制版本校验。如果 master 校验成功。从库接下来就通过 psync 将自己的复制 id、复制偏移发送给 master，正式开始准备数据同步。</p>
<p>主库接收到从库发来的 psync 指令后，则开始判断可以进行数据同步的方式。前面讲到，Redis 当前保存了复制 id，replid 和 replid2。如果从库发来的复制 id，与 master 的复制 id（即 replid 和 replid2）相同，并且复制偏移在复制缓冲积压中，则可以进行增量同步。master 发送 continue 响应，并返回 master 的 replid。slave 将 master 的 replid 替换为自己的 replid，并将之前的复制 id 设置为 replid2。之后，master 则可继续发送，复制偏移位置 之后的指令，给 slave，完成数据同步。</p>
<p>如果主库发现从库传来的复制 id 和自己的 replid、replid2 都不同，或者复制偏移不在复制积压缓冲中，则判定需要进行全量复制。master 发送 fullresync 响应，附带 replid 及复制偏移。然后， master 根据需要构建 rdb，并将 rdb 及复制缓冲发送给 slave。</p>
<p>对于增量复制，slave 接下来就等待接受 master 传来的复制缓冲及新增的写指令，进行数据同步。</p>
<p>而对于全量同步，slave 会首先进行，嵌套复制的清理工作，比如 slave 当前还有嵌套的子slave，则该 slave 会关闭嵌套子slave 的所有连接，并清理自己的复制积压缓冲。然后，slave 会构建临时 rdb 文件，并从 master 连接中读取 rdb 的实际数据，写入 rdb 中。在写 rdb 文件时，每写 8M，就会做一个 fsync操作， 刷新文件缓冲。当接受 rdb 完毕则将 rdb 临时文件改名为 rdb 的真正名字。</p>
<p>接下来，slave 会首先清空老数据，即删除本地所有 DB 中的数据，并暂时停止从 master 继续接受数据。然后，slave 就开始全力加载 rdb 恢复数据，将数据从 rdb 加载到内存。在 rdb 加载完毕后，slave 重新利用与 master 的连接 socket，创建与 master 连接的 client，并在此注册读事件，可以开始接受 master 的写指令了。此时，slave 还会将 master 的 replid 和复制偏移设为自己的复制 id 和复制偏移 offset，并将自己的 replid2 清空，因为，slave 的所有嵌套子slave 接下来也需要进行全量复制。最后，slave 就会打开 aof 文件，在接受 master 的写指令后，执行完毕并写入到自己的 aof 中。</p>
<p>相比之前的 sync，psync2 优化很明显。在短时间断开连接、slave 重启、切主等多种场景，只要延迟不太久，复制偏移仍然在复制积压缓冲，均可进行增量同步。master 不用构建并发送巨大的 rdb，可以大大减轻 master 的负荷和网络带宽的开销。同时，slave 可以通过轻量的增量复制，实现数据同步，快速恢复服务，减少系统抖动。</p>
<p>但是，psync 依然严重依赖于复制缓冲积压，太大会占用过多内存，太小会导致频繁的全量复制。而且，由于内存限制，即便设置相对较大的复制缓冲区，在 slave 断开连接较久时，仍然很容易被复制缓冲积压冲刷，从而导致全量复制。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>将jar包设置成windows的service</title>
    <url>/2019/08/25/%E5%B0%86jar%E5%8C%85%E6%B3%A8%E5%86%8C%E6%88%90windows%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><blockquote>
<p>在开发过程中，有时会需要自定义一些服务启动，但是每次都要手动在命令行窗口中运行命令，而且会有一个窗口在任务栏里，太麻烦了。</p>
<p>例如，我需要部署一个<code>Jrebel</code>的注册器，idea才可以激活<code>Jrebel</code>成功，所以想注册成一个服务，开机后自动启动服务，不需要再操作任何东西。</p>
</blockquote>
<h1 id="准备Jar包"><a href="#准备Jar包" class="headerlink" title="准备Jar包"></a>准备Jar包</h1><p>自行准备需要注册成服务的jar包。如果是<code>Java</code>程序的话，maven打包成jar即可。</p>
<p>这里我需要一个<code>Jrebel</code>的注册器的Jar包。</p>
<p><a href="https://gitee.com/gsls200808/JrebelLicenseServerforJava">JrebelLicenseService下载地址</a></p>
<h1 id="下载winsw"><a href="#下载winsw" class="headerlink" title="下载winsw"></a>下载winsw</h1><p>winsw是一款可将可执行程序安装成Windows Service的开源工具。<a href="https://github.com/kohsuke/winsw/releases">winsw下载地址</a></p>
<p>只需要下载可执行文件(<code>.exe</code>)和配置文件(<code>.xml</code>)，配置文件是为了参考需要配置什么，到时直接在上面改即可。</p>
<ul>
<li><code>sample-minimal.xml</code>:  最小配置</li>
<li><code>sample-allOptions.xml</code>： 可选择的配置</li>
</ul>
<p><img src="http://image.leonote.cn/Snipaste_2019-11-28_16-54-33.png" alt=""></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="配置服务所需要的文件"><a href="#配置服务所需要的文件" class="headerlink" title="配置服务所需要的文件"></a>配置服务所需要的文件</h2><ol>
<li>首先创建一个文件夹<code>Jrebel</code>。</li>
<li>将下载好的<code>JrebelBrainsLicenseServerforJava-1.0-SNAPSHOT-jar-with-dependencies.jar</code>改名为<code>Jrebel.jar</code>，并复制进去。</li>
<li>将下载好的<code>WinSW.NET4.exe</code>改名为<code>Jrebel.exe</code>，并复制进去。</li>
<li>因为我不需要特别复杂的配置，所以使用<code>sample-minimal.xml</code>即可，改名为<code>Jrebel.xml</code>，并复制进去。</li>
</ol>
<p>如图所示：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-11-28_16-56-25.png" alt=""></p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改<code>Jrebel.xml</code>的内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 服务ID: 启动、关闭、删除服务时，都是通过ID来操作的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>JrebelService<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 服务名称, 用于显示 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>JrebelService<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 服务描述 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>This service is Jrebel License Service<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 若配置了java环境变量，直接写成“java”就行; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以写成这样来指定使用的jdk版本: C:\Program Files\Java\jdk8\jre\bin\java --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executable</span>&gt;</span>java<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 启动参数 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar包不在同一个文件夹下可以使用这种写法: G:\Jrebel\Jrebel.jar--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arguments</span>&gt;</span>-jar Jrebel.jar -p 8081<span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 设置开机启动 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">startmode</span>&gt;</span>Automatic<span class="tag">&lt;/<span class="name">startmode</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 日志配置 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- logpath指定在哪个文件下记录log，这里是在同级目录下创建logs文件夹存放log --&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">logpath</span>&gt;</span>logs<span class="tag">&lt;/<span class="name">logpath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">logmode</span>&gt;</span>rotate<span class="tag">&lt;/<span class="name">logmode</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注册服务"><a href="#注册服务" class="headerlink" title="注册服务"></a>注册服务</h2><ol>
<li>已管理员身份打开命令行。</li>
<li>进入到(<code>.exe</code>)目录下，即D:\Jrebel。如果将该路径配置在Path路径下，则这步省略。</li>
<li>输入 <code>Jrebel install</code> 即可注册服务。</li>
<li>服务注册成功后，使用<code>net start JrebelService</code>运行该服务。</li>
</ol>
<p>这样就完成了。</p>
<h1 id="可能碰到的问题"><a href="#可能碰到的问题" class="headerlink" title="可能碰到的问题"></a>可能碰到的问题</h1><h2 id="“无法将XXXX项识别为-cmdlet、函数、脚本文件或可运行程序的名称”的问题"><a href="#“无法将XXXX项识别为-cmdlet、函数、脚本文件或可运行程序的名称”的问题" class="headerlink" title="“无法将XXXX项识别为 cmdlet、函数、脚本文件或可运行程序的名称”的问题"></a>“无法将XXXX项识别为 cmdlet、函数、脚本文件或可运行程序的名称”的问题</h2><blockquote>
<p>在这次服务中出现的话，应该是报：<strong><em>“无法将Jrebel.exe项识别为 cmdlet、函数、脚本文件或可运行程序的名称”的问题</em></strong></p>
<p>解决方法：</p>
<p>第一种方式：需要在有<code>Jrebel.exe</code>的目录下执行该命令。</p>
<p>第二种方式：将<code>Jrebel.exe</code>所在目录配置在Path路径下。</p>
</blockquote>
<h2 id="FATAL-WMI-Operation-failure-AccessDenied"><a href="#FATAL-WMI-Operation-failure-AccessDenied" class="headerlink" title="FATAL - WMI Operation failure: AccessDenied"></a>FATAL - WMI Operation failure: AccessDenied</h2><blockquote>
<p>这个是因为没有使用管理员身份运行<code>Jrebel</code>命令，用管理员身份打开命令行即可。</p>
</blockquote>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>虽然是成功配置好了服务，但是关闭服务，注销服务，都需要重新在命令行中执行命令，也是很麻烦的。所以可以编写bat文件来执行这些操作。</p>
<p>这里主要是四个命令：</p>
<ul>
<li><code>Jrebel install</code></li>
<li><code>net start JrebelService</code></li>
<li><code>net stop JrebelService</code></li>
<li><code>Jrebel uninstall</code></li>
</ul>
<p>所以需要创建四个bat文件，分别是</p>
<ul>
<li><code>Jrebel_install.bat</code>   对应命令   <code>Jrebel install</code></li>
<li><code>Jrebel_start.bat</code>   对应命令   <code>net start JrebelService</code></li>
<li><code>Jrebel_stop.bat</code>   对应命令   <code>net stop JrebelService</code></li>
<li><code>Jrebel_uninstall.bat</code>   对应命令   <code>net stop JrebelService</code> 和 <code>Jrebel uninstall</code></li>
</ul>
<p>但是这样还不行，因为这些服务命令需要使用管理员身份运行才有效。</p>
<p>所以需要在每个bat文件里面开头加上这段命令<strong>用于申请管理员权限</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">nul 2&gt;&amp;1 <span class="string">&quot;%SYSTEMROOT%\system32\cacls.exe&quot;</span> <span class="string">&quot;%SYSTEMROOT%\system32\config\system&quot;</span></span></span><br><span class="line">if &#x27;%errorlevel%&#x27; NEQ &#x27;0&#x27; (</span><br><span class="line">goto UACPrompt</span><br><span class="line">) else ( goto gotAdmin )</span><br><span class="line">:UACPrompt</span><br><span class="line">echo Set UAC = CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">echo UAC.ShellExecute &quot;%~s0&quot;, &quot;&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">&quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">exit /B</span><br><span class="line">:gotAdmin</span><br><span class="line">if exist &quot;%temp%\getadmin.vbs&quot; ( del &quot;%temp%\getadmin.vbs&quot; )</span><br><span class="line">pushd &quot;%CD%&quot;</span><br><span class="line">cd /D &quot;%~dp0&quot;</span><br></pre></td></tr></table></figure>

<p>其中一个示例：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-11-28_17-02-48.png" alt=""></p>
<blockquote>
<p>这样就可以双击执行bat文件，快速注册服务，启动服务，停止服务和注销服务。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发环境</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>jar</tag>
        <tag>Jrebel</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库索引</title>
    <url>/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><h3 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h3><ul>
<li>B-Tree 索引</li>
<li>hash 索引</li>
<li>Full-test 索引</li>
<li>R-Tree 索引</li>
</ul>
<h3 id="物理存储角度"><a href="#物理存储角度" class="headerlink" title="物理存储角度"></a>物理存储角度</h3><p>cluster</p>
<ul>
<li>聚簇索引（聚集索引）：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列<ul>
<li><code>CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH</code></li>
<li><code>ALLOW_DUP_ROW(允许有重复记录的聚簇索引)</code></li>
</ul>
</li>
<li>非聚簇索引（群集索引）：<code>CREATE UNCLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn)</code></li>
</ul>
<h3 id="逻辑角度"><a href="#逻辑角度" class="headerlink" title="逻辑角度"></a>逻辑角度</h3><ul>
<li>唯一索引 <code>CREATE UNIQUE INDEX myclumn_uindex ON mytable(mycolumn)</code></li>
<li>主键索引（主索引）primary key</li>
<li>(复)组合索引（多列索引）：<code>CREATE INDEX mycolumn_index ON mytable (mycolumn1, mycolumn2)</code></li>
<li>普通索引（单列索引）：<code>CREATE INDEX mycolumn_index ON mytable (mycolumn)</code></li>
<li>空间索引：</li>
</ul>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>创建唯一性索引，保证数据库表中每一行数据的唯一性</li>
<li><strong>大大加快数据的检索速度</strong> – 最主要的原因</li>
<li>加速表和表之间的连接</li>
<li>在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占用数据表以外的物理存储空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引需要被重建，降低了数据的维护速度</li>
</ol>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><ol>
<li>当字段的数据更新频率较低，查询使用频率较高并且存在大量重复值时，建议使用<strong>聚簇索引</strong></li>
<li>经常同时存取多列，且每列都含有重复值可考虑建立<strong>组合索引</strong></li>
<li>组合索引的前导列一定好控制好，否则无法起到索引的效果。如果查询时前导列不在查询条件中则该组合索引不会被使用，前导列一定是使用最频繁的列。</li>
</ol>
<h2 id="数据库优化-ORACLE"><a href="#数据库优化-ORACLE" class="headerlink" title="数据库优化(ORACLE)"></a>数据库优化(ORACLE)</h2><h3 id="SQL使用索引的例子"><a href="#SQL使用索引的例子" class="headerlink" title="SQL使用索引的例子"></a>SQL使用索引的例子</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INDEX_COLUMN <span class="operator">=</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">&gt;</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">&gt;=</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">&lt;</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">&lt;=</span> ?</span><br><span class="line">INDEX_COLUMN <span class="keyword">between</span> ? <span class="keyword">and</span> ?</span><br><span class="line">INDEX_COLUMN <span class="keyword">in</span> (?,?,...,?)</span><br><span class="line">INDEX_COLUMN <span class="keyword">like</span> ?<span class="operator">||</span><span class="string">&#x27;%&#x27;</span> <span class="comment">--（后导模糊查询）</span></span><br><span class="line">T1.INDEX_COLUMN<span class="operator">=</span>T2.COLUMN1 <span class="comment">--（两个表通过索引字段关联）</span></span><br></pre></td></tr></table></figure>

<h3 id="SQL不使用索引的例子"><a href="#SQL不使用索引的例子" class="headerlink" title="SQL不使用索引的例子"></a>SQL不使用索引的例子</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不等于操作不能使用索引</span></span><br><span class="line">INDEX_COLUMN <span class="operator">&lt;&gt;</span> ?</span><br><span class="line">INDEX_COLUMN <span class="keyword">not</span> <span class="keyword">in</span> (?,?,...,?)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 经过普通运算或函数运算后的索引字段不能使用索引</span></span><br><span class="line"><span class="keyword">function</span>(INDEX_COLUMN) <span class="operator">=</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> ?</span><br><span class="line">INDEX_COLUMN <span class="operator">||</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> ?</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 含前导模糊查询的Like语法不能使用索引</span></span><br><span class="line">INDEX_COLUMN <span class="keyword">like</span> <span class="string">&#x27;%&#x27;</span><span class="operator">||</span>?</span><br><span class="line">INDEX_COLUMN <span class="keyword">like</span> <span class="string">&#x27;%&#x27;</span><span class="operator">||</span>?<span class="operator">||</span><span class="string">&#x27;%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- B-TREE索引里不保存字段为NULL值记录，因此IS NULL不能使用索引</span></span><br><span class="line">INDEX_COLUMN <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Oracle在做数值比较时需要将两边的数据转换成同一种数据类型，如果两边数据类型不同时会对字段值隐式转换，相当于加了一层函数处理，所以不能使用索引。</span></span><br><span class="line">NUMBER_INDEX_COLUMN<span class="operator">=</span><span class="string">&#x27;12345&#x27;</span></span><br><span class="line">CHAR_INDEX_COLUMN<span class="operator">=</span><span class="number">12345</span></span><br><span class="line">a.INDEX_COLUMN<span class="operator">=</span>a.COLUMN_1</span><br></pre></td></tr></table></figure>

<h3 id="常用优化方法（ORACLE）"><a href="#常用优化方法（ORACLE）" class="headerlink" title="常用优化方法（ORACLE）"></a>常用优化方法（ORACLE）</h3><h4 id="where子句中的连接顺序"><a href="#where子句中的连接顺序" class="headerlink" title="where子句中的连接顺序"></a>where子句中的连接顺序</h4><p>   WHERE 子句是从下往上执行，筛选掉内容最多的条件必须写在 WHERE 子句的末尾，尤其是<code>主键ID=?</code>这样的条件。</p>
<h4 id="select子句中避免使用-‘-‘"><a href="#select子句中避免使用-‘-‘" class="headerlink" title="select子句中避免使用 ‘ * ‘"></a>select子句中避免使用 ‘ * ‘</h4><p>   oracle解析过程中，会把*依次转换为所有列名，这个工作是通过查询数据字典来完成的， 这意味着将耗费更多的时间</p>
<h4 id="避免在索引列上使用函数"><a href="#避免在索引列上使用函数" class="headerlink" title="避免在索引列上使用函数"></a>避免在索引列上使用函数</h4><p>WHERE子句中，如果索引列是函数的一部分。优化器将不使用索引而使用全表扫描</p>
<h4 id="避免在索引列上使用NOT"><a href="#避免在索引列上使用NOT" class="headerlink" title="避免在索引列上使用NOT"></a>避免在索引列上使用NOT</h4><p>NOT 会产生在和在索引列上使用函数相同的效果。 </p>
<h4 id="避免在索引列上使用IS-NULL和IS-NOT-NULL"><a href="#避免在索引列上使用IS-NULL和IS-NOT-NULL" class="headerlink" title="避免在索引列上使用IS NULL和IS NOT NULL"></a>避免在索引列上使用IS NULL和IS NOT NULL</h4><p>避免在索引中使用任何可以为空的列，oracle 将无法使用该索引</p>
<blockquote>
<p>对于单列索引，如果列包含空值，索引中将不存在此记录</p>
<p>对于复合索引，如果每个列都为空，索引中同样不存在此记录</p>
</blockquote>
<h4 id="注意通配符-的影响"><a href="#注意通配符-的影响" class="headerlink" title="注意通配符%的影响"></a>注意通配符%的影响</h4><h5 id="前导模糊查询的Like语法不能使用索引"><a href="#前导模糊查询的Like语法不能使用索引" class="headerlink" title="前导模糊查询的Like语法不能使用索引"></a>前导模糊查询的Like语法不能使用索引</h5><p><code>INDEX_COLUMN like &#39;%&#39;||?</code></p>
<h5 id="后导模糊查询的Like语法可以使用索引"><a href="#后导模糊查询的Like语法可以使用索引" class="headerlink" title="后导模糊查询的Like语法可以使用索引"></a>后导模糊查询的Like语法可以使用索引</h5><p><code>INDEX_COLUMN like ?||&#39;%&#39;</code></p>
<h4 id="避免改变索引列的类型"><a href="#避免改变索引列的类型" class="headerlink" title="避免改变索引列的类型"></a>避免改变索引列的类型</h4><p>在做数值比较时需要将两边的数据转换成同一种数据类型，如果两边数据类型不同时会对字段值隐式转换，相当于加了一层函数处理，导致不能使用索引。</p>
<h4 id="用-UNION-UNION-ALL替换OR-适用于索引列"><a href="#用-UNION-UNION-ALL替换OR-适用于索引列" class="headerlink" title="用(UNION)UNION ALL替换OR (适用于索引列)"></a>用(UNION)UNION ALL替换OR (适用于索引列)</h4><p>通常情况下， 用UNION替换WHERE子句中的OR将会起到较好的效果，对索引列使用OR将造成全表扫描。</p>
<blockquote>
<p>注意：以上规则只针对多个索引列有效。如果有column没有被索引，查询效率可能会因为你没有选择OR而降低</p>
</blockquote>
<h4 id="用UNION-ALL-替换UNION-如果有可能的话"><a href="#用UNION-ALL-替换UNION-如果有可能的话" class="headerlink" title="用UNION-ALL 替换UNION ( 如果有可能的话)"></a>用UNION-ALL 替换UNION ( 如果有可能的话)</h4><p>当 SQL语句需要UNION两个查询结果集合时，这两个结果集合会以UNION-ALL的方式被合并， 然后在输出最终结果前进行排序。 如果用UNION ALL替代UNION， 这样排序就不是必要了， 效率就会因此得到提高。 </p>
<blockquote>
<p>注意：UNION ALL 将重复输出两个结果集合中相同记录</p>
</blockquote>
<h4 id="EXISTS替换DISTINCT"><a href="#EXISTS替换DISTINCT" class="headerlink" title="EXISTS替换DISTINCT"></a>EXISTS替换DISTINCT</h4><p>带有DISTINCT、UNION、MINUS、INTERSECT的SQL语句会启动SQL引擎执行耗费资源的排序(SORT)功能。</p>
<blockquote>
<p> DISTINCT 需要<strong>一次</strong>排序操作， 而其他的至少需要执行<strong>两次</strong>排序。</p>
<p>通常， 带有UNION、MINUS 、INTERSECT的SQL语句都可以用其他方式重写。</p>
</blockquote>
<h4 id="合理的使用EXISTS和IN"><a href="#合理的使用EXISTS和IN" class="headerlink" title="合理的使用EXISTS和IN"></a>合理的使用EXISTS和IN</h4><p>EXISTS：首先检查主查询，然后运行子查询直到它找到第一个匹配项，这就节省了时间。<br>IN 子查询：首先系统先将主查询挂起，然后执行子查询，并将获得的结果列表存放在一个加了索引的临时表中。待子查询执行完毕，再执行主查询。这也就是使用EXISTS比使用IN通常查询速度快的原因。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> A.id <span class="operator">=</span> B.id) ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> A.id <span class="keyword">in</span> (<span class="keyword">select</span> B.id <span class="keyword">from</span> B) ;</span><br></pre></td></tr></table></figure>

<p>当子查询的表大，exists 优于 in；</p>
<blockquote>
<p>补充</p>
<ol>
<li>EXISTS(subquery) 只返回 TRUE or FALSE，实际实行时会优化子查询的select清单，因此子查询里写 select * / select 1 / select ‘X’，没有任何区别</li>
<li>如果两个表的大小相当，exists 和 in 差别不大</li>
<li>无论哪个表大，not exists 都比 not in 要快，因为 not in 内外表都不走索引；而 not exists的子查询依然可以用表的索引</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>索引</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库锁</title>
    <url>/2020/09/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    <content><![CDATA[<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p>按获取锁的方式：</p>
<ul>
<li>排他锁</li>
<li>共享锁</li>
</ul>
<p>按系统并发：</p>
<ul>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
<p>按保护对象：</p>
<ul>
<li>DML锁：<ul>
<li>TX行锁</li>
<li>TM表锁</li>
</ul>
</li>
<li>DDL锁：<ul>
<li>DDL排他锁</li>
<li>DDL共享锁</li>
<li>DDL可分解解析锁</li>
</ul>
</li>
<li>系统锁：<ul>
<li>闩锁Latch</li>
<li>互斥锁Mutexes</li>
<li>内部锁：<ul>
<li>字典缓存锁</li>
<li>文件和日志管理锁</li>
<li>表空间和撤销段锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> 乐观锁 和 悲观锁 是一种思想</p>
<p> 实现形式可能不一样：如 Java的原子类，数据库的version字段</p>
</blockquote>
<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>顾名思义，就是很悲观，它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的<strong>行锁</strong>，<strong>表锁</strong>不论是<strong>读写锁</strong>都是悲观锁。</p>
<h3 id="悲观锁按照使用性质划分"><a href="#悲观锁按照使用性质划分" class="headerlink" title="悲观锁按照使用性质划分"></a>悲观锁按照使用性质划分</h3><h4 id="共享锁-S锁"><a href="#共享锁-S锁" class="headerlink" title="共享锁(S锁)"></a>共享锁(S锁)</h4><blockquote>
<p>多个事务可以同时读，但不能有写操作</p>
</blockquote>
<p>读锁，事务A对对象T加S锁，其他事务也只能对T加S，直到A释放S锁。</p>
<h4 id="排它锁-X锁"><a href="#排它锁-X锁" class="headerlink" title="排它锁(X锁)"></a>排它锁(X锁)</h4><blockquote>
<p>只有一个事务可以操作，其他事务等待</p>
</blockquote>
<p>写锁，事务A对对象T加X锁以后，其他事务不能对T加任何锁，只有事务A可以读写对象T直到A释放X锁。</p>
<h4 id="更新锁-U锁"><a href="#更新锁-U锁" class="headerlink" title="更新锁(U锁)"></a>更新锁(U锁)</h4><p>用来预定要对此对象施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。</p>
<h4 id="排它锁和共享锁的相容矩阵"><a href="#排它锁和共享锁的相容矩阵" class="headerlink" title="排它锁和共享锁的相容矩阵"></a>排它锁和共享锁的相容矩阵</h4><table>
<thead>
<tr>
<th><strong>T1\T2</strong></th>
<th><strong>X</strong></th>
<th><strong>S</strong></th>
<th><strong>-</strong></th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>S</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>-</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
<h3 id="悲观锁按照作用范围划分"><a href="#悲观锁按照作用范围划分" class="headerlink" title="悲观锁按照作用范围划分"></a>悲观锁按照作用范围划分</h3><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><blockquote>
<p>作用范围：行级别</p>
<p>数据库能够确定那些行需要锁的情况下使用行锁，<strong>如果不知道会影响哪些行的时候就会使用表锁</strong>。</p>
<p>举例：</p>
<p>​    一个用户表user，有主键id和用户生日birthday当你使用<code>update … where id=?</code>这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用<code>update … where birthday=?</code>这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。</p>
</blockquote>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><blockquote>
<p>作用范围：整张表</p>
</blockquote>
<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>顾名思义，就是很乐观，每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是在更新的时候会去判断在此期间数据有没有被修改，需要用户自己去实现。</p>
<h3 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h3><blockquote>
<p>两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
</blockquote>
<h3 id="乐观锁实现方式"><a href="#乐观锁实现方式" class="headerlink" title="乐观锁实现方式"></a>乐观锁实现方式</h3><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><blockquote>
<p><strong>实现</strong>：实体上增加版本标识，数据库上表增加一个<code>version</code>字段；每次更新把这个字段加1</p>
<p><strong>原理</strong>：读数据时把<code>version</code>读出来，在更新数据时比较<code>version</code>，如果读的<code>version</code>没有变化可以更新了，如果DB的<code>version</code>比读的<code>version</code>大，说明有其他事务更新了该数据。这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。</p>
<p><strong>关键</strong>：判断<code>version</code>和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新，但是在正式更新前，又有别的数据修改了version，这个时候你的更新就会覆盖别的事务的更新，造成第二类丢失更新问题。</p>
<p><code>update … , version = version + 1 where … and version=&#39;old version&#39;;</code>，根据返回结果是0还是非0来判断是否更新成功。</p>
</blockquote>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><blockquote>
<p>和版本号基本一样，只是通过时间戳来判断而已，注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间</p>
</blockquote>
<h4 id="待更新字段"><a href="#待更新字段" class="headerlink" title="待更新字段"></a>待更新字段</h4><blockquote>
<p>实现：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。</p>
<p>原理：假如待更新字段叫count，先去读取这个count，更新时去比较数据库中count的值是不是原来读取的值，如果是就更新，否则更新失败。JAVA原子类型对象：如<code>AtomicInteger</code>就是这种思想。</p>
</blockquote>
<h4 id="所有字段"><a href="#所有字段" class="headerlink" title="所有字段"></a>所有字段</h4><blockquote>
<p>和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。</p>
</blockquote>
]]></content>
      <categories>
        <category>锁</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>系统架构演化</title>
    <url>/2020/11/15/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96/</url>
    <content><![CDATA[<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><h2 id="系统技术挑战与方案"><a href="#系统技术挑战与方案" class="headerlink" title="系统技术挑战与方案"></a>系统技术挑战与方案</h2><h3 id="互联网系统面临怎样的挑战"><a href="#互联网系统面临怎样的挑战" class="headerlink" title="互联网系统面临怎样的挑战?"></a>互联网系统面临怎样的挑战?</h3><ul>
<li><p>需要面对<strong>高并发</strong>用户，<strong>大流量</strong>访问</p>
<ul>
<li>Google 日均 PV 数 35 亿，日均 IP 访问数 3 亿</li>
<li>微信在线用户数 10 亿</li>
<li>天猫双十一活动一天交易额 3000 亿</li>
</ul>
</li>
<li><p><strong>高可用</strong></p>
<ul>
<li>系统 7×24 小时不间断服务，大型互联网站的<strong>宕机</strong>事件通常会成为新闻焦点</li>
</ul>
</li>
<li><p>需要存储、管理<strong>海量数据</strong></p>
<ul>
<li>Facebook 每周上传的照片数目接近10亿 </li>
<li>百度收录的网页数目有数百亿 </li>
<li>Google 有近百万台服务器为全球用户提供服务</li>
</ul>
</li>
<li><p>用户分布广泛，<strong>网络情况复杂</strong></p>
<ul>
<li>许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别。 在国内，有各个运营商网络互通难的问题。而中美光缆的数次故障，也让一些对国外用户依赖较大的网站不得不考虑在海外建立数据中心</li>
</ul>
</li>
<li><p>安全环境恶劣</p>
<ul>
<li>由于互联网的开放性，使得互联网站更容易受到攻击，大型网站几乎每天都会遇到黑客攻击情况。2011年国内多个重要网站泄露用户密码，让普通用户也直面一次互联网安全问题</li>
</ul>
</li>
<li><p><strong>需求快速变更，发布频繁</strong></p>
<ul>
<li>和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率也是极高的。Office 的产品版本以年为单位发布，而一般大型网站的产品每周都有新版本发布上线，至于中小型网站的发布就更频繁了，有时候一天会发布几十次</li>
</ul>
</li>
<li><p>渐进式发展</p>
<ul>
<li>不同于传统软件产品或者企业应用系统，一开始就规划好全部的功能和非功能需求，几 乎所有的大型互联网站都是从一个小网站开始，渐进的发展起来的。</li>
<li>好的互联网产品都是慢慢运营出来的，不是一开始就开发好的。那些刚建立就投入巨资， 有巨大背景的网站，后来发展都很惨淡。</li>
</ul>
</li>
</ul>
<h3 id="应对高并发挑战的两个技术方向"><a href="#应对高并发挑战的两个技术方向" class="headerlink" title="应对高并发挑战的两个技术方向"></a>应对高并发挑战的两个技术方向</h3><h4 id="垂直伸缩"><a href="#垂直伸缩" class="headerlink" title="垂直伸缩"></a>垂直伸缩</h4><p>​    通过<strong>升级硬件和网络吞吐能力</strong>可以实现垂直伸缩。由于不需要改变应用架构，所以通常 被认为是<strong>最简单的短期伸缩性方案</strong>。 </p>
<ul>
<li>通过使用 RAID（独立冗余磁盘阵列）增加 I/O 吞吐能力</li>
<li>通过切换到 SSD（固态硬盘）改善 I/O 访问速度</li>
<li>通过增加内存减少 I/O 操作</li>
<li>通过升级网络接口或者增加网络接口提高网络吞吐能力</li>
<li>更新服务器使用更多处理器或者更多超线程</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>达到某个程度后，增加计算能力需要的更多的花费。</p>
<ul>
<li>垂直伸缩有物理极限。</li>
<li>操作系统的设计或者应用程序自身制约着垂直伸缩最多只能达到某个点。</li>
</ul>
<p><img src="http://image.leonote.cn//20201115101239.png" alt=""></p>
<h4 id="水平伸缩"><a href="#水平伸缩" class="headerlink" title="水平伸缩"></a>水平伸缩</h4><p>水平伸缩是指通过增加服务器提升计算能力的一类架构方法。 </p>
<p>水平伸缩被认为是伸缩性的圣杯，水平伸缩可以克服垂直伸缩带来的单位计算成本随计算 能力增加而迅速飙升的问题。</p>
<p>另外，水平伸缩总是可以增加更多服务器，这样，就不会像垂直伸缩那样遭遇到单台服 务器的极限。</p>
<p><img src="http://image.leonote.cn//20201115101557.png" alt=""></p>
<h2 id="互联网架构演化"><a href="#互联网架构演化" class="headerlink" title="互联网架构演化"></a>互联网架构演化</h2><h3 id="第零阶段：最简单的互联网应用架构"><a href="#第零阶段：最简单的互联网应用架构" class="headerlink" title="第零阶段：最简单的互联网应用架构"></a>第零阶段：最简单的互联网应用架构</h3><p>一台服务器里面完成所有的事情</p>
<p><img src="http://image.leonote.cn//20201115101756.png" alt=""></p>
<h3 id="第一阶段：应用数据分离"><a href="#第一阶段：应用数据分离" class="headerlink" title="第一阶段：应用数据分离"></a>第一阶段：应用数据分离</h3><p><img src="http://image.leonote.cn//20201115101928.png" alt=""></p>
<h3 id="第二阶段：使用缓存改善系统性能"><a href="#第二阶段：使用缓存改善系统性能" class="headerlink" title="第二阶段：使用缓存改善系统性能"></a>第二阶段：使用缓存改善系统性能</h3><p><img src="http://image.leonote.cn//20201115102022.png" alt=""></p>
<h3 id="第三阶段：使用应用服务器集群改善系统的并发处理能力"><a href="#第三阶段：使用应用服务器集群改善系统的并发处理能力" class="headerlink" title="第三阶段：使用应用服务器集群改善系统的并发处理能力"></a>第三阶段：使用应用服务器集群改善系统的并发处理能力</h3><p><img src="http://image.leonote.cn//20201115102252.png" alt=""></p>
<h3 id="第四阶段：数据库读写分离"><a href="#第四阶段：数据库读写分离" class="headerlink" title="第四阶段：数据库读写分离"></a>第四阶段：数据库读写分离</h3><p><img src="http://image.leonote.cn//20201115102505.png" alt=""></p>
<h3 id="第五阶段：使用反向代理和-CDN-加速网站响应"><a href="#第五阶段：使用反向代理和-CDN-加速网站响应" class="headerlink" title="第五阶段：使用反向代理和 CDN 加速网站响应"></a>第五阶段：使用反向代理和 CDN 加速网站响应</h3><p><img src="http://image.leonote.cn//20201115102618.png" alt=""></p>
<h3 id="第六阶段：使用分布式文件系统和分布式数据库系统"><a href="#第六阶段：使用分布式文件系统和分布式数据库系统" class="headerlink" title="第六阶段：使用分布式文件系统和分布式数据库系统"></a>第六阶段：使用分布式文件系统和分布式数据库系统</h3><p><img src="http://image.leonote.cn//20201115102720.png" alt=""></p>
<h3 id="第七阶段：使用-NoSQL-和搜索引擎"><a href="#第七阶段：使用-NoSQL-和搜索引擎" class="headerlink" title="第七阶段：使用 NoSQL 和搜索引擎"></a>第七阶段：使用 NoSQL 和搜索引擎</h3><p><img src="http://image.leonote.cn//20201115102805.png" alt=""></p>
<h3 id="第八阶段：业务拆分"><a href="#第八阶段：业务拆分" class="headerlink" title="第八阶段：业务拆分"></a>第八阶段：业务拆分</h3><p><img src="http://image.leonote.cn//20201115102903.png" alt=""></p>
<h3 id="第九阶段：微服务及中台化"><a href="#第九阶段：微服务及中台化" class="headerlink" title="第九阶段：微服务及中台化"></a>第九阶段：微服务及中台化</h3><p><img src="http://image.leonote.cn//20201115102933.png" alt=""></p>
<h3 id="第十阶段-大数据与智能化"><a href="#第十阶段-大数据与智能化" class="headerlink" title="第十阶段 大数据与智能化"></a>第十阶段 大数据与智能化</h3><h2 id="互联网架构模式"><a href="#互联网架构模式" class="headerlink" title="互联网架构模式"></a>互联网架构模式</h2><p>每一个模式描述了一个在我们周围不断重复发生的问题以及该问题解决方案的核心。这 样，你就能一次又一次的使用该方案而不必做重复工作。 </p>
<p>模式的关键在于模式的可重复性，问题与场景的可重复性带来解决方案的可重复使用。</p>
<p>互联网架构模式就是试图去描述那些为解决互联网系统高性能、高可用、易扩展、可伸 缩、安全等目标，被很多互联网应用重复使用的一些解决方案，这些解决方案是互联网 软件系统的重要组成部分。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>分层是企业应用系统中最常见的一种架构模式，将系统在横向维度上切分成几个部分， 每个部分负责一部分相对比较单一的职责，然后通过上层对下层依赖和调用组成一个完 整的系统。</p>
<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>如果说分层是将软件在横向方面进行切分，那么分割就是在纵向方面对软件进行切分。 系统越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有助于软件的开发和维护；另一方面， 便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力。</p>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>对于大型网站，<strong>分层和分割的一个主要目的是为了切分后的模块便于分布式部署</strong>，就是将不同模块部署在不同的服务器上，通过远程调用协同工作。分布式意味着解决同样的问题可以使用更多的计算机，计算机越多，CPU、内存、存储资源也就越多，能够处理的并发访问和数据量就越大。</p>
<ul>
<li>分布式应用和服务 </li>
<li>分布式静态资源 </li>
<li>分布式数据和存储 </li>
<li>分布式计算</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块， 比如网站的首页，还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。 </p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存就是将数据存放在距离计算最近的位置以加快处理速度。<strong>缓存是改善软件性能的第一手段</strong>，现代 CPU 越来越快的一个重要因素就是使用了更多的缓存，在复杂的软件设计中，缓存几乎无处不在。大型网站架构设计在很多方面都使用了缓存设计。</p>
<ul>
<li>CDN </li>
<li>反向代理 </li>
<li>本地缓存 </li>
<li>远程缓存 </li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>计算机软件发展的一个重要目标和驱动力是<strong>降低软件耦合性</strong>。事物之间越少直接关系， 那么就越少被彼此影响，越可以独立发展。大型网站架构中，系统解耦合的手段除了前面提到的分层、分割、分布等手段，还有一个重要手段是异步，就是将一个业务操作分成多个阶段，每个阶段之间<strong>通过共享数据而不是直接调用</strong>的方法进行协作。 </p>
<ul>
<li>提高系统可用性 </li>
<li>加快网站响应速度 </li>
<li>消除并发访问高峰 </li>
</ul>
<h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>互联网应用需要 7×24 小时连续运行，但是服务器总有可能会出现故障，特别是服务器规模比较大的时候，<strong>服务器宕机是必然事件</strong>。要想保证在服务器宕机的情况下网站依然可以继续服务，数据不会丢失，就需要<strong>一定程度的服务器冗余运行，数据冗余备份</strong>。 </p>
<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>在无人值守的情况下网站可以正常运行，一切都可以自动化是网站的理想状态。目前互联网的自动化架构设计主要集中在运维方面。 </p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>互联网的开放特性使得其从诞生起就面对巨大的安全挑战，网站在安全架构方面也积累了许多模式：通过密码和手机校验码进行<strong>身份认证</strong>；登录、交易等操作需要对网络通讯进行<strong>加密</strong>，网站服务器上存储的敏感数据如用户信息等也进行加密处理；为了防止机器人程序滥用网络资源供给网站，网站使用<strong>验证码</strong>进行识别；对于常见的用于攻击网站的 XSS 攻击，SQL 注入，进行<strong>编码转换</strong>等相应处理；对于垃圾信息、敏感信息进行<strong>过滤</strong>； 对转账交易等重要操作根据交易模式和交易信息进行<strong>风险控制</strong>。</p>
<h2 id="如何衡量一个系统的架构设计"><a href="#如何衡量一个系统的架构设计" class="headerlink" title="如何衡量一个系统的架构设计"></a>如何衡量一个系统的架构设计</h2><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>性能是互联网的一个重要指标，除非是没得选择，否则用户无法忍受一个响应缓慢的应用。一个打开缓慢应用会导致严重的用户流失，很多时候系统性能问题是系统架构升级优化的触发器。可以说性能是互联网系统架构设计的一个重要方面，任何架构设计方案都必须考虑可能会带来的性能问题。 </p>
<p>也正是因为性能问题几乎无处不在，所以优化网站性能的手段也非常多，从用户端到数据库，从代码到机房部署，<strong>影响用户请求的所有环节都可以进行性能优化</strong>。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>因为互联网分布式系统使用的服务器硬件通常是普通的商用服务器，这些服务器的设计目标本身并不保证高可用，也就是说，很有可能会出现服务器硬件故障，也就是俗称的服务器宕机。大型互联网系统通常都会有上万台服务器，每天都必定会有一些服务器宕机，因此<strong>系统高可用架构设计的前提是必然会出现服务器宕机</strong>，而高可用设计的目标就是当服务器宕机的时候，服务或者应用依然可用。 系统高可用的主要手段是<strong>冗余</strong>，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失。</p>
<h3 id="可伸缩"><a href="#可伸缩" class="headerlink" title="可伸缩"></a>可伸缩</h3><p>大型互联网应用通过集群的方式将多台服务器组成一个整体共同提供服务。所谓伸缩性是指<strong>通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</strong>。 </p>
<p>衡量架构伸缩性的<strong>主要标准</strong>就是</p>
<ul>
<li>是否可以用多台服务器构建集群</li>
<li>是否容易向集群中添加新的服务器</li>
<li>加入新的服务器后是否可以提供和原来的服务器无差别的服务</li>
<li>集群中可容纳的总的服务器数量是否有限制</li>
</ul>
<h3 id="可扩展"><a href="#可扩展" class="headerlink" title="可扩展"></a>可扩展</h3><p>不同于其他架构要素主要关注非功能性需求，<strong>扩展性架构直接关注系统的功能需求</strong>。互联网应用快速发展，功能不断扩展，如何设计系统的架构使其能够快速响应需求变化， 是系统可扩展架构主要的目的。 </p>
<p>衡量系统架构扩展性好坏的主要标准就是在系统增加新的业务产品时</p>
<ul>
<li>是否可以实现<strong>对现有产品透明无影响</strong>，不需要任何改动或者很少改动既有业务功能就可以上线新产品。</li>
<li>不同产品之间是否很<strong>少耦合</strong>，一个产品改动对其他产品无影响，其他产品和功能不需要 受牵连进行改动。 </li>
</ul>
<p>可扩展架构的主要手段是<strong>事件驱动架构</strong>和<strong>分布式服务</strong>。</p>
<h3 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h3><p>互联网是开放的，任何人在任何地方都可以访问系统。系统的安全架构就是保护系统不受恶意访问和攻击，保护网站的重要数据不被窃取。 </p>
<p>衡量系统安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略。</p>
<h2 id="互联网架构技术"><a href="#互联网架构技术" class="headerlink" title="互联网架构技术"></a>互联网架构技术</h2><p><img src="http://image.leonote.cn//20201115105842.png" alt=""></p>
<h3 id="前端架构"><a href="#前端架构" class="headerlink" title="前端架构"></a>前端架构</h3><ul>
<li>App 及 Web 开发技术</li>
<li>浏览器及 HTTP 优化技术</li>
<li>CDN</li>
<li>动静分离</li>
<li>图片服务</li>
<li>反向代理</li>
<li>DNS</li>
</ul>
<h3 id="网关及应用层架构"><a href="#网关及应用层架构" class="headerlink" title="网关及应用层架构"></a>网关及应用层架构</h3><ul>
<li>网关架构</li>
<li>负载均衡</li>
<li>动态页面静态化</li>
<li>业务拆分 </li>
</ul>
<h3 id="服务层架构"><a href="#服务层架构" class="headerlink" title="服务层架构"></a>服务层架构</h3><ul>
<li>微服务框架</li>
<li>分布式消息队列</li>
<li>分布式缓存</li>
<li>分布式一致性（锁）服务 </li>
</ul>
<h3 id="存储层架构"><a href="#存储层架构" class="headerlink" title="存储层架构"></a>存储层架构</h3><ul>
<li>分布式文件</li>
<li>分布式关系数据库</li>
<li>NoSQL 数据库 </li>
</ul>
<h3 id="后台架构"><a href="#后台架构" class="headerlink" title="后台架构"></a>后台架构</h3><ul>
<li>大数据平台</li>
<li>搜索引擎</li>
<li>推荐引擎</li>
<li>数据仓库 </li>
</ul>
<h3 id="运维与安全"><a href="#运维与安全" class="headerlink" title="运维与安全"></a>运维与安全</h3><ul>
<li>数据采集与展示 </li>
<li>数据监控与报警 </li>
<li>攻击与防护</li>
<li>数据加密与解密</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>又叫做<strong>静态工厂方法</strong>（Static Factory Method）</p>
<blockquote>
<p>简单工厂模式的实质是由一个工厂类<strong>根据传入的参数</strong>，<strong>动态决定</strong>应该<strong>创建哪一个产品类</strong>。 </p>
</blockquote>
<p>Spring 中的<code>BeanFactory</code>就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 <code>HelloItxxz</code> 类中创建一个 <code>itxxzBean</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;singletonBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itxxz.HelloItxxz&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是singletonBean<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;itxxzBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itxxz.HelloItxxz&quot;</span>  <span class="attr">singleton</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是itxxzBean! <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>线程不安全实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查模式实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton singleton; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123; </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a>枚举单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 ( Strategy Pattern )"></a>策略模式 ( Strategy Pattern )</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>使用策略模式可以避免使用多重条件语句</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类</li>
<li>策略模式造成很多的策略类</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h4><p>定义一个抽象类，强制子类实现该方法</p>
<p>这种实现，对父类对子类不一定是透明的，如果父类提供了默认的实现，子类需要了解实现的细节，再决定是否重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以将该方法设置成抽象方法， 强迫子类来实现该方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供一个默认的实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionModelA</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aStyleBrake();<span class="comment">// A 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionModelB</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bStyleBrake(); <span class="comment">// B 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合实现"><a href="#组合实现" class="headerlink" title="组合实现"></a>组合实现</h4><p>这种实现是透明的，只需要改变对象的引用就可以改变其行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStyleBrake</span> <span class="keyword">implements</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aStyleBrake(); <span class="comment">// A 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BStyleBrake</span> <span class="keyword">implements</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bStyleBrake(); <span class="comment">// B 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> IBrakeBehavior brakeBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    brakeBehavior.execute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrakeBehavior</span><span class="params">(<span class="keyword">final</span> IBrakeBehavior brakeType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.brakeBehavior = brakeType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过工厂类，根据运行的参数选择出对应的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Action action  = ActionFactory.createAction(String parameters);   action.execute();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有在策略选择里有条件选择语句，其他地方不出现。</p>
<p>如上述的<code>createAction()</code>方法</p>
</blockquote>
<h2 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 ( Adapter Pattern )"></a>适配器模式 ( Adapter Pattern )</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。分为两种模式：</p>
<ul>
<li>类适配器模式：适配器与适配者之间是<strong>继承（或实现）关系</strong></li>
<li>对象适配器模式：适配器与适配者之间是<strong>关联关系</strong></li>
</ul>
<p>前者的耦合度比后者高，且要求开发了解现有组件库中的相关组件的内部结构，应用相对较少些。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p><strong>类适配器模式优点：</strong></p>
<p>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p><strong>对象适配器模式优点：</strong></p>
<p>同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><strong>类适配器模式缺点：</strong></p>
<p>对于 Java 等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p>
<p><strong>对象适配器模式缺点：</strong></p>
<p>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><strong>角色</strong></p>
<ul>
<li><strong>Target（目标抽象类）</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
<li><strong>Adapter（适配器类）</strong>：适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。</li>
<li><strong>Adaptee（适配者类）</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ul>
<h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><p>首先有一个已存在的将被适配的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个目标接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果通过一个适配器类，实现 <code>Target</code> 接口，同时继承了 <code>Adaptee</code> 类，然后在实现的 <code>request()</code> 方法中调用父类的 <code>adapteeRequest()</code> 即可实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 <code>Adapter</code> 类即可将转变为对象适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>在我们的项目中遇到这样一个问题：我们的项目<strong>需要连接多个数据库</strong>，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而<code>sessionFactory</code>的<code>dataSource</code>属性总是指向这个数据源并且恒定不变，所有DAO在使用<code>sessionFactory</code>的时候都是通过这个数据源访问数据库。</p>
<p>但是现在，由于项目的需要，我们的DAO在访问<code>sessionFactory</code>的时候都不得不<strong>在多个数据源中不断切换</strong>，问题就出现了：如何让<code>sessionFactory</code>在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ </p>
<p>首先想到在spring的<code>applicationContext</code>中配置所有的<code>dataSource</code>。这些<code>dataSource</code>可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的<code>org.apache.commons.dbcp.BasicDataSource</code>、spring提供的<code>org.springframework.jndi.JndiObjectFactoryBean</code>等。然后<code>sessionFactory</code>根据客户的每次请求，将<code>dataSource</code>属性设置成不同的数据源，以到达切换数据源的目的。</p>
<p>spring中用到的<strong>包装器模式在类名</strong>上有两种表现：一种是类名中含有<strong>Wrapper</strong>，另一种是类名中含有<strong>Decorator</strong>。</p>
<blockquote>
<p>基本上都是<strong>动态地给一个对象添加一些额外的职责</strong>。</p>
</blockquote>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。spring中的<code>JdbcTemplate</code>，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到<code>JdbcTemplate</code>已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入<code>JdbcTemplate</code>的方法中。但是变化的东西是一段代码，而且这段代码会用到<code>JdbcTemplate</code>中的变量。怎么办？那我们就用回调对象吧。</p>
<p>在这个回调对象中定义一个操纵<code>JdbcTemplate</code>中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到<code>JdbcTemplate</code>，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式。 </p>
<p>以下是一个具体的例子： </p>
<p><code>JdbcTemplate</code>中的execute方法 </p>
<p>![](F:/CloudNode/后台/2-Java EE/Spring/image/6.png)</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Springboot服务到云服务器上</title>
    <url>/2019/12/06/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="部署一个java服务器到自己的云服务器上"><a href="#部署一个java服务器到自己的云服务器上" class="headerlink" title="部署一个java服务器到自己的云服务器上"></a>部署一个java服务器到自己的云服务器上</h1><blockquote>
<p>以腾讯云服务器为例</p>
</blockquote>
<h2 id="设置安全组，开放一些常用端口"><a href="#设置安全组，开放一些常用端口" class="headerlink" title="设置安全组，开放一些常用端口"></a>设置安全组，开放一些常用端口</h2><p>在菜单里选择安全组配置一条安全组规则，添加完后会多一行记录：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-12-10_10-15-21.png" alt=""></p>
<p>选择添加规则，设置入站规则和出站规则：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-12-10_10-17-29.png" alt=""></p>
<p><img src="http://image.leonote.cn/Snipaste_2019-12-10_10-18-11.png" alt=""></p>
<p>将这个安全组规则关联到自己的云主机上：</p>
<p><img src="http://image.leonote.cn/Snipaste_2019-12-10_10-18-42.png" alt=""></p>
<p><img src="http://image.leonote.cn/Snipaste_2019-12-10_10-19-24.png" alt=""></p>
<h2 id="使用xshell访问云服务器"><a href="#使用xshell访问云服务器" class="headerlink" title="使用xshell访问云服务器"></a>使用xshell访问云服务器</h2><p>当开放完22端口后，就可以去生成公私钥，把私钥下载后，使用xshell访问云服务器的公网IP，会出现输入账号，密码和密钥。把下载好的密钥加载进来，就可以使用xshell访问了。以后再详细写。。</p>
<h2 id="下载必要的软件"><a href="#下载必要的软件" class="headerlink" title="下载必要的软件"></a>下载必要的软件</h2><blockquote>
<p>PS: 暂时还不懂使用 docker 部署服务，所以用最原始的方式部署</p>
</blockquote>
<p>我部署的是<code>springboot</code>项目，所以需要使用到<code>java</code>环境，先安装<code>jdk</code>。</p>
<h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><h4 id="查看是否已经安装了JDK"><a href="#查看是否已经安装了JDK" class="headerlink" title="查看是否已经安装了JDK"></a>查看是否已经安装了JDK</h4><p><code>whereis java</code><br><code>which java</code></p>
<blockquote>
<p>如果有<code>jdk</code>会输出所在位置，如果没有不输出，或者输出找不到</p>
</blockquote>
<h4 id="卸载旧版本的JDK"><a href="#卸载旧版本的JDK" class="headerlink" title="卸载旧版本的JDK"></a>卸载旧版本的JDK</h4><p>找到JDK的位置：<code>rpm -qa | grep jdk</code></p>
<p>根据位置卸载：</p>
<h4 id="安装想要的JDK版本"><a href="#安装想要的JDK版本" class="headerlink" title="安装想要的JDK版本"></a>安装想要的JDK版本</h4><p>我这里下载的是 jdk8 <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载地址</a> ，下载 tar.gz 格式的文件</p>
<p>下载完后，使用 xftp 上载到云服务器上，我这里放到了<code>/usr/local</code> 。</p>
<p><img src="http://image.leonote.cn/snipaste_20191205_203752.png" alt=""></p>
<p>解压到当前文件夹上： <code>tar zxvf jdk8.tar.gz</code></p>
<p>将该jdk配置到环境变量上去：</p>
<p><code>vi /etc/profile</code></p>
<p>文件末尾追加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_231</span><br><span class="line">JRE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_231&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib</span><br><span class="line"></span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>

<p>保存退出后，使其立即生效： <code>source /etc/profile</code>  </p>
<p>创建<code>Test.java</code>文件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello world !&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>编译并运行，如果输出hello wold则配置完成</p>
<p><code>javac Test.java</code></p>
<p><code>java Test</code></p>
<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>因为我的云服务器安装的是<code>CentOs7</code> ，所以使用yum下载</p>
<p>安装 Docker： <code>yum -y install docker</code></p>
<p>启动 Docker：<code>systemctl start docker</code></p>
<p>验证是否成功：<code>docker run hello-world</code>  如果输出hello world则成功</p>
<h4 id="下载想要运行的软件"><a href="#下载想要运行的软件" class="headerlink" title="下载想要运行的软件"></a>下载想要运行的软件</h4><p>我这里需要用到<code>Mysql</code>：<code>docker pull mysql</code></p>
<p>运行 <code>mysql</code>，这里没有设置复杂的密码：<code>docker run -itd --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 docker.io/mysql</code></p>
<p>进入<code>mysql</code>容器：<code>docker exec  -it  mysql  /bin/bash</code>  </p>
<p>输入账号：<code>mysql -uroot -p</code></p>
<p>输入密码：</p>
<p>进入<code>mysql</code>后，创建数据库并使用：<code>create database mini;</code>  和 <code>use mini;</code></p>
<p>退出<code>mysql</code>命令行模式：<code>exit</code></p>
<p>退出 docker 容器：<code>exit</code></p>
<h2 id="maven-打包"><a href="#maven-打包" class="headerlink" title="maven 打包"></a>maven 打包</h2><p>使用命令或者ide进行打包</p>
<p>如果云上的配置和本地的配置不一样，可以打包后，解压打开，用云上的配置替换本地的配置</p>
<h2 id="在-xshell-运行springboot"><a href="#在-xshell-运行springboot" class="headerlink" title="在 xshell 运行springboot"></a>在 xshell 运行springboot</h2><p>进入到springboot项目存放的位置，运行java -jar命令</p>
<p><img src="http://image.leonote.cn/snipaste_20191205_211502.png" alt=""></p>
<h2 id="直接用云服务器的公网访问自己写的api"><a href="#直接用云服务器的公网访问自己写的api" class="headerlink" title="直接用云服务器的公网访问自己写的api"></a>直接用云服务器的公网访问自己写的api</h2><p><img src="http://image.leonote.cn/snipaste_20191205_211619.png" alt=""></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>运维</tag>
        <tag>云服务器</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖动</title>
    <url>/2020/08/20/%E9%98%B2%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<p><a href="https://github.com/YvetteLau/Step-By-Step/issues/10">参考的连接</a></p>
<h2 id="什么是防抖"><a href="#什么是防抖" class="headerlink" title="什么是防抖"></a>什么是防抖</h2><p>所谓防抖，就是指触发事件后在n秒内只能执行一次，如果在n秒内触发事件的，则会重新计算函数执行事件</p>
<h2 id="防抖的两种状态"><a href="#防抖的两种状态" class="headerlink" title="防抖的两种状态"></a>防抖的两种状态</h2><h3 id="立即执行"><a href="#立即执行" class="headerlink" title="立即执行"></a>立即执行</h3><p>触发事件后函数立即执行</p>
<h3 id="非立即执行"><a href="#非立即执行" class="headerlink" title="非立即执行"></a>非立即执行</h3><p>触发事件后函数不会立即执行，而是在n秒后开始执行</p>
<h2 id="防抖使用场景"><a href="#防抖使用场景" class="headerlink" title="防抖使用场景"></a>防抖使用场景</h2><blockquote>
<p>防抖函数常用来进行处理某些频繁触发的请求事件（或者前端计算的事件）</p>
<ul>
<li>window滚动条事件 scroll</li>
<li>window的resize</li>
<li>鼠标的mouse move</li>
<li>下拉框的远程模糊搜索</li>
<li>表单组件输入内容验证</li>
<li>防止多次点击导致表单多次提交</li>
</ul>
<p>目的：限制函数触发频率；对性能优化，减少服务器负担；</p>
<p>实现核心：维护一个<code>setTimeout</code>，在冷却时间内再次触发函数则清空原<code>setTimeout</code>重新计算一个<code>setTimeout</code>推入队列等待执行</p>
</blockquote>
<h2 id="lodash的方法"><a href="#lodash的方法" class="headerlink" title="lodash的方法"></a>lodash的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.debounce(func, [wait=<span class="number">0</span>], [options=&#123;&#125;])</span><br></pre></td></tr></table></figure>

<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol>
<li><code>func</code> <em>(Function)</em>: 要防抖动的函数。</li>
<li><code>[wait=0]</code> <em>(number)</em>: 需要延迟的毫秒数。</li>
<li><code>[options=&#123;&#125;]</code> <em>(Object)</em>: 选项对象。</li>
<li><code>[options.leading=false]</code> <em>(boolean)</em>: 指定在延迟开始前调用。</li>
<li><code>[options.maxWait]</code> <em>(number)</em>: 设置 <code>func</code> 允许被延迟的最大值。</li>
<li><code>[options.trailing=true]</code> <em>(boolean)</em>: 指定在延迟结束后调用。</li>
</ol>
<h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p><em>(Function)</em>: 返回新的 debounced（防抖动）函数。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 避免窗口在变动时出现昂贵的计算开销。</span></span><br><span class="line">jQuery(<span class="built_in">window</span>).on(<span class="string">&#x27;resize&#x27;</span>, _.debounce(calculateLayout, <span class="number">150</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 当点击时 `sendMail` 随后就被调用。</span></span><br><span class="line">jQuery(element).on(<span class="string">&#x27;click&#x27;</span>, _.debounce(sendMail, <span class="number">300</span>, &#123;</span><br><span class="line">  <span class="string">&#x27;leading&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&#x27;trailing&#x27;</span>: <span class="literal">false</span></span><br><span class="line">&#125;));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 确保 `batchLog` 调用1次之后，1秒内会被触发。</span></span><br><span class="line"><span class="keyword">var</span> debounced = _.debounce(batchLog, <span class="number">250</span>, &#123; <span class="string">&#x27;maxWait&#x27;</span>: <span class="number">1000</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> EventSource(<span class="string">&#x27;/stream&#x27;</span>);</span><br><span class="line">jQuery(source).on(<span class="string">&#x27;message&#x27;</span>, debounced);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 取消一个 trailing 的防抖动调用</span></span><br><span class="line">jQuery(<span class="built_in">window</span>).on(<span class="string">&#x27;popstate&#x27;</span>, debounced.cancel);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>lodash</tag>
        <tag>防止多次提交</tag>
      </tags>
  </entry>
  <entry>
    <title>Wake On Lan 配置远程启动电脑</title>
    <url>/2020/07/04/WOL%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>远程控制电脑开机。</p>
<blockquote>
<p>本人笔记本是合起来放在书架后面的，每次开机都要把它拿出来打开，非常麻烦，所以想要通过其他方式唤醒电脑。</p>
</blockquote>
<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><blockquote>
<p>使用Wake On Lan通过网卡控制电脑开机。</p>
</blockquote>
<h1 id="什么是Wake-On-Lan"><a href="#什么是Wake-On-Lan" class="headerlink" title="什么是Wake On Lan"></a>什么是Wake On Lan</h1><p> Wake-On-LAN 简称 WOL，是一种电源管理功能；它是由IBM公司提出的网络唤醒标准，目前该标准已被大多数主板厂商支持。支持该标准的主板允许从远程通过网络唤醒计算机，也就是远程开机。</p>
<h1 id="如何实现远程开机"><a href="#如何实现远程开机" class="headerlink" title="如何实现远程开机"></a>如何实现远程开机</h1><h2 id="打开你的网络设置"><a href="#打开你的网络设置" class="headerlink" title="打开你的网络设置"></a>打开你的网络设置</h2><p>方式1：我的电脑-&gt;右键-&gt;管理-&gt;设备管理器-&gt;网络适配器-&gt;找到自己的网卡-&gt;右键-&gt;属性</p>
<p><img src="http://image.leonote.cn/image-20200703221016604.png" alt="image-20200703221016604"></p>
<p>方式2：打开网络和Internet设置-&gt;网络共享中心-&gt;更改适配器设置-&gt;找到自己的网卡-&gt;右键-&gt;属性-&gt;配置</p>
<p><img src="http://image.leonote.cn/image-20200703221145601.png" alt="image-20200703221145601"></p>
<p><img src="http://image.leonote.cn/image-20200703221347169.png" alt="image-20200703221347169"></p>
<p><img src="http://image.leonote.cn/image-20200703221417037.png" alt="image-20200703221417037"></p>
<h2 id="选择网卡唤醒"><a href="#选择网卡唤醒" class="headerlink" title="选择网卡唤醒"></a>选择网卡唤醒</h2><p><img src="http://image.leonote.cn/image-20200703221524097.png" alt="image-20200703221524097"></p>
<p><img src="http://image.leonote.cn/image-20200703221625409.png" alt="image-20200703221625409"></p>
<h2 id="设置防火墙策略"><a href="#设置防火墙策略" class="headerlink" title="设置防火墙策略"></a>设置防火墙策略</h2><p>防火墙和网络保护-&gt; 高级设置</p>
<p><img src="http://image.leonote.cn/image-20200703221741989.png" alt="image-20200703221741989"></p>
<p><img src="http://image.leonote.cn/image-20200703221814410.png" alt="image-20200703221814410"></p>
<p><img src="http://image.leonote.cn/image-20200703222006090.png" alt="image-20200703222006090"></p>
<p><img src="http://image.leonote.cn/image-20200703222150080.png" alt="image-20200703222150080"></p>
<p><img src="http://image.leonote.cn/image-20200703222054000.png" alt="image-20200703222054000"></p>
<p><img src="http://image.leonote.cn/image-20200703222122592.png" alt="image-20200703222122592"></p>
<h2 id="在路由器设置里将PC的MAC地址和网线的IP绑定"><a href="#在路由器设置里将PC的MAC地址和网线的IP绑定" class="headerlink" title="在路由器设置里将PC的MAC地址和网线的IP绑定"></a>在路由器设置里将PC的MAC地址和网线的IP绑定</h2><p><img src="http://image.leonote.cn/snipaste_20200703_215804.png" alt="snipaste_20200703_215804"></p>
<h2 id="PC安装测试软件"><a href="#PC安装测试软件" class="headerlink" title="PC安装测试软件"></a>PC安装测试软件</h2><p><a href="https://www.depicus.com/wake-on-lan/wake-on-lan-monitor">https://www.depicus.com/wake-on-lan/wake-on-lan-monitor</a> </p>
<p>下载完成后打开，设置UDP端口为刚才设置的端口号9，点击Start</p>
<p><img src="http://image.leonote.cn/image-20200703222934685.png" alt="image-20200703222934685"></p>
<h2 id="手机安装WOL的软件"><a href="#手机安装WOL的软件" class="headerlink" title="手机安装WOL的软件"></a>手机安装WOL的软件</h2><p>这里我Iphone安装的是Wolow</p>
<p><img src="http://image.leonote.cn/image-20200703223328607.png" alt="image-20200703223328607"></p>
<p><img src="http://image.leonote.cn/image-20200703223420342.png" alt="image-20200703223420342"></p>
<p>点击后，如果刚才打开的monitor软件，出现以下的内容，理论上已经代表能够联通，关机后如果还是没有唤醒可能需要找下其他原因。</p>
<p><img src="http://image.leonote.cn/image-20200703224052572.png" alt="image-20200703224052572"></p>
<h1 id="Wake-On-Lan原理"><a href="#Wake-On-Lan原理" class="headerlink" title="Wake On Lan原理"></a>Wake On Lan原理</h1><p>Wake-On-LAN的实现，主要是向目标主机发送特殊格式的数据包，俗称魔术包（Magic Packet）。</p>
<p>Magic Packet 格式的数据包是由 AMD 公司开发推广的技术，虽然其并非世界公认的标准，但是仍然受到很多网卡制造商的支持，因此许多具有网络唤醒功能的网卡都能与之兼容。</p>
<h2 id="Magic-Packet"><a href="#Magic-Packet" class="headerlink" title="Magic Packet"></a>Magic Packet</h2><p>魔法数据包（Magic Packet）是一个广播性的帧（frame），通过端口7或端口9进行发送，且可以用无连接（Connectionless protocol）的通信协议（如UDP）来传递。<br> 在魔法数据包内，每次都会先有连续6个”FF”（十六进制，换算成二进制即：11111111）的数据，即：FF FF FF FF FF FF，在连续6个”FF”后则开始带出MAC地址信息（MAC地址重复16次），有时还会带出4字节或6字节的密码，一旦经由网卡侦测、解读、研判（广播）魔法数据包的内容，内容中的MAC地址、密码若与电脑自身的地址、密码吻合，就会引导唤醒、开机的程序。</p>
<p>Magic Packet 魔术数据包的格式一般看上去像下面这个样子<br> 假设MAC地址为：00-00-00-00-00</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th align="center">MagicPacket</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">FF FF FF FF FF FF</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">00 00 00 00 00 00</td>
</tr>
</tbody></table>
<p>魔法数据包（Magic Packet）结构上非常简单。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.jianshu.com/p/22cbb5e9036a">C#语言去实现一个WakeOnLan软件</a></p>
]]></content>
      <categories>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>WOL</tag>
      </tags>
  </entry>
  <entry>
    <title>7大缓存经典问题</title>
    <url>/2020/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-7%E5%A4%A7%E7%BC%93%E5%AD%98%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="7大缓存经典问题"><a href="#7大缓存经典问题" class="headerlink" title="7大缓存经典问题"></a>7大缓存经典问题</h1><p><img src="http://image.leonote.cn/20201123134403.png" alt=""></p>
<h2 id="第一个经典问题-缓存失效"><a href="#第一个经典问题-缓存失效" class="headerlink" title="第一个经典问题-缓存失效"></a>第一个经典问题-缓存失效</h2><p><strong>问题描述</strong></p>
<p>服务系统查数据，首先会查缓存，如果缓存数据不存在，就进一步查 DB，最后查到数据后回种到缓存并返回。</p>
<p>缓存的性能比 DB 高 50~100 倍以上，所以我们希望数据查询尽可能命中缓存，这样系统负荷最小，性能最佳。</p>
<p>缓存里的数据存储基本上都是以 key 为索引进行存储和获取的。<strong>业务访问时，如果大量的 key 同时过期，很多缓存数据访问都会 miss，进而穿透到 DB，DB 的压力就会明显上升</strong>，由于 DB 的性能较差，只在缓存的 1%~2% 以下，这样请求的慢查率会明显上升。这就是缓存失效的问题。</p>
<p><strong>原因分析</strong></p>
<p>导致缓存失效，特别是很多 key 一起失效的原因，跟我们日常写缓存的过期时间息息相关。</p>
<p>在写缓存时，我们一般会根据业务的访问特点，给每种业务数据预置一个过期时间，在写缓存时把这个过期时间带上，让缓存数据在这个固定的过期时间后被淘汰。<strong>一般情况下，因为缓存数据是逐步写入的，所以也是逐步过期被淘汰的。</strong> <strong><em>但在某些场景，一大批数据会被系统主动或被动从 DB 批量加载，然后写入缓存。</em></strong>这些数据写入缓存时，由于使用相同的过期时间，在经历这个过期时间之后，这批数据就会一起到期，从而被缓存淘汰。此时，对这批数据的所有请求，都会出现缓存失效，从而都穿透到 DB，DB 由于查询量太大，就很容易压力大增，请求变慢。</p>
<p><strong>业务场景</strong></p>
<p>很多业务场景，稍不注意，就出现大量的缓存失效，进而导致系统 DB 压力大、请求变慢的情况。比如同一批火车票、飞机票，当可以售卖时，系统会一次性加载到缓存，如果缓存写入时，过期时间按照预先设置的过期值，那过期时间到期后，系统就会因缓存失效出现变慢的问题。类似的业务场景还有很多，比如微博业务，会有后台离线系统，持续计算热门微博，每当计算结束，会将这批热门微博批量写入对应的缓存。还比如，很多业务，在部署新 IDC 或新业务上线时，会进行缓存预热，也会一次性加载大批热数据。</p>
<p>解决方案<br>对于批量 key 缓存失效的问题，原因既然是预置的固定过期时间，那解决方案也从这里入手。设计缓存的过期时间时，使用公式：过期时间=baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力，如下图所示。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计原则</title>
    <url>/2020/09/16/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>面向对象设计（OOD：Object Oriented Design）的六大设计原则</p>
<table>
<thead>
<tr>
<th align="left">缩写</th>
<th align="left">英文名称</th>
<th>中文名称</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SRP</td>
<td align="left">Single Responsibility Principle</td>
<td>单一职责原则</td>
</tr>
<tr>
<td align="left">OCP</td>
<td align="left">Open Close Principle</td>
<td>开闭原则</td>
</tr>
<tr>
<td align="left">LSP</td>
<td align="left">Liskov Substitution Principle</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td align="left">ISP</td>
<td align="left">Interface Segregation Principle</td>
<td>接口分离原则</td>
</tr>
<tr>
<td align="left">DIP</td>
<td align="left">Dependency Inversion Principle</td>
<td>依赖倒置原则</td>
</tr>
<tr>
<td align="left">LoD</td>
<td align="left">Law of Demeter （ Least Knowledge Principle）</td>
<td>迪米特法则（最少知道原则）</td>
</tr>
</tbody></table>
<blockquote>
<p>前五个设计原则就是通常所说的<code>SOLID</code>（上方表格缩写的首字母，从上到下）</p>
</blockquote>
<h2 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 ( OCP )"></a>开闭原则 ( OCP )</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>📌 Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p>
</blockquote>
<p>即：一个软件实体如类、模块和函数等应该对扩展开放，对修改关闭。</p>
<p>不需要修改软件实体（类、模块、函数等），就应该能实现功能的扩展</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本。</p>
<h3 id="实现的方法"><a href="#实现的方法" class="headerlink" title="实现的方法"></a>实现的方法</h3><p>关键是抽象，通过实现预先设置好的抽象的接口（抽象类）来实现新的功能。</p>
<h4 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式 ( Strategy Pattern )"></a>策略模式 ( Strategy Pattern )</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ol>
<li>使用策略模式可以避免使用多重条件语句</li>
<li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码</li>
<li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的</li>
<li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法</li>
<li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离</li>
</ol>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol>
<li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类</li>
<li>策略模式造成很多的策略类</li>
</ol>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><h6 id="继承实现"><a href="#继承实现" class="headerlink" title="继承实现"></a>继承实现</h6><p>定义一个抽象类，强制子类实现该方法</p>
<p>这种实现，对父类对子类不一定是透明的，如果父类提供了默认的实现，子类需要了解实现的细节，再决定是否重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 也可以将该方法设置成抽象方法， 强迫子类来实现该方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供一个默认的实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionModelA</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aStyleBrake();<span class="comment">// A 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionModelB</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bStyleBrake(); <span class="comment">// B 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="组合实现"><a href="#组合实现" class="headerlink" title="组合实现"></a>组合实现</h6><p>这种实现是透明的，只需要改变对象的引用就可以改变其行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AStyleBrake</span> <span class="keyword">implements</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aStyleBrake(); <span class="comment">// A 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BStyleBrake</span> <span class="keyword">implements</span> <span class="title">IBrakeBehavior</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bStyleBrake(); <span class="comment">// B 风格的行为</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> IBrakeBehavior brakeBehavior;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    brakeBehavior.execute();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrakeBehavior</span><span class="params">(<span class="keyword">final</span> IBrakeBehavior brakeType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.brakeBehavior = brakeType;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过工厂类，根据运行的参数选择出对应的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Action action  = ActionFactory.createAction(String parameters);   action.execute();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有在策略选择里有条件选择语句，其他地方不出现。</p>
<p>如上述的<code>createAction()</code>方法</p>
</blockquote>
<h4 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式 ( Adapter Pattern )"></a>适配器模式 ( Adapter Pattern )</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。分为两种模式：</p>
<ul>
<li>类适配器模式：适配器与适配者之间是<strong>继承（或实现）关系</strong></li>
<li>对象适配器模式：适配器与适配者之间是<strong>关联关系</strong></li>
</ul>
<p>前者的耦合度比后者高，且要求开发了解现有组件库中的相关组件的内部结构，应用相对较少些。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ul>
<p><strong>类适配器模式优点：</strong></p>
<p>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p>
<p><strong>对象适配器模式优点：</strong></p>
<p>同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p><strong>类适配器模式缺点：</strong></p>
<p>对于 Java 等不支持多重继承的语言，一次最多只能适配一个适配者类，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</p>
<p><strong>对象适配器模式缺点：</strong></p>
<p>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p>
<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>角色</p>
<ul>
<li><strong>Target（目标抽象类）</strong>：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
<li><strong>Adapter（适配器类）</strong>：适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。</li>
<li><strong>Adaptee（适配者类）</strong>：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ul>
<h6 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h6><p>首先有一个已存在的将被适配的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被适配者的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个目标接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果通过一个适配器类，实现 <code>Target</code> 接口，同时继承了 <code>Adaptee</code> 类，然后在实现的 <code>request()</code> 方法中调用父类的 <code>adapteeRequest()</code> 即可实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h6><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 <code>Adapter</code> 类即可将转变为对象适配器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="观察者模式-（-Observer-Pattern-）"><a href="#观察者模式-（-Observer-Pattern-）" class="headerlink" title="观察者模式 （ Observer Pattern ）"></a>观察者模式 （ Observer Pattern ）</h4><h2 id="依赖倒置原则（-Dependency-Inversion-Principle-）"><a href="#依赖倒置原则（-Dependency-Inversion-Principle-）" class="headerlink" title="依赖倒置原则（ Dependency Inversion Principle ）"></a>依赖倒置原则（ Dependency Inversion Principle ）</h2><h3 id="依赖倒置原则定义"><a href="#依赖倒置原则定义" class="headerlink" title="依赖倒置原则定义"></a>依赖倒置原则定义</h3><blockquote>
<p>📌High level modules should not depend upon low level modules, Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions</p>
</blockquote>
<p>翻译过来：</p>
<ul>
<li>高层模块不依赖低层模块，两者都应该依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象</li>
</ul>
<p>按照Java的理解，是面向接口编程</p>
<h3 id="依赖倒置原则作用"><a href="#依赖倒置原则作用" class="headerlink" title="依赖倒置原则作用"></a>依赖倒置原则作用</h3><h4 id="降低类间的耦合性"><a href="#降低类间的耦合性" class="headerlink" title="降低类间的耦合性"></a>降低类间的耦合性</h4><p>类间的依赖都是通过接口完成的，某个类的实现变了，也不影响上游代码。</p>
<h4 id="减少并行开发引起的风险"><a href="#减少并行开发引起的风险" class="headerlink" title="减少并行开发引起的风险"></a>减少并行开发引起的风险</h4><p>各层级，模块间都是通过接口定义的约束，只要都遵循这些约束，能相应减少了并行开发的冲突。</p>
<h3 id="依赖倒置的实现方法"><a href="#依赖倒置的实现方法" class="headerlink" title="依赖倒置的实现方法"></a>依赖倒置的实现方法</h3><h4 id="构造函数传递依赖对象"><a href="#构造函数传递依赖对象" class="headerlink" title="构造函数传递依赖对象"></a>构造函数传递依赖对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;          </span><br></pre></td></tr></table></figure>

<h4 id="Setter方法传递依赖对象"><a href="#Setter方法传递依赖对象" class="headerlink" title="Setter方法传递依赖对象"></a>Setter方法传递依赖对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car = car;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.car.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口声明依赖"><a href="#接口声明依赖" class="headerlink" title="接口声明依赖"></a>接口声明依赖</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        car.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h3><blockquote>
<p>don’t call us, we’ll call you</p>
</blockquote>
<p>因为在好莱坞，把简历递交给演艺公司后就只有回家等待。由演艺公司对整个娱乐项的完全控制，演员只能被动式的接受公司的差使，在需要的环节中，完成自己的演出。</p>
<h4 id="为什么有时候依赖倒置原则又被称为好莱坞原则"><a href="#为什么有时候依赖倒置原则又被称为好莱坞原则" class="headerlink" title="为什么有时候依赖倒置原则又被称为好莱坞原则"></a>为什么有时候依赖倒置原则又被称为好莱坞原则</h4><p>好莱坞有一个角色，找演员来演</p>
<p>好莱坞相当于高层，演员们相当于低层，他们间的联系是通过某个角色，</p>
<p>这个角色由哪个演员来演都可以，并不依赖于具体某个演员，</p>
<p>整个流程有点像面向接口编程。</p>
<blockquote>
<p>📌两个原则强调的点应该是不一样的，查到的资料给我的感觉是：</p>
<p>好莱坞原则：强调的是高层对底层的主动调用</p>
<p>依赖倒置原则：强调的是面向接口编程</p>
<p>有点类似，但又不全是。</p>
</blockquote>
<h2 id="里氏替换原则（）"><a href="#里氏替换原则（）" class="headerlink" title="里氏替换原则（）"></a>里氏替换原则（）</h2><h2 id="单一职责原则（）"><a href="#单一职责原则（）" class="headerlink" title="单一职责原则（）"></a>单一职责原则（）</h2><h2 id="接口隔离原则（）"><a href="#接口隔离原则（）" class="headerlink" title="接口隔离原则（）"></a>接口隔离原则（）</h2>]]></content>
      <categories>
        <category>架构</category>
        <category>面向对象设计原则</category>
      </categories>
      <tags>
        <tag>面向对象设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>贫血模型和充血模型</title>
    <url>/2021/02/27/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="贫血模型和充血模型"><a href="#贫血模型和充血模型" class="headerlink" title="贫血模型和充血模型"></a>贫血模型和充血模型</h1><h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p>概念：是指领域对象里只有get和set方法，或者包含少量的CRUD方法，所有的业务逻辑都不包含在内而是放在Business Logic层。</p>
<p>优点：是系统的层次结构清楚，各层之间单向依赖，Client -&gt; (Business Facade) -&gt; Business Logic -&gt; Data Access。</p>
<p>​          当然 Business Logic 是依赖 Domain Object 的。似乎现在流行的架构就是这样，当然层次还可以细分。 </p>
<p>缺点：是不够面向对象，领域对象只是作为保存状态或者传递状态使用，所以就说只有数据没有行为的对象不是真正的对象。</p>
<blockquote>
<p>在 Business Logic 里面处理所有的业务逻辑，在 POEAA (企业应用架构模式)一书中被称为 Transaction Script 模式。</p>
</blockquote>
<h2 id="充血模型"><a href="#充血模型" class="headerlink" title="充血模型"></a>充血模型</h2><p>概念：大多业务逻辑和持久化放在 Domain Object 里面，Business Logic 只是简单封装部分业务逻辑以及控制事务、权限等，</p>
<p>​          这样层次结构就变成 Client -&gt;（Business Facade) -&gt; Business Logic -&gt; Domain Object -&gt; Data Access。</p>
<p>优点：是面向对象，Business Logic 符合单一职责，不像在贫血模型里面那样包含所有的业务逻辑太过沉重。</p>
<p>缺点：是如何划分业务逻辑，什么样的逻辑应该放在 Domain Object 中，什么样的业务逻辑应该放在 Business Logic 中，这是很含糊的。</p>
<p>​          即使划分好了业务逻辑，由于分散在 Business Logic 和 Domain Object 层中，不能更好的分模块开发。熟悉业务逻辑的开发人员需要渗</p>
<p>​          透到 Domain Logic 中去，而在 Domain Logic 又包含了持久化，对于开发者来说这十分混乱。 其次，因为 Business Logic 要控制事务</p>
<p>​          并且为上层提供一个统一的服务调用入口点，它就必须把在 Domain Logic 里实现的业务逻辑全部重新包装一遍，完全属于重复劳动。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>领域驱动设计</tag>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security (一) 架构框架-Component、Service、Filter分析</title>
    <url>/2020/05/30/Spring%20Security%20(%E4%B8%80)%20%E6%9E%B6%E6%9E%84%E6%A1%86%E6%9E%B6-Component%E3%80%81Service%E3%80%81Filter%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>【转载】</p>
<p>作者：Ccww</p>
<p>链接：<a href="https://juejin.im/post/5d074dc1f265da1bce3dd10f">https://juejin.im/post/5d074dc1f265da1bce3dd10f</a></p>
</blockquote>
<h1 id="Spring-security-（一）架构框架-Component、Service、Filter分析"><a href="#Spring-security-（一）架构框架-Component、Service、Filter分析" class="headerlink" title="Spring security （一）架构框架-Component、Service、Filter分析"></a>Spring security （一）架构框架-Component、Service、Filter分析</h1><pre><code>想要深入spring security的authentication （身份验证）和access-control（访问权限控制）工作流程，必须清楚spring security的主要技术点包括关键接口、类以及抽象类如何协同工作进行authentication 和access-control的实现。</code></pre><h2 id="Spring-Security-认证和授权流程"><a href="#Spring-Security-认证和授权流程" class="headerlink" title="Spring Security 认证和授权流程"></a>Spring Security 认证和授权流程</h2><p>常见认证和授权流程可以分成：</p>
<ol>
<li>A user is prompted to log in with a username and password （用户用账密码登录）</li>
<li>The system (successfully) verifies that the password is correct for the username（校验密码正确性）</li>
<li>The context information for that user is obtained (their list of roles and so on).（获取用户信息context，如权限）</li>
<li>A security context is established for the user（为用户创建security context）</li>
<li>The user proceeds, potentially to perform some operation which is potentially protected by an access control mechanism which checks the required permissions for the operation against the current security context information.（访问权限控制，是否具有访问权限）</li>
</ol>
<h3 id="Spring-Security-认证"><a href="#Spring-Security-认证" class="headerlink" title="Spring Security 认证"></a>Spring Security 认证</h3><p>上述前三点为spring security认证验证环节：</p>
<ol>
<li>通常通过<code>AbstractAuthenticationProcessingFilter</code>过滤器将账号密码组装成Authentication实现类<code>UsernamePasswordAuthenticationToken</code>；</li>
<li>将token传递给AuthenticationManager验证是否有效，而AuthenticationManager通常使用<code>ProviderManager</code>实现类来检验；</li>
<li><code>AuthenticationManager</code>认证成功后将返回一个拥有详细信息的Authentication object（包括权限信息，身份信息，细节信息，但密码通常会被移除）；</li>
<li>通过<code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code>将Authentication设置到security context中。</li>
</ol>
<h3 id="Spring-Security-访问授权"><a href="#Spring-Security-访问授权" class="headerlink" title="Spring Security 访问授权"></a>Spring Security 访问授权</h3><ol>
<li>通过<code>FilterSecurityInterceptor</code>过滤器入口进入；</li>
<li><code>FilterSecurityInterceptor</code>通过其继承的抽象类AbstractSecurityInterceptor的<code>beforeInvocation(Object object)</code>方法进行访问授权，其中涉及了类<code>AuthenticationManager</code>、<code>AccessDecisionManager</code>、<code>SecurityMetadataSource</code>等。</li>
</ol>
<p>根据上述描述的过程，我们接下来主要去分析其中涉及的一下Component、Service、Filter。</p>
<h2 id="核心组件（Core-Component-）"><a href="#核心组件（Core-Component-）" class="headerlink" title="核心组件（Core Component ）"></a>核心组件（Core Component ）</h2><h3 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h3><pre><code>`SecurityContextHolder`提供对`SecurityContext`的访问，存储security context（用户信息、角色权限等），而且其具有下列储存策略即工作模式：</code></pre><ol>
<li><code>SecurityContextHolder.MODE_THREADLOCAL</code>（默认）：使用<code>ThreadLocal</code>，信息可供此线程下的所有的方法使用，一种与线程绑定的策略，此天然很适合Servlet Web应用。</li>
<li><code>SecurityContextHolder.MODE_GLOBAL</code>：使用于独立应用</li>
<li><code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code>：具有相同安全标示的线程</li>
</ol>
<p>修改<code>SecurityContextHolder</code>的工作模式有两种方法 :</p>
<ol>
<li>设置一个系统属性(system.properties) : spring.security.strategy;</li>
<li>调用<code>SecurityContextHolder</code>静态方法<code>setStrategyName()</code></li>
</ol>
<p>在默认<code>ThreadLocal</code>策略中，<code>SecurityContextHolder</code>为静态方法获取用户信息为:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); </span><br><span class="line"><span class="keyword">if</span> (principal <span class="keyword">instanceof</span> UserDetails) &#123;      </span><br><span class="line">     String username = ((UserDetails)principal).getUsername();  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     String username = principal.toString();     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是一般不需要自身去获取。 其中<code>getAuthentication()</code>返回一个<code>Authentication</code>认证主体，接下来分析<code>Authentication</code>、<code>UserDetails</code>细节。</p>
<h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><pre><code>Spring Security使用一个`Authentication`对象来描述当前用户的相关信息,其包含用户拥有的权限信息列表、用户细节信息（身份信息、认证信息）。`Authentication`为认证主体在spring security中时最高级别身份/认证的抽象，常见的实现类`UsernamePasswordAuthenticationToken`。`Authentication`接口源码：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Authentication</span> <span class="keyword">extends</span> <span class="title">Principal</span>, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="comment">//权限信息列表,默认GrantedAuthority接口的一些实现类</span></span><br><span class="line">    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); </span><br><span class="line">    <span class="comment">//密码信息</span></span><br><span class="line">    <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值</span></span><br><span class="line">    <span class="function">Object <span class="title">getDetails</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//通常返回值为UserDetails实现类</span></span><br><span class="line">    <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAuthenticated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面两个组件都涉及了UserDetails，以及GrantedAuthority其到底是什么呢？2.3小节分析。</p>
<h3 id="UserDetails-amp-GrantedAuthority"><a href="#UserDetails-amp-GrantedAuthority" class="headerlink" title="UserDetails&amp;GrantedAuthority"></a>UserDetails&amp;GrantedAuthority</h3><pre><code>UserDetails提供从应用程序的DAO或其他安全数据源构建Authentication对象所需的信息，包含GrantedAuthority。其官方实现类为User，开发者可以实现其接口自定义UserDetails实现类。其接口源码：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     Collection&lt;? extends GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line">     <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>UserDetails与Authentication接口功能类似，其含义是Authentication为用户提交的认证凭证（账号密码）；</code></pre><p>​        UserDetails为系统中用户正确认证凭证；</p>
<p>​        UserDetailsService中的loadUserByUsername方法获取正确的认证凭证；</p>
<pre><code>其中在getAuthorities()方法中获取到GrantedAuthority列表是代表用户访问应用程序权限范围，此类权限通常是“role(角色）”，例如`ROLE_ADMINISTRATOR`或`ROLE_HR_SUPERVISOR`；</code></pre><p>​        GrantedAuthority接口常见的实现类SimpleGrantedAuthority。</p>
<h2 id="核心服务类（Core-Services）"><a href="#核心服务类（Core-Services）" class="headerlink" title="核心服务类（Core Services）"></a>核心服务类（Core Services）</h2><h3 id="AuthenticationManager、ProviderManager以及AuthenticationProvider"><a href="#AuthenticationManager、ProviderManager以及AuthenticationProvider" class="headerlink" title="AuthenticationManager、ProviderManager以及AuthenticationProvider"></a>AuthenticationManager、ProviderManager以及AuthenticationProvider</h3><pre><code>`AuthenticationManager`是认证相关的核心接口，是认证一切的起点。</code></pre><p>​         <strong><em>常见的认证流程都是AuthenticationManager实现类ProviderManager处理</em></strong>，而且ProviderManager实现类基于委托者模式维护<code>AuthenticationProvider</code> 列表用于不同的认证方式。例如：</p>
<ol>
<li>使用<strong>账号密码</strong>认证方式<code>DaoAuthenticationProvider</code>实现类（继承了AbstractUserDetailsAuthenticationProvide抽象类），其为默认认证方式，进行数据库库获取认证数据信息。</li>
<li><strong>游客</strong>身份登录认证方式<code>AnonymousAuthenticationProvider</code>实现类</li>
<li>从<strong>cookies</strong>获取认证方式<code>RememberMeAuthenticationProvider</code>实现类</li>
</ol>
<p><code>ProviderManager</code>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">	Class&lt;? extends Authentication&gt; toTest = authentication.getClass();</span><br><span class="line">	AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">	Authentication result = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//AuthenticationProvider列表依次认证</span></span><br><span class="line">	<span class="keyword">for</span> (AuthenticationProvider provider : getProviders()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!provider.supports(toTest)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">//每个AuthenticationProvider进行认证</span></span><br><span class="line">			result = provider.authenticate(authentication)</span><br><span class="line">			<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">				copyDetails(authentication, result);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		....</span><br><span class="line">		<span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">			lastException = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//进行父类AuthenticationProvider进行认证</span></span><br><span class="line">	<span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Allow the parent to try.</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			result = parent.authenticate(authentication);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">			lastException = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	   <span class="comment">// 如果有Authentication信息，则直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (eraseCredentialsAfterAuthentication</span><br><span class="line">				&amp;&amp; (result <span class="keyword">instanceof</span> CredentialsContainer)) &#123;</span><br><span class="line">				<span class="comment">//清除密码</span></span><br><span class="line">			((CredentialsContainer) result).eraseCredentials();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//发布登录成功事件</span></span><br><span class="line">		eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="comment">//如果都没认证成功，抛出异常</span></span><br><span class="line">	<span class="keyword">if</span> (lastException == <span class="keyword">null</span>) &#123;</span><br><span class="line">		lastException = <span class="keyword">new</span> ProviderNotFoundException(messages.getMessage(</span><br><span class="line">				<span class="string">&quot;ProviderManager.providerNotFound&quot;</span>,</span><br><span class="line">				<span class="keyword">new</span> Object[] &#123; toTest.getName() &#125;,</span><br><span class="line">				<span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	prepareException(lastException, authentication);</span><br><span class="line">	<span class="keyword">throw</span> lastException;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<pre><code>ProviderManager 中的`List&lt;AuthenticationProvider&gt;`，会**依照次序**去认证；</code></pre><p>​         默认策略下，只需要通过一个<code>AuthenticationProvider</code>的认证，即可被认为是登录成功，而且认证成功后返回一个<code>Authentication</code>实体，并为了安全会进行清除密码。</p>
<p>​        如果所有认证器都无法认证成功，则ProviderManager 会抛出一个<code>ProviderNotFoundException</code>异常。</p>
<h3 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h3><pre><code>UserDetailsService接口作用是从特定的地方获取认证的数据源（账号、密码）。如何获取到系统中正确的认证凭证，通过`loadUserByUsername(String username)`获取认证信息，而且其只有一个方法：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>;  </span><br></pre></td></tr></table></figure>

<p>​    UserDetailsService常见的实现类</p>
<ol>
<li>从数据库获取的JdbcDaoImpl实现类，</li>
<li>从内存中获取的InMemoryUserDetailsManager实现类，</li>
<li>….</li>
<li>自定义UserDetailsService实现类，如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomUserService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="comment">//用户mapper</span></span><br><span class="line"> <span class="keyword">private</span> UserInfoMapper userInfoMapper;</span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> <span class="comment">//用户权限mapper</span></span><br><span class="line"> <span class="keyword">private</span> PermissionInfoMapper permissionInfoMapper;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    UserInfoDTO userInfo = userInfoMapper.getUserInfoByUserName(username);</span><br><span class="line">    <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;PermissionInfoDTO&gt; permissionInfoDTOS = permissionInfoMapper.findByAdminUserId(userInfo.getId());</span><br><span class="line">        List&lt;GrantedAuthority&gt; grantedAuthorityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//组装权限GrantedAuthority object</span></span><br><span class="line">        <span class="keyword">for</span> (PermissionInfoDTO permissionInfoDTO : permissionInfoDTOS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (permissionInfoDTO != <span class="keyword">null</span> &amp;&amp; permissionInfoDTO.getPermissionName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                GrantedAuthority grantedAuthority = <span class="keyword">new</span> SimpleGrantedAuthority(</span><br><span class="line">                        permissionInfoDTO.getPermissionName());</span><br><span class="line">                grantedAuthorityList.add(grantedAuthority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回用户信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(userInfo.getUserName(), userInfo.getPasswaord(), grantedAuthorityList);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//抛出用户不存在异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;admin&quot;</span> + username + <span class="string">&quot;do not exist&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="AccessDecisionManager-amp-SecurityMetadataSource"><a href="#AccessDecisionManager-amp-SecurityMetadataSource" class="headerlink" title="AccessDecisionManager&amp;SecurityMetadataSource"></a>AccessDecisionManager&amp;SecurityMetadataSource</h3><pre><code>AccessDecisionManager是由AbstractSecurityInterceptor调用，负责做出最终的访问控制决策。</code></pre><p>AccessDecisionManager接口源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//访问控制决策</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication, Object secureObject,Collection&lt;ConfigAttribute&gt; attrs)</span> <span class="keyword">throws</span> AccessDeniedException</span>;</span><br><span class="line"> <span class="comment">//是否支持处理传递的ConfigAttribute</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"> <span class="comment">//确认class是否为AccessDecisionManager</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class clazz)</span></span>;</span><br></pre></td></tr></table></figure>

<pre><code>SecurityMetadataSource包含着AbstractSecurityInterceptor访问授权所需的元数据（动态url、动态授权所需的数据）；在AbstractSecurityInterceptor授权模块中结合AccessDecisionManager进行访问授权，其涉及了ConfigAttribute。 </code></pre><p>SecurityMetadataSource接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Collection&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IllegalArgumentException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们还可以自定义SecurityMetadataSource数据源，实现接口FilterInvocationSecurityMetadataSource。例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilterSecurityMetadataSource</span> <span class="keyword">implements</span> <span class="title">FilterInvocationSecurityMetadataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ConfigAttribute&gt; <span class="title">getAttributes</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        FilterInvocation fi = (FilterInvocation) object;</span><br><span class="line">        String url = fi.getRequestUrl();</span><br><span class="line">        String httpMethod = fi.getRequest().getMethod();</span><br><span class="line">        List&lt;ConfigAttribute&gt; attributes = <span class="keyword">new</span> ArrayList&lt;ConfigAttribute&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lookup your database (or other source) using this information and populate the</span></span><br><span class="line">        <span class="comment">// list of attributes</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> attributes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title">getAllConfigAttributes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterInvocation.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PasswordEncoder"><a href="#PasswordEncoder" class="headerlink" title="PasswordEncoder"></a>PasswordEncoder</h3><pre><code>为了存储安全，一般要对密码进行算法加密。</code></pre><p>Spring Security提供了加密<code>PasswordEncoder</code>接口。其实现类有：</p>
<ol>
<li><p>BCrypt hash算法实现的<code>BCryptPasswordEncoder</code>；</p>
</li>
<li><p>SCrypt hashing 算法实现的<code>SCryptPasswordEncoder</code>；</p>
</li>
</ol>
<p>PasswordEncoder接口只有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//密码加密</span></span><br><span class="line">    <span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line">    <span class="comment">//密码配对</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="核心-Security-过滤器（Core-Security-Filters）"><a href="#核心-Security-过滤器（Core-Security-Filters）" class="headerlink" title="核心 Security 过滤器（Core Security Filters）"></a>核心 Security 过滤器（Core Security Filters）</h2><h3 id="FilterSecurityInterceptor"><a href="#FilterSecurityInterceptor" class="headerlink" title="FilterSecurityInterceptor"></a>FilterSecurityInterceptor</h3><pre><code>`FilterSecurityInterceptor`是Spring Security**授权模块入口**，该类根据访问的用户的角色，权限授权访问那些资源（访问特定路径应该具备的权限）。
`FilterSecurityInterceptor`封装`FilterInvocation`对象进行操作；</code></pre><p>​           所有的请求到了<code>FilterSecurityInterceptor</code>，如果这个filter之前没有执行过的话，那么首先执行其父类<code>AbstractSecurityInterceptor</code>提供的<code>InterceptorStatusToken token = super.beforeInvocation(fi)</code>，该方法会：</p>
<ol>
<li>使用AuthenticationManager获取Authentication中用户详情；</li>
<li>使用ConfigAttribute封装已定义好访问权限详情；</li>
<li>使用AccessDecisionManager.decide()方法进行访问权限控制。</li>
</ol>
<p><code>FilterSecurityInterceptor</code>源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(FilterInvocation fi)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((fi.getRequest() != <span class="keyword">null</span>)</span><br><span class="line">			&amp;&amp; (fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="keyword">null</span>)</span><br><span class="line">			&amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">		fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// first time this request being called, so perform security checking</span></span><br><span class="line">		<span class="keyword">if</span> (fi.getRequest() != <span class="keyword">null</span> &amp;&amp; observeOncePerRequest) &#123;</span><br><span class="line">			fi.getRequest().setAttribute(FILTER_APPLIED, Boolean.TRUE);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//回调其继承的抽象类AbstractSecurityInterceptor的方法</span></span><br><span class="line">		InterceptorStatusToken token = <span class="keyword">super</span>.beforeInvocation(fi);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">super</span>.finallyInvocation(token);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">super</span>.afterInvocation(token, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractSecurityInterceptor源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//获取所有访问权限（url-role）属性列表（已定义在数据库或者其他地方）</span></span><br><span class="line">	Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">			.getAttributes(object);</span><br><span class="line">	....</span><br><span class="line">	<span class="comment">//获取该用户访问信息（包括url，访问权限）</span></span><br><span class="line">	Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attempt authorization</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//进行授权访问</span></span><br><span class="line">		<span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">	&#125;<span class="keyword">catch</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UsernamePasswordAuthenticationFilter"><a href="#UsernamePasswordAuthenticationFilter" class="headerlink" title="UsernamePasswordAuthenticationFilter"></a>UsernamePasswordAuthenticationFilter</h3><pre><code>`UsernamePasswordAuthenticationFilter`使用username和password表单登录使用的过滤器，也是**最常用的**过滤器。其源码：</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">     <span class="comment">//获取表单中的用户名和密码</span></span><br><span class="line">     String username = obtainUsername(request);</span><br><span class="line">     String password = obtainPassword(request);</span><br><span class="line">     ...</span><br><span class="line">     username = username.trim();</span><br><span class="line">     <span class="comment">//组装成username+password形式的token</span></span><br><span class="line">     UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span><br><span class="line">     username, password);</span><br><span class="line">     <span class="comment">// Allow subclasses to set the &quot;details&quot; property</span></span><br><span class="line">     setDetails(request, authRequest);</span><br><span class="line">     <span class="comment">//交给内部的AuthenticationManager去认证，并返回认证信息</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<pre><code>其主要代码为创建`UsernamePasswordAuthenticationToken`的Authentication实体以及调用AuthenticationManager进行authenticate认证，根据认证结果执行successfulAuthentication或者unsuccessfulAuthentication，无论成功失败，一般的实现都是转发或者重定向等处理，不再细究AuthenticationSuccessHandler和AuthenticationFailureHandle。若有兴趣，可以研究一下其父类AbstractAuthenticationProcessingFilter过滤器。</code></pre><h3 id="AnonymousAuthenticationFilter"><a href="#AnonymousAuthenticationFilter" class="headerlink" title="AnonymousAuthenticationFilter"></a>AnonymousAuthenticationFilter</h3><p><code>AnonymousAuthenticationFilter</code>是匿名登录过滤器，它位于常用的身份认证过滤器（如UsernamePasswordAuthenticationFilter、BasicAuthenticationFilter、RememberMeAuthenticationFilter）之后，意味着只有在上述身份过滤器执行完毕后，SecurityContext依旧没有用户信息，AnonymousAuthenticationFilter该过滤器才会有意义——给<strong>当前请求</strong>一个匿名身份。</p>
<p> AnonymousAuthenticationFilter源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">	<span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AnonymousAuthenticationFilter</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>(key, <span class="string">&quot;anonymousUser&quot;</span>, AuthorityUtils.createAuthorityList(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    <span class="comment">//创建匿名登录Authentication的信息</span></span><br><span class="line">	    	SecurityContextHolder.getContext().setAuthentication(</span><br><span class="line">			    	createAuthentication((HttpServletRequest) req));</span><br><span class="line">		    		...</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    chain.doFilter(req, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建匿名登录Authentication的信息方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Authentication <span class="title">createAuthentication</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">	    AnonymousAuthenticationToken auth = <span class="keyword">new</span> AnonymousAuthenticationToken(key,</span><br><span class="line">			principal, authorities);</span><br><span class="line">	    auth.setDetails(authenticationDetailsSource.buildDetails(request));</span><br><span class="line">	    <span class="keyword">return</span> auth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SecurityContextPersistenceFilter"><a href="#SecurityContextPersistenceFilter" class="headerlink" title="SecurityContextPersistenceFilter"></a>SecurityContextPersistenceFilter</h3><pre><code>SecurityContextPersistenceFilter的两个主要作用：</code></pre><ol>
<li>当Request过来时，创建SecurityContext安全上下文信息</li>
<li>当Request结束时，清空SecurityContextHolder。</li>
</ol>
<h2 id="小节总结："><a href="#小节总结：" class="headerlink" title="小节总结："></a>小节总结：</h2><p>. AbstractAuthenticationProcessingFilter:主要处理登录<br>. FilterSecurityInterceptor:主要处理鉴权</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Security</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data ElasticSearch</title>
    <url>/2021/01/31/SpringDataElasticSearch/</url>
    <content><![CDATA[<h1 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h1><h2 id="Spring-Data-ElasticSearch-入门案例"><a href="#Spring-Data-ElasticSearch-入门案例" class="headerlink" title="Spring Data ElasticSearch 入门案例"></a>Spring Data ElasticSearch 入门案例</h2><p>Spring Data 和 Elasticsearch 结合的时候，唯一需要注意的是版本之间的兼容性问题，Elasticsearch 和 Spring Boot 是同时向前发展的，而 Elasticsearch 的大版本之间还存在一定的 API 兼容性问题，所以必须要知道这些版本之间的关系，表格如下：</p>
<table>
<thead>
<tr>
<th align="center">Spring Data Release Train</th>
<th align="center">Spring Data Elasticsearch</th>
<th align="center">Elasticsearch</th>
<th align="center">Spring Boot</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2020.0.0<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1">[1]</a></td>
<td align="center">4.1.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1">[1]</a></td>
<td align="center">7.9.3</td>
<td align="center">2.4.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_1">[1]</a></td>
</tr>
<tr>
<td align="center">Neumann</td>
<td align="center">4.0.x</td>
<td align="center">7.6.2</td>
<td align="center">2.3.x</td>
</tr>
<tr>
<td align="center">Moore</td>
<td align="center">3.2.x</td>
<td align="center">6.8.12</td>
<td align="center">2.2.x</td>
</tr>
<tr>
<td align="center">Lovelace</td>
<td align="center">3.1.x</td>
<td align="center">6.2.2</td>
<td align="center">2.1.x</td>
</tr>
<tr>
<td align="center">Kay<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=490#/detail/pc?id=4731">[2]</a></td>
<td align="center">3.0.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_2">[2]</a></td>
<td align="center">5.5.0</td>
<td align="center">2.0.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_2">[2]</a></td>
</tr>
<tr>
<td align="center">Ingalls<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_2">[2]</a></td>
<td align="center">2.1.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_2">[2]</a></td>
<td align="center">2.4.0</td>
<td align="center">1.5.x<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#_footnotedef_2">[2]</a></td>
</tr>
</tbody></table>
<p>由于版本越新越便利，所以一般情况下直接采用最新的版本。</p>
<p><strong>第一步：利用 Helm Chart 安装一个 Elasticsearch 集群 7.9.3 版本</strong>，执行命令如下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. helm2 repo add elastic https://helm.elastic.co</span><br><span class="line">2. helm2 install --name myelasticsearch elastic/elasticsearch  --set imageTag=7.9.3</span><br></pre></td></tr></table></figure>

<p>安装完之后，就可以看到如下信息。</p>
<p><img src="http://image.leonote.cn//20210131155146.jpg" alt=""></p>
<p>这代表安装成功。</p>
<p>由于 ElasticSearch 是发展变化的，所以它的安装方式可以参考<a href="https://github.com/elastic/helm-charts/tree/master/elasticsearch">官方文档</a></p>
<p>然后利用 k8s 集群端口映射到本地，就可以开始测试了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~ ❯❯❯ kubectl port-forward svc/elasticsearch-master 9200:9200 -n my-namespace</span><br><span class="line">Forwarding from 127.0.0.1:9200 -&gt; 9200</span><br><span class="line">Forwarding from [::1]:9200 -&gt; 9200</span><br></pre></td></tr></table></figure>

<p><strong>第二步：在 gradle.build 里面配置 Spring Data ElasticSearch 依赖的 Jar 包。</strong></p>
<p>依赖 Spring Boot 2.4.1 版本，完整的 gradle.build 文件如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">&#x27;org.springframework.boot&#x27;</span> version <span class="string">&#x27;2.4.1&#x27;</span></span><br><span class="line">   id <span class="string">&#x27;io.spring.dependency-management&#x27;</span> version <span class="string">&#x27;1.0.10.RELEASE&#x27;</span></span><br><span class="line">   id <span class="string">&#x27;java&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">group = <span class="string">&#x27;com.example.data.es&#x27;</span></span><br><span class="line">version = <span class="string">&#x27;0.0.1-SNAPSHOT&#x27;</span></span><br><span class="line">sourceCompatibility = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">configurations &#123;</span><br><span class="line">   compileOnly &#123;</span><br><span class="line">      extendsFrom annotationProcessor</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">   mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">   implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-actuator&#x27;</span></span><br><span class="line">   implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-elasticsearch&#x27;</span></span><br><span class="line">   implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">   compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">   developmentOnly <span class="string">&#x27;org.springframework.boot:spring-boot-devtools&#x27;</span></span><br><span class="line">   runtimeOnly <span class="string">&#x27;io.micrometer:micrometer-registry-prometheus&#x27;</span></span><br><span class="line">   annotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">   testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test &#123;</span><br><span class="line">   useJUnitPlatform()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：新建一个目录，结构如下图所示，方便我们测试。</strong></p>
<p><img src="http://image.leonote.cn//20210131155436.jpg" alt=""></p>
<p><strong>第四步：在 application.properties 里面新增 es 的连接地址，连接本地的 Elasticsearch。</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.elasticsearch.client.reactive.endpoints</span>=<span class="string">127.0.0.1:9200</span></span><br></pre></td></tr></table></figure>

<p><strong>第五步：新增一个 ElasticSearchConfiguration 的配置文件，主要是为了开启扫描的包。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo.es;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.config.EnableElasticsearchRepositories;</span><br><span class="line"><span class="comment">//利用@EnableElasticsearchRepositories注解指定Elasticsearch相关的Repository的包路径在哪里</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(basePackages = &quot;com.example.data.es.demo.es&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第六步：新增一个 Topic 的 Document，它类似 JPA 里面的实体，用来保存和读取 Topic 的数据</strong>，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo.es;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;topic&quot;)</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="comment">//论坛主题信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field(type = FieldType.Nested, includeInParent = true)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Author&gt; authors;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.data.es.demo.es;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="comment">//作者信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第七步：新建一个 Elasticsearch 的 Repository，用来对 Elasticsearch 索引的增删改查</strong>，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo.es;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//类似JPA一样直接操作Topic类型的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TopicRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Topic</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Topic&gt; <span class="title">findByTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第八步: 新建一个 Controller，对 Topic 索引进行查询和添加。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> TopicRepository topicRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询topic的所有索引</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;topics&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Topic&gt; <span class="title">query</span><span class="params">(<span class="meta">@Param(&quot;title&quot;)</span> String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topicRepository.findByTitle(title);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存 topic索引</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;topics&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Topic <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> Topic topic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> topicRepository.save(topic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第九步：发送一个添加和查询的请求测试一下。</strong></p>
<p>发送三个 POST 请求，添加三条索引，代码如下所示。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/topics</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8080</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>d9cc1f6c-24dd-17ff-f2e8-3063fa6b86fc</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:&quot;jack&quot;,</span><br><span class="line">    &quot;id&quot;:2,</span><br><span class="line">    &quot;authors&quot;:[&#123;</span><br><span class="line">        &quot;name&quot;:&quot;jk1&quot;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;jk2&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后发送一个 get 请求，获得标题是 jack 的索引，如下面这行代码所示。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/topics?title=jack</span><br></pre></td></tr></table></figure>

<p>得到如下结果。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://127.0.0.1:8080/topics?title=jack</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span><span class="punctuation">: </span>chunked</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Wed, 30 Dec 2020 15:12:16 GMT</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=60</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 1,</span><br><span class="line">    &quot;title&quot;: &quot;jack&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk2&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 3,</span><br><span class="line">    &quot;title&quot;: &quot;jack&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk2&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: 2,</span><br><span class="line">    &quot;title&quot;: &quot;jack&quot;,</span><br><span class="line">    &quot;authors&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk1&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;jk2&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 348ms; Content length: 199 bytes</span><br><span class="line">Cannot preserve cookies, cookie storage file is included in ignored list:</span><br><span class="line">&gt; /Users/jack/Company/git_hub/spring-data-jpa-guide/2.3/elasticsearch-data/.idea/httpRequests/http-client.cookies</span><br></pre></td></tr></table></figure>

<p>使用 Spring Data Elasticsearch 来操作 ES 相关的 API 的话，比直接写 Http 的 client 要简单很多，因为这里面封装了很多基础逻辑，省去了很多重复造轮子的过程。</p>
<p><strong>第十步：Elasticsearch Repository 的测试用例写法</strong>，如下面的代码和注释所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo;</span><br><span class="line"><span class="keyword">import</span> com.example.data.es.demo.es.Author;</span><br><span class="line"><span class="keyword">import</span> com.example.data.es.demo.es.Topic;</span><br><span class="line"><span class="keyword">import</span> com.example.data.es.demo.es.TopicRepository;</span><br><span class="line"><span class="keyword">import</span> org.assertj.core.util.Lists;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.TestPropertySource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;&quot;logging.level.org.springframework.data.elasticsearch.core=TRACE&quot;, &quot;logging.level.org.springframework.data.elasticsearch.client=trace&quot;, &quot;logging.level.org.elasticsearch.client=TRACE&quot;, &quot;logging.level.org.apache.http=TRACE&quot;&#125;)</span><span class="comment">//新增一些配置， 开启spring data elastic search的http的调用过程，可以查看一下日志</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchRepositoryTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> TopicRepository topicRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        topicRepository.deleteAll(); //可以直接删除所有索引</span></span><br><span class="line">        Topic topic = Topic.builder().id(<span class="number">11L</span>)</span><br><span class="line">            						.title(<span class="string">&quot;jacktest&quot;</span>)</span><br><span class="line">            						.authors(Lists.newArrayList(Author.builder()</span><br><span class="line">                                                                .name(<span class="string">&quot;jk1&quot;</span>)</span><br><span class="line">                                                                .build()))</span><br><span class="line">            						.build();</span><br><span class="line">        topicRepository.save(topic);<span class="comment">//集成测试保存索引</span></span><br><span class="line">        Topic topic1 = Topic.builder().id(<span class="number">14L</span>)</span><br><span class="line">            						 .title(<span class="string">&quot;jacktest&quot;</span>)</span><br><span class="line">            					 	 .authors(Lists.newArrayList(Author.builder()</span><br><span class="line">                                        .name(<span class="string">&quot;jk1&quot;</span>)</span><br><span class="line">                                        .build()))</span><br><span class="line">            						 .build();</span><br><span class="line">        topicRepository.save(topic1);</span><br><span class="line">        Topic topic2 = Topic.builder().id(<span class="number">15L</span>)</span><br><span class="line">            						 .title(<span class="string">&quot;jacktest&quot;</span>)</span><br><span class="line">            						 .authors(Lists.newArrayList(Author.builder()</span><br><span class="line">                                        .name(<span class="string">&quot;jk1&quot;</span>)</span><br><span class="line">                                        .build()))</span><br><span class="line">            						 .build();</span><br><span class="line">        topicRepository.save(topic2);<span class="comment">//保存索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterable&lt;Topic&gt; topics = topicRepository.findAll();</span><br><span class="line">        topics.forEach(topic1 -&gt; &#123;</span><br><span class="line">            System.out.println(topic1);</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Topic&gt; topicList = topicRepository.findByTitle(<span class="string">&quot;jacktest&quot;</span>);</span><br><span class="line">        topicList.forEach(t -&gt; &#123;</span><br><span class="line">            System.out.println(t);<span class="comment">//获得索引的查询结果</span></span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;Topic&gt; topicList2 = topicRepository.findByTitle(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        topicList2.forEach(t -&gt; &#123;</span><br><span class="line">            System.out.println(t);<span class="comment">//也可以用断言测试</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下测试用例的调用日志，从日志可以看出，调用的时候发生的 Http 的 PUT 请求，是用来创建和修改一个索引的文档的。请看下面的图片。</p>
<p><img src="http://image.leonote.cn//20210131160243.jpg" alt=""></p>
<p>从中也可以看得出来，转化成 es 的 api 查询语法之后，发送的 post 请求又变成下图显示的样子。</p>
<p><img src="http://image.leonote.cn//20210131160331.jpg" alt=""></p>
<h2 id="Spring-Data-ElasticSearch-关键的类"><a href="#Spring-Data-ElasticSearch-关键的类" class="headerlink" title="Spring Data ElasticSearch 关键的类"></a>Spring Data ElasticSearch 关键的类</h2><p>通过上面的案例可以知道，Spring Data ElasticSearch 的用法其实非常简单，并且通过日志也可以看到，底层实现是基于 http 请求，来操作 Elasticsearch 的 server 中的 api 进行的。</p>
<p>那么简单看一下这一框架还提供了哪些 ElasticSearch 的操作方法。看一下 Repository 的所有子类，如下图所示：</p>
<p><img src="http://image.leonote.cn//20210131160632.jpg" alt=""></p>
<p>从图中可以看得出来，<code>ElasticsearchRepository</code> 是默认的 Repository 的实现类，如果继续往下面看源码的话，就可以看到里面进行了很多 ES 的 Http Client 操作。</p>
<p>同时再看一下 Structure 视图，如下所示。</p>
<p><img src="http://image.leonote.cn//20210131160716.jpg" alt=""></p>
<p>从这张图可以知道，<code>ElasticsearchRepository</code> 默认提供了 search 和 index 相关的一些操作方法，并且 Spring Data Common 里面的一些公共方法同样适用，这和刚才演示的 Defining Method Query 的 JPA 语法同样适用，可以大大减轻操作 ES 的难度，提高了开发的效率，甚至像分页、排序、limit 等同样适用。</p>
<p>和 Spring Data JPA 用相同的思路，就可以很快掌握 Spring Data Elasticsearch 的基本用法，及其大概的实现思路。</p>
<h2 id="ESRepository-和-JPARepository-同时存在"><a href="#ESRepository-和-JPARepository-同时存在" class="headerlink" title="ESRepository 和 JPARepository 同时存在"></a>ESRepository 和 JPARepository 同时存在</h2><p>假设刚才测试的样例里面，同时有关于 User 信息的 DB 操作，那么项目应该怎么写。</p>
<p><strong>第一步：将对 Elasticsearch 的实体、Repository 和对 JPA 操作的实体、Repository 放到不同的文件里面</strong>，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131160920.jpg" alt=""></p>
<p><strong>第二步：新增 JpaConfiguration，用来指定 Jpa 相关的 Repository 目录</strong>，完整代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo.jpa;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"><span class="comment">//利用 @EnableJpaRepositories 指定JPA的目录是 &quot;com.example.data.es.demo.jpa&quot;</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.example.data.es.demo.jpa&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：新增 User 实体，用来操作用户基本信息。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四步：新增 UserRepository，用来进行 DB 操作。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo.jpa;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="comment">//对User的DB操作，直接继承JpaRepository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：写测试用例进行测试。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.data.es.demo;</span><br><span class="line"><span class="keyword">import</span> com.example.data.es.demo.jpa.User;</span><br><span class="line"><span class="keyword">import</span> com.example.data.es.demo.jpa.UserRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用@DataJpaTest完成集成测试</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//往数据库里面保存一条数据，并且打印一下</span></span><br><span class="line">        userRepository.save(User.builder().id(<span class="number">1L</span>)</span><br><span class="line">                            .name(<span class="string">&quot;jkdb&quot;</span>)</span><br><span class="line">                            .email(<span class="string">&quot;jack@email.com&quot;</span>)</span><br><span class="line">                            .build());</span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">        users.forEach(user -&gt; &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，测试用例就变成了如下图所示的结构。</p>
<p><img src="http://image.leonote.cn//20210131161203.jpg" alt=""></p>
<p>JPA 和 Elasticsearch 同时存在，和启动项目是一样的效果，这里就不写 Controller 了。</p>
<p>再整体运行一下这三个测试用例，进行完整的测试，就可以看到如下结果。</p>
<ol>
<li><p><code>ElasticSearchRepositoryTest</code> 执行的时候，通过日志可以看到这是对 ES 进行的操作，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131161259.jpg" alt=""></p>
</li>
<li><p><code>UserRepositoryTest</code> 执行的时候，通过日志可以看出来这是对 DB 进行的操作，所以谁也不影响谁，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131161344.jpg" alt=""></p>
</li>
</ol>
<p>   Spring Data 对 JPA 等 SQL 型的传统数据库的支持是非常好的，同时对 NoSQL 型的非关系类数据库的支持也比较友好，大大降低了操作不同数据源的难度，可以有效提升开发效率。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data ElasticSearch</category>
      </categories>
      <tags>
        <tag>Spring Data ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>PlantUML语法</title>
    <url>/2020/09/21/PlantUML%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="PlantUML语法"><a href="#PlantUML语法" class="headerlink" title="PlantUML语法"></a>PlantUML语法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://plantuml.com/">官方站点</a></p>
<ol>
<li>需要 java 环境。</li>
<li>需要安装 <a href="http://www.graphviz.org/">Graphviz</a> 依赖</li>
<li>下载 <a href="http://plantuml.com/download">plantuml</a></li>
</ol>
<h2 id="使用-IDEA-来创建和预览"><a href="#使用-IDEA-来创建和预览" class="headerlink" title="使用 IDEA 来创建和预览"></a>使用 IDEA 来创建和预览</h2><ol>
<li>下载 <a href="https://www.jetbrains.com/zh-cn/idea/download/">IDEA</a> 编辑器</li>
<li>打开 Plugins 搜索 “plantuml”，选中 PlantUML integration，点击安装即可</li>
<li>配置 PlantUML </li>
</ol>
<p><img src="http://image.leonote.cn/20200921160019.png" alt=""></p>
<h2 id="脚本语法"><a href="#脚本语法" class="headerlink" title="脚本语法"></a>脚本语法</h2><p>puml 是脚本语言，是按照换行来识别语法的。</p>
<p>一般的表达语句为:</p>
<ol>
<li><p><code>节点  连接符号  节点</code></p>
</li>
<li><p><code>关键字  节点或内容</code></p>
</li>
<li><pre><code class="uml">开始关键字
  内容
结束关键字
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注意**空格**等非字符作为节点内容的使用，有些多关键字语句中需要使用**双引号**来包含带空格的语句</span><br><span class="line"></span><br><span class="line">### 活动图 ( Activity Diagram )</span><br><span class="line"></span><br><span class="line">#### Simple Activity</span><br><span class="line"></span><br><span class="line">语法是 &#96;: 节点 ;&#96; 结束</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;plantuml</span><br><span class="line">@startuml</span><br><span class="line">title act_new_1</span><br><span class="line">:步骤一;</span><br><span class="line">:此处有个支持简单的 mark 语法 **加粗字体**;</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p><img src="http://image.leonote.cn//20200921184659.png" alt=""></p>
<h4 id="Start-Stop-开始和结束"><a href="#Start-Stop-开始和结束" class="headerlink" title="Start / Stop 开始和结束"></a>Start / Stop 开始和结束</h4><p>开始位置为 start 开始，stop 停止，end 结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_2</span><br><span class="line">start</span><br><span class="line">:步骤一;</span><br><span class="line">:mark 语法 **加粗字体**;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921184843.png" alt=""></p>
<h4 id="Conditional-条件语句"><a href="#Conditional-条件语句" class="headerlink" title="Conditional 条件语句"></a>Conditional 条件语句</h4><p>控制语句的使用，注意内容 <code>()</code> 的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_3</span><br><span class="line">start</span><br><span class="line">if (是否已下载 graphviz?) then (是)</span><br><span class="line">    :执行 \ndiagrams;</span><br><span class="line">else (否)</span><br><span class="line">    :需要下载 graphviz 后才能执行</span><br><span class="line">    __activity__ diagrams;</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921184945.png" alt=""></p>
<h4 id="Repeat-loop-循环处理（控制语句）"><a href="#Repeat-loop-循环处理（控制语句）" class="headerlink" title="Repeat loop 循环处理（控制语句）"></a>Repeat loop 循环处理（控制语句）</h4><p>使用关键字 <code>repeat</code>，<code>repeat while ()</code> 来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_4</span><br><span class="line">start</span><br><span class="line">repeat</span><br><span class="line">    :读取文件;</span><br><span class="line">    :编译 diagrams;</span><br><span class="line">repeat while (更多，执行下一个?)</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921192651.png" alt=""></p>
<h4 id="While-loop-循环控制"><a href="#While-loop-循环控制" class="headerlink" title="While loop 循环控制"></a>While loop 循环控制</h4><p>使用 <code>while</code> <code>endwhile</code> 循环控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_5</span><br><span class="line">start</span><br><span class="line">while (执行条件允许文件存在?)</span><br><span class="line">    :读取文件;</span><br><span class="line">    :编译 diagrams;</span><br><span class="line">endwhile</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921192834.png" alt=""></p>
<p>可以追加标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_6</span><br><span class="line">start</span><br><span class="line">:打开文件;</span><br><span class="line">while (检查文件大小 ?) is (有内容)</span><br><span class="line">    :读取文件;</span><br><span class="line">    :编译 dia;</span><br><span class="line">endwhile (空)</span><br><span class="line">:关闭文件;</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193035.png" alt=""></p>
<h4 id="Parallel-processing-并行处理"><a href="#Parallel-processing-并行处理" class="headerlink" title="Parallel processing 并行处理"></a>Parallel processing 并行处理</h4><p>使用 <code>fork</code> 关键字创建并行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_7</span><br><span class="line">start</span><br><span class="line">if (multiprocessor?) then (yes)</span><br><span class="line">  fork</span><br><span class="line">    :Treatment 1;</span><br><span class="line">  fork again</span><br><span class="line">    :Treatment 2;</span><br><span class="line">  end fork</span><br><span class="line">else (monoproc)</span><br><span class="line">  :Treatment 1;</span><br><span class="line">  :Treatment 2;</span><br><span class="line">endif</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193139.png" alt=""></p>
<h4 id="Notes-注释"><a href="#Notes-注释" class="headerlink" title="Notes 注释"></a>Notes 注释</h4><ul>
<li>单行注释使用 <code>note right|left 内容</code>，注意后面没有分号</li>
<li>多行注释使用 <code>note right|left 换行 内容 换行 end note</code>的方式处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_8</span><br><span class="line">start</span><br><span class="line">: 步骤1;</span><br><span class="line">note left: This is a __NOTE__</span><br><span class="line">: 步骤2;</span><br><span class="line">note right</span><br><span class="line">    支持 mark 编辑语法</span><br><span class="line">    This note is on several</span><br><span class="line">    &#x2F;&#x2F;lines&#x2F;&#x2F; and can</span><br><span class="line">    contain &lt;b&gt;HTML&lt;&#x2F;b&gt;</span><br><span class="line">    &#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    * Calling the method &quot;&quot;foo()&quot;&quot; is prohibited</span><br><span class="line">end note</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193326.png" alt=""></p>
<p>注意 mark 并非 Markdown 语法，以案例为 b</p>
<h4 id="Color-颜色"><a href="#Color-颜色" class="headerlink" title="Color 颜色"></a>Color 颜色</h4><p>在冒号钱可以追加 <code>#十六进制</code> 的颜色编号或者名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_9</span><br><span class="line">start</span><br><span class="line">:进程开始;</span><br><span class="line">#red:试着读取文件</span><br><span class="line">文件必须有可写权限!;</span><br><span class="line">#AAAAAA:结束进程;</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193453.png" alt=""></p>
<h4 id="Complete-example-案例"><a href="#Complete-example-案例" class="headerlink" title="Complete example 案例"></a>Complete example 案例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title act_new_10</span><br><span class="line">start</span><br><span class="line">:ClickServlet.handleRequest();</span><br><span class="line">:new page;</span><br><span class="line">if (Page.onSecurityCheck) then (true)</span><br><span class="line">    #7c7c7c:Page.onInit();</span><br><span class="line">    if (isForward?) then (no)</span><br><span class="line">    #red:Process controls;</span><br><span class="line">    if (continue processing?) then (no)</span><br><span class="line">        stop</span><br><span class="line">    endif</span><br><span class="line">    if (isPost?) then (yes)</span><br><span class="line">        :Page.onPost();</span><br><span class="line">    else (no)</span><br><span class="line">        :Page.onGet();</span><br><span class="line">    endif</span><br><span class="line">    :Page.onRender();</span><br><span class="line">    endif</span><br><span class="line">else (false)</span><br><span class="line">endif</span><br><span class="line">if (do redirect?) then (yes)</span><br><span class="line">    :redirect process;</span><br><span class="line">else</span><br><span class="line">    if (do forward?) then (yes)</span><br><span class="line">    :Forward request;</span><br><span class="line">    else (no)</span><br><span class="line">    :Render page template;</span><br><span class="line">    endif</span><br><span class="line">endif</span><br><span class="line">stop</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193617.png" alt=""></p>
<h3 id="时序图-Sequence-Diagram"><a href="#时序图-Sequence-Diagram" class="headerlink" title="时序图 ( Sequence Diagram )"></a>时序图 ( Sequence Diagram )</h3><p>基本语法</p>
<ol>
<li>使用 <code>节点 -&gt; 节点: 描述</code> -&gt; 为实线</li>
<li>如果使用虚线则 用 <code>--&gt;</code></li>
<li>箭头的方向可以是双向的 <code>节点 &lt;-- 节点</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_1</span><br><span class="line">用户 -&gt; 平台: 发送登录请求</span><br><span class="line">平台 --&gt; 用户: 验证通过</span><br><span class="line">用户 -&gt; 平台: 另一个请求</span><br><span class="line">用户 &lt;-- 平台: 返回验证消息</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921193759.png" alt=""></p>
<h4 id="Comments-注释"><a href="#Comments-注释" class="headerlink" title="Comments 注释"></a>Comments 注释</h4><p>内部注释使用 <code>&#39;</code> 单引号来开始 单行注释， 多行注释则使用 <code>/&#39;</code> 和 <code>&#39;/</code> 包括</p>
<h4 id="Declaring-participant-（角色）"><a href="#Declaring-participant-（角色）" class="headerlink" title="Declaring participant （角色）"></a>Declaring participant （角色）</h4><p>提供了的声明参加者 (角色)，来丰富图形，默认情况下在箭头两边的已经隐式声明了( participant )，也可以使用 <code>participant 节点</code> 来显示声明角色，这种状况主要是为了声明角色的顺序。</p>
<ul>
<li>actor</li>
<li>boundary</li>
<li>control</li>
<li>entity</li>
<li>database</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_2</span><br><span class="line">actor Foo1</span><br><span class="line">boundary Foo2</span><br><span class="line">control Foo3</span><br><span class="line">entity Foo4</span><br><span class="line">database Foo5</span><br><span class="line">Foo1 -&gt; Foo2 : To boundary</span><br><span class="line">Foo1 -&gt; Foo3 : To control</span><br><span class="line">Foo1 -&gt; Foo4 : To entity</span><br><span class="line">Foo1 -&gt; Foo5 : To database</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194112.png" alt=""></p>
<p>追加色彩案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_3</span><br><span class="line">actor 客户 #red</span><br><span class="line">&#39; 声明角色的时候在后面可以追加颜色</span><br><span class="line">&#39; 注释内容并不会显示</span><br><span class="line">&#39; The only difference between actor</span><br><span class="line">&#39; and participant is the drawing</span><br><span class="line">participant 服务端</span><br><span class="line">participant &quot;I have a really\nlong name&quot; as L #99FF99</span><br><span class="line">&#x2F;&#39;  这里使用 &#96;as&#96; 关键字声明了 L 来作为别名</span><br><span class="line">    你也可以这样写:</span><br><span class="line">    participant L as &quot;I have a really\nlong name&quot;  #99FF99</span><br><span class="line">    &#39;&#x2F;</span><br><span class="line">服务端-&gt;客户: 请求认证</span><br><span class="line">客户-&gt;服务端: Authentication Response</span><br><span class="line">客户-&gt;L: Log transaction</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194240.png" alt=""></p>
<h4 id="Use-non-letters-in-participants-非字符处理"><a href="#Use-non-letters-in-participants-非字符处理" class="headerlink" title="Use non-letters in participants 非字符处理"></a>Use non-letters in participants 非字符处理</h4><p>在声明非字母的角色的时候使用双引号处理 (包含空格)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_4</span><br><span class="line">服务端 -&gt; &quot;客户()&quot; : Hello</span><br><span class="line">&quot;客户()&quot; -&gt; &quot;This is very\nlong&quot; as Long</span><br><span class="line">&#39; You can also declare:</span><br><span class="line">&#39; &quot;客户()&quot; -&gt; Long as &quot;This is very\nlong&quot;</span><br><span class="line">Long --&gt; &quot;客户()&quot; : ok</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194357.png" alt=""></p>
<h4 id="Message-to-Self"><a href="#Message-to-Self" class="headerlink" title="Message to Self"></a>Message to Self</h4><p>在介绍过长的内容的时候使用 <code>\n</code> 来换行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_5</span><br><span class="line">服务端-&gt;服务端: This is a signal to self.\nIt also demonstrates\nmultiline \ntext</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194508.png" alt=""></p>
<h4 id="Change-arrow-style-箭头样式"><a href="#Change-arrow-style-箭头样式" class="headerlink" title="Change arrow style 箭头样式"></a>Change arrow style 箭头样式</h4><p>在时序图中可以使用多种样式，基于下面的案例，来替换默认的箭头</p>
<blockquote>
<p>总体来说 <code>-</code> 表示实线， <code>--</code> 标识虚线<br>而在在两边的标识箭头的方向和样式</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_6</span><br><span class="line">客户 -&gt; 服务端</span><br><span class="line">客户 -&gt;&gt; 服务端</span><br><span class="line">客户 -\ 服务端</span><br><span class="line">客户 \\- 服务端</span><br><span class="line">客户 &#x2F;&#x2F;-- 服务端</span><br><span class="line">客户 -&gt;o 服务端</span><br><span class="line">客户 o\\-- 服务端</span><br><span class="line">客户 &lt;-&gt; 服务端</span><br><span class="line">客户 &lt;-&gt;o 服务端</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194637.png" alt=""></p>
<h4 id="Change-arrow-color-箭头色彩"><a href="#Change-arrow-color-箭头色彩" class="headerlink" title="Change arrow color 箭头色彩"></a>Change arrow color 箭头色彩</h4><p>使用关键字 <code>autonumber</code> 来自动为消息生成索引数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_8</span><br><span class="line">autonumber</span><br><span class="line">客户 -&gt; 服务端 : 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194722.png" alt=""></p>
<p>在 <code>autonumber</code> 后可以设定 <code>开始位置 梯度</code> 参数<br>在默认情况下 <code>autonumber</code> 自动追加了 <code>start</code> 参数， 在使用 <code>stop</code> 参数可以停止计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_9</span><br><span class="line">autonumber</span><br><span class="line">客户 -&gt; 服务端 : 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Authentication Response</span><br><span class="line">autonumber stop</span><br><span class="line">客户 &lt;- 服务端 : 停止</span><br><span class="line">autonumber 15</span><br><span class="line">客户 -&gt; 服务端 : Another 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Another authentication Response</span><br><span class="line">autonumber 40 10</span><br><span class="line">客户 -&gt; 服务端 : Yet another 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Yet another authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921194933.png" alt=""></p>
<p>你也可以对数字进行格式化输出，为 <code>autonumber</code> 追加格式化使用单引号 <code>&quot;格式&quot;</code> ，内部可以使用 HTML 标记，可以参看后面的 Formatting using HTML </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_10</span><br><span class="line">autonumber &quot;&lt;b&gt;[000]&lt;&#x2F;b&gt;&quot;</span><br><span class="line">客户 -&gt; 服务端 : 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Authentication Response</span><br><span class="line">autonumber 15 &quot;&lt;b&gt;(&lt;u&gt;###&lt;&#x2F;u&gt;)&quot;</span><br><span class="line">客户 -&gt; 服务端 : Another 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Another authentication Response</span><br><span class="line">autonumber 40 10 &quot;&lt;font color&#x3D;red&gt;&lt;b&gt;Message 0  &quot;</span><br><span class="line">客户 -&gt; 服务端 : Yet another 请求认证</span><br><span class="line">客户 &lt;- 服务端 : Yet another authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921195056.png" alt=""></p>
<h4 id="Splitting-diagrams-分割为多个图形"><a href="#Splitting-diagrams-分割为多个图形" class="headerlink" title="Splitting diagrams 分割为多个图形"></a>Splitting diagrams 分割为多个图形</h4><p>关键字 <code>newpage</code> 可以将同一张图形分割为多个图，可以追加 标题参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_11</span><br><span class="line">服务端 -&gt; 客户 : message 1</span><br><span class="line">服务端 -&gt; 客户 : message 2</span><br><span class="line">newpage</span><br><span class="line">服务端 -&gt; 客户 : message 3</span><br><span class="line">服务端 -&gt; 客户 : message 4</span><br><span class="line">newpage 第三章的标题\n最后一页</span><br><span class="line">服务端 -&gt; 客户 : message 5</span><br><span class="line">服务端 -&gt; 客户 : message 6</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921195943.png" alt=""></p>
<h4 id="Grouping-message-分组消息"><a href="#Grouping-message-分组消息" class="headerlink" title="Grouping message 分组消息"></a>Grouping message 分组消息</h4><p>提供了一下几组关键词</p>
<ul>
<li>alt/else</li>
<li>opt</li>
<li>loop</li>
<li>par</li>
<li>break</li>
<li>critical</li>
<li>group, followed by a text to be displayed</li>
</ul>
<p>关键词后可以追加文本，来作为副标题<br>使用 <code>end</code> 关键词来表示结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_12</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">alt 成功</span><br><span class="line">    客户 -&gt; 服务端: 许可认证</span><br><span class="line">else 可识别的正常失败</span><br><span class="line">    客户 -&gt; 服务端: 认证失败</span><br><span class="line">    group 组名称</span><br><span class="line">        服务端 -&gt;  日志:  attack start</span><br><span class="line">        loop 1000 times</span><br><span class="line">            服务端 -&gt; 客户: DNS Attack</span><br><span class="line">        end</span><br><span class="line">        服务端 -&gt;  日志: Log attack end</span><br><span class="line">    end</span><br><span class="line">else  其他失败</span><br><span class="line">   客户 -&gt; 服务端: 重新请求</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200044.png" alt=""></p>
<h4 id="Notes-on-messages"><a href="#Notes-on-messages" class="headerlink" title="Notes on messages"></a>Notes on messages</h4><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note right:  右侧的内容</span><br><span class="line">note left:  右侧的内容</span><br></pre></td></tr></table></figure>

<h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">note right:</span><br><span class="line">多行内容</span><br><span class="line">end note</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_13</span><br><span class="line">服务端-&gt;客户 : hello</span><br><span class="line">note left: this is a first note</span><br><span class="line">客户-&gt;服务端 : ok</span><br><span class="line">note right: this is another note</span><br><span class="line">客户-&gt;客户 : I am thinking</span><br><span class="line">note left</span><br><span class="line">    a note</span><br><span class="line">    can also be defined</span><br><span class="line">    on several lines</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200217.png" alt=""></p>
<h4 id="Some-other-notes"><a href="#Some-other-notes" class="headerlink" title="Some other notes"></a>Some other notes</h4><p><code>of</code>，<code>over</code> 后跟上角色（参与者），可以管理，其中 <code>over</code> 可以覆盖在线上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_14</span><br><span class="line">participant 服务端</span><br><span class="line">participant 客户</span><br><span class="line">note left of 服务端 #aqua</span><br><span class="line">    显示</span><br><span class="line">    左侧 of 服务端.</span><br><span class="line">end note</span><br><span class="line">note right of 服务端: 显示在右侧 of 服务端.</span><br><span class="line">note over 服务端: over 注释覆盖在服务端.</span><br><span class="line">note over 服务端, 客户 #FFAAAA: 注释\n 覆盖在 客户 和 服务端.</span><br><span class="line">note over 客户, 服务端</span><br><span class="line">    This is yet another</span><br><span class="line">    example of</span><br><span class="line">    a long note.</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200340.png" alt=""></p>
<h4 id="Formatting-using-HTML"><a href="#Formatting-using-HTML" class="headerlink" title="Formatting using HTML"></a>Formatting using HTML</h4><p>使用类 html-tag：</p>
<ul>
<li><code>&lt;b&gt;</code> 来加粗字体</li>
<li><code>&lt;u&gt;</code> or <code>&lt;u:#AAAAAA&gt;</code> or <code>&lt;u:colorName&gt;</code> 输出下划线</li>
<li><code>&lt;i&gt;</code> 斜体字输出</li>
<li><code>&lt;s&gt;</code> or <code>&lt;s:#AAAAAA&gt;</code> or <code>&lt;s:colorName&gt;</code> for strike text</li>
<li><code>&lt;w&gt; or</code>&lt;w:#AAAAAA&gt;<code>or</code>&lt;w:colorName&gt;` for wave underline text</li>
<li><code>&lt;color:#AAAAAA&gt;</code> or <code>&lt;color:colorName&gt;</code></li>
<li><code>&lt;back:#AAAAAA&gt;</code> or <code>&lt;back:colorName&gt;</code> for background color</li>
<li>`<a href="size:nn">size:nn</a> to change font size</li>
<li><code>&lt;img src=&quot;file&quot;&gt;</code> or <code>&lt;img:file&gt;</code> : the file must be accessible by the filesystem</li>
<li><code>&lt;img src=&quot;http://url&quot;&gt;</code> or <code>&lt;img:http://url&gt;</code> : the URL must be available from the Internet</li>
</ul>
<p><strong>example</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_15</span><br><span class="line">participant 服务端</span><br><span class="line">participant &quot;The &lt;b&gt;Famous&lt;&#x2F;b&gt; 客户&quot; as 客户</span><br><span class="line">服务端 -&gt; 客户 : A &lt;i&gt;well formated&lt;&#x2F;i&gt; message</span><br><span class="line">note right of 服务端</span><br><span class="line"> This is &lt;back:cadetblue&gt;&lt;size:18&gt;displayed&lt;&#x2F;size&gt;&lt;&#x2F;back&gt;</span><br><span class="line"> &lt;u&gt;left of&lt;&#x2F;u&gt; 服务端.</span><br><span class="line">end note</span><br><span class="line">note left of 客户</span><br><span class="line"> &lt;u:red&gt;This&lt;&#x2F;u&gt; is &lt;color #118888&gt;displayed&lt;&#x2F;color&gt;</span><br><span class="line"> &lt;b&gt;&lt;color purple&gt;left of&lt;&#x2F;color&gt; &lt;s:red&gt;服务端&lt;&#x2F;strike&gt; 客户&lt;&#x2F;b&gt;.</span><br><span class="line">end note</span><br><span class="line">note over 服务端, 客户</span><br><span class="line"> &lt;w:#FF33FF&gt;This is hosted&lt;&#x2F;w&gt; by &lt;img http:&#x2F;&#x2F;s.plantuml.com&#x2F;logoc.png&gt;</span><br><span class="line">end note</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200506.png" alt=""></p>
<h4 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h4><p>If you want, you can split a diagram using == separator to divide your diagram into logical steps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_16</span><br><span class="line">&#x3D;&#x3D; Initialisation &#x3D;&#x3D;</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">客户 --&gt; 服务端: Authentication Response</span><br><span class="line">&#x3D;&#x3D; Repetition &#x3D;&#x3D;</span><br><span class="line">服务端 -&gt; 客户: Another 请求认证</span><br><span class="line">服务端 &lt;-- 客户: another authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200612.png" alt=""></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>You can use reference in a diagram, using the keyword ref over</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_17</span><br><span class="line">participant 服务端</span><br><span class="line">actor 客户</span><br><span class="line">ref over 服务端, 客户 : init</span><br><span class="line">服务端 -&gt; 客户 : hello</span><br><span class="line">ref over 客户</span><br><span class="line">  This can be on</span><br><span class="line">  several lines</span><br><span class="line">end ref</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200730.png" alt=""></p>
<h4 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h4><p>You can use … to indicate a delay in the diagram. And it is also possible to put a message with this delay.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_18</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">...</span><br><span class="line">客户 --&gt; 服务端: Authentication Response</span><br><span class="line">...5 minutes latter...</span><br><span class="line">客户 --&gt; 服务端: Bye !</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200821.png" alt=""></p>
<h4 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h4><p>对消息使用空行 <code>|||</code>，也可以自己定义像素高度 <code>||数字||</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_19</span><br><span class="line">服务端 -&gt; 客户: message 1</span><br><span class="line">客户 --&gt; 服务端: ok</span><br><span class="line">|||</span><br><span class="line">服务端 -&gt; 客户: message 2</span><br><span class="line">客户 --&gt; 服务端: ok</span><br><span class="line">||45||</span><br><span class="line">服务端 -&gt; 客户: message 3</span><br><span class="line">客户 --&gt; 服务端: ok</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921200928.png" alt=""></p>
<h4 id="Lifeline-Activation-and-Destruction-生命周期"><a href="#Lifeline-Activation-and-Destruction-生命周期" class="headerlink" title="Lifeline Activation and Destruction 生命周期"></a>Lifeline Activation and Destruction 生命周期</h4><p>使用 <code>activate 角色</code> 表示开始生命周期，使用 <code>destory 角色</code> 标识结束周期</p>
<p>开始和结束必须成对的存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_20</span><br><span class="line">participant User</span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line">A -&gt; B: &lt;&lt; createRequest &gt;&gt;</span><br><span class="line">activate B</span><br><span class="line">B -&gt; C: DoWork</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: WorkDone</span><br><span class="line">destroy C</span><br><span class="line">B --&gt; A: RequestCreated</span><br><span class="line">deactivate B</span><br><span class="line">A -&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921201053.png" alt=""></p>
<p>为进程的生命周期进行标记色彩 ，可以追加色彩参数， 在 plantuml 中色彩使用 #十六进制的色彩值 来表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title seq_21</span><br><span class="line">participant User</span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A #FFBBBB</span><br><span class="line">A -&gt; A: Internal call</span><br><span class="line">activate A #DarkSalmon</span><br><span class="line">A -&gt; B: &lt;&lt; createRequest &gt;&gt;</span><br><span class="line">activate B</span><br><span class="line">B --&gt; A: RequestCreated</span><br><span class="line">deactivate B</span><br><span class="line">deactivate A</span><br><span class="line">A -&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921201142.png" alt=""></p>
<h4 id="Participant-creation"><a href="#Participant-creation" class="headerlink" title="Participant creation"></a>Participant creation</h4><p>You can use the create keyword just before the first reception of a message to emphasize the fact that this message is actually creating this new object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">客户 -&gt; 服务端 : hello</span><br><span class="line">create Other</span><br><span class="line">服务端 -&gt; Other : new</span><br><span class="line">create control String</span><br><span class="line">服务端 -&gt; String</span><br><span class="line">note right : You can also put notes!</span><br><span class="line">服务端 --&gt; 客户 : ok</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="Incoming-and-outgoing-messages"><a href="#Incoming-and-outgoing-messages" class="headerlink" title="Incoming and outgoing messages"></a>Incoming and outgoing messages</h4><p>You can use incoming or outgoing arrows if you want to focus on a part of the diagram. Use square brackets to denotate the left “[“ or the right “]” side of the diagram.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">[-&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line">A -&gt; A: Internal call</span><br><span class="line">activate A</span><br><span class="line">A -&gt;] : &lt;&lt; createRequest &gt;&gt;</span><br><span class="line">A&lt;--] : RequestCreated</span><br><span class="line">deactivate A</span><br><span class="line">[&lt;- A: Done</span><br><span class="line">deactivate A</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921201337.png" alt=""></p>
<h4 id="Stereotypes-and-Spots"><a href="#Stereotypes-and-Spots" class="headerlink" title="Stereotypes and Spots"></a>Stereotypes and Spots</h4><p>It is possible to add stereotypes to participants using &lt;&lt; and &gt;&gt;. In the stereotype, you can add a spotted character in a colored circle using the syntax (X,color)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">participant &quot;Famous 客户&quot; as 客户 &lt;&lt; Generated &gt;&gt;</span><br><span class="line">participant 服务端 &lt;&lt; (C,#ADD1B2) Testable &gt;&gt;</span><br><span class="line">客户-&gt;服务端: First message</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200921201436.png" alt=""></p>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">participant 客户 &lt;&lt; (C,#ADD1B2) &gt;&gt;</span><br><span class="line">participant 服务端 &lt;&lt; (C,#ADD1B2) &gt;&gt;</span><br><span class="line">客户-&gt;服务端: First message</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="More-information-on-titles"><a href="#More-information-on-titles" class="headerlink" title="More information on titles"></a>More information on titles</h4><p>You can use some HTML tags in the title.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title &lt;u&gt;Simple&lt;&#x2F;u&gt; communication example</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">客户 -&gt; 服务端: Authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>You can add newline using \n in the title description.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">title &lt;u&gt;Simple&lt;&#x2F;u&gt; communication example\non several lines</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">客户 -&gt; 服务端: Authentication Response</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<p>You can also define title on several lines using title and end title keywords.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line"> &lt;u&gt;Simple&lt;&#x2F;u&gt; communication example</span><br><span class="line"> on &lt;i&gt;several&lt;&#x2F;i&gt; lines and using &lt;font color&#x3D;red&gt;html&lt;&#x2F;font&gt;</span><br><span class="line"> This is hosted by &lt;img:sourceforge.jpg&gt;</span><br><span class="line">end title</span><br><span class="line"></span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">客户 -&gt; 服务端: Authentication Response</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="7-22-Participants-englober"><a href="#7-22-Participants-englober" class="headerlink" title="7.22. Participants englober"></a>7.22. Participants englober</h4><p>It is possible to draw a box arround some participants, using box and end box commands. You can add an optional title or a optional background color, after the box keyword.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">box &quot;Internal Service&quot; #LightBlue</span><br><span class="line">    participant 客户</span><br><span class="line">    participant 服务端</span><br><span class="line">end box</span><br><span class="line">participant Other</span><br><span class="line">客户 -&gt; 服务端 : hello</span><br><span class="line">服务端 -&gt; Other : hello</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h4 id="7-23-Removing-Footer"><a href="#7-23-Removing-Footer" class="headerlink" title="7.23. Removing Footer"></a>7.23. Removing Footer</h4><p>You can use the hide footbox keywords to remove the footer of the diagram.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">hide footbox</span><br><span class="line">title Footer removed</span><br><span class="line">服务端 -&gt; 客户: 请求认证</span><br><span class="line">客户 --&gt; 服务端: Authentication Response</span><br></pre></td></tr></table></figure>

<p>@enduml</p>
<p>Skinparam</p>
<p>You can use the skinparam command to change colors and fonts for the drawing. You can use this command :</p>
<p>In the diagram definition, like any other commands, In an included file, In a configuration file, provided in the command line or the ANT task.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">skinparam backgroundColor #EEEBDC</span><br><span class="line"></span><br><span class="line">skinparam sequence &#123;</span><br><span class="line">    ArrowColor DeepSkyBlue</span><br><span class="line">    ActorBorderColor DeepSkyBlue</span><br><span class="line">    LifeLineBorderColor blue</span><br><span class="line">    LifeLineBackgroundColor #A9DCDF</span><br><span class="line"></span><br><span class="line">    ParticipantBorderColor DeepSkyBlue</span><br><span class="line">    ParticipantBackgroundColor DodgerBlue</span><br><span class="line">    ParticipantFontName Impact</span><br><span class="line">    ParticipantFontSize 17</span><br><span class="line">    ParticipantFontColor #A9DCDF</span><br><span class="line"></span><br><span class="line">    ActorBackgroundColor aqua</span><br><span class="line">    ActorFontColor DeepSkyBlue</span><br><span class="line">    ActorFontSize 17</span><br><span class="line">    ActorFontName Aapex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">actor User</span><br><span class="line">participant &quot;First Class&quot; as A</span><br><span class="line">participant &quot;Second Class&quot; as B</span><br><span class="line">participant &quot;Last Class&quot; as C</span><br><span class="line"></span><br><span class="line">User -&gt; A: DoWork</span><br><span class="line">activate A</span><br><span class="line"></span><br><span class="line">A -&gt; B: Create Request</span><br><span class="line">activate B</span><br><span class="line"></span><br><span class="line">B -&gt; C: DoWork</span><br><span class="line">activate C</span><br><span class="line">C --&gt; B: WorkDone</span><br><span class="line">destroy C</span><br><span class="line"></span><br><span class="line">B --&gt; A: Request Created</span><br><span class="line">deactivate B</span><br><span class="line"></span><br><span class="line">A --&gt; User: Done</span><br><span class="line">deactivate A</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://erasin.wang/plantuml/">PlantUML语法</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/134200993">PlantUML语法</a></p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>plantuml</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 二级缓存的思考</title>
    <url>/2021/01/30/SpringDataJpa%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E6%80%9D%E8%80%83-%E7%BB%93%E5%90%88Redis/</url>
    <content><![CDATA[<h1 id="二级缓存的思考：JPA结合Redis"><a href="#二级缓存的思考：JPA结合Redis" class="headerlink" title="二级缓存的思考：JPA结合Redis"></a>二级缓存的思考：JPA结合Redis</h1><h2 id="二级缓存的概念"><a href="#二级缓存的概念" class="headerlink" title="二级缓存的概念"></a>二级缓存的概念</h2><p>一级缓存的实体的生命周期和 PersistenceContext 是相同的，即载体为同一个 Session 才有效；而 Hibernate 提出了二级缓存的概念，也就是可以在不同的 Session 之间共享实体实例，说白了就是在单个应用内的整个 application 生命周期之内共享实体，减少数据库查询。</p>
<p>由于 JPA 协议本身并没有规定二级缓存的概念，所以这是 Hibernate 独有的特性。在 Hibernate 中，从数据库里面查询实体的过程就变成了：第一步先看看一级缓存里面有没有实体，如果没有再看看二级缓存里面有没有，如果还是没有再从数据库里面查询。</p>
<h3 id="Hibernate-中二级缓存的配置方法"><a href="#Hibernate-中二级缓存的配置方法" class="headerlink" title="Hibernate 中二级缓存的配置方法"></a>Hibernate 中二级缓存的配置方法</h3><p>Hibernate 中，默认情况下二级缓存是关闭的，如果想开启二级缓存需要通过如下三个步骤。</p>
<p><strong>第一步：引入第三方二级缓存的实现的 jar。</strong></p>
<p>因为 Hibernate 本身并没有实现缓存的功能，而是主要依赖第三方，如 Ehcache、jcache、redis 等第三方库。下面以 EhCache 为例，利用 gradle 引入 hibernate-ehcache 的依赖。代码如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.hibernate:hibernate-ehcache:5.2.2.Final&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果想用 jcache，可以通过如下方式。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">compile <span class="string">&#x27;org.hibernate:hibernate-jcache:5.2.2.Final&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步：在配置文件里面开启二级缓存。</strong></p>
<p>二级缓存默认是关闭的，所以需要用如下方式开启二级缓存，并且配置 cache.region.factory_class 为不同的缓存实现类。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">hibernate.cache.use_second_level_cache</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hibernate.cache.region.factory_class</span>=<span class="string">org.hibernate.cache.ehcache.EhCacheRegionFactory</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步：在用到二级缓存的地方配置 @Cacheable 和 @Cache 的策略。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Cacheable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Cacheable</span></span><br><span class="line"><span class="meta">@org</span>.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二级缓存的思考"><a href="#二级缓存的思考" class="headerlink" title="二级缓存的思考"></a>二级缓存的思考</h3><p>二级缓存主要解决的是单应用场景下跨 Session 生命周期的实体共享问题，可是一定要通过 Hibernate 来做吗？答案并不是，其实可以通过各种 Cache 的手段来做，因为 Hibernate 里面一级缓存的复杂度相对较高，并且使用的话实体的生命周期会有变化，查询问题的过程较为麻烦。</p>
<p>同时，随着现在逐渐微服务化、分布式化，如今的应用都不是单机应用，那么缓存之间如何共享呢？分布式缓存又该如何解决？比如一个机器变了，另一个机器没变，应该如何处理？似乎 Hibernate 并没有考虑到这些问题。</p>
<p>此外，还有什么时间数据会变更、变化了之后如何清除缓存，等等，这些都是要思考的，所以 Hibernate 的二级缓存听起来“高大上”，但是使用起来绝对没有那么简单。</p>
<p>那么经过这一连串的疑问，如果不用 Hibernate 的二级缓存，还有没有更好的解决方案呢？</p>
<h2 id="利用-Redis-进行缓存"><a href="#利用-Redis-进行缓存" class="headerlink" title="利用 Redis 进行缓存"></a>利用 Redis 进行缓存</h2><p>在实际工作中经常需要 cache 的就是 Redis，那么通过一个例子，来看下 Spring Cache 结合 Redis 是怎么使用的。</p>
<h3 id="Spring-Cache-和-Redis-结合"><a href="#Spring-Cache-和-Redis-结合" class="headerlink" title="Spring Cache 和 Redis 结合"></a>Spring Cache 和 Redis 结合</h3><p>第一步：在 gradle 中引入 cache 和 redis 的依赖，代码如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来只用到了JPA</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-jpa&#x27;</span></span><br><span class="line"><span class="comment">//为了引入cache和redis机制需要引入如下两个jar包</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-data-redis&#x27;</span> <span class="comment">//redis的依赖</span></span><br><span class="line">implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-cache&#x27;</span> <span class="comment">//cache 的依赖</span></span><br></pre></td></tr></table></figure>

<p>第二步：在 application.properties 里面增加 redis 的相关配置，代码如下。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">sySj6vmYke</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">6000</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<p>第三步：通过 <code>@EnableCaching</code> 开启缓存，增加 configuration 配置类，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：在需要缓存的地方添加 <code>@Cacheable</code> 注解即可。为了方便演示，把 <code>@Cacheable</code> 注解配置在了 controller 方法上，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;userInfo&quot;, key = &quot;&#123;#root.methodName, #id&#125;&quot;, unless = &quot;#result == null&quot;)</span> <span class="comment">//利用默认key值生成规则value加key生成一个redis的key值，result==null的时候不进行缓存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//第二次就不会再执行这里了</span></span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.findById(id).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步：启动项目，请求一下这个 API 会发现，第一次请求过后，redis 里面就有一条记录了，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130161543.jpg" alt=""></p>
<p>可以看到，第二次请求之后，取数据就不会再请求数据库了。那么 redis 已经熟悉了，那么来看一下 Spring Cache 都做了哪些事情。</p>
<h3 id="Spring-Cache-介绍"><a href="#Spring-Cache-介绍" class="headerlink" title="Spring Cache 介绍"></a>Spring Cache 介绍</h3><p>Spring 3.1 之后引入了基于注释（annotation）的缓存（cache）技术，它本质上不是一个具体的缓存实现方案（例如 EHCache 或者 Redis），而是一个对缓存使用的抽象概念，通过在既有代码中添加少量它定义的各种 annotation，就能够达到缓存方法的返回对象的效果。</p>
<p>Spring 的缓存技术还具备相当的灵活性，不仅能够使用 SpEL（Spring Expression Language）来定义缓存的 key 和各种 condition，还提供开箱即用的缓存临时存储方案，也支持主流的专业缓存，例如 Redis，EHCache 集成。而 Spring Cache 属于 Spring framework 的一部分，在下面图片所示的这个包里面。</p>
<p><img src="http://image.leonote.cn//20210130161742.jpg" alt=""></p>
<p><strong>Spring cache 里面的主要的注解</strong></p>
<p><strong>@Cacheable</strong></p>
<p>应用到读取数据的方法上，就是可以缓存的方法，如查找方法：先从缓存中读取，如果没有再调用方法获取数据，然后把数据添加到缓存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cacheable &#123;</span><br><span class="line">   <span class="meta">@AliasFor(&quot;cacheNames&quot;)</span></span><br><span class="line">   String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//cache的名字。可以根据名字设置不同cache处理类。redis里面可以根据cache名字设置不同的失效时间。</span></span><br><span class="line">   <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">   String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//缓存的key的名字，支持 SPEL</span></span><br><span class="line">   <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//key的生成策略，不指定可以用全局的默认的。</span></span><br><span class="line">   <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//客户选择不同的CacheManager</span></span><br><span class="line">   <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//配置不同的cache resolver</span></span><br><span class="line">   <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//满足什么样的条件才能被缓存，支持SpEL，可以去掉方法名、参数</span></span><br><span class="line">   <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//排除哪些返回结果不加入缓存里面去，支持SpEL，实际工作中常见的是result ==null等</span></span><br><span class="line">   <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//是否同步读取缓存、更新缓存</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是@Cacheable 相关的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable(cacheNames=&quot;book&quot;, condition=&quot;#name.length() &lt; 32&quot;, unless=&quot;#result.notNeedCache&quot;)</span><span class="comment">//利用SPEL表达式只有当name参数长度小于32的时候再进行缓存，排除notNeedCache的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">findBook</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>@CachePut</strong></p>
<p>调用方法时会自动把相应的数据放入缓存，它与 @Cacheable 不同的是所有注解的方法每次都会执行，一般配置在 Update 和 insert 方法上。其源码里面的字段和用法基本与 @Cacheable 相同，只是使用场景不一样。</p>
<p><strong>@CacheEvict</strong></p>
<p>删除缓存，一般配置在删除方法上面。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheEvict &#123;</span><br><span class="line"><span class="comment">//与@Cacheable相同的部分就不重复叙述了。</span></span><br><span class="line">......</span><br><span class="line">	<span class="comment">//是否删除所有的实体对象</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">allEntries</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">   <span class="comment">//是否方法执行之前执行。默认在方法调用成功之后删除</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">beforeInvocation</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="meta">@Caching</span> 所有Cache注解的组合配置方法，源码如下：</span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> Caching &#123;</span><br><span class="line">   Cacheable[] cacheable() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   CachePut[] put() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   CacheEvict[] evict() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还有 @CacheConfig 表示全局 Cache 配置；@EnableCaching，表示是否开启 SpringCache 的配置。</p>
<p><strong>Spring Cache Redis 里面主要的类</strong></p>
<p><strong>org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration</strong></p>
<p>cache 的自动装配类，此类被加载的方式是在 spring boot的spring.factories 文件里面，其关键源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(CacheManager.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(CacheAspectSupport.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = CacheManager.class, name = &quot;cacheResolver&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; CouchbaseDataAutoConfiguration.class, HazelcastAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">      HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123; CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ImportSelector&#125; to add &#123;<span class="doctag">@link</span> CacheType&#125; configuration classes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        CacheType[] types = CacheType.values();</span><br><span class="line">        String[] imports = <span class="keyword">new</span> String[types.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">           imports[i] = CacheConfigurations.getConfigurationClass(types[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> imports;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以看到，此类的关键作用是加载 Cache 的依赖配置，以及加载所有 CacheType 的配置文件，而 CacheConfigurations 里面定义了不同的 Cache 实现方式的配置，里面包含了 Ehcache、Redis、Jcache 的各种实现方式，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130162157.jpg" alt=""></p>
<p><strong>org.springframework.cache.annotation.CachingConfigurerSupport</strong></p>
<p>通过此类可以自定义 Cache 里面的 CacheManager、CacheResolver、KeyGenerator、CacheErrorHandler，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingConfigurerSupport</span> <span class="keyword">implements</span> <span class="title">CachingConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cache的manager，主要是管理不同的cache的实现方式，如redis还是ehcache等</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// cache的不同实现者的操作方法，CacheResolver解析器，用于根据实际情况来动态解析使用哪个Cache</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CacheResolver <span class="title">cacheResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//cache的key的生成规则</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//cache发生异常的回调处理，一般情况下我会打印个warn日志，方便知道发生了什么事情</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CacheErrorHandler <span class="title">errorHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，所有 CacheManager 是 Spring 提供的各种缓存技术抽象接口，通过它来管理，Spring framework 里面默认实现的 CacheManager 有不同的实现类，redis 默认加载的是 RedisCacheManager，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130162327.jpg" alt=""></p>
<p><strong>org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration</strong></p>
<p>它是加载 Cache 的实现者，也是 redis 的实现类，关键源码如下图所示。</p>
<p><img src="http://image.leonote.cn//20210130163005.jpg" alt=""></p>
<p>可以看得出来，它依赖本身的 Redis 的连接，并且加载了 RedisCacheManager；同时可以看到关于 Cache 和 Redis 的配置有哪些。</p>
<p>通过 CacheProperties 里面 redis 的配置，可以设置“<strong>key 的统一前缀、默认过期时间、是否缓存 null 值、是否使用前缀</strong>”这四个配置。</p>
<p><img src="http://image.leonote.cn//20210130163115.jpg" alt=""></p>
<h2 id="Spring-Cache-结合-Redis-使用的最佳实践"><a href="#Spring-Cache-结合-Redis-使用的最佳实践" class="headerlink" title="Spring Cache 结合 Redis 使用的最佳实践"></a>Spring Cache 结合 Redis 使用的最佳实践</h2><p><strong>不同 cache 的 name 在 redis 里面配置不同的过期时间</strong></p>
<p>默认情况下所有 redis 的 cache 过期时间是一样的，实际工作中一般需要自定义不同 cache 的 name 的过期时间，这里 cache 的 name 就是指 @Cacheable 里面 value 属性对应的值。主要步骤如下。</p>
<p>第一步：自定义一个配置文件，用来指定不同的 cacheName 对应的过期时间不一样。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cache.redis&quot;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 改善一下cacheName的最佳实践方法，目前主要用不同的cache name不同的过期时间，可以扩展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Duration&gt; cacheNameConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：通过自定义类 MyRedisCacheManagerBuilderCustomizer 实现 <code>RedisCacheManagerBuilderCustomizer</code> 里面的 customize 方法，用来指定不同的 name 采用不同的 RedisCacheConfiguration，从而达到设置不同的过期时间的效果。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个依赖spring boot 2.2 以上版本才有效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCacheManagerBuilderCustomizer</span> <span class="keyword">implements</span> <span class="title">RedisCacheManagerBuilderCustomizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyCacheProperties myCacheProperties;</span><br><span class="line">    <span class="keyword">private</span> RedisCacheConfiguration redisCacheConfiguration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRedisCacheManagerBuilderCustomizer</span><span class="params">(MyCacheProperties myCacheProperties, RedisCacheConfiguration redisCacheConfiguration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myCacheProperties = myCacheProperties;</span><br><span class="line">        <span class="keyword">this</span>.redisCacheConfiguration = redisCacheConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用默认配置的只需要在这里加就可以了</span></span><br><span class="line"><span class="comment">     * spring.cache.cache-names=abc,def,userlist2,user3</span></span><br><span class="line"><span class="comment">     * 下面是不同的cache-name可以配置不同的过期时间，yaml也支持，如果以后还有其他属性扩展可以改这里</span></span><br><span class="line"><span class="comment">     * spring.cache.redis.cache-name-config.user2=2h</span></span><br><span class="line"><span class="comment">     * spring.cache.redis.cache-name-config.def=2m</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RedisCacheManager.RedisCacheManagerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(myCacheProperties.getCacheNameConfig())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = myCacheProperties.getCacheNameConfig().entrySet().stream()</span><br><span class="line">                .collect(Collectors</span><br><span class="line">                        .toMap(e-&gt;e.getKey(),v-&gt;builder</span><br><span class="line">                                .getCacheConfigurationFor(v.getKey())</span><br><span class="line">                                .orElse(RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(redisCacheConfiguration.getValueSerializationPair()))</span><br><span class="line">                                .entryTtl(v.getValue())));</span><br><span class="line">        builder.withInitialCacheConfigurations(cacheConfigurations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：在 CacheConfiguration 里面把自定义的 CacheManagerCustomize 加载进去即可，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;MyCacheProperties.class,CacheProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;CacheAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持不同的cache name有不同的缓存时间的配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> myCacheProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisCacheConfiguration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;myRedisCacheManagerBuilderCustomizer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(RedisCacheManagerBuilderCustomizer.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRedisCacheManagerBuilderCustomizer <span class="title">myRedisCacheManagerBuilderCustomizer</span><span class="params">(MyCacheProperties myCacheProperties, RedisCacheConfiguration redisCacheConfiguration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRedisCacheManagerBuilderCustomizer(myCacheProperties,redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：使用的时候非常简单，只需要在 application.properties 里面做如下配置即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置默认的过期时间是20分钟</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">20m</span></span><br><span class="line"><span class="comment"># 设置刚才的例子 @Cacheable(value=&quot;userInfo&quot;)5分钟过期</span></span><br><span class="line"><span class="meta">spring.cache.redis.cache-name-config.userInfo</span>=<span class="string">5m</span></span><br><span class="line"><span class="comment"># 设置 room的cache1小时过期</span></span><br><span class="line"><span class="meta">spring.cache.redis.cache-name-config.room</span>=<span class="string">1h</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义 KeyGenerator 实现，redis 的 key 自定义拼接规则</strong></p>
<p>假如不喜欢默认的 cache 生成的 key 的 string 规则，那么可以自定义。创建 MyRedisCachingConfigurerSupport 集成 CachingConfigurerSupport 即可，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCachingConfigurerSupport</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖默认的redis key的生成规则，变成&quot;方法名:参数:参数&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyGenerator <span class="title">getKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; &#123;</span><br><span class="line">            StringBuilder key = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            key.append(ClassUtils.getQualifiedMethodName(method));</span><br><span class="line">            <span class="keyword">for</span> (Object obc : params) &#123;</span><br><span class="line">                key.append(<span class="string">&quot;:&quot;</span>).append(obc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生 cache 和 redis 的操作异常时，不希望阻碍主流程，打印一个关键日志即可</p>
<p>只需要在 MyRedisCachingConfigurerSupport 里面再实现父类的 errorHandler 即可，代码变成了如下模样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisCachingConfigurerSupport</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖默认的redis key的生成规则，变成&quot;方法名:参数:参数&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyGenerator <span class="title">getKeyGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (target, method, params) -&gt; &#123;</span><br><span class="line">            StringBuilder key = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            key.append(ClassUtils.getQualifiedMethodName(method));</span><br><span class="line">            <span class="keyword">for</span> (Object obc : params) &#123;</span><br><span class="line">                key.append(<span class="string">&quot;:&quot;</span>).append(obc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> key.toString();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖默认异常处理方法，不抛异常，改打印error日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheErrorHandler <span class="title">errorHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheErrorHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheGetError</span><span class="params">(RuntimeException exception, Cache cache, Object key)</span> </span>&#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;Spring cache GET error:cache=%s,key=%s&quot;</span>, cache, key), exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCachePutError</span><span class="params">(RuntimeException exception, Cache cache, Object key, Object value)</span> </span>&#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;Spring cache PUT error:cache=%s,key=%s&quot;</span>, cache, key), exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheEvictError</span><span class="params">(RuntimeException exception, Cache cache, Object key)</span> </span>&#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;Spring cache EVICT error:cache=%s,key=%s&quot;</span>, cache, key), exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheClearError</span><span class="params">(RuntimeException exception, Cache cache)</span> </span>&#123;</span><br><span class="line">                log.error(String.format(<span class="string">&quot;Spring cache CLEAR error:cache=%s&quot;</span>, cache), exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改变默认的 cache 里面 redis 的 value 序列化方式</strong></p>
<p>默认有可能是 JDK 序列化方式，所以一般看不懂 redis 里面的值，那么就可以把序列化方式改成 JSON 格式，只需要在 CacheConfiguration 里面增加默认的 RedisCacheConfiguration 配置即可，完整的 CacheConfiguration 变成如下代码所示的样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;MyCacheProperties.class,CacheProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;CacheAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持不同的cache name有不同的缓存时间的配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> myCacheProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> redisCacheConfiguration</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;myRedisCacheManagerBuilderCustomizer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(RedisCacheManagerBuilderCustomizer.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRedisCacheManagerBuilderCustomizer <span class="title">myRedisCacheManagerBuilderCustomizer</span><span class="params">(MyCacheProperties myCacheProperties, RedisCacheConfiguration redisCacheConfiguration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRedisCacheManagerBuilderCustomizer(myCacheProperties,redisCacheConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cache异常不抛异常，只打印error日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;myRedisCachingConfigurerSupport&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyRedisCachingConfigurerSupport <span class="title">myRedisCachingConfigurerSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRedisCachingConfigurerSupport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依赖默认的ObjectMapper，实现普通的json序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> defaultObjectMapper</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;genericJackson2JsonRedisSerializer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;genericJackson2JsonRedisSerializer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericJackson2JsonRedisSerializer <span class="title">genericJackson2JsonRedisSerializer</span><span class="params">(ObjectMapper defaultObjectMapper)</span> </span>&#123;</span><br><span class="line">        ObjectMapper objectMapper = defaultObjectMapper.copy();</span><br><span class="line">        objectMapper.registerModule(<span class="keyword">new</span> Hibernate5Module().enable(REPLACE_PERSISTENT_COLLECTIONS)); <span class="comment">//支持JPA的实体的json的序列化</span></span><br><span class="line">        objectMapper.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, <span class="keyword">true</span>);</span><br><span class="line">        objectMapper.deactivateDefaultTyping(); <span class="comment">//关闭 defaultType，不需要关心redis里面是否为对象的类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer(objectMapper);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖 RedisCacheConfiguration，只是修改serializeValues with jackson</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;jacksonRedisCacheConfiguration&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheConfiguration <span class="title">jacksonRedisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                  GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer)</span> </span>&#123;</span><br><span class="line">        CacheProperties.Redis redisProperties = cacheProperties.getRedis();</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration</span><br><span class="line">                .defaultCacheConfig();</span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer));<span class="comment">//修改的关键所在，指定Jackson2JsonRedisSerializer的方式</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 使用 SPEL</title>
    <url>/2021/01/25/SpringDataJpa%E4%BD%BF%E7%94%A8SPEL/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-使用-SPEL"><a href="#Spring-Data-Jpa-使用-SPEL" class="headerlink" title="Spring Data Jpa 使用 SPEL"></a>Spring Data Jpa 使用 SPEL</h1><h2 id="SpEL-基础语法"><a href="#SpEL-基础语法" class="headerlink" title="SpEL 基础语法"></a>SpEL 基础语法</h2><h3 id="SpEL-大纲"><a href="#SpEL-大纲" class="headerlink" title="SpEL 大纲"></a>SpEL 大纲</h3><p>SpEL 的全称为 Spring Expression Language，即 Spring 表达式语言，是 Spring framework 里面的核心项目。spring-expression 的 jar 包的引用关系，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210125130549.png" alt=""></p>
<p>从核心引用来看，SpEL 贯穿所有 Spring 的核心功能。当然了，SpEL 可以脱离 Spring 工程独立使用，其项目里有三个重要的接口：<code>ExpressionParser</code>、<code>Expression</code>、<code>EvaluationContext</code>，我从官方文档中找了一张图来说明它们之间的关系。</p>
<p><img src="http://image.leonote.cn/20210125130830.png" alt=""></p>
<h3 id="ExpressionParser"><a href="#ExpressionParser" class="headerlink" title="ExpressionParser"></a>ExpressionParser</h3><p>它是 SpEL 的处理接口，默认实现类是 <code>SpelExpressionParser</code>，对外提供的只有两个方法，如下述代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExpressionParser</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 根据传入的表达式生成Expression</span></span><br><span class="line">   <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">   <span class="comment">// 根据传入的表达式和ParserContext生成Expression对象</span></span><br><span class="line">   <span class="function">Expression <span class="title">parseExpression</span><span class="params">(String expressionString, ParserContext context)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法的目的都是生成 Expression。</p>
<h3 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h3><p>它默认的实现是 <code>SpELExpression</code>，主要对外提供的接口就是根据表达式获得表达式响应的结果，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210125131058.png" alt=""></p>
<p>而它的这些方法中，最重的一个参数就是 EvaluationContext。</p>
<h3 id="EvaluationContext"><a href="#EvaluationContext" class="headerlink" title="EvaluationContext"></a>EvaluationContext</h3><p>表示解析 String 表达式所需要的上下文，例如寻找 ROOT 是谁，反射解析的 Method、Field、Constructor 的解析器和取值所需要的上下文。看一下其接口提供的方法，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210125131201.png" alt=""></p>
<h3 id="SpEL-的基本用法"><a href="#SpEL-的基本用法" class="headerlink" title="SpEL 的基本用法"></a>SpEL 的基本用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ExpressionParser是操作SpEL的总入口，创建一个接口ExpressionParser对应的实例SpelExpressionParser</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"><span class="comment">//通过上面的parser.parseExpression方法获得一个Expression的实例，里面实现的就是new一个SpelExpression对象；而parseExpression的参数就是SpEL的使用重点，各种表达式的字符串</span></span><br><span class="line"><span class="comment">//1.简单的string类型用&#x27;&#x27; 引用</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//2.SpEL支持很多功能特性，如调用方法、访问属性、调用构造函数，可以直接调用String对象里面的concat方法进行字符串拼接</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.concat(&#x27;!&#x27;)&quot;</span>);</span><br><span class="line"><span class="comment">//通过getValue方法可以得到经过Expresion计算parseExpression方法的字符串参数(符合SpEL语法的表达式)的结果</span></span><br><span class="line">String message = (String) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>而访问属性值如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.invokes getBytes()方法</span></span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;&#x27;Hello World&#x27;.bytes&quot;</span>);</span><br><span class="line"><span class="keyword">byte</span>[] bytes = (<span class="keyword">byte</span>[]) exp.getValue(); <span class="comment">//得到 byte[]类型的结果</span></span><br></pre></td></tr></table></figure>

<p>SpEL 字符串表达式还支持使用“.”进行嵌套属性 prop1.prop2.prop3 访问，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; invokes getBytes().length</span><br><span class="line">Expression exp &#x3D; parser.parseExpression(&quot;&#39;Hello World&#39;.bytes.length&quot;);</span><br><span class="line">int length &#x3D; (Integer) exp.getValue();</span><br></pre></td></tr></table></figure>

<p>访问构造方法，例如字符串的构造方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;new String(&#x27;hello world&#x27;).toUpperCase()&quot;</span>);</span><br><span class="line">String message = exp.getValue(String.class);</span><br></pre></td></tr></table></figure>

<p>也可以通过 EvaluationContext 来配置一些根元素，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过一个Expression表达式想取name属性对应的值</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">Expression exp = parser.parseExpression(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//通过EvaluationContext设置rootObject等于new的UserInfo对象</span></span><br><span class="line">UserInfo rootUserInfo = UserInfo.builder().name(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext(rootUserInfo);</span><br><span class="line"><span class="comment">//getValue根据设置的context取值，可以得到jack字符串</span></span><br><span class="line">String name = (String) exp.getValue(context);</span><br><span class="line"><span class="comment">//也可以利用SpEL的表达式进行运算，判断名字是否等于字符串Nikola</span></span><br><span class="line">Expression exp2 = parser.parseExpression(<span class="string">&quot;name == &#x27;Nikola&#x27;&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> result2 = exp2.getValue(context, Boolean.class); <span class="comment">// 根据UserInfo的rootObject得到false</span></span><br></pre></td></tr></table></figure>

<p><code>SpelExpressionParser</code> 的构造方法还支持一些配置，例如经常遇到<strong>空指针异常</strong>和<strong>下标越界</strong>的问题，就可以通过 <code>SpelParserConfiguration</code> 配置：当 Null 的时候自动初始化，当 Collection 越界的时候自动扩容增加。例子如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造一个Class，方便测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启自动初始化null和自动扩容collection</span></span><br><span class="line">SpelParserConfiguration config = <span class="keyword">new</span> SpelParserConfiguration(<span class="keyword">true</span>,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//利用config生成ExpressionParser的实例</span></span><br><span class="line">ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser(config);</span><br><span class="line"><span class="comment">//通过表达式取这个用户的第三个地址</span></span><br><span class="line">Expression expression = parser.parseExpression(<span class="string">&quot;address[3]&quot;</span>);</span><br><span class="line">MyUser demo = <span class="keyword">new</span> MyUser(); </span><br><span class="line"><span class="comment">//new一个对象，但是没有初始化MyUser里面的address，由于配置了自动初始化和扩容，所以通过下面的计算，没有得到异常，o可以得到一个空的字符串</span></span><br><span class="line">Object o = expression.getValue(demo);<span class="comment">// 空字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="SpEL-在-Spring-中常见的使用场景"><a href="#SpEL-在-Spring-中常见的使用场景" class="headerlink" title="SpEL 在 Spring 中常见的使用场景"></a>SpEL 在 Spring 中常见的使用场景</h2><p>SpEL 在 @Value 里面的用法最常见</p>
<h3 id="Value-的应用场景"><a href="#Value-的应用场景" class="headerlink" title="@Value 的应用场景"></a>@Value 的应用场景</h3><p>新建一个 <code>DemoProperties</code> 对象，用 Spring 装载，测试一下两个语法点：运算符和 Map、List。</p>
<p><strong>第一个语法：通过 @Value 展示 SpEL 里面支持的各种运算符的写法。</strong>如下面的表格所示。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">操作符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑运算</td>
<td align="center">+, -, *, /, %, ^, div, mod</td>
</tr>
<tr>
<td align="center">逻辑比较符号</td>
<td align="center">&lt;, &gt;, ==, !=, &lt;=, &gt;=, lt, gt, eq, ne, le, ge</td>
</tr>
<tr>
<td align="center">逻辑关系</td>
<td align="center">and, or, not, &amp;&amp;, ||, !</td>
</tr>
<tr>
<td align="center">三元表达式</td>
<td align="center">?:</td>
</tr>
<tr>
<td align="center">正则表达式</td>
<td align="center">matches</td>
</tr>
</tbody></table>
<p>展示一下 SpEL 里面支持的各种运算符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//通过@Value使用SpEL的地方，一定要将此对象交由Spring进行管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoProperties</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 第一部分：逻辑运算操作</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;19 + 1&#125;&quot;)</span> <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> add;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;String1 &#x27; + &#x27;string2&#x27;&#125;&quot;)</span> <span class="comment">// &quot;String1 string2&quot;</span></span><br><span class="line">    <span class="keyword">private</span> String addString;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;20 - 1&#125;&quot;)</span> <span class="comment">// 19</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> subtract;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;10 * 2&#125;&quot;)</span> <span class="comment">// 20</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> multiply;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;36 / 2&#125;&quot;)</span> <span class="comment">// 19</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> divide;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;36 div 2&#125;&quot;)</span> <span class="comment">// 18, the same as for / operator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> divideAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;37 % 10&#125;&quot;)</span> <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> modulo;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;37 mod 10&#125;&quot;)</span> <span class="comment">// 7, the same as for % operator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> moduloAlphabetic;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二部分：逻辑比较符号</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 == 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> equal;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 eq 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> equalAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 != 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> notEqual;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 ne 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> notEqualAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 &lt; 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lessThan;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 lt 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lessThanAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 &lt;= 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lessThanOrEqual;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 le 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lessThanOrEqualAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 &gt; 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> greaterThan;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 gt 1&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> greaterThanAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 &gt;= 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> greaterThanOrEqual;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;1 ge 1&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> greaterThanOrEqualAlphabetic;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 第三部分：逻辑关系运算符    </span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;250 &gt; 200 &amp;&amp; 200 &lt; 4000&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> and;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;250 &gt; 200 and 200 &lt; 4000&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> andAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;400 &gt; 300 || 150 &lt; 100&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> or;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;400 &gt; 300 or 150 &lt; 100&#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orAlphabetic;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;!true&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> not;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;not true&#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> notAlphabetic;    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 第四部分：三元表达式 &amp; Elvis运算符</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;2 &gt; 1 ? &#x27;a&#x27; : &#x27;b&#x27;&#125;&quot;)</span> <span class="comment">// &quot;b&quot;</span></span><br><span class="line">    <span class="keyword">private</span> String ternary;</span><br><span class="line">    <span class="comment">//demoProperties 就是通过spring加载的当前对象，</span></span><br><span class="line">    <span class="comment">//取spring容器里面的某个bean的属性，</span></span><br><span class="line">    <span class="comment">//这里取的是demoProperties对象里面的someProperty属性，</span></span><br><span class="line">    <span class="comment">//如果不为null就直接用，如果为null返回&#x27;default&#x27;字符串</span></span><br><span class="line">   <span class="meta">@Value(&quot;#&#123;demoProperties.someProperty != null ? demoProperties.someProperty : &#x27;default&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ternaryProperty;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Elvis运算符是三元表达式简写的方式，和上面一样的结果。如果someProperty为null则返回default值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;demoProperties.someProperty ?: &#x27;default&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String elvis;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取系统环境的属性，如果系统属性pop3.port已定义会直接注入，如果未定义，则返回默认值25。systemProperties是spring容器里面的systemProperties实体；</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;systemProperties[&#x27;pop3.port&#x27;] ?: 25&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 还可以用于安全引用运算符主要为了避免空指针，源于Groovy语言。</span></span><br><span class="line"><span class="comment">     * 很多时候你引用一个对象的方法或者属性时都需要做非空校验。</span></span><br><span class="line"><span class="comment">     * 为了避免此类问题，使用安全引用运算符只会返回null而不是抛出一个异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Value(&quot;#&#123;demoPropertiesx?:someProperty&#125;&quot;) </span></span><br><span class="line">    <span class="comment">// 如果demoPropertiesx不为null，则返回someProperty值</span></span><br><span class="line">    <span class="keyword">private</span> String someProperty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第五部分：正则表达式的支持</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;100&#x27; matches &#x27;\\d+&#x27; &#125;&quot;)</span> <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validNumericStringResult;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;100fghdjf&#x27; matches &#x27;\\d+&#x27; &#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> invalidNumericStringResult;</span><br><span class="line">    <span class="comment">// 利用matches匹配正则表达式，返回true</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;valid alphabetic string&#x27; matches &#x27;[a-zA-Z\\s]+&#x27; &#125;&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validAlphabeticStringResult;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;invalid alphabetic string #$1&#x27; matches &#x27;[a-zA-Z\\s]+&#x27; &#125;&quot;)</span> <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> invalidAlphabeticStringResult;</span><br><span class="line">    <span class="comment">//如果someValue只有数字</span></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;demoProperties.someValue matches &#x27;\\d+&#x27;&#125;&quot;)</span> <span class="comment">// true </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validNumericValue;</span><br><span class="line">    <span class="comment">//新增一个空的someValue属性方便测试</span></span><br><span class="line">    <span class="keyword">private</span> String someValue=<span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>@Value</code> 测试各种 SpEL 的表达式，这和放在 <code>parser.parseExpression(&quot;SpEL 的表达式字符串&quot;);</code> 里面的效果是一样的。</p>
<p>测试用例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@Import(TestConfiguration.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.example.jpa.demo.config.DemoProperties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPropertiesTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> DemoProperties demoProperties;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试@Value里面不同表达式的值了</span></span><br><span class="line">        System.out.println(demoProperties.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> DemoProperties <span class="title">demoProperties</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DemoProperties();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者可以启动项目，也能看到结果。</p>
<h3 id="Value-的解析原理"><a href="#Value-的解析原理" class="headerlink" title="@Value 的解析原理"></a>@Value 的解析原理</h3><p>Spring 项目启动的时候会根据 @Value 的注解，去加载 SpelExpressionResolver 及算出来需要的 StandardEvaluationContext，然后再调用 Expression 方法进行 getValue 操作，其中计算 StandardEvaluationContext 的关键源码如下面两张图所示。</p>
<p><img src="http://image.leonote.cn/20210125132506.png" alt=""></p>
<p><img src="http://image.leonote.cn/20210125132515.png" alt=""></p>
<p><strong>第二个语法：@Value 展示了 SpEL 可以直接读取 Map 和 List 里面的值</strong>，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过@Component加载一个类，并且给其中的List和Map附上值</span></span><br><span class="line"><span class="meta">@Component(&quot;workersHolder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkersHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; workers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> Map&lt;String, Integer&gt; salaryByWorkers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkersHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                workers.add(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">                workers.add(<span class="string">&quot;Susie&quot;</span>);</span><br><span class="line">                workers.add(<span class="string">&quot;Alex&quot;</span>);</span><br><span class="line">                workers.add(<span class="string">&quot;George&quot;</span>);</span><br><span class="line">                salaryByWorkers.put(<span class="string">&quot;John&quot;</span>, <span class="number">35000</span>);</span><br><span class="line">                salaryByWorkers.put(<span class="string">&quot;Susie&quot;</span>, <span class="number">47000</span>);</span><br><span class="line">                salaryByWorkers.put(<span class="string">&quot;Alex&quot;</span>, <span class="number">12000</span>);</span><br><span class="line">                salaryByWorkers.put(<span class="string">&quot;George&quot;</span>, <span class="number">14000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Getters and setters ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SpEL直接读取Map和List里面的值</span></span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.salaryByWorkers[&#x27;John&#x27;]&#125;&quot;)</span> <span class="comment">// 35000</span></span><br><span class="line"><span class="keyword">private</span> Integer johnSalary;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.salaryByWorkers[&#x27;George&#x27;]&#125;&quot;)</span> <span class="comment">// 14000</span></span><br><span class="line"><span class="keyword">private</span> Integer georgeSalary;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.salaryByWorkers[&#x27;Susie&#x27;]&#125;&quot;)</span> <span class="comment">// 47000</span></span><br><span class="line"><span class="keyword">private</span> Integer susieSalary;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.workers[0]&#125;&quot;)</span> <span class="comment">// John</span></span><br><span class="line"><span class="keyword">private</span> String firstWorker;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.workers[3]&#125;&quot;)</span> <span class="comment">// George</span></span><br><span class="line"><span class="keyword">private</span> String lastWorker;</span><br><span class="line"><span class="meta">@Value(&quot;#&#123;workersHolder.workers.size()&#125;&quot;)</span> <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">private</span> Integer numberOfWorkers;</span><br></pre></td></tr></table></figure>

<h3 id="Value-使用的注意事项-与-的区别"><a href="#Value-使用的注意事项-与-的区别" class="headerlink" title="@Value 使用的注意事项 # 与 $ 的区别"></a>@Value 使用的注意事项 # 与 $ 的区别</h3><p>SpEL 表达式默认以 # 开始，以大括号进行包住，如 <code>#&#123;expression&#125;</code>。默认规则在 ParserContext 里面设置，也可以自定义，但是一般建议不要动。</p>
<p><img src="http://image.leonote.cn/20210126125812.png" alt=""></p>
<p>这里注意要与 Spring 中的 Properties 进行区别，Properties 相关的表达式是以 $ 开始的大括号进行包住的，如 <code>$&#123;property.name&#125;</code>。</p>
<p>也就是说 @Value 的值有两类：</p>
<ul>
<li><p><code>$&#123; property**:**default_value &#125;</code></p>
</li>
<li><p><code>#&#123; obj.property**? :**default_value &#125;</code></p>
</li>
</ul>
<p>第一个注入的是外部参数对应的 Property，第二个则是 SpEL 表达式对应的内容。</p>
<p>而 Property placeholders 不能包含 SpEL 表达式，但是 SpEL 表达式可以包含 Property 的引用。如 <code>#&#123;$&#123;someProperty&#125; + 2&#125;</code>，如果 someProperty=1，那么效果将是 <code>#&#123; 1 + 2&#125;</code>，最终的结果将是 3。</p>
<h3 id="JPA-中-Query-的应用场景"><a href="#JPA-中-Query-的应用场景" class="headerlink" title="JPA 中 @Query 的应用场景"></a>JPA 中 @Query 的应用场景</h3><p>SpEL 除了能在 @Value 里面使用外，也能在 @Query 里使用，而在 @Query 里还有一个特殊的地方，就是它可以用来取方法的参数。</p>
<h4 id="通过-SpEL-取被-Query-注解的方法参数"><a href="#通过-SpEL-取被-Query-注解的方法参数" class="headerlink" title="通过 SpEL 取被 @Query 注解的方法参数"></a>通过 SpEL 取被 @Query 注解的方法参数</h4><p>在 @Query 注解中使用 SpEL 的主要目的是取方法的参数，主要有三种用法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用法一：根据下标取方法里面的参数</span></span><br><span class="line"><span class="meta">@Query(&quot;select u from User u where u.age = ?#&#123;[0]&#125;&quot;)</span> </span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsersByAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"><span class="comment">//用法二：#customer取@Param(&quot;customer&quot;)里面的参数</span></span><br><span class="line"><span class="meta">@Query(&quot;select u from User u where u.firstname = :#&#123;#customer.firstname&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findUsersByCustomersFirstname</span><span class="params">(<span class="meta">@Param(&quot;customer&quot;)</span> Customer customer)</span></span>;</span><br><span class="line"><span class="comment">//用法三：用JPA约定的变量entityName取得当前实体的实体名字</span></span><br><span class="line"><span class="meta">@Query(&quot;from #&#123;#entityName&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">findAllByEntityName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<ul>
<li><p>方法一可以通过 [0] 的方式，根据下标取到方法的参数；</p>
</li>
<li><p>方法二通过 <code>#customer</code> 可以根据 @Param 注解的参数的名字取到参数，必须通过 <code>?#&#123;&#125;</code> 和 <code>:#&#123;&#125;</code> 来触发 SpEL 的表达式语法；</p>
</li>
<li><p>方法三通过下述语法，取约定的实体的名字。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#&#123;#entityName&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>再来看一个更复杂一点的例子，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// JPA约定的变量entityName取得当前实体的实体名字</span></span><br><span class="line">   <span class="meta">@Query(&quot;from #&#123;#entityName&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findAllByEntityName</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//一个查询中既可以支持SpEL也可以支持普通的:ParamName的方式</span></span><br><span class="line">   <span class="meta">@Modifying</span></span><br><span class="line">   <span class="meta">@Query(&quot;update #&#123;#entityName&#125; u set u.name = :name where u.id =:id&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">updateUserActiveState</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//演示SpEL根据数组下标取参数，和根据普通的Parma的名字:name取参数</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.lastName like %:#&#123;[0]&#125; and u.name like %:name%&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findContainingEscaped</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//SpEL取Parma的名字customer里面的属性</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.name = :#&#123;#customer.name&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findUsersByCustomersFirstname</span><span class="params">(<span class="meta">@Param(&quot;customer&quot;)</span> UserInfo customer)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//利用SpEL根据一个写死的&#x27;jack&#x27;字符串作为参数</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.name = ?#&#123;&#x27;jack&#x27;&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findOliverBySpELExpressionWithoutArgumentsWithQuestionmark</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//同时SpEL支持特殊函数escape和escapeCharacter</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.lastName like %?#&#123;escape([0])&#125;% escape ?#&#123;escapeCharacter()&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findByNameWithSpelExpression</span><span class="params">(String name)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// #entityName和#[]同时使用</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from #&#123;#entityName&#125; u where u.name = ?#&#123;[0]&#125; and u.lastName = ?#&#123;[1]&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression</span><span class="params">(String name, String lastName)</span></span>;</span><br><span class="line">   <span class="comment">//对于 native SQL同样适用，并且同样支持取pageable分页里面的属性值</span></span><br><span class="line">   <span class="meta">@Query(value = &quot;select * from (&quot; //</span></span><br><span class="line"><span class="meta">         + &quot;select u.*, rownum() as RN from (&quot; //</span></span><br><span class="line"><span class="meta">         + &quot;select * from user_info ORDER BY ucase(firstname)&quot; //</span></span><br><span class="line"><span class="meta">         + &quot;) u&quot; //</span></span><br><span class="line"><span class="meta">         + &quot;) where RN between ?#&#123; #pageable.offset +1 &#125; and ?#&#123;#pageable.offset + #pageable.pageSize&#125;&quot;, //</span></span><br><span class="line"><span class="meta">         countQuery = &quot;select count(u.id) from user_info u&quot;, //</span></span><br><span class="line"><span class="meta">         nativeQuery = true)</span></span><br><span class="line">   <span class="function">Page&lt;UserInfo&gt; <span class="title">findUsersInNativeQueryWithPagination</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人比较推荐使用 @Param 的方式，这样语义清晰，参数换位置了也不影响执行结果。</p>
<p>关于源码的实现，可以到 ExpressionBasedStringQuery.class 里面继续研究，关键代码如下图所示。</p>
<p><img src="http://image.leonote.cn/20210126130209.png" alt=""></p>
<h4 id="spring-security-data-在-Query-中的用法"><a href="#spring-security-data-在-Query-中的用法" class="headerlink" title="spring-security-data 在 @Query 中的用法"></a>spring-security-data 在 @Query 中的用法</h4><p>在实际工作中，有时会用 spring-security 做鉴权，详细可以参考<a href="https://spring.io/projects/spring-security#learn">官方文档</a>。</p>
<p>当我们用 Spring Security 的时候，其实可以额外引入 jai 包 spring-security-data。如果使用了 JPA 和 Spring Security 的话，build.gradle 最终会变成如下形式，请看代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入spring data jpa</span><br><span class="line">implementation &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;</span><br><span class="line">&#x2F;&#x2F;集成spring security</span><br><span class="line">implementation &#39;org.springframework.boot:spring-boot-starter-security&#39;</span><br><span class="line">&#x2F;&#x2F; 集成spring security data对JPA的支持</span><br><span class="line">implementation &#39;org.springframework.security:spring-security-data&#39;</span><br></pre></td></tr></table></figure>

<p>假设继承 Spring Security 之后，SecurityContextHolder 里面放置的 Authentication 是 UserInfo，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//应用上下文中设置登录用户信息，此时Authentication类型为UserInfo</span></span><br><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span><br></pre></td></tr></table></figure>

<p>这样 JPA 里面的 @Query 就可以取到当前的 SecurityContext 信息，其用法如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据当前用户email取当前用户的信息</span></span><br><span class="line"><span class="meta">@Query(&quot;select u from UserInfo u where u.emailAddress = ?#&#123;principal.email&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">findCurrentUserWithCustomQuery</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//如果当前用户是admin，就返回某业务的所有对象；如果不是admin角色，就只给当前用户的某业务数据</span></span><br><span class="line"><span class="meta">@Query(&quot;select o from BusinessObject o where o.owner.emailAddress like &quot;+</span></span><br><span class="line"><span class="meta">      &quot;?#&#123;hasRole(&#x27;ROLE_ADMIN&#x27;) ? &#x27;%&#x27; : principal.emailAddress&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;BusinessObject&gt; <span class="title">findBusinessObjectsForCurrentUser</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过看源码会发现，spring-security-data 就帮我们做了一件事情：实现 EvaluationContextExtension，设置了 SpEL 所需要的 rootObject 为 SecurityExpressionRoot。关键代码如下图所示。</p>
<p><img src="http://image.leonote.cn/20210126130511.png" alt=""></p>
<p>由于 SecurityExpressionRoot 是 rootObject，根据上面介绍的 SpEL 的基本用法，SecurityExpressionRoot 里面的各种属性和方法都可以在 SpEL 中使用，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210126130554.png" alt=""></p>
<p>这其实也给了一些启发：当需要自动 rootObject 给 @Query 使用的时候，也可以采用这种方式，这样 @Query 的灵活性会增强很多。</p>
<h3 id="SpEL-在-Cacheable-中的应用场景"><a href="#SpEL-在-Cacheable-中的应用场景" class="headerlink" title="SpEL 在 @Cacheable 中的应用场景"></a>SpEL 在 @Cacheable 中的应用场景</h3><p>在实际工作中还有一个经常用到 SpEL 的场景，就是在 Cache 的时候，也就是 Spring Cache 的相关注解里面，如 <code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code> 等。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//缓存key取当前方法名，判断一下只有返回结果不为null或者非empty才进行缓存</span></span><br><span class="line"><span class="meta">@Cacheable(value = &quot;APP&quot;, key = &quot;#root.methodName&quot;, cacheManager = &quot;redis.cache&quot;, unless = &quot;#result == null || #result.isEmpty()&quot;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Map&lt;String, String&gt;&gt; getAppGlobalSettings() &#123;&#125;</span><br><span class="line"><span class="comment">//evict策略的key是当前参数customer里面的name属性</span></span><br><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">@CacheEvict(value=&quot;directory&quot;, key=&quot;#customer.name&quot;) &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">(Customer customer)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//在condition里面使用，当参数里面customer的name属性的值等于字符串Tom才放到缓存里面</span></span><br><span class="line"><span class="meta">@CachePut(value=&quot;addresses&quot;, condition=&quot;#customer.name==&#x27;Tom&#x27;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">(Customer customer)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//用在unless里面，利用SpEL的条件表达式判断，排除返回的结果地址长度小于64的请求</span></span><br><span class="line"><span class="meta">@CachePut(value=&quot;addresses&quot;, unless=&quot;#result.length()&lt;64&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">(Customer customer)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring-Cache-中-SpEL-支持的上下文语法"><a href="#Spring-Cache-中-SpEL-支持的上下文语法" class="headerlink" title="Spring Cache 中 SpEL 支持的上下文语法"></a>Spring Cache 中 SpEL 支持的上下文语法</h4><p>Spring Cache 提供了一些可使用的 SpEL 上下文数据，如下表所示（摘自 Spring 官方文档）。</p>
<table>
<thead>
<tr>
<th align="center">支持的属性</th>
<th align="center">作用域</th>
<th align="center">功能描述</th>
<th align="center">使用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">methodName</td>
<td align="center">root 对象</td>
<td align="center">当前被调用的方法名</td>
<td align="center">#root.methodName</td>
</tr>
<tr>
<td align="center">method</td>
<td align="center">root 对象</td>
<td align="center">当前被调用的方法</td>
<td align="center">#root.method.name</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center">root 对象</td>
<td align="center">当前被调用的目标对象</td>
<td align="center">#root.target</td>
</tr>
<tr>
<td align="center">targetClass</td>
<td align="center">root 对象</td>
<td align="center">当前被调用的目标对象类</td>
<td align="center">#root.targetClass</td>
</tr>
<tr>
<td align="center">args</td>
<td align="center">root 对象</td>
<td align="center">当前被调用的方法的参数列表</td>
<td align="center">#root.args[0]</td>
</tr>
<tr>
<td align="center">caches</td>
<td align="center">root 对象</td>
<td align="center">当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个 cache</td>
<td align="center">#root.caches[0].name</td>
</tr>
<tr>
<td align="center">argument name</td>
<td align="center">执行上下文</td>
<td align="center">当前被调用的方法的参数，如 findById(Long id)，我们可以通过 #id 拿到参数</td>
<td align="center">#user.id 表示参数 user 里面的 id</td>
</tr>
<tr>
<td align="center">result</td>
<td align="center">执行上下文</td>
<td align="center">方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的 beforeInvocation=false）</td>
<td align="center">#result</td>
</tr>
</tbody></table>
<p>也可以看一下 Spring Cache 中 SpEL 的 EvaluationContext 加载方式，关键源码如下图所示。</p>
<p><img src="http://image.leonote.cn/20210126131110.png" alt=""></p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 在CompletableFuture异步线程中正确使用JPA</title>
    <url>/2021/01/09/SpringDataJpa%E5%9C%A8CompletableFuture%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8JPA/</url>
    <content><![CDATA[<h1 id="在-CompletableFuture-异步线程中正确使用JPA"><a href="#在-CompletableFuture-异步线程中正确使用JPA" class="headerlink" title="在 CompletableFuture 异步线程中正确使用JPA"></a>在 CompletableFuture 异步线程中正确使用JPA</h1><h2 id="CompletableFuture-的使用实际案例"><a href="#CompletableFuture-的使用实际案例" class="headerlink" title="CompletableFuture 的使用实际案例"></a>CompletableFuture 的使用实际案例</h2><p>在实际开发过程中，难免会用到异步方法，这里列举一个异步方法的例子，经典地还原一些在异步方法里面经常会犯的错误。</p>
<p>模拟一个 Service 方法，通过异步操作，更新 UserInfo 信息，并且可能一个方法里面有不同的业务逻辑，会多次更新 UserInfo 信息，模拟的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//异步操作必须要建立线程池</span></span><br><span class="line">   <span class="meta">@Autowired</span> <span class="keyword">private</span>  Executor executor;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 模拟一个业务service方法，里面有一些异步操作，一些业务方法里面可能修改了两次用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;test/async/user&quot;)</span></span><br><span class="line">   <span class="meta">@Transactional</span> <span class="comment">// 模拟一个 service 方法，期待是一个事务</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testSaveUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      UserInfo user = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">      <span class="comment">//..... 此处模拟一些业务操作，第一次改变 UserInfo 里面的值；</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">200L</span>);<span class="comment">// 加上复杂业务耗时 200 毫秒</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_first&quot;</span>+name); <span class="comment">//模拟一些业务操作，改变了 UserInfo 里面的值</span></span><br><span class="line">      userInfoRepository.save(user);</span><br><span class="line">      <span class="comment">//..... 此处模拟一些业务操作，第二次改变 UserInfo 里面的值；</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="number">300L</span>);<span class="comment">// 加上复杂业务耗时 300 毫秒</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_second&quot;</span>+name);<span class="comment">//模拟一些业务操作，改变了 UserInfo 里面的值</span></span><br><span class="line">      userInfoRepository.save(user);</span><br><span class="line">   &#125;, executor).exceptionally(throwable -&gt; &#123;</span><br><span class="line">      throwable.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//... 实际业务中，可能还有会其他异步方法</span></span><br><span class="line">   cf.isDone();</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 testSaveUser 方法里面开了一个异步线程，异步线程采用 CompletableFuture 方法，在里面执行了两次 UserInfo 的 Save 操作</p>
<p>那么上面的代码问题的表象是什么呢？</p>
<h2 id="表现出来的问题现状是什么样的？"><a href="#表现出来的问题现状是什么样的？" class="headerlink" title="表现出来的问题现状是什么样的？"></a>表现出来的问题现状是什么样的？</h2><p>那么实际工作中，如果写出来类似的代码，会发生什么样的问题呢？</p>
<ol>
<li><p>整个请求非常正常，永远都是 200；也没有任何报错信息，但是发现数据库里面第二次的 save(user) 永远不生效，永远不会出现 name 包含 “_second” 的记录，这个是必现的；</p>
</li>
<li><p>整个请求非常正常，永远都是 200；也没有任何报错信息，有的时候会发现数据库里面没有任何变化，甚至第一次 save(user) 都没有生效，但是这个是偶发的。</p>
</li>
</ol>
<h3 id="步骤拆解"><a href="#步骤拆解" class="headerlink" title="步骤拆解"></a>步骤拆解</h3><h4 id="CompletableFuture-使用最佳实践"><a href="#CompletableFuture-使用最佳实践" class="headerlink" title="CompletableFuture 使用最佳实践"></a>CompletableFuture 使用最佳实践</h4><p>CompletableFuture 主要的功能是实现了 Future 和 CompletionStage 的接口，主要的方法如下述代码所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过给定的线程池，异步执行 Runnable 方法，不带返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; 	<span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过给定的线程池，异步执行 Runnable 方法，带返回结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; 	<span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="comment">//当上面的异步方法执行完之后需要执行的回调方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; 	<span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="comment">//阻塞等待 future 执行完结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//阻塞获取结果</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//当异步操作发生异常的时候执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span>;</span><br></pre></td></tr></table></figure>

<p>CompletableFuture 还有更多的方法，其功能也非常强大，所以一般开发过程中用此类的场景还非常多。</p>
<p>其实上面的 Demo 只是利用 runAsync 做了异步操作，并利用 isDone 做了阻塞等待的动作，而没有使用 Exceptionally 处理异常信息。</p>
<p>所以如果想打印异常信息，基本上可以利用 Exceptionally。改进一下 Demo 代码，把异常信息打印一下，看看是否发生了异常。代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">   ......这里的代码不变</span><br><span class="line">&#125;, executor).exceptionally(e -&gt; &#123;</span><br><span class="line">   log.error(e);<span class="comment">//把异常信息打印出来</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再请求上面的 Controller 方法的时候，发现控制台就会打印出如下所示的 Error 信息:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java.util.concurrent.CompletionException: org.springframework.orm.ObjectOptimisticLockingFailureException: Object of <span class="class"><span class="keyword">class</span> [<span class="title">com</span>.<span class="title">example</span>.<span class="title">jpa</span>.<span class="title">demo</span>.<span class="title">db</span>.<span class="title">UserInfo</span>] <span class="title">with</span> <span class="title">identifier</span> [1]: <span class="title">optimistic</span> <span class="title">locking</span> <span class="title">failed</span>; <span class="title">nested</span> <span class="title">exception</span> <span class="title">is</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">StaleObjectStateException</span>: <span class="title">Row</span> <span class="title">was</span> <span class="title">updated</span> <span class="title">or</span> <span class="title">deleted</span> <span class="title">by</span> <span class="title">another</span> <span class="title">transaction</span> (<span class="title">or</span> <span class="title">unsaved</span>-<span class="title">value</span> <span class="title">mapping</span> <span class="title">was</span> <span class="title">incorrect</span>) : [<span class="title">com</span>.<span class="title">example</span>.<span class="title">jpa</span>.<span class="title">demo</span>.<span class="title">db</span>.<span class="title">UserInfo</span>#1]</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">CompletableFuture</span>.<span class="title">encodeThrowable</span>(<span class="title">CompletableFuture</span>.<span class="title">java</span>:314)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">CompletableFuture</span>.<span class="title">completeThrowable</span>(<span class="title">CompletableFuture</span>.<span class="title">java</span>:319)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">CompletableFuture</span>$<span class="title">AsyncRun</span>.<span class="title">run</span>$$$<span class="title">capture</span>(<span class="title">CompletableFuture</span>.<span class="title">java</span>:1739)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">CompletableFuture</span>$<span class="title">AsyncRun</span>.<span class="title">run</span>(<span class="title">CompletableFuture</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span>.<span class="title">runWorker</span>(<span class="title">ThreadPoolExecutor</span>.<span class="title">java</span>:1167)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span>$<span class="title">Worker</span>.<span class="title">run</span>(<span class="title">ThreadPoolExecutor</span>.<span class="title">java</span>:641)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span>.<span class="title">run</span>(<span class="title">Thread</span>.<span class="title">java</span>:844)</span></span><br><span class="line"><span class="class"><span class="title">Caused</span> <span class="title">by</span>: <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">orm</span>.<span class="title">ObjectOptimisticLockingFailureException</span>: <span class="title">Object</span> <span class="title">of</span> <span class="title">class</span> [<span class="title">com</span>.<span class="title">example</span>.<span class="title">jpa</span>.<span class="title">demo</span>.<span class="title">db</span>.<span class="title">UserInfo</span>] <span class="title">with</span> <span class="title">identifier</span> [1]: <span class="title">optimistic</span> <span class="title">locking</span> <span class="title">failed</span>; <span class="title">nested</span> <span class="title">exception</span> <span class="title">is</span> <span class="title">org</span>.<span class="title">hibernate</span>.<span class="title">StaleObjectStateException</span>: <span class="title">Row</span> <span class="title">was</span> <span class="title">updated</span> <span class="title">or</span> <span class="title">deleted</span> <span class="title">by</span> <span class="title">another</span> <span class="title">transaction</span> (<span class="title">or</span> <span class="title">unsaved</span>-<span class="title">value</span> <span class="title">mapping</span> <span class="title">was</span> <span class="title">incorrect</span>) : [<span class="title">com</span>.<span class="title">example</span>.<span class="title">jpa</span>.<span class="title">demo</span>.<span class="title">db</span>.<span class="title">UserInfo</span>#1]</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">orm</span>.<span class="title">jpa</span>.<span class="title">vendor</span>.<span class="title">HibernateJpaDialect</span>.<span class="title">convertHibernateAccessException</span>(<span class="title">HibernateJpaDialect</span>.<span class="title">java</span>:337)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">orm</span>.<span class="title">jpa</span>.<span class="title">vendor</span>.<span class="title">HibernateJpaDialect</span>.<span class="title">translateExceptionIfPossible</span>(<span class="title">HibernateJpaDialect</span>.<span class="title">java</span>:255)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">aop</span>.<span class="title">framework</span>.<span class="title">ReflectiveMethodInvocation</span>.<span class="title">proceed</span>(<span class="title">ReflectiveMethodInvocation</span>.<span class="title">java</span>:186)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">aop</span>.<span class="title">framework</span>.<span class="title">JdkDynamicAopProxy</span>.<span class="title">invoke</span>(<span class="title">JdkDynamicAopProxy</span>.<span class="title">java</span>:212)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy116</span>.<span class="title">save</span>(<span class="title">Unknown</span> <span class="title">Source</span>)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">jpa</span>.<span class="title">demo</span>.<span class="title">web</span>.<span class="title">UserInfoController</span>.<span class="title">lambda</span>$<span class="title">testSaveUser</span>$0(<span class="title">UserInfoController</span>.<span class="title">java</span>:57)</span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">java</span>.<span class="title">base</span>/<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">CompletableFuture</span>$<span class="title">AsyncRun</span>.<span class="title">run</span>$$$<span class="title">capture</span>(<span class="title">CompletableFuture</span>.<span class="title">java</span>:1736)</span></span><br><span class="line"><span class="class">	... 4 <span class="title">more</span></span></span><br></pre></td></tr></table></figure>

<p>通过报错信息，可以发现其实就是发生了<strong>乐观锁异常</strong>，导致上面实例中的第二次 save(user) 必然失败；而第一次 save(user) 的失败，主要是因为在并发的情况下有其他请求线程改变了 UserInfo 的值，也就是改变了 Version。</p>
<p>来看一下完整的 UserInfo 对象实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@EntityListeners(&#123;AuditingEntityListener.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span></span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="meta">@Version</span></span><br><span class="line">   <span class="keyword">private</span> Integer version;</span><br><span class="line">   <span class="meta">@CreatedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@CreatedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant createTime;</span><br><span class="line">   <span class="meta">@LastModifiedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="meta">@LastModifiedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant lastModifiedTime;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="keyword">private</span> String emailAddress;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 @Version 乐关锁机制就是防止数据被覆盖；而实际生产过程中其实很难发现类似问题。</p>
<p>所以当使用任何的异步线程处理框架的时候，一定要想好异常情况下怎么打印日志，否则就像黑洞一样，完全不知道发生了什么。</p>
<p>那么既然知道发生了乐观锁异常，这里就有个疑问了：在 UserInfoController 的 testSaveUser 方法上面加了 @Transaction 的注解，为什么事务没有回滚？</p>
<h4 id="通过日志查看事务的执行过程"><a href="#通过日志查看事务的执行过程" class="headerlink" title="通过日志查看事务的执行过程"></a>通过日志查看事务的执行过程</h4><p>看看异步请求的情况下，事务应该怎么做呢？先打开事务的日志，看看上面方法的事务执行过程是什么样的。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在 db 的连接中开启 logger=Slf4JLogger&amp;profileSQL=true 看一下每个事务里执行的 sql 有哪些</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?logger=Slf4JLogger&amp;profileSQL=true</span></span><br><span class="line"><span class="comment">## 打开下面这些类的日志级别，观察一下事务的开启和关闭时机</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm.jpa</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.transaction</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm.jpa.JpaTransactionManager</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.engine.transaction.internal.TransactionImpl</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>再请求一下刚才的测试接口：POST <a href="http://localhost:8087/test/async/user?name=jack">http://localhost:8087/test/async/user?name=jack</a> 就会产生下图所示的日志。</p>
<p><img src="http://image.leonote.cn/20210111161229.png" alt=""></p>
<p>先看一下上半部分，通过日志可以看到，首先执行这个方法的时候开启了两个事务，分别做如下解释。</p>
<p><strong>线程 1</strong>：[nio-8087-exec-1] 开启了 UserInfoController.testSaveUser 方法上面的事务，也就是 http 的请求线程，开启了一个 Controller 请求事务。这是因为在 testSaveUser 的方法上面加了 @Transaction 的注解，所以开启了一个事务。</p>
<p>而通过日志可以发现，事务 1 里面什么都没有做，随后就进行了 Commit 操作，所以看得出来，<strong><em>默认不做任何处理的情况下，事务是不能跨线程的。每个线程里面的事务相互隔离、互不影响。</em></strong></p>
<p><strong>线程 2</strong>：[         task-1]，通过异步线程池开启了 SimpleJpaRepository.findById 方法上面的只读事务。这是因为默认的 SimpleJpaRepository 类上面加了 @Transaction(readOnly=true) 产生的结果。通过 MySQL 的日志也可以看得出来，此次事务里面只做了和代码相关的 select user_info 的操作。</p>
<p>再看一下后半部分的日志，如图所示。</p>
<p><img src="http://image.leonote.cn/20210111162146.png" alt=""></p>
<p>通过后半部分日志，可以看到两次 save(user) 方法，也分别开启了各自的事务，这是因为 SimpleJpaRepository.save 方法上面有 @Transaction 注解起了作用，而第二次事务因为 JPA 的实现方法判断了数据库这条数据的 Version 和 UserInfo 的对象中的 Version 不一致，从而第二次进行了回滚操作。</p>
<p>两次 save(user) 的操作里面分别有一次 Select 和 Update 语义。两次事务，分别开启了两个 Session，所以对象对于这两次 Session 来说分别是从游离态（Detached）转成持久态（Persistent）的过程，所以两个独立的事务里面，一次 Select，一次 Update。</p>
<p>通过日志可以看到，上面一个简单的方法中一共发生了四次事务，都是采用的默认隔离级别和传播机制。那么如果想让异步方法里面只有一个事务应该怎么办呢？</p>
<h3 id="异步事务的正确使用方法"><a href="#异步事务的正确使用方法" class="headerlink" title="异步事务的正确使用方法"></a>异步事务的正确使用方法</h3><p>异步方法里面的事务是独立的，那么直接把异步的代码块用独立的事务包装起来即可，做法有如下几种：</p>
<p>第一种处理方法：把其中的异步代码块，移到一个外部类里面。这里放到 UserInfoService 中，同时方法中加上 @Transaction 注解用来开启事务，加上 @Retryable 注解进行乐观锁重试，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上事务，这样可以做到原子性，解决事务加到异常方法之外没有任何作用的问题</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="comment">//加上重试机制，这样当发生乐观锁异常的时候，重新尝试下面的逻辑，减少请求的失败次数</span></span><br><span class="line"><span class="meta">@Retryable(value = ObjectOptimisticLockingFailureException.class,backoff = @Backoff(multiplier = 1.5,random = true))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessUserMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   UserInfo user = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">   <span class="comment">//..... 此处模拟一些业务操作，第一次改变UserInfo里面的值；</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">200L</span>);<span class="comment">// 加上复杂业务耗时 200 毫秒</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_first&quot;</span>+name); <span class="comment">//模拟一些业务操作，改变了 UserInfo 里面的值</span></span><br><span class="line">   userInfoRepository.save(user);</span><br><span class="line">   <span class="comment">//..... 此处模拟一些业务操作，第二次改变 UserInfo 里面的值；</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">300L</span>);<span class="comment">// 加上复杂业务耗时 300 毫秒</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_second&quot;</span>+name);<span class="comment">//模拟一些业务操作，改变了 UserInfo 里面的值</span></span><br><span class="line">   userInfoRepository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 Controller 里面只需要变成如下写法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个业务service方法，里面有一些异步操作，一些业务方法里面可能修改了两次用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;test/async/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSaveUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      userInfoService.businessUserMethod(name);</span><br><span class="line">   &#125;, executor).exceptionally(e -&gt; &#123;</span><br><span class="line">      log.error(e);<span class="comment">//把异常信息打印出来</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//... 实际业务中，可能还有会其他异步方法</span></span><br><span class="line">   cf.isDone();</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次发起一下请求，看一下日志。</p>
<p><img src="http://image.leonote.cn/20210111163243.png" alt=""></p>
<p>通过上图的日志，可以知道两个重要信息：</p>
<ol>
<li><p>这个时候只有 UserInfoServiceImpl.businessUserMethod 开启了一个事务，这是因为 findById 和 Save 方法中，事务的传播机制都是“如果存在事务就利用当前事务”的原理，所以就不会像上面一样创建四次事务了；</p>
</li>
<li><p>而此时两次 save(user) 只产生了一个 update 的 sql 语句，并且也很难出现乐观锁异常了，因为这是 Session 的机制，将两次对 UserInfo 实体的操作进行了合并；所以使用 JPA 的时候某种程度上也会降低 db 的压力，增加代码的执行性能。</p>
</li>
</ol>
<p>而另外一个侧论，就是当事务的生命周期执行越快的时候，发生异常的概率就会越低，因为可以减少并发处理的机会。</p>
<p>第二种处理方法：TransactionTemplate 方法开启事务</p>
<p>第三种处理方法：可以建一个自己的 TransactionHelper，并带上重试机制，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用spring进行管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Component</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TransactionHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用 spring 机制和 jdk8 的 Consumer 机制实现只消费的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Transactional(rollbackFor = Exception.class) <span class="comment">//可以根据实际业务情况，指定明确的回滚异常</span></span><br><span class="line">    @Retryable(value = ObjectOptimisticLockingFailureException.class,backoff = @Backoff(multiplier = <span class="number">1.5</span>,random = <span class="literal">true</span>))</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">transactional</span>(<span class="params">Consumer consumer,<span class="built_in">Object</span> o</span>)</span> &#123;</span><br><span class="line">        consumer.accept(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller 里面的写法可以变成如下方式，也可以达到同样效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;test/async/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSaveUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">   CompletableFuture&lt;Void&gt; cf = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">      transactionHelper.transactional((param)-&gt;&#123; <span class="comment">// 通过lambda实现事务管理</span></span><br><span class="line">         UserInfo user = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">         <span class="comment">//..... 此处模拟一些业务操作，第一次改变UserInfo里面的值；</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200L</span>);<span class="comment">// 加上复杂业务耗时200毫秒</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_first&quot;</span>+name); <span class="comment">//模拟一些业务操作，改变了UserInfo里面的值</span></span><br><span class="line">         userInfoRepository.save(user);</span><br><span class="line">         <span class="comment">//..... 此处模拟一些业务操作，第二次改变UserInfo里面的值；</span></span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">300L</span>);<span class="comment">// 加上复杂业务耗时300毫秒</span></span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_second&quot;</span>+name);<span class="comment">//模拟一些业务操作，改变了UserInfo里面的值</span></span><br><span class="line">         userInfoRepository.save(user);</span><br><span class="line">      &#125;,name);</span><br><span class="line">   &#125;, executor).exceptionally(e -&gt; &#123;</span><br><span class="line">      log.error(e);<span class="comment">//把异常信息打印出来</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//... 实际业务中，可能还有会其他异步方法</span></span><br><span class="line">   cf.isDone();</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式主要是通过 Lambda 表达式解决事务问题。</p>
<p>总之，不管是以上哪种方法，都可以解决所说的异步事务的问题。所以搞清楚事务的背后实现逻辑，就很容易解决类似问题了。</p>
<p>还有一个问题就是，为什么当异步方法中是同一个事务的时候，第二次 save(user) 就成功了？而异步代码块里面的两个 save(user) 分别在两个事务里面，第二次就不成功了呢？</p>
<h2 id="Session-的机制与-Repository-save-entity-是什么关系？"><a href="#Session-的机制与-Repository-save-entity-是什么关系？" class="headerlink" title="Session 的机制与 Repository.save(entity) 是什么关系？"></a>Session 的机制与 Repository.save(entity) 是什么关系？</h2><p>Entity 有不同的状态。</p>
<p>在一个 Session 里面，如果通过 findById(id) 得到一个 Entity，它就会变成 Manager（persist） 持久态。那么同一个 Session 里面，同一个 Entity 多次操作 Hibernate 就会进行 Merge 操作。</p>
<p>所以上面的实例中，当在 businessUserMethod 方法上面加 @Transaction 的时候，会造成异步代码的整块逻辑处于同一个事务里面， 同一个事务就会共享同一个 Session，所以同一个事务里面的 findById、save、save 的多次操作都是同一个实例。</p>
<p>什么意思呢？可以通过设置 Debug 断点，查看一下对象的内存对象地址是否一样，就可以看得出来。如下图所示，findById 之后和两次 save 之后都是同一个对象。</p>
<p><img src="http://image.leonote.cn/20210111164917.png" alt=""></p>
<p>而如果跨 Session 传递实体对象，那么在一个 Session 里面持久态的对象，对于另外一个 Session 来说就是一个Detached（游离态）的对象。</p>
<p>而根据 Session 里面的 Persistent Context 的原理，一旦这个游离态的对象进行 db 操作，Session 会 Copy 一个新的实体对象。也就是说，当我们不在异步代码中加事务的时候，即去掉异步代码块 businessUserMethod 方法中的 @Transaction 注解，findById 之后就会产生一个新的事务、新的 Session，那么返回的就是对象 1；第一次 Save 之后，由于又是一个新的事务、新的 Session，那么返回的实体 u2 就是对象 2。</p>
<p>知道这个原理之后，对代码做如下改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  @Transactional 去掉事务</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessUserMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      UserInfo user = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">      user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_first&quot;</span>+name); <span class="comment">//模拟一些业务操作，改变了UserInfo里面的值</span></span><br><span class="line">      UserInfo u2 = userInfoRepository.save(user);</span><br><span class="line">      user.setName(RandomUtils.nextInt(<span class="number">1</span>,<span class="number">100000</span>)+ <span class="string">&quot;_second&quot;</span>+name); <span class="comment">//模拟一些业务操作，改变了UserInfo里面的值</span></span><br><span class="line">      UserInfo u3 = userInfoRepository.save(u2);<span class="comment">// 第二次save采用第一次save的返回结果，这样里面带有了最新的version的值，所以也就会保存成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步里面调用这个方法也是成功的，因为乐观锁的原理是 Version 变了，我们用最新的对象，也就是最新的 Version 就可以了。</p>
<p>设置一个断点看一下 user、u2、u3 在不同的 Session 作用域之后，就变成不同的实例了，如下所示。</p>
<p><img src="http://image.leonote.cn/20210111165244.png" alt=""></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol>
<li><p>在上面 Demo 中的异步场景下设置 open-in-view 等于 true / false，会对上面的测试结果有影响吗？</p>
<p>答案是 肯定没有影响的，spring.jpa.open-in-view 的本质还是开启 Session，而保持住 Session 的本质还是利用 ThreadLocal，也就是必须为同一个线程的情况下才适用。所以<strong><em>异步场景不受 spring.jpa.open-in-view 控制</em></strong>。</p>
</li>
<li><p>如果是大量的异步操作 db connection 的持有模式，应该配置成哪一种比较合适？</p>
<p>答案是 DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION，因为这样可以做到对 db 连接最大的利用率。用的时候就获取，事务提交完就释放，这样就不用关心业务逻辑执行多长时间了。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在开发业务代码的时候，需要思考一下几个问题</p>
<ol>
<li>一个请求，开启了几次事务？几次 Session？在什么时机开启的？</li>
<li>事务和 Session 分别会对实体的状态有什么影响？</li>
<li><strong>一个请求，对 db 连接池里面的连接持有时间是多久？</strong></li>
<li><strong>一个请求，性能指标都有哪些决定因素？</strong></li>
</ol>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 处理生产环境多数据源的问题</title>
    <url>/2020/11/17/SpringDataJpa%E5%A4%84%E7%90%86%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="生产环境多数据源的处理方法有哪些？"><a href="#生产环境多数据源的处理方法有哪些？" class="headerlink" title="生产环境多数据源的处理方法有哪些？"></a>生产环境多数据源的处理方法有哪些？</h1><p>工作中我们时常会遇到跨数据库操作的情况，这时候就需要配置多数据源：</p>
<ul>
<li>如何配置？</li>
<li>常用的方式及其背后的原理？</li>
</ul>
<h2 id="常用的配置方式"><a href="#常用的配置方式" class="headerlink" title="常用的配置方式"></a>常用的配置方式</h2><ol>
<li>通过多个 @Configuration 文件</li>
<li>利用 <code>AbstractRoutingDataSource</code> 配置多数据源</li>
</ol>
<h2 id="第一种方式：多个数据源的-Configuration-的配置方法"><a href="#第一种方式：多个数据源的-Configuration-的配置方法" class="headerlink" title="第一种方式：多个数据源的 @Configuration 的配置方法"></a>第一种方式：多个数据源的 @Configuration 的配置方法</h2><blockquote>
<p>🎯主要思路：不同 Package 下面的实体和 Repository 采用不同的 Data Source</p>
</blockquote>
<p>所以改造一下 example 目录结构，来看看不同 Repositories 的数据源是怎么处理的。</p>
<p><strong>第一步：规划 Entity 和 Repository 的目录结构，为了方便配置多数据源。</strong></p>
<ul>
<li>将 User 和 UserAddress、UserRepository 和 UserAddressRepository 移动到 db1 里面；</li>
<li>将 UserInfo 和 UserInfoRepository 移动到 db2 里面。</li>
</ul>
<p>如下图所示：</p>
<p><img src="http://image.leonote.cn//20201117193953.png" alt=""></p>
<p>把实体和 Repository 分别放到了 db1 和 db2 两个目录里面，假设数据源 1 是 MySQL，User 表和 UserAddress 表在数据源 1 里面，那么需要配置一个数据源 1 的 Configuration 类，并且在里面配置 DataSource、TransactionManager 和 EntityManager。</p>
<p><strong>第二步：配置 DataSource1Config 类。</strong></p>
<p>目录结构调整完之后，接下来开始配置数据源，完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="comment">//利用EnableJpaRepositories配置哪些包下面的Repositories，采用哪个EntityManagerFactory和哪个transactionManager</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(</span></span><br><span class="line"><span class="meta">      basePackages = &#123;&quot;com.example.jpa.example1.db1&quot;&#125;,//数据源1的repository的包路径</span></span><br><span class="line"><span class="meta">      entityManagerFactoryRef = &quot;db1EntityManagerFactory&quot;,//改变数据源1的EntityManagerFactory的默认值，改为db1EntityManagerFactory</span></span><br><span class="line"><span class="meta">      transactionManagerRef = &quot;db1TransactionManager&quot;//改变数据源1的transactionManager的默认值，改为db1TransactionManager</span></span><br><span class="line"><span class="meta">      )</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSource1Config</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定数据源1的dataSource配置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;db1DataSourceProperties&quot;)</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(&quot;spring.datasource1&quot;)</span> <span class="comment">//数据源1的db配置前缀采用spring.datasource1</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 可以选择不同的数据源，这里用HikariDataSource举例，创建数据源1</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> db1DataSourceProperties</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;db1DataSource&quot;)</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari.db1&quot;)</span> <span class="comment">//配置数据源1所用的hikari配置key的前缀</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(<span class="meta">@Qualifier(&quot;db1DataSourceProperties&quot;)</span> DataSourceProperties db1DataSourceProperties)</span> </span>&#123;</span><br><span class="line">      HikariDataSource dataSource = db1DataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(db1DataSourceProperties.getName())) &#123;</span><br><span class="line">         dataSource.setPoolName(db1DataSourceProperties.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置数据源1的entityManagerFactory命名为db1EntityManagerFactory，用来对实体进行一些操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> db1DataSource entityManager依赖db1DataSource</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;db1EntityManagerFactory&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(EntityManagerFactoryBuilder builder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                                      <span class="meta">@Qualifier(&quot;db1DataSource&quot;)</span> DataSource db1DataSource)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> builder.dataSource(db1DataSource)</span><br><span class="line">					.packages(<span class="string">&quot;com.example.jpa.example1.db1&quot;</span>) <span class="comment">//数据1的实体所在的路径</span></span><br><span class="line">					.persistenceUnit(<span class="string">&quot;db1&quot;</span>)<span class="comment">// persistenceUnit的名字采用db1</span></span><br><span class="line">					.build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置数据源1的事务管理者，命名为db1TransactionManager依赖db1EntityManagerFactory</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> db1EntityManagerFactory </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Primary</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;db1TransactionManager&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;db1EntityManagerFactory&quot;)</span> </span></span></span><br><span class="line"><span class="function"><span class="params">                                                        EntityManagerFactory db1EntityManagerFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(db1EntityManagerFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，数据源 1 就配置完了，下面再配置数据源 2。</p>
<p><strong>第三步：配置 DataSource2Config 类，加载数据源 2。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="comment">//利用EnableJpaRepositories，配置哪些包下面的Repositories，采用哪个EntityManagerFactory和哪个transactionManager</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(</span></span><br><span class="line"><span class="meta">        basePackages = &#123;&quot;com.example.jpa.example1.db2&quot;&#125;,//数据源2的repository的包路径</span></span><br><span class="line"><span class="meta">        entityManagerFactoryRef = &quot;db2EntityManagerFactory&quot;,//改变数据源2的EntityManagerFactory的默认值，改为db2EntityManagerFactory</span></span><br><span class="line"><span class="meta">        transactionManagerRef = &quot;db2TransactionManager&quot;//改变数据源2的transactionManager的默认值，改为db2TransactionManager</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSource2Config</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定数据源2的dataSource配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2DataSourceProperties&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;spring.datasource2&quot;)</span> <span class="comment">//数据源2的db配置前缀采用spring.datasource2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceProperties <span class="title">dataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以选择不同的数据源，这里我用HikariDataSource举例，创建数据源2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> db2DataSourceProperties</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2DataSource&quot;)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari.db2&quot;)</span> <span class="comment">//配置数据源2的hikari配置key的前缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HikariDataSource <span class="title">dataSource</span><span class="params">(<span class="meta">@Qualifier(&quot;db2DataSourceProperties&quot;)</span> DataSourceProperties db2DataSourceProperties)</span> </span>&#123;</span><br><span class="line">        HikariDataSource dataSource = db2DataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(db2DataSourceProperties.getName())) &#123;</span><br><span class="line">            dataSource.setPoolName(db2DataSourceProperties.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置数据源2的entityManagerFactory命名为db2EntityManagerFactory，用来对实体进行一些操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> db2DataSource entityManager依赖db2DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2EntityManagerFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(EntityManagerFactoryBuilder builder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                                       <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource db2DataSource)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> builder.dataSource(db2DataSource)</span><br><span class="line">           			 .packages(<span class="string">&quot;com.example.jpa.example1.db2&quot;</span>) <span class="comment">//数据2的实体所在的路径</span></span><br><span class="line">                	 .persistenceUnit(<span class="string">&quot;db2&quot;</span>)<span class="comment">// persistenceUnit的名字采用db2</span></span><br><span class="line">         		     .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置数据源2的事务管理者，命名为db2TransactionManager依赖db2EntityManagerFactory</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> db2EntityManagerFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;db2TransactionManager&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;db2EntityManagerFactory&quot;)</span> </span></span></span><br><span class="line"><span class="function"><span class="params">                                                         EntityManagerFactory db2EntityManagerFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(db2EntityManagerFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🤣注意：DataSource1Config 和 DataSource2Config 不同的是，1 里面每个 @Bean 都 @Primary，而 2 里面不是的。</p>
</blockquote>
<p><strong>第四步：通过 application.properties 配置两个数据源的值</strong>，代码如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">###########datasource1 采用Mysql数据库</span></span><br><span class="line"><span class="meta">spring.datasource1.url</span>=<span class="string">jdbc:mysql://localhost:3306/test2?logger=Slf4JLogger&amp;profileSQL=true</span></span><br><span class="line"><span class="meta">spring.datasource1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource1.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">##数据源1的连接池的名字</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db1.pool-name</span>=<span class="string">jpa-hikari-pool-db1</span></span><br><span class="line"><span class="comment">##最长生命周期15分钟够了</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db1.maxLifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db1.maximumPoolSize</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">###########datasource2 采用h2内存数据库</span></span><br><span class="line"><span class="meta">spring.datasource2.url</span>=<span class="string">jdbc:h2:~/test</span></span><br><span class="line"><span class="meta">spring.datasource2.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="meta">spring.datasource2.password</span>=<span class="string">sa</span></span><br><span class="line"><span class="comment">##数据源2的连接池的名字</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db2.pool-name</span>=<span class="string">jpa-hikari-pool-db2</span></span><br><span class="line"><span class="comment">##最长生命周期和数据源1区分开，设置成500秒</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db2.maxLifetime</span>=<span class="string">500000</span></span><br><span class="line"><span class="comment">##最大连接池大小和数据源1区分开，配置成6个</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.db2.maximumPoolSize</span>=<span class="string">6</span></span><br></pre></td></tr></table></figure>

<p><strong>第五步：写个 Controller 测试一下。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">   <span class="meta">@Autowired</span> <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="comment">//操作user的Repository</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//操作userInfo的Repository</span></span><br><span class="line">  <span class="meta">@PostMapping(&quot;/user/info&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserInfo <span class="title">saveUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> userInfoRepository.save(userInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第六步：直接启动我们的项目，测试一下。</strong></p>
<p>请看这一步的启动日志：</p>
<p><img src="http://image.leonote.cn//20201117195320.png" alt=""></p>
<p>可以看到启动的是两个数据源，其对应的连接池的监控是不一样的：数据源 1 有 8 个，数据源 2 有 6 个。</p>
<p><img src="http://image.leonote.cn//20201117195706.png" alt=""></p>
<p>如果分别请求 Controller 写的两个方法的时候，也会分别插入到不同的数据源里面去。</p>
<h3 id="Datasource-与-TransactionManager、EntityManagerFactory-的关系分析"><a href="#Datasource-与-TransactionManager、EntityManagerFactory-的关系分析" class="headerlink" title="Datasource 与 TransactionManager、EntityManagerFactory 的关系分析"></a>Datasource 与 TransactionManager、EntityManagerFactory 的关系分析</h3><p>通过一个类的关系图来分析一下：</p>
<p><img src="http://image.leonote.cn//20201117200329.png" alt=""></p>
<p>其中，</p>
<ol>
<li><code>HikariDataSource</code> 负责实现 DataSource，交给 EntityManager 和 TransactionManager 使用；</li>
<li>EntityManager 是利用 DataSource 来操作数据库，而其实现类是 <code>SessionImpl</code>；</li>
<li>EntityManagerFactory 是用来管理和生成 EntityManager 的，而 EntityManagerFactory 的实现类是 <code>LocalContainerEntityManagerFactoryBean</code>，通过实现 FactoryBean 接口实现，利用了 FactoryBean 在 Spring 中的 bean 管理机制，所以需要在 Datasource1Config 里面配置 <code>LocalContainerEntityManagerFactoryBean</code> 的 bean 的注入方式；</li>
<li><code>JpaTransactionManager</code> 是用来管理事务的，实现了 TransactionManager 并且通过 EntityManagerFactory 和 Datasource 进行 db 操作，所以要在 DataSourceConfig 里面告诉 JpaTransactionManager 用的 TransactionManager 是 db1EntityManagerFactory。</li>
</ol>
<blockquote>
<p>🏓关系图：</p>
<p><code>DataSourceConfig</code> -&gt; <code>TransactionManager</code> -&gt; <code>EntityManagerFactory</code> -&gt; <code>EntityManager</code> -&gt; <code>DataSource</code> </p>
<pre><code>↓                                        ↓                                                                ↓</code></pre><p>​                    <code>JpaTransactionManager</code> -&gt; <code>LocalContainerEntityManagerFactoryBean</code> -&gt;  ..  -&gt; <code>HikariDataSource</code> </p>
</blockquote>
<p>默认情况下 Datasource 的 EntityManagerFactory 和 TransactionManager 是怎么加载和配置的呢？</p>
<h3 id="默认的-JpaBaseConfiguration-的加载方式分析"><a href="#默认的-JpaBaseConfiguration-的加载方式分析" class="headerlink" title="默认的 JpaBaseConfiguration 的加载方式分析"></a>默认的 JpaBaseConfiguration 的加载方式分析</h3><p>可以通过 HibernateJpaConfiguration，找到父类 JpaBaseConfiguration 类，如图所示：</p>
<p><img src="http://image.leonote.cn//20201117201745.png" alt=""></p>
<p>接着打开 <code>JpaBaseConfiguration</code> 就可以看到多数据源的参考原型，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201117202608.png" alt=""></p>
<p>通过上面的代码，可以看到在单个数据源情况下的 EntityManagerFactory 和 TransactionManager 的加载方法，</p>
<p>并且我们在<strong>多数据源的配置</strong>里面还加载了一个类：EntityManagerFactoryBuilder ，正是从上面的方法加载进去的。</p>
<h2 id="第二种方式：利用-AbstractRoutingDataSource-配置多数据源"><a href="#第二种方式：利用-AbstractRoutingDataSource-配置多数据源" class="headerlink" title="第二种方式：利用 AbstractRoutingDataSource 配置多数据源"></a>第二种方式：利用 AbstractRoutingDataSource 配置多数据源</h2><p>DataSource 的本质是获得数据库连接，而 <code>AbstractRoutingDataSource</code> 帮我们实现了动态获得数据源的可能性。</p>
<p><strong>第一步：定一个数据源的枚举类，用来标示数据源有哪些。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个数据源的枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">RoutingDataSourceEnum</span> </span>&#123;</span><br><span class="line">   DB1, <span class="comment">// 实际工作中枚举的语义可以更加明确一点；</span></span><br><span class="line">   DB2;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RoutingDataSourceEnum <span class="title">findByCode</span><span class="params">(String dbRouting)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (RoutingDataSourceEnum e : values()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (e.name().equals(dbRouting)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> db1;<span class="comment">//没找到的情况下，默认返回数据源1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：新增 DataSourceRoutingHolder，用来存储当前线程需要采用的数据源。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用 ThreadLocal 来存储，当前的线程使用的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceRoutingHolder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;RoutingDataSourceEnum&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBranchContext</span><span class="params">(RoutingDataSourceEnum dataSourceEnum)</span> </span>&#123;</span><br><span class="line">      threadLocal.set(dataSourceEnum);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RoutingDataSourceEnum <span class="title">getBranchContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearBranchContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      threadLocal.remove();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：配置 RoutingDataSourceConfig，用来指定哪些 Entity 和 Repository 采用动态数据源。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(</span></span><br><span class="line"><span class="meta">      //数据源的 repository 的包路径，这里我们覆盖 db1 和 db2 的包路径</span></span><br><span class="line"><span class="meta">      basePackages = &#123;&quot;com.example.jpa.example1&quot;&#125;,</span></span><br><span class="line"><span class="meta">      entityManagerFactoryRef = &quot;routingEntityManagerFactory&quot;,</span></span><br><span class="line"><span class="meta">      transactionManagerRef = &quot;routingTransactionManager&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingDataSourceConfig</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;db1DataSource&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> DataSource db1DataSource;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> DataSource db2DataSource;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建RoutingDataSource，引用我们之前配置的db1DataSource和db2DataSource</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;routingDataSource&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Map&lt;Object, Object&gt; dataSourceMap = Maps.newHashMapWithExpectedSize(<span class="number">2</span>);</span><br><span class="line">      dataSourceMap.put(RoutingDataSourceEnum.DB1, db1DataSource);</span><br><span class="line">      dataSourceMap.put(RoutingDataSourceEnum.DB2, db2DataSource);</span><br><span class="line">      RoutingDataSource routingDataSource = <span class="keyword">new</span> RoutingDataSource();</span><br><span class="line">      <span class="comment">//设置RoutingDataSource的默认数据源</span></span><br><span class="line">      routingDataSource.setDefaultTargetDataSource(db1DataSource);</span><br><span class="line">      <span class="comment">//设置RoutingDataSource的数据源列表</span></span><br><span class="line">      routingDataSource.setTargetDataSources(dataSourceMap);</span><br><span class="line">      <span class="keyword">return</span> routingDataSource;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 类似db1和db2的配置，唯一不同的是，这里采用routingDataSource</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> routingDataSource entityManager依赖routingDataSource</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;routingEntityManagerFactory&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(EntityManagerFactoryBuilder builder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                                      <span class="meta">@Qualifier(&quot;routingDataSource&quot;)</span> DataSource routingDataSource)</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> builder.dataSource(routingDataSource)</span><br><span class="line">            .packages(<span class="string">&quot;com.example.jpa.example1&quot;</span>) <span class="comment">//数据routing的实体所在的路径，这里我们覆盖db1和db2的路径</span></span><br><span class="line">            .persistenceUnit(<span class="string">&quot;db-routing&quot;</span>)<span class="comment">// persistenceUnit的名字采用db-routing</span></span><br><span class="line">            .build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 配置数据的事务管理者，命名为 routingTransactionManager 依赖 routingEntityManagerFactory</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> routingEntityManagerFactory</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean(name = &quot;routingTransactionManager&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;routingEntityManagerFactory&quot;)</span> </span></span></span><br><span class="line"><span class="function"><span class="params">                                                        EntityManagerFactory routingEntityManagerFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JpaTransactionManager(routingEntityManagerFactory);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由数据源配置与 DataSource1Config 和 DataSource2Config 有相互覆盖关系，这里覆盖 db1 和 db2 的包路径，以便于动态数据源生效。</p>
<p><strong>第四步：写一个 MVC 拦截器，用来指定请求分别采用什么数据源。</strong></p>
<p>新建一个类 <code>DataSourceInterceptor</code>，用来在请求前后指定数据源，请看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态路由的实现逻辑，我们通过请求里面的db-routing，来指定此请求采用什么数据源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求处理之前更改线程里面的数据源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                      HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      String dbRouting = request.getHeader(<span class="string">&quot;db-routing&quot;</span>);</span><br><span class="line">      DataSourceRoutingHolder.setBranchContext(RoutingDataSourceEnum.findByCode(dbRouting));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 请求结束之后清理线程里面的数据源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">      DataSourceRoutingHolder.clearBranchContext();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时需要在实现 WebMvcConfigurer 的配置里面，把我们自定义拦截器 dataSourceInterceptor 加载进去，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现WebMvcConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> DataSourceInterceptor dataSourceInterceptor;</span><br><span class="line">   <span class="comment">//添加自定义拦截器</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">      registry.addInterceptor(dataSourceInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">      WebMvcConfigurer.<span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">   &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处采用的是 MVC 的拦截器机制动态改变的数据配置，你也可以使用自己的 AOP 任意的拦截器，如事务拦截器、Service 的拦截器等，都可以实现。</p>
<blockquote>
<p>🏓注意：要在开启事务之前配置完毕</p>
</blockquote>
<p><strong>第五步：启动测试。</strong></p>
<p>在 Http 请求头里面加上 db-routing：DB2，那么本次请求就会采用数据源 2 进行处理，请求代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/user/info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8089</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">db-routing</span><span class="punctuation">: </span>DB2</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>56d8dc02-7f3e-7b95-7ff1-572a4bb7d102</span><br><span class="line">&#123;&quot;ages&quot;:10&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面五个步骤，可以利用 <code>AbstractRoutingDataSource</code> 实现动态数据源，实际工作中可能更复杂，可能需要考虑多线程、线程安全等问题。</p>
<h3 id="多数据源的注意事项"><a href="#多数据源的注意事项" class="headerlink" title="多数据源的注意事项"></a>多数据源的注意事项</h3><ol>
<li><p>这种方式利用了<strong>当前线程事务不变的原理</strong>，所以要<strong>注意异步线程</strong>的处理方式；</p>
</li>
<li><p>这种方式利用了 DataSource 的原理，动态地返回不同的 db 连接，一般<strong>需要在开启事务之前使用</strong>，需要<strong>注意事务的生命周期</strong>；</p>
</li>
<li><p>比较<strong>适合读写操作分开的业务场景</strong>；</p>
</li>
<li><p>多数据的情况下，<strong>避免一个事务里面采用不同的数据源</strong>，这样会有意想不到的情况发生，比如死锁现象；</p>
</li>
<li><p>学会通过日志检查开启请求的方法和开启的数据源是否正确，可以通过 Debug 断点来观察数据源是否选择的正确，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201117205419.png" alt=""></p>
</li>
</ol>
<h3 id="微服务下的建议"><a href="#微服务下的建议" class="headerlink" title="微服务下的建议"></a>微服务下的建议</h3><p>在实际工作中，为了便捷省事，更多开发者喜欢配置多个数据源，但是强烈建议不要在对用户直接提供的 API 服务上面配置多数据源，否则将出现令人措手不及的 Bug。</p>
<p>如果是做后台管理界面，供公司内部员工使用的，那么这种 API 可以为了方便而使用多数据源。</p>
<p>微服务的大环境下，<strong>服务越小，内聚越高</strong>，低耦合服务越健壮，所以一般跨库之间<strong>通过 REST 的 API 协议，进行内部服务之间的调用</strong>，是<strong>最稳妥</strong>的方式，原因有如下几点：</p>
<ol>
<li><p>REST 的 API 协议更容易监控，更容易实现事务的原子性；</p>
</li>
<li><p>db 之间解耦，使业务领域代码职责更清晰，更容易各自处理各种问题；</p>
</li>
<li><p>只读和读写的 API 更容易分离和管理。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa @Entity的回调方法</title>
    <url>/2020/11/09/SpringDataJpa%E7%9A%84@Entity%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Entity-的回调方法"><a href="#Entity-的回调方法" class="headerlink" title="@Entity 的回调方法"></a>@Entity 的回调方法</h1><h2 id="JPA-的-Callbacks-有哪些"><a href="#JPA-的-Callbacks-有哪些" class="headerlink" title="JPA 的 Callbacks 有哪些"></a>JPA 的 Callbacks 有哪些</h2><p>JPA 协议里面规定，可以通过一些注解，为其监听回调事件、指定回调方法。</p>
<p>回调事件注解表：</p>
<table>
<thead>
<tr>
<th>Annotation</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>@PrePersist</code></td>
<td>EntityManager.persist 方法调用之前的回调注解，即新增之前调用</td>
</tr>
<tr>
<td><code>@PostPersist</code></td>
<td>EntityManager.persist 方法之后调用的回调注解，EntityManager.flush 或 EntityManager.commit 方法之后调用的此方法，即保存到数据库之后进行调用</td>
</tr>
<tr>
<td><code>@PreRemove</code></td>
<td>EntityManager.remove 之前调用的回调注解，即删除之前调用</td>
</tr>
<tr>
<td><code>@PostRemove</code></td>
<td>EntityManager.remove 之后调用的回调注解，即删除之后调用</td>
</tr>
<tr>
<td><code>@PreUpdate</code></td>
<td>在实体更新之前调用，所谓的更新起始是在merge之后，实体发生变化，这一注解可以在变化储存到数据库之前调用</td>
</tr>
<tr>
<td><code>@PostUpdate</code></td>
<td>在实体更新之后调用，即实体的字段的值变化之后，在调用EntityManager.flush 或 EntityManager.commit 方法之后调用的此方法</td>
</tr>
<tr>
<td><code>@postLoad</code></td>
<td>在实体从DB加载到程序里面之后回调</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：</p>
<ul>
<li><strong>回调函数</strong>都是和 EntityManager.flush 或 EntityManager.commit 在同一个线程里面执行的，只不过调用方法有先后之分，都是同步调用，所以当任何一个回调方法里面发生异常，都会触发事务进行回滚，而不会触发事务提交。</li>
<li>Callbacks 注解可以放在实体里面，可以放在 super-class 里面，也可以定义在 Entity 的 listener 里面，但需要注意的是：放在实体（或者 super-class）里面的方法，签名格式为“void ()”，即没有参数，方法里面操作的是 this 对象自己；放在实体的 Entity Listener 里面的方法签名格式为“void (Object)”，也就是方法可以有参数，参数是代表用来接收回调方法的实体。</li>
<li>上述注解生效的回调方法可以是 public、private、protected、friendly 类型的，但是不能是 static 和 final 类型的方法。</li>
</ul>
</blockquote>
<h2 id="JPA-Callbacks-的使用方法"><a href="#JPA-Callbacks-的使用方法" class="headerlink" title="JPA Callbacks 的使用方法"></a>JPA Callbacks 的使用方法</h2><h3 id="在实体和-super-class-中使用"><a href="#在实体和-super-class-中使用" class="headerlink" title="在实体和 super-class 中使用"></a>在实体和 super-class 中使用</h3><p>第一步：修改 <code>BaseEntity</code>，在里面新增回调函数和注解，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.base;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.support.AuditingEntityListener;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line"><span class="comment">// @CreatedBy 这个可能会被 AuditingEntityListener 覆盖，为了方便测试，先注释掉</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@CreatedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant createTime;</span><br><span class="line">   <span class="meta">@LastModifiedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="meta">@LastModifiedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant lastModifiedTime;</span><br><span class="line"><span class="comment">//  @Version 由于本身有乐观锁机制，这个测试的时候先注释掉，改用手动设置的值；</span></span><br><span class="line">   <span class="keyword">private</span> Integer version;</span><br><span class="line">   <span class="meta">@PreUpdate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;preUpdate::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">      <span class="keyword">this</span>.setCreateUserId(<span class="number">200</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostUpdate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;postUpdate::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PreRemove</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;preRemove::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostRemove</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;postRemove::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostLoad</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;postLoad::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，使用了<code>@PreUpdate</code>、<code>@PostUpdate</code>、<code>@PreRemove</code>、<code>@PostRemove</code>、<code>@PostLoad</code> 几个注解，并在相应的回调方法里面加了相应的日志。并且在 <code>@PreUpdate</code> 方法里面修改了 create_user_id 的值为 200，这样做是为了方便我们后续测试。</p>
<p>第二步：修改一下 User 类，也新增两个回调函数，并且和 <code>BaseEntity</code> 做法一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.example1.base.BaseEntity;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line"><span class="keyword">import</span> lombok.*;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addresses&quot;,callSuper = true)</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;<span class="comment">// implements Auditable&lt;Integer,Long, Instant&gt; &#123;</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;user&quot;)</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;UserAddress&gt; addresses;</span><br><span class="line">   <span class="keyword">private</span> Boolean deleted;</span><br><span class="line">   <span class="meta">@PrePersist</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prePersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;prePersist::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">      <span class="keyword">this</span>.setVersion(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostPersist</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postPersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;postPersist::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了 <code>@PrePersist</code>、<code>@PostPersist</code> 回调事件，为了方便测试，在 <code>@PrePersist</code> 里面将 version 修改为 1。</p>
<p>第三步：写一个测试用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@Import(JpaConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    MyAuditorAware myAuditorAware;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了和测试方法的事务分开，我们在 init 里面初始化数据做新增操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于测试用例模拟 web context 环境，这里利用 @MockBean，mock掉方法，期待返回13这个用户ID</span></span><br><span class="line">       Mockito.when(myAuditorAware.getCurrentAuditor()).thenReturn(Optional.of(<span class="number">13</span>));</span><br><span class="line">        User u1 = User.builder()</span><br><span class="line">                .name(<span class="string">&quot;jack&quot;</span>)</span><br><span class="line">                .email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                .sex(SexEnum.BOY)</span><br><span class="line">                .age(<span class="number">20</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//没有save之前 version是null</span></span><br><span class="line">        Assertions.assertNull(u1.getVersion());</span><br><span class="line">        userRepository.save(u1);</span><br><span class="line">        <span class="comment">//这里面触发保存方法，这个时候我们将version设置成了1，然后验证一下</span></span><br><span class="line">        Assertions.assertEquals(<span class="number">1</span>,u1.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试一下更新和查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallBackUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时会触发@PostLoad事件</span></span><br><span class="line">        User u1 = userRepository.getOne(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">//从db里面重新查询出来，验证一下version是不是1</span></span><br><span class="line">        Assertions.assertEquals(<span class="number">1</span>,u1.getVersion());</span><br><span class="line">        u1.setSex(SexEnum.GIRL);</span><br><span class="line">        <span class="comment">//此时会触发@PreUpdate事件</span></span><br><span class="line">        userRepository.save(u1);</span><br><span class="line">        List&lt;User&gt; u3 = userRepository.findAll();</span><br><span class="line">        u3.stream().forEach(u-&gt;&#123;</span><br><span class="line">            <span class="comment">//从db查询出来，验证一下CreateUserId是否为我们刚才修改的200</span></span><br><span class="line">           Assertions.assertEquals(<span class="number">200</span>,u.getCreateUserId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试一下删除事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCallBackDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此时会触发@PostLoad事件</span></span><br><span class="line">        User u1 = userRepository.getOne(<span class="number">1L</span>);</span><br><span class="line">        Assertions.assertEquals(<span class="number">200</span>,u1.getCreateUserId());</span><br><span class="line">        userRepository.delete(u1);</span><br><span class="line">        <span class="comment">//此时会触发@PreRemove、@PostRemove事件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;delete_after::&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过测试用例验证了回调函数的事件后，看一下输出的 SQL 和日志：</p>
<p><img src="http://image.leonote.cn/20201109133706.png" alt=""></p>
<p>通过上图的日志也可以看到响应的回调函数被触发了，并且可以看到执行顺序为：</p>
<ul>
<li>保存：PrePersist -&gt; Insert -&gt; PostPersist</li>
<li>查询：Select -&gt; PostLoad</li>
<li>更新：PreUpdate -&gt; Update -&gt; PostUpdate</li>
<li>删除：PreRemove -&gt; Remove -&gt; PostRemove</li>
</ul>
<p>若回调函数里面发生异常，数据会回滚，如在<code>@PostPersist</code>的方法里抛异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostPersist</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postPersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;postPersist::&quot;</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;jack test exception transactional roll back&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再跑测试用例就会发现，其中发生了 <code>RollbackException</code> 异常，这样的话数据是不会提交到 DB 里面的，也就会导致数据进行回滚，后面的业务流程无法执行下去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Error while committing the transaction</span><br><span class="line">org.springframework.transaction.TransactionSystemException: Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Error while committing the transaction</span><br></pre></td></tr></table></figure>


<p>所以在使用此方法时，你要注意考虑异常情况，避免不必要的麻烦。</p>
<h3 id="自定义-EntityListener"><a href="#自定义-EntityListener" class="headerlink" title="自定义 EntityListener"></a>自定义 EntityListener</h3><p>第一步：自定义一个 <code>EntityLoggingListener</code> 用来记录操作日志，通过 listener 的方式配置回调函数注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.base;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.example1.User;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityLoggingListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prePersist</span><span class="params">(BaseEntity entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//entity.setVersion(1); 如果注释了，测试用例这个地方的验证也需要去掉</span></span><br><span class="line">        log.info(<span class="string">&quot;prePersist::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostPersist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postPersist</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postPersist::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preUpdate</span><span class="params">(BaseEntity entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//entity.setCreateUserId(200); 如果注释了，测试用例这个地方的验证也需要去掉</span></span><br><span class="line">        log.info(<span class="string">&quot;preUpdate::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostUpdate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postUpdate</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postUpdate::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreRemove</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preRemove</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;preRemove::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostRemove</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postRemove</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;postRemove::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostLoad</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postLoad</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询方法里面可以对一些敏感信息做一些日志</span></span><br><span class="line">        <span class="keyword">if</span> (User.class.isInstance(entity)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;postLoad::&#123;&#125;&quot;</span>,entity.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这一步骤中需要注意的是：</p>
<p>上面注释的代码，也可以改变 entity 里面的值，但是在这个 Listener 的里面我们不做修改，所以把 <code>setVersion</code> 和 <code>setCreateUserId</code> 注释掉了，要注意测试用例里面这两处也需要修改。</p>
<p>如果在 <code>@PostLoad</code> 里面记录日志，不一定每个实体、每次查询都需要记录日志，只需要对一些敏感的实体或者字段做日志记录即可。</p>
<p>回调函数时可以加上参数，这个参数可以是父类 Object，可以是 <code>BaseEntity</code>，也可以是具体的某一个实体；推荐用 <code>BaseEntity</code>，因为这样的方法是类型安全的，它可以约定一些框架逻辑，比如 <code>getCreateUserId</code>、<code>getLastModifiedUserId</code> 等。</p>
<p>第二步：写一个测试用例。</p>
<p>这次执行 <code>testCallBackDelete()</code>，看看会得到什么样的效果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-10-05 13:55:19.332  INFO 62541 --- [    Test worker] c.e.j.e.base.EntityLoggingListener       : prePersist::User(super=BaseEntity(id=null, createUserId=13, createTime=2020-10-05T05:55:19.246Z, lastModifiedUserId=13, lastModifiedTime=2020-10-05T05:55:19.246Z, version=null), name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null)</span><br><span class="line">2020-10-05 13:55:19.449  INFO 62541 --- [    Test worker] c.e.j.e.base.EntityLoggingListener       : postPersist::User(super=BaseEntity(id=1, createUserId=13, createTime=2020-10-05T05:55:19.246Z, lastModifiedUserId=13, lastModifiedTime=2020-10-05T05:55:19.246Z, version=0), name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null)</span><br><span class="line">2020-10-05 13:55:19.698  INFO 62541 --- [    Test worker] c.e.j.e.base.EntityLoggingListener       : postLoad::User(super=BaseEntity(id=1, createUserId=13, createTime=2020-10-05T05:55:19.246Z, lastModifiedUserId=13, lastModifiedTime=2020-10-05T05:55:19.246Z, version=0), name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null)</span><br><span class="line">2020-10-05 13:55:19.719  INFO 62541 --- [    Test worker] c.e.j.e.base.EntityLoggingListener       : preRemove::User(super=BaseEntity(id=1, createUserId=13, createTime=2020-10-05T05:55:19.246Z, lastModifiedUserId=13, lastModifiedTime=2020-10-05T05:55:19.246Z, version=0), name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null)</span><br><span class="line">2020-10-05 13:55:19.798  INFO 62541 --- [    Test worker] c.e.j.e.base.EntityLoggingListener       : postRemove::User(super=BaseEntity(id=1, createUserId=13, createTime=2020-10-05T05:55:19.246Z, lastModifiedUserId=13, lastModifiedTime=2020-10-05T05:55:19.246Z, version=0), name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null)</span><br></pre></td></tr></table></figure>

<p>通过日志我们可以很清晰地看到 callback 注解标注的方法的执行过程，及其实体参数的值。你就会发现，原来自定义 <code>EntityListener</code> 回调函数的方法也是如此简单。</p>
<p>细心的你这个时候可能也会发现，我们上面其实应用了两个 <code>EntityListener</code>，所以这个时候 <code>@EntityListeners</code> 有个加载顺序的问题，你需要重点注意一下。</p>
<p><strong>关于 <code>@EntityListeners</code> 加载顺序的说明</strong></p>
<ul>
<li><p>默认如果子类和父类都有 <code>EntityListeners</code>，那么 listeners 会按照加载的顺序执行所有 <code>EntityListeners</code>；</p>
</li>
<li><p><code>EntityListeners</code> 和实体里面的回调函数注解可以同时使用，但需要注意顺序问题；</p>
</li>
<li><p>如果我们不想加载 super-class 里面的<code>EntityListeners</code>，那么我们可以通过注解 <code>@ExcludeSuperclassListeners</code>，排除所有父类里面的实体监听者，需要用到的时候，我们再在子类实体里面重新引入即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExcludeSuperclassListeners</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="JPA-Callbacks-的最佳实践"><a href="#JPA-Callbacks-的最佳实践" class="headerlink" title="JPA Callbacks 的最佳实践"></a>JPA Callbacks 的最佳实践</h2><p>个人经验总结了几个最佳实践</p>
<ol>
<li><p>回调函数里面应尽量避免直接操作业务代码，最好用一些具有框架性的公用代码，如 Auditing 或 实体操作日志 等；</p>
</li>
<li><p>注意回调函数方法要在同一个事务中进行，异常要可预期，非可预期的异常要进行捕获，以免出现意想不到的线上 Bug；</p>
</li>
<li><p>回调函数方法是同步的，如果一些计算量大的和一些耗时的操作，可以通过发消息等机制异步处理，以免阻塞主流程，影响接口的性能。比如上面说的日志，如果我们要将其记录到数据库里面，可以在回调方法里面发个消息，改进之后将变成如下格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditLoggingListener</span> </span>&#123;</span><br><span class="line">   <span class="meta">@PostLoad</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postLoad</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.notice(entity, OperateType.load);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostPersist</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postPersist</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.notice(entity, OperateType.create);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostRemove</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PostRemove</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.notice(entity, OperateType.remove);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PostUpdate</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PostUpdate</span><span class="params">(Object entity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.notice(entity, OperateType.update);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(Object entity, OperateType type)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//我们通过active mq 异步发出消息处理事件</span></span><br><span class="line">      ActiveMqEventManager.notice(<span class="keyword">new</span> ActiveMqEvent(type, entity));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Getter</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">OperateType</span> </span>&#123;</span><br><span class="line">      create(<span class="string">&quot;创建&quot;</span>), remove(<span class="string">&quot;删除&quot;</span>),update(<span class="string">&quot;修改&quot;</span>),load(<span class="string">&quot;查询&quot;</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> String description;</span><br><span class="line">      OperateType(String description) &#123;</span><br><span class="line">         <span class="keyword">this</span>.description=description;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在回调函数里面，尽量不要直接在操作 <code>EntityManager</code> 后再做 session 的整个生命周期的其他持久化操作，以免破坏事务的处理流程；也不要进行其他额外的关联关系更新动作，业务性的代码一定要放在 service 层面，否则太过复杂，时间长了代码很难维护；</p>
</li>
<li><p>回调函数里面比较适合用一些计算型的transient方法，如下面这个操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prePersist</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一些逻辑计算年龄；</span></span><br><span class="line">        user.calculationAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JPA 官方比较建议放一些默认值，但是我不是特别赞同，因为觉得那样不够直观，直接用字段初始化就可以了，没必要在回调函数里面放置默认值。</p>
</li>
</ol>
<p>除了日志，其他公用的场景不多。当遇到其他场景，可以根据不同的实体实际情况制定自己独有的 <code>EntityListener</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@EntityListeners(UserListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;<span class="comment">// implements Auditable&lt;Integer,Long, Instant&gt; &#123;</span></span><br><span class="line">   <span class="meta">@Transient</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculationAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//通过一些逻辑计算年龄；</span></span><br><span class="line">      <span class="keyword">this</span>.age=<span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ......<span class="comment">//其他不重要的省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，User 中我们有个计算年龄的逻辑要独立调用，就可以在持久化之前调用此方法，新建一个自己的 <code>UserListener</code> 即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prePersist</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一些逻辑计算年龄；</span></span><br><span class="line">        user.calculationAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JPA-Callbacks-的实现原理，事件机制"><a href="#JPA-Callbacks-的实现原理，事件机制" class="headerlink" title="JPA Callbacks 的实现原理，事件机制"></a>JPA Callbacks 的实现原理，事件机制</h2><p>Java Persistence API 规定：JPA 的实现方需要实现功能，需要支持回调事件注解；而 Hibernate 内部负责实现，Hibernate 内部维护了一套实体的 <code>EventType</code>，其内部包含了各种回调事件，下面列举一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PreLoadEventListener&gt; PRE_LOAD = create( <span class="string">&quot;pre-load&quot;</span>, PreLoadEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PreDeleteEventListener&gt; PRE_DELETE = create( <span class="string">&quot;pre-delete&quot;</span>, PreDeleteEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PreUpdateEventListener&gt; PRE_UPDATE = create( <span class="string">&quot;pre-update&quot;</span>, PreUpdateEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PreInsertEventListener&gt; PRE_INSERT = create( <span class="string">&quot;pre-insert&quot;</span>, PreInsertEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PostLoadEventListener&gt; POST_LOAD = create( <span class="string">&quot;post-load&quot;</span>, PostLoadEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PostDeleteEventListener&gt; POST_DELETE = create( <span class="string">&quot;post-delete&quot;</span>, PostDeleteEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PostUpdateEventListener&gt; POST_UPDATE = create( <span class="string">&quot;post-update&quot;</span>, PostUpdateEventListener.class );</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;PostInsertEventListener&gt; POST_INSERT = create( <span class="string">&quot;post-insert&quot;</span>, PostInsertEventListener.class );</span><br><span class="line">更多的事件类型，你可以通过查看 org.hibernate.event.spi.EventType 类，了解更多；在 session factory 构建的时候，EventListenerRegistryImpl 负责注册这些事件，我们看一下 debug 的关键节点：</span><br></pre></td></tr></table></figure>

<p>这部分原理不常用，知道有这么回事即可</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa @Query的使用</title>
    <url>/2020/10/14/SpringDataJpa%E7%9A%84@Query%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-Query的使用"><a href="#Spring-Data-Jpa-Query的使用" class="headerlink" title="Spring Data Jpa @Query的使用"></a>Spring Data Jpa @Query的使用</h1><blockquote>
<ol>
<li>快速体验 @Query 的方法、</li>
<li>JpaQueryLookupStrategy 关键源码剖析、</li>
<li>@Query 的基本用法、</li>
<li>@Query 之 Projections 应用返回指定 DTO、</li>
<li>@Query 动态查询解决方法</li>
</ol>
</blockquote>
<h2 id="快速体验-Query-的方法"><a href="#快速体验-Query-的方法" class="headerlink" title="快速体验 @Query 的方法"></a>快速体验 @Query 的方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.query.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDtoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//通过query注解根据name查询user信息</span></span><br><span class="line">   <span class="meta">@Query(&quot;From User where name=:name&quot;)</span></span><br><span class="line">   <span class="function">User <span class="title">findByQuery</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String nameParam)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们新增一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryQueryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserDtoRepository userDtoRepository;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//新增一条数据方便测试      userDtoRepository.save(User.builder().name(&quot;jackxx&quot;).email(&quot;123456@126.com&quot;).sex(&quot;man&quot;).address(&quot;shanghai&quot;).build());</span></span><br><span class="line">      <span class="comment">//调用上面的方法查看结果</span></span><br><span class="line">      User user2 = userDtoRepository.findByQuery(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">      System.out.println(user2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，看到运行的结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">user</span> <span class="params">(address, email, name, sex, version, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?, ?, ?, ?)</span></span></span><br><span class="line"><span class="function">Hibernate: select user0_.id as id1_0_, user0_.address as address2_0_, user0_.email as email3_0_, user0_.name as name4_0_, user0_.sex as sex5_0_, user0_.version as version6_0_ from user user0_ where user0_.name</span>=?</span><br><span class="line">User(id=<span class="number">1</span>, name=jack, email=<span class="number">123456</span>@<span class="number">126.</span>com, version=<span class="number">0</span>, sex=man, address=shanghai)</span><br></pre></td></tr></table></figure>

<p>通过上面的例子不是通过方法名来生成查询语法，而是 @Query 注解在其中起了作用，</p>
<p>使 <code>From User where name=:name</code> JPQL 生效了。</p>
<h2 id="JpaQueryLookupStrategy-关键源码剖析"><a href="#JpaQueryLookupStrategy-关键源码剖析" class="headerlink" title="JpaQueryLookupStrategy 关键源码剖析"></a>JpaQueryLookupStrategy 关键源码剖析</h2><p>打开 QueryExecutorMethodInterceptor 类，找到如下代码：</p>
<p><img src="http://image.leonote.cn//20201013204422.png" alt=""></p>
<p>再运行上面的测试用例，这时候在99行设置一个断点，可以看到默认的策略是CreateIfNotFound，也就是<strong>如果有@Query注解，那么以@Query的注解内容为准，可以忽略方法名</strong>。</p>
<p>进入到 lookupStrategy.resolveQuery 里面，如下所示：</p>
<p><img src="http://image.leonote.cn//20201013204655.png" alt=""></p>
<p>通过上图的断点和红框之处，发现Spring Data JPA 这个地方使用了策略、模式，当我们自己写策略模式的时候也可以进行参考。</p>
<p>往下 debug，进入到 resolveQuery 方法里面，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201013204820.png" alt=""></p>
<p>图中 ①处，如果 Query 注解找到了，就不会走到 ② 处了。</p>
<p>查看 Query 属性，你会发现这里同时生成了两个 SQL：</p>
<ol>
<li>查询总数的 Query 定义</li>
<li>查询结果的 Query 定义</li>
</ol>
<p>如果想看 Query 具体是怎么生成的、上面的 @Param 注解是怎么生效的，可以在上面的图 ① 处 debug 继续往里面看，如下所示：</p>
<p><img src="http://image.leonote.cn//20201013205215.png" alt=""></p>
<h2 id="Query-的基本用法"><a href="#Query-的基本用法" class="headerlink" title="@Query 的基本用法"></a>@Query 的基本用法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.jpa.repository;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Query &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定JPQL的查询语句。（nativeQuery=true的时候，是原生的Sql语句）</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 指定count的JPQL语句，如果不指定将根据query自动生成。</span></span><br><span class="line"><span class="comment">    * （如果当nativeQuery=true的时候，指的是原生的Sql语句）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">countQuery</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据哪个字段来count，一般默认即可。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   <span class="function">String <span class="title">countProjection</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认是false，表示value里面是不是原生的sql语句</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">nativeQuery</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 可以指定一个query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">	* 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 可以指定一个count的query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">	* 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;.count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">countName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Query 用法是使用 JPQL 为实体创建声明式查询方法。我们一般只需要关心 @Query 里面的 value 和 nativeQuery、countQuery 的值即可。</p>
<p>使用声明式 JPQL 查询有个好处，就是启动的时候就知道你的语法正确不正确。</p>
<h3 id="JPQL-的语法"><a href="#JPQL-的语法" class="headerlink" title="JPQL 的语法"></a>JPQL 的语法</h3><p>查询的语法结构，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line">[<span class="keyword">WHERE</span> ...]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> ... [<span class="keyword">HAVING</span> ...]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br></pre></td></tr></table></figure>

<p>它的语法结构有点类似 SQL，唯一的区别就是 JPQL FROM 后面跟的是对象，而 SQL 里面的字段对应的是对象里面的属性字段。</p>
<p>同理我们看一下 update 和 delete 的语法结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> ... [<span class="keyword">WHERE</span> ...]</span><br><span class="line">UPDATE ... <span class="keyword">SET</span> ... [<span class="keyword">WHERE</span> ...]</span><br></pre></td></tr></table></figure>

<p>其中“…”省略的部分是实体对象名字和实体对象里面的字段名字，而其中类似 SQL 一样包含的语法关键字有：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">FROM</span>  <span class="keyword">WHERE</span>  UPDATE  <span class="keyword">DELETE</span>  <span class="keyword">JOIN</span>  <span class="keyword">OUTER</span>  <span class="keyword">INNER</span>  <span class="keyword">LEFT</span>  <span class="keyword">GROUP</span>  <span class="keyword">BY</span>  <span class="keyword">HAVING</span>  <span class="keyword">FETCH</span>  <span class="keyword">DISTINCT</span>  OBJECT  <span class="keyword">NULL</span>  <span class="literal">TRUE</span>  <span class="literal">FALSE</span>  <span class="keyword">NOT</span>  <span class="keyword">AND</span>  <span class="keyword">OR</span>  <span class="keyword">BETWEEN</span>  <span class="keyword">LIKE</span>  <span class="keyword">IN</span>  <span class="keyword">AS</span>  <span class="literal">UNKNOWN</span>  <span class="keyword">EMPTY</span>  <span class="keyword">MEMBER</span>  <span class="keyword">OF</span>  <span class="keyword">IS</span>  AVG  MAX  MIN  SUM  COUNT  <span class="keyword">ORDER</span>  <span class="keyword">BY</span>  <span class="keyword">ASC</span>  <span class="keyword">DESC</span>  MOD  UPPER  LOWER  TRIM  POSITION  <span class="keyword">CHARACTER_LENGTH</span>  <span class="keyword">CHAR_LENGTH</span>  BIT_LENGTH  <span class="built_in">CURRENT_TIME</span>  <span class="built_in">CURRENT_DATE</span>  <span class="built_in">CURRENT_TIMESTAMP</span>  <span class="keyword">NEW</span>  <span class="keyword">EXISTS</span>  <span class="keyword">ALL</span>  <span class="keyword">ANY</span>  <span class="keyword">SOME</span> </span><br></pre></td></tr></table></figure>


<p>通过查看这个 <a href="https://docs.oracle.com/html/E13946_04/ejb3_langref.html">Oracle 的 JPQL 文档</a>，找到解决问题的办法。</p>
<h3 id="Query-用法案例"><a href="#Query-用法案例" class="headerlink" title="@Query 用法案例"></a>@Query 用法案例</h3><p> @Query 怎么使用、怎么传递参数、怎么分页</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><p>要在 Repository 的查询方法上声明一个注解，这里就是 @Query 注解标注的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><p>LIKE 查询，注意 firstname 不会自动加上“%”关键字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname like %?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByFirstnameEndsWith</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例 3"></a>案例 3</h4><p>直接用原始 SQL，nativeQuery = true 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：nativeQuery 不支持直接 Sort 的参数查询。</p>
</blockquote>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例 4"></a>案例 4</h4><p>下面是nativeQuery 的排序错误的写法，会导致无法启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query(value = &quot;select * from user_info where first_name=?1&quot;,nativeQuery = true)</span></span><br><span class="line">  <span class="function">List&lt;UserInfoEntity&gt; <span class="title">findByFirstName</span><span class="params">(String firstName,Sort sort)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="案例-5"><a href="#案例-5" class="headerlink" title="案例 5"></a>案例 5</h4><p>nativeQuery 排序的正确写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value = &quot;select * from user_info where first_name=?1 order by ?2&quot;,nativeQuery = true)</span></span><br><span class="line"><span class="function">List&lt;UserInfoEntity&gt; <span class="title">findByFirstName</span><span class="params">(String firstName,String sort)</span></span>;</span><br><span class="line"><span class="comment">//调用的地方写法last_name是数据里面的字段名，不是对象的字段名</span></span><br><span class="line">repository.findByFirstName(<span class="string">&quot;jackzhang&quot;</span>,<span class="string">&quot;last_name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过上面几个案例，我们看到了 @Query 的几种用法，你就会明白排序、参数、使用方法、LIKE、原始 SQL 怎么写。</p>
<h3 id="Query-的排序"><a href="#Query-的排序" class="headerlink" title="@Query 的排序"></a>@Query 的排序</h3><p>@Query中在用JPQL的时候，想要实现排序，方法上直接用 PageRequest 或者 Sort 参数都可以做到。</p>
<p>在排序实例中，实际使用的属性需要与实体模型里面的字段相匹配，这意味着它们需要解析为查询中使用的属性或别名。我们看一下例子，这是一个state_field_path_expression JPQL的定义，并且 Sort 的对象支持一些特定的函数。</p>
<h4 id="案例-6"><a href="#案例-6" class="headerlink" title="案例 6"></a>案例 6</h4><p>Sort and JpaSort 的使用，它可以进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByAndSort</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方的写法，如下：</span></span><br><span class="line">repo.findByAndSort(<span class="string">&quot;lannister&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;firstname&quot;</span>));               </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;stark&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;LENGTH(firstname)&quot;</span>));          </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;targaryen&quot;</span>, JpaSort.unsafe(<span class="string">&quot;LENGTH(firstname)&quot;</span>));</span><br><span class="line">repo.findByAsArrayAndSort(<span class="string">&quot;bolton&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;fn_len&quot;</span>));   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面这个案例讲述的是排序用法，再来看下 @Query 的分页用法。</p>
<h3 id="Query-的分页"><a href="#Query-的分页" class="headerlink" title="@Query 的分页"></a>@Query 的分页</h3><p>@Query 的分页分为两种情况，分别为 JQPl 的排序和 nativeQuery 的排序。</p>
<h4 id="案例-7"><a href="#案例-7" class="headerlink" title="案例 7"></a>案例 7</h4><p>直接用 Page 对象接受接口，参数直接用 Pageable 的实现类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(value = &quot;select u from User u where u.lastname = ?1&quot;)</span></span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者的写法</span></span><br><span class="line">repository.findByFirstName(<span class="string">&quot;jackzhang&quot;</span>,<span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="案例-8"><a href="#案例-8" class="headerlink" title="案例 8"></a>案例 8</h4><p>@Query 对原生 SQL 的分页支持，并不是特别友好，因为这种写法比较“骇客”，可能随着版本的不同会有所变化。我们以 MySQL 为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfoEntity</span>, <span class="title">Integer</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">UserInfoEntity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Query(value = &quot;select * from user_info where first_name=?1 /* #pageable# */&quot;,</span></span><br><span class="line"><span class="meta">         countQuery = &quot;select count(*) from user_info where first_name=?1&quot;,</span></span><br><span class="line"><span class="meta">         nativeQuery = true)</span></span><br><span class="line">   <span class="function">Page&lt;UserInfoEntity&gt; <span class="title">findByFirstName</span><span class="params">(String firstName, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者的写法</span></span><br><span class="line"><span class="keyword">return</span> userRepository.findByFirstName(<span class="string">&quot;jackzhang&quot;</span>,<span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">10</span>, Sort.Direction.DESC,<span class="string">&quot;last_name&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印出来的sql</span></span><br><span class="line">select  *   from  user_info  where  first_name=? <span class="comment">/* #pageable# */</span>  order by  last_name desc limit ?, ?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这个注释 / #pageable# / 必须有。</p>
<p>另外，随着版本的变化，这个方法有可能会进行优化。</p>
<p>此外还有一种实现方法，就是自己写两个查询方法，自己手动分页。</p>
</blockquote>
<h3 id="Param-用法"><a href="#Param-用法" class="headerlink" title="@Param 用法"></a>@Param 用法</h3><p>@Param 注解指定方法参数的具体名称，通过绑定的参数名字指定查询条件，这样不需要关心参数的顺序。<strong>比较推荐这种做法，因为它比较利于代码重构</strong>。如果不用 @Param 也是可以的，参数是有序的，这使得查询方法对参数位置的重构容易出错。我们看个案例。</p>
<h4 id="案例-9"><a href="#案例-9" class="headerlink" title="案例 9"></a>案例 9</h4><p>根据 firstname 和 lastname 参数查询 user 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByLastnameOrFirstname</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Param(&quot;firstname&quot;)</span> String firstname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="案例-10"><a href="#案例-10" class="headerlink" title="案例 10"></a>案例 10</h3><p>根据参数进行查询，top 10 前面说的“query method”关键字照样有用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findTop10ByLastnameOrFirstname</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Param(&quot;firstname&quot;)</span> String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过 @Query 定义自己的查询方法时，建议也用 Spring Data JPA 的 name query 的命名方法，这样下来风格就比较统一了。</p>
</blockquote>
<h3 id="Query-之-Projections-应用返回指定-DTO"><a href="#Query-之-Projections-应用返回指定-DTO" class="headerlink" title="@Query 之 Projections 应用返回指定 DTO"></a>@Query 之 Projections 应用返回指定 DTO</h3><p><a href="https://docs.spring.io/spring-data/jpa/docs/2.0.7.RELEASE/reference/html/#projections">JPA文档 - 3.3.1 关于 Projections</a></p>
<p>新增一张表 UserExtend，里面包含身份证、学号、年龄等信息，最终我们的实体变成如下模样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExtend</span> </span>&#123; <span class="comment">//用户扩展信息表</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> Long userId;</span><br><span class="line">   <span class="keyword">private</span> String idCard;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String studentNumber;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; <span class="comment">//用户基本信息表</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Version</span></span><br><span class="line">   <span class="keyword">private</span> Long version;</span><br><span class="line">   <span class="keyword">private</span> String sex;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果我们想定义一个 DTO 对象，里面只要 name、email、idCard，这个时候我们怎么办呢？这种场景非常常见，但好多人使用的都不是最佳实践，我在这里介绍几种方式做一下对比。</p>
<p>我们先看一下，刚学 JPA 的时候别手别脚的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDtoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询用户表里面的name、email和UserExtend表里面的idCard</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u.name,u.email,e.idCard from User u,UserExtend e where u.id= e.userId and u.id=:id&quot;)</span></span><br><span class="line">   List&lt;Object[]&gt; findByUserId(<span class="meta">@Param(&quot;id&quot;)</span> Long id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们通过下面的测试用例来取上面 findByUserId 方法返回的数据组结果值，再塞到 DTO 里面，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增一条用户数据  userDtoRepository.save(User.builder().name(&quot;jack&quot;).email(&quot;123456@126.com&quot;).sex(&quot;man&quot;).address(&quot;shanghai&quot;).build());</span></span><br><span class="line"><span class="comment">//再新增一条和用户一对一的UserExtend数据  userExtendRepository.save(UserExtend.builder().userId(1L).idCard(&quot;shengfengzhenghao&quot;).ages(18).studentNumber(&quot;xuehao001&quot;).build());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询我们想要的结果</span></span><br><span class="line">   List&lt;Object[]&gt; userArray = userDtoRepository.findByUserId(<span class="number">1L</span>);</span><br><span class="line">   System.out.println(String.valueOf(userArray.get(<span class="number">0</span>)[<span class="number">0</span>])+String.valueOf(userArray.get(<span class="number">0</span>)[<span class="number">1</span>]));</span><br><span class="line">   UserDto userDto = UserDto.builder().name(String.valueOf(userArray.get(<span class="number">0</span>)[<span class="number">0</span>])).build();</span><br><span class="line">   System.out.println(userDto);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实经验的丰富的“老司机”一看就知道这肯定不是最佳实践，这多麻烦呀，肯定会有更优解。那么我们再对此稍加改造，用 UserDto 接收返回结果。</p>
<h4 id="利用-class-UserDto-获取我们想要的结果"><a href="#利用-class-UserDto-获取我们想要的结果" class="headerlink" title="利用 class UserDto 获取我们想要的结果"></a>利用 class UserDto 获取我们想要的结果</h4><p>首先，我们新建一个 UserDto 类的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name,email,idCard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其次，我们看下利用 @Query 在 Repository 里面怎么写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDtoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Query(&quot;select new com.example.jpa.example1.UserDto(CONCAT(u.name,&#x27;JK123&#x27;),u.email,e.idCard) from User u,UserExtend e where u.id= e.userId and u.id=:id&quot;)</span></span><br><span class="line">   <span class="function">UserDto <span class="title">findByUserDtoId</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们利用 JPQL，new 了一个 UserDto；再通过构造方法，接收查询结果。其中你会发现，我们用 CONCAT 的关键字做了一个字符串拼接。</p>
<p>你可以查看<a href="https://docs.oracle.com/html/E13946_04/ejb3_langref.html">JPQL的 Oracle 文档</a>，也可以通过源码来看支持的关键字有哪些。</p>
<p>打开 ParameterizedFunctionExpression 会发现 Hibernate 支持的关键字有这么多，都是 MySQL 数据库的查询关键字。</p>
<p><img src="http://image.leonote.cn//20201013213658.png" alt=""></p>
<p>然后，我们写一个测试方法，调用上面的方法测试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryAnnotationDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  userDtoRepository.save(</span><br><span class="line">      User.builder().name(<span class="string">&quot;jack&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">      .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">  userExtendRepository.save(</span><br><span class="line">      UserExtend.builder()</span><br><span class="line">          .userId(<span class="number">1L</span>)</span><br><span class="line">          .idCard(<span class="string">&quot;shengfengzhenghao&quot;</span>)</span><br><span class="line">          .ages(<span class="number">18</span>)</span><br><span class="line">          .studentNumber(<span class="string">&quot;xuehao001&quot;</span>)</span><br><span class="line">          .build());</span><br><span class="line">  UserDto userDto = userDtoRepository.findByUserDtoId(<span class="number">1L</span>);</span><br><span class="line">  System.out.println(userDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们运行一下测试用例，结果如下。这时你会发现，我们按照预期操作得到了 UserDto 的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">user</span> <span class="params">(address, email, name, sex, version, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?, ?, ?, ?)</span></span></span><br><span class="line"><span class="function">Hibernate: insert into <span class="title">user_extend</span> <span class="params">(ages, id_card, student_number, user_id, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?, ?, ?)</span></span></span><br><span class="line"><span class="function">Hibernate: <span class="title">select</span> <span class="params">(user0_.name||<span class="string">&#x27;JK123&#x27;</span>)</span> as col_0_0_, user0_.email as col_1_0_, userextend1_.id_card as col_2_0_ from user user0_ cross join user_extend userextend1_ where user0_.id</span>=userextend1_.user_id and user0_.id=?</span><br><span class="line">UserDto(name=jackJK123, email=<span class="number">123456</span>@<span class="number">126.</span>com, idCard=shengfengzhenghao)</span><br></pre></td></tr></table></figure>

<p>那么还有更简单的方法吗？答案是有，下面我们利用 UserDto 接口来实现一下。</p>
<h4 id="利用-UserDto-接口获得我们想要的结果"><a href="#利用-UserDto-接口获得我们想要的结果" class="headerlink" title="利用 UserDto 接口获得我们想要的结果"></a>利用 UserDto 接口获得我们想要的结果</h4><p>首先，新增一个 UserSimpleDto 接口来得到我们想要的 name、email、idCard 信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserSimpleDto</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getIdCard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其次，在 UserDtoRepository 里面新增一个方法，返回结果是 UserSimpleDto 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDtoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用接口DTO获得返回结果，需要注意的是每个字段需要as和接口里面的get方法名字保持一样</span></span><br><span class="line"><span class="meta">@Query(&quot;select CONCAT(u.name,&#x27;JK123&#x27;) as name,UPPER(u.email) as email ,e.idCard as idCard from User u,UserExtend e where u.id= e.userId and u.id=:id&quot;)</span></span><br><span class="line"><span class="function">UserSimpleDto <span class="title">findByUserSimpleDtoId</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，测试用例写法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryAnnotationDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDtoRepository.save(</span><br><span class="line">        User.builder().name(<span class="string">&quot;jack&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">        .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">    userExtendRepository.save(</span><br><span class="line">        UserExtend.builder()</span><br><span class="line">            .userId(<span class="number">1L</span>)</span><br><span class="line">            .idCard(<span class="string">&quot;shengfengzhenghao&quot;</span>)</span><br><span class="line">            .ages(<span class="number">18</span>)</span><br><span class="line">            .studentNumber(<span class="string">&quot;xuehao001&quot;</span>)</span><br><span class="line">            .build());</span><br><span class="line">    UserSimpleDto userDto = userDtoRepository.findByUserSimpleDtoId(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(userDto);</span><br><span class="line">    System.out.println(userDto.getName() + <span class="string">&quot;:&quot;</span> + userDto.getEmail() + <span class="string">&quot;:&quot;</span> + userDto.getIdCard());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们执行可以得到如下结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.data.jpa.repository.query.AbstractJpaQuery$TupleConverter$TupleBackedMap@373c28e5</span><br><span class="line">jackJK123:<span class="number">123456</span>@<span class="number">126.</span>COM:shengfengzhenghao</span><br></pre></td></tr></table></figure>

<p>我们发现，比起 DTO 我们不需要 new 了，并且接口只能读，那么我们返回的结果 DTO 的职责就更单一了，只用来查询。</p>
<blockquote>
<p>接口的方式是比较推荐的做法，因为它是只读的，对构造方法没有要求，返回的实际是 HashMap。</p>
</blockquote>
<h2 id="Query-动态查询解决方法"><a href="#Query-动态查询解决方法" class="headerlink" title="@Query 动态查询解决方法"></a>@Query 动态查询解决方法</h2><p>我们看一个例子，来了解一下如何实现 @Query 的动态参数查询。</p>
<p>首先，新增一个 UserOnlyName 接口，只查询 User 里面的 name 和 email 字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserOnlyName</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其次，在我们的 UserDtoRepository 里面新增两个方法：一个是利用 JPQL 实现动态查询，一个是利用原始 SQL 实现动态查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.query.Param;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDtoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 利用JQPl动态查询用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> email</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> UserSimpleDto接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u.name as name,u.email as email from User u where (:name is null or u.name =:name) and (:email is null or u.email =:email)&quot;)</span></span><br><span class="line">   <span class="function">UserOnlyName <span class="title">findByUser</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name,<span class="meta">@Param(&quot;email&quot;)</span> String email)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 利用原始sql动态查询用户信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Query(value = &quot;select u.name as name,u.email as email from user u where (:#&#123;#user.name&#125; is null or u.name =:#&#123;#user.name&#125;) and (:#&#123;#user.email&#125; is null or u.email =:#&#123;#user.email&#125;)&quot;,nativeQuery = true)</span></span><br><span class="line"><span class="function">UserOnlyName <span class="title">findByUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，我们新增一个测试类，测试一下上面方法的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryDinamicDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDtoRepository.save(</span><br><span class="line">User.builder().name(<span class="string">&quot;jack&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">.sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">   UserOnlyName userDto = userDtoRepository.findByUser(<span class="string">&quot;jack&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">   System.out.println(userDto.getName() + <span class="string">&quot;:&quot;</span> + userDto.getEmail());</span><br><span class="line">   UserOnlyName userDto2 = userDtoRepository.findByUser(User.builder().email(<span class="string">&quot;123456@126.com&quot;</span>).build());</span><br><span class="line">   System.out.println(userDto2.getName() + <span class="string">&quot;:&quot;</span> + userDto2.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，运行结果如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">user</span> <span class="params">(address, email, name, sex, version, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?, ?, ?, ?)</span></span></span><br><span class="line"><span class="function"> : binding parameter [1] as [VARCHAR] - [shanghai]</span></span><br><span class="line"><span class="function"> : binding parameter [2] as [VARCHAR] - [123456@126.com]</span></span><br><span class="line"><span class="function"> : binding parameter [3] as [VARCHAR] - [jack]</span></span><br><span class="line"><span class="function"> : binding parameter [4] as [VARCHAR] - [man]</span></span><br><span class="line"><span class="function"> : binding parameter [5] as [BIGINT] - [0]</span></span><br><span class="line"><span class="function"> : binding parameter [6] as [BIGINT] - [1]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Hibernate: select user0_.name as col_0_0_, user0_.email as col_1_0_ from user user0_ <span class="title">where</span> <span class="params">(? is <span class="keyword">null</span> or user0_.name=?)</span> <span class="title">and</span> <span class="params">(? is <span class="keyword">null</span> or user0_.email=?)</span></span></span><br><span class="line"><span class="function"> : binding parameter [1] as [VARCHAR] - [jack]</span></span><br><span class="line"><span class="function"> : binding parameter [2] as [VARCHAR] - [jack]</span></span><br><span class="line"><span class="function"> : binding parameter [3] as [VARCHAR] - [<span class="keyword">null</span>]</span></span><br><span class="line"><span class="function"> : binding parameter [4] as [VARCHAR] - [<span class="keyword">null</span>]</span></span><br><span class="line"><span class="function">jack:123456@126.com</span></span><br><span class="line"><span class="function">Hibernate: select u.name as name,u.email as email from user u <span class="title">where</span> <span class="params">(? is <span class="keyword">null</span> or u.name =?)</span> <span class="title">and</span> <span class="params">(? is <span class="keyword">null</span> or u.email =?)</span></span></span><br><span class="line"><span class="function"> : binding parameter [1] as [VARBINARY] - [<span class="keyword">null</span>]</span></span><br><span class="line"><span class="function"> : binding parameter [2] as [VARBINARY] - [<span class="keyword">null</span>]</span></span><br><span class="line"><span class="function"> : binding parameter [3] as [VARCHAR] - [123456@126.com]</span></span><br><span class="line"><span class="function"> : binding parameter [4] as [VARCHAR] - [123456@126.com]</span></span><br><span class="line"><span class="function">jack:123456@126.com</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：其中我们打印了一下 SQL 传入的参数，是为了让我们更清楚参数都传入了什么值。<br>上面的两个方法，分别采用了 JPQL 的动态参数和 SPEL 的表达式方式获取参数</p>
</blockquote>
<p>通过上面的实例可以看得出来，我们采用了 :email is null or s.email = :email 这种方式来实现动态查询的效果，实际工作中也可能演变得很复杂。</p>
<blockquote>
<ol>
<li>能用方法名表示的，尽量用方法名表示，因为这样语义清晰、简单快速，基本上只要编译通过，一定不会有问题；</li>
<li>能用 @Query 里面的 JPQL 表示的，就用 JPQL，这样与 SQL 无关，万一哪天换数据库了，基本上代码不用改变；</li>
<li>最后实在没有办法了，可以选择 nativeQuery 写原始 SQL，特别是一开始从 MyBatis 转过来的同学，选择写 SQL 会更容易一些。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>Defining Query Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>Defining Query Methods语法</title>
    <url>/2020/09/22/SpringDataJpa%E7%9A%84DQM%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Defining-Query-Methods"><a href="#Defining-Query-Methods" class="headerlink" title="Defining Query Methods"></a>Defining Query Methods</h1><p>Spring Data JPA 的方法名定义查询方法 （ Defining Query Methods ）可以使语义更加清晰，提升开发效率。</p>
<p>DQM 语法共有 2 种</p>
<ol>
<li>直接通过方法名实现</li>
<li>@Query 手动在方法上定义</li>
</ol>
<h2 id="定义查询方法的配置和使用方法"><a href="#定义查询方法的配置和使用方法" class="headerlink" title="定义查询方法的配置和使用方法"></a>定义查询方法的配置和使用方法</h2><p>若想要实现 CRUD 的操作，常规做法是写一大堆 SQL 语句。但在 JPA 里面，只需要继承 Spring Data Common 里面的任意 Repository 接口或者子接口，然后直接通过方法名就可以实现。具体使用步骤：</p>
<p>User 实体的 <code>UserRepository</code> 继承 Spring Data Common 里面的 Repository 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Service 层就可以直接使用 <code>UserRepository</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJpa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userRepository.deleteAll();</span><br><span class="line">        userRepository.findAll();</span><br><span class="line">        userRepository.findByEmailAddress(<span class="string">&quot;zjk@126.com&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就可以直接调用 <code>CrudRepository</code> 里面暴露的所有接口方法，以及 <code>UserRepository</code> 里面定义的方法，不需要写任何 SQL 语句，也不需要写任何实现方法。</p>
<h2 id="选择性暴露方法"><a href="#选择性暴露方法" class="headerlink" title="选择性暴露方法"></a>选择性暴露方法</h2><p>有时不想暴露 <code>CrudRepository</code> 里面的所有方法，可以直接继承我们认为需要暴露的那些方法的接口。</p>
<p>假如 <code>UserRepository</code> 只想暴露 <code>findOne</code> 和 <code>save</code>，除了这两个方法之外不允许任何的 User 操作，其做法如下：</p>
<p>选择性地暴露 CRUD 方法，直接继承Repository（因为这里面没有任何方法），把<code>CrudRepository</code> 里面的 <code>save</code> 和 <code>findOne</code> 方法复制到我们自己的 <code>MyBaseRepository</code> 接口即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">findOne</span><span class="params">(ID id)</span></span>; </span><br><span class="line">    <span class="function">T <span class="title">save</span><span class="params">(T entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在 Service 层就只有 <code>findOne</code>、<code>save</code>、<code>findByEmailAddress</code> 这 3 个方法可以调用，不会有更多方法了，我们可以对 SimpleJpaRepository 里面任意已经实现的方法做选择性暴露。</p>
<blockquote>
<p>综上所述，得出以下 2 点结论：</p>
<ul>
<li>MyRepository Extends Repository 接口可以实现 Defining Query Methods 的功能；</li>
<li>继承其他 Repository 的子接口，或者自定义子接口，可以选择性地暴露 SimpleJpaRepository 里面已经实现的基础公用方法。</li>
</ul>
</blockquote>
<h2 id="方法的查询策略设置"><a href="#方法的查询策略设置" class="headerlink" title="方法的查询策略设置"></a>方法的查询策略设置</h2><p>鸡肋。。</p>
<p>通过 @EnableJpaRepositories 注解来配置方法的查询策略，详细配置方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(queryLookupStrategy= QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)</span></span><br></pre></td></tr></table></figure>

<p>QueryLookupStrategy.Key 的值共 3 个，具体如下：</p>
<ul>
<li><strong>Create</strong>：直接根据方法名进行创建，规则是根据方法名称的构造进行尝试，一般的方法是从方法名中删除给定的一组已知前缀，并解析该方法的其余部分。如果方法名不符合规则，启动的时候会报异常，这种情况可以理解为，即使配置了 @Query 也是没有用的。</li>
<li><strong>USE_DECLARED_QUERY</strong>：声明方式创建，启动的时候会尝试找到一个声明的查询，如果没有找到将抛出一个异常，可以理解为必须配置 @Query。</li>
<li><strong>CREATE_IF_NOT_FOUND</strong>：这个是==默认的==，除非有特殊需求，可以理解为这是以上 2 种方式的兼容版。先用声明方式（@Query）进行查找，如果没有找到与方法相匹配的查询，那用 Create 的方法名创建规则创建一个查询；这两者都不满足的情况下，启动就会报错。</li>
</ul>
<p>以 Spring Boot 项目为例，更改其配置方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(queryLookupStrategy= QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example1Application</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SpringApplication.run(Example1Application.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Defining-Query-Method-语法"><a href="#Defining-Query-Method-语法" class="headerlink" title="Defining Query Method 语法"></a>Defining Query Method 语法</h2><blockquote>
<p>带查询功能的方法名：查询策略（关键字）+ 查询字段 + 一些限制性条件</p>
<p>具有语义清晰、功能完整的特性，我们实际工作中 80% 的 API 查询都可以简单实现。</p>
</blockquote>
<p>举例说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// and 的查询关系</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line">   <span class="comment">// 包含 distinct 去重，or 的 sql 语法</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">   <span class="comment">// 根据 lastname 字段查询忽略大小写</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">   <span class="comment">// 根据 lastname 和 firstname 查询 equal 并且忽略大小写</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>; </span><br><span class="line">  <span class="comment">// 对查询结果根据 lastname 排序，正序</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="comment">// 对查询结果根据 lastname 排序，倒序</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常用的关键字列表"><a href="#常用的关键字列表" class="headerlink" title="常用的关键字列表"></a>常用的关键字列表</h2><table>
<thead>
<tr>
<th align="center">Keyword</th>
<th align="center">Sample</th>
<th align="center">JPQL snippet</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>And</code></td>
<td align="center"><code>findByLastnameAndFirstname</code></td>
<td align="center"><code>… where x.lastname = ?1 and x.firstname = ?2</code></td>
</tr>
<tr>
<td align="center"><code>Or</code></td>
<td align="center"><code>findByLastnameOrFirstname</code></td>
<td align="center"><code>… where x.lastname = ?1 or x.firstname = ?2</code></td>
</tr>
<tr>
<td align="center"><code>Is</code>, <code>Equals</code></td>
<td align="center"><code>findByFirstname</code>  <code>findByFirstnameIs</code> <code>findByFirstnameEquals</code></td>
<td align="center"><code>… where x.firstname = ?1</code></td>
</tr>
<tr>
<td align="center"><code>Between</code></td>
<td align="center"><code>findByStartDateBetween</code></td>
<td align="center"><code>… where x.startDate between ?1 and ?2</code></td>
</tr>
<tr>
<td align="center"><code>LessThan</code></td>
<td align="center"><code>findByAgeLessThan</code></td>
<td align="center"><code>… where x.age &lt; ?1</code></td>
</tr>
<tr>
<td align="center"><code>LessThanEqual</code></td>
<td align="center"><code>findByAgeLessThanEqual</code></td>
<td align="center"><code>… where x.age &lt;= ?1</code></td>
</tr>
<tr>
<td align="center"><code>GreaterThan</code></td>
<td align="center"><code>findByAgeGreaterThan</code></td>
<td align="center"><code>… where x.age &gt; ?1</code></td>
</tr>
<tr>
<td align="center"><code>GreaterThanEqual</code></td>
<td align="center"><code>findByAgeGreaterThanEqual</code></td>
<td align="center"><code>… where x.age &gt;= ?1</code></td>
</tr>
<tr>
<td align="center"><code>After</code></td>
<td align="center"><code>findByStartDateAfter</code></td>
<td align="center"><code>… where x.startDate &gt; ?1</code></td>
</tr>
<tr>
<td align="center"><code>Before</code></td>
<td align="center"><code>findByStartDateBefore</code></td>
<td align="center"><code>… where x.startDate &lt; ?1</code></td>
</tr>
<tr>
<td align="center"><code>IsNull</code>, <code>Null</code></td>
<td align="center"><code>findByAge(Is)Null</code></td>
<td align="center"><code>… where x.age is null</code></td>
</tr>
<tr>
<td align="center"><code>IsNotNull</code>, <code>NotNull</code></td>
<td align="center"><code>findByAge(Is)NotNull</code></td>
<td align="center"><code>… where x.age not null</code></td>
</tr>
<tr>
<td align="center"><code>Like</code></td>
<td align="center"><code>findByFirstnameLike</code></td>
<td align="center"><code>… where x.firstname like ?1</code></td>
</tr>
<tr>
<td align="center"><code>NotLike</code></td>
<td align="center"><code>findByFirstnameNotLike</code></td>
<td align="center"><code>… where x.firstname not like ?1</code></td>
</tr>
<tr>
<td align="center"><code>StartingWith</code></td>
<td align="center"><code>findByFirstnameStartingWith</code></td>
<td align="center"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</td>
</tr>
<tr>
<td align="center"><code>EndingWith</code></td>
<td align="center"><code>findByFirstnameEndingWith</code></td>
<td align="center"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</td>
</tr>
<tr>
<td align="center"><code>Containing</code></td>
<td align="center"><code>findByFirstnameContaining</code></td>
<td align="center"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</td>
</tr>
<tr>
<td align="center"><code>OrderBy</code></td>
<td align="center"><code>findByAgeOrderByLastnameDesc</code></td>
<td align="center"><code>… where x.age = ?1 order by x.lastname desc</code></td>
</tr>
<tr>
<td align="center"><code>Not</code></td>
<td align="center"><code>findByLastnameNot</code></td>
<td align="center"><code>… where x.lastname &lt;&gt; ?1</code></td>
</tr>
<tr>
<td align="center"><code>In</code></td>
<td align="center"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td>
<td align="center"><code>… where x.age in ?1</code></td>
</tr>
<tr>
<td align="center"><code>NotIn</code></td>
<td align="center"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td>
<td align="center"><code>… where x.age not in ?1</code></td>
</tr>
<tr>
<td align="center"><code>True</code></td>
<td align="center"><code>findByActiveTrue()</code></td>
<td align="center"><code>… where x.active = true</code></td>
</tr>
<tr>
<td align="center"><code>False</code></td>
<td align="center"><code>findByActiveFalse()</code></td>
<td align="center"><code>… where x.active = false</code></td>
</tr>
<tr>
<td align="center"><code>IgnoreCase</code></td>
<td align="center"><code>findByFirstnameIgnoreCase</code></td>
<td align="center"><code>… where UPPER(x.firstame) = UPPER(?1)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>综上，总结 3 点经验：</p>
<ul>
<li>方法名的表达式通常是实体属性连接运算符的组合，如 And、or、Between、LessThan、GreaterThan、Like 等属性连接运算表达式，不同的数据库（NoSQL、MySQL）可能产生的效果不一样，如果遇到问题，可以打开 SQL 日志观察。</li>
<li>IgnoreCase 可以针对单个属性（如 findByLastnameIgnoreCase(…)），也可以针对查询条件里面所有的实体属性忽略大小写（所有属性必须在 String 情况下，如 findByLastnameAndFirstnameAllIgnoreCase(…)）。</li>
<li>OrderBy 可以在某些属性的排序上提供方向（Asc 或 Desc），称为静态排序，也可以通过一个方便的参数 Sort 实现指定字段的动态排序的查询方法（如 repository.findAll(Sort.by(Sort.Direction.ASC, “myField”))）。</li>
</ul>
</blockquote>
<p>上述表格虽然大多是 find 开头的方法，但其实 JPA 还支持 read、get、query、stream、count、exists、delete、remove 等前缀，如字面意思一样。我们来看看 count、delete、remove 的例子，其他前缀可以举一反三。实例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 查询总数</span></span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">    <span class="comment">// 根据一个字段进行删除操作，并返回删除行数</span></span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">    <span class="comment">// 根据 Lastname 删除一堆 User，并返回删除的 User</span></span><br><span class="line">     <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字都定义在下面两个类里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.data.repository.query.parser.PartTree</span><br><span class="line">org.springframework.data.repository.query.parser.Part</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20200924192709.png" alt=""></p>
<p><img src="http://image.leonote.cn//20200924192724.png" alt=""></p>
<p>看源码就可以知道框架支持了哪些逻辑关键字，比如 NotIn、Like、In、Exists 等，有的时候比查文档和任何人写的博客都准确、还快。</p>
<h2 id="Sort-排序和-Pageable-分页"><a href="#Sort-排序和-Pageable-分页" class="headerlink" title="Sort 排序和 Pageable 分页"></a>Sort 排序和 Pageable 分页</h2><p>Sort 在查询的时候可以实现动态排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sort</span><span class="params">(Direction direction, String... properties)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(direction, properties == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;() : Arrays.asList(properties));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sort 里面决定了我们哪些字段的排序方向（ASC 正序、DESC 倒序）</p>
<p>Pageable 在查询的时候可以实现分页效果和动态排序双重效果</p>
<p>Pageable 的 Structure，如下图所示：</p>
<p><img src="http://image.leonote.cn//20200924193232.png" alt=""></p>
<h3 id="方法一：Page"><a href="#方法一：Page" class="headerlink" title="方法一：Page"></a>方法一：Page</h3><p>允许将 org.springframework.data.domain.Pageable 实例传递给查询方法，将分页参数添加到静态定义的查询中，通过 Page 返回的结果得知可用的元素和页面的总数。</p>
<p>这种分页查询方法可能是昂贵的（<strong>会默认执行一条 count 的 SQL 语句</strong>），所以用的时候要考虑一下使用场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：Slice"><a href="#方法二：Slice" class="headerlink" title="方法二：Slice"></a>方法二：Slice</h3><p>返回结果是 Slice，因为只知道是否有下一个 Slice 可用，而不知道 count，所以当查询较大的结果集时，只知道数据是足够的，也就是说用在业务场景中时不用关心一共有多少页。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="方法三：List"><a href="#方法三：List" class="headerlink" title="方法三：List"></a>方法三：List</h3><p>如果只需要排序，需在 org.springframework.data.domain.Sort 参数中添加一个参数，正如上面看到的，只需返回一个 List 也是有可能的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br></pre></td></tr></table></figure>

<p>排序选项也通过 Pageable 实例处理，在这种情况下，Page 将不会创建构建实际实例所需的附加元数据（即不需要计算和查询分页相关数据），而仅仅用来做限制查询给定范围的实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<p>PageRequest 里面提供的几个 of 静态方法（多态），分别构建页码、页面大小、排序等。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询user里面的lastname=jk的第一页，每页大小是20条；并会返回一共有多少页的信息</span></span><br><span class="line">Page&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;jk&quot;</span>, PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询user里面的lastname=jk的第一页的20条数据，不知道一共多少条</span></span><br><span class="line">Slice&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;jk&quot;</span>, PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//查询出来所有的user里面的lastname=jk的User数据，并按照name正序返回List</span></span><br><span class="line">List&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;jk&quot;</span>, <span class="keyword">new</span> Sort(Sort.Direction.ASC, <span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="comment">//按照createdAt倒序，查询前一百条User数据</span></span><br><span class="line">List&lt;User&gt; users = userRepository.findByLastname(<span class="string">&quot;jk&quot;</span>, PageRequest.of(<span class="number">0</span>, <span class="number">100</span>, Sort.Direction.DESC, <span class="string">&quot;createdAt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="限制查询结果-First-和-Top"><a href="#限制查询结果-First-和-Top" class="headerlink" title="限制查询结果 First 和 Top"></a>限制查询结果 First 和 Top</h2><p>有的时候我们想直接查询前几条数据，也不需要动态排序，那么就可以简单地在方法名字中使用 First 和 Top 关键字，来限制返回条数。</p>
<p>我们可以在 userRepository 里面定义的一些限制返回结果的使用。在查询方法上加限制查询结果的关键字 First 和 Top。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findDistinctUserTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中：</p>
<ul>
<li>查询方法在使用 First 或 Top 时，数值可以追加到 First 或 Top 后面，指定返回最大结果的大小；</li>
<li>如果数字被省略，则假设结果大小为 1；</li>
<li>限制表达式也支持 Distinct 关键字；</li>
<li>如果将 Pageable 作为参数，以 Top 和 First 后面的数字为准，即分页将在限制结果中应用。</li>
</ul>
</blockquote>
<h2 id="NonNull、-NonNullApi、-Nullable"><a href="#NonNull、-NonNullApi、-Nullable" class="headerlink" title="@NonNull、@NonNullApi、@Nullable"></a>@NonNull、@NonNullApi、@Nullable</h2><p>从 Spring Data 2.0 开始，JPA 新增了<a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNull.html">@NonNull</a> <a href="https://docs.spring.io/spring-framework/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html">@NonNullApi</a> <a href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/javadoc-api/org/springframework/lang/Nullable.html">@Nullable</a>，是对 null 的参数和返回结果做的支持。</p>
<ul>
<li><p>@NonNullApi：在<strong>包级别</strong>用于声明参数，以及返回值的默认行为是不接受或产生空值的。</p>
</li>
<li><p>@NonNull：用于不能为空的参数或返回值（在 @NonNullApi 适用的参数和返回值上不需要）。</p>
</li>
<li><p>@Nullable：用于可以为空的参数或返回值。</p>
</li>
</ul>
<p>我在自己的 Repository 所在 package 的 package-info.java 类里面做如下声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi</span><br><span class="line"><span class="keyword">package</span> com.myrespository;</span><br></pre></td></tr></table></figure>

<p>myRepository 下面的 UserRepository 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myrespository;                  </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">User <span class="title">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候当 emailAddress 参数为 null 的时候就会抛异常，当返回结果为 null 的时候也会抛异常。因为我们在package 的 package-info.java里面指定了 NonNullApi，所有返回结果和参数不能为 Null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当我们添加 @Nullable 注解之后，参数和返回结果这个时候就都会允许为 null 了；</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">User <span class="title">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span></span>;</span><br><span class="line"><span class="comment">//返回结果允许为 null，参数不允许为 null 的情况</span></span><br><span class="line"><span class="function">Optional&lt;User&gt; <span class="title">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在实际工作中，也可以将方法名（非常语义化的 repository 里面所定义方法命名规范）的强制约定规范运用到 controller 和 service 层，这样全部统一后，可以减少很多的沟通成本。Spring Data Common 里面的 repository 基类，我们是否可以应用推广到 service 层呢？能否也建立一个自己的 baseService？我们来看下面的实战例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseService</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getDomainClass</span><span class="params">()</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(ID id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllInBatch</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getOne</span><span class="params">(ID id)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Optional&lt;S&gt; <span class="title">findOne</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line">    <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">Page&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Pageable pageable)</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们模仿 JpaRepository 接口也自定义了一个自己的 BaseService，声明了常用的 CRUD操作。当然了我们也可以建立自己的 PagingAndSortingService、ComplexityService、SampleService 等来划分不同的 service接口，供不同目的 Service 子类继承。</p>
<p>我们再来模仿一个 SimpleJpaRepository，来实现自己的 BaseService 的实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span>, <span class="title">R</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">BaseService</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class, Class&gt; DOMAIN_CLASS_CACHE = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> R repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseServiceImpl</span><span class="params">(R repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getDomainClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class thisClass = getClass();</span><br><span class="line">        Class&lt;T&gt; domainClass = DOMAIN_CLASS_CACHE.get(thisClass);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(domainClass)) &#123;</span><br><span class="line">            domainClass = GenericsUtils.getGenericClass(thisClass, <span class="number">0</span>);</span><br><span class="line">            DOMAIN_CLASS_CACHE.putIfAbsent(thisClass, domainClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> domainClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> R <span class="title">getRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; entities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.saveAll(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span> </span>&#123;</span><br><span class="line">        repository.delete(entity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">        repository.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.deleteAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span> </span>&#123;</span><br><span class="line">        repository.deleteAll(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteInBatch</span><span class="params">(Iterable&lt;T&gt; entities)</span> </span>&#123;</span><br><span class="line">        repository.deleteInBatch(entities);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllInBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.deleteAllInBatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOne</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.getOne(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">Optional&lt;S&gt; <span class="title">findOne</span><span class="params">(Example&lt;S&gt; example)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findOne(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(sort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Sort sort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example, sort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">Page&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example, Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAll(example, pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">findAllById</span><span class="params">(Iterable&lt;ID&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.findAllById(ids);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.count();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Example&lt;S&gt; example)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.count(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Example&lt;S&gt; example)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.exists(example);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.existsById(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        repository.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.saveAndFlush(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是 BaseService 常用的 CURL 实现代码，我们这里面大部分也是直接调用 Repository 提供的方法。需要注意的是，当继承 BaseServiceImpl 的时候需要传递自己的 Repository，如下面实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">User</span>, <span class="title">Long</span>, <span class="title">UserRepository</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(repository);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>Defining Query Methods</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa DataSource 加载过程</title>
    <url>/2020/10/14/SpringDataJpa%E7%9A%84DataSource%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="DataSource-为何物？加载过程是怎样的？"><a href="#DataSource-为何物？加载过程是怎样的？" class="headerlink" title="DataSource 为何物？加载过程是怎样的？"></a>DataSource 为何物？加载过程是怎样的？</h1><h2 id="数据源是什么？"><a href="#数据源是什么？" class="headerlink" title="数据源是什么？"></a>数据源是什么？</h2><p>当我们用第三方工具去连接数据库（Mysql，Oracle 等）的时候，一般都会让我们选择数据源，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115175120.png" alt=""></p>
<p>以 MySQL 为例，当选择 MySQL 的时候就会弹出如下图显示的界面：</p>
<p><img src="http://image.leonote.cn//20201115175234.png" alt=""></p>
<p>其中，我们在选择了 Driver（驱动）和 Host、User、Password 等之后，就可以创建一个 Connection，然后连接到数据库里面了。</p>
<p>同样的道理，在 Java 里面我们也需要用到 DataSource 去连接数据库，而 Java 定义了一套 JDBC 的协议标准，其中有一个 javax.sql.DataSource 接口类，通过实现此类就可以进行数据库连接，我们通过源码来分析一下。</p>
<h3 id="DataSource-源码分析"><a href="#DataSource-源码分析" class="headerlink" title="DataSource 源码分析"></a>DataSource 源码分析</h3><p>DataSource 接口里面主要的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSource</span> <span class="keyword">extends</span> <span class="title">CommonDataSource</span>, <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">  <span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过源码可以很清楚地看到，DataSource 的主要目的就是获得数据库连接，就像我们前面用工具连接数据库一样，只不过工具是通过界面实现的，而 DataSource 是通过代码实现的。</p>
<p>那么在<strong>程序里面如何实现</strong>呢？也有很多第三方的实现方式，常见的有C3P0、BBCP、Proxool、Druid、Hikari，而目前 Spring Boot 里面是采用 Hikari 作为默认数据源。Hikari 的优点是：开源，社区活跃，性能高，监控完整。我们通过工具看一下项目里面DataSource 的实现类有哪些，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115180504.png" alt=""></p>
<p>其中，当采用默认数据源的时候，可以看到数据源的实现类有：</p>
<ul>
<li>h2 里面的 JdbcDataSource</li>
<li>MySQL 连接里面的 MysqlDataSource</li>
<li>HikariDataSource（默认数据源，也是 Spring 社区推荐的最佳数据源）</li>
</ul>
<p>直接打开 HikariDataSource 的源码看一下，它的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HikariDataSource</span> <span class="keyword">extends</span> <span class="title">HikariConfig</span> <span class="keyword">implements</span> <span class="title">DataSource</span>, <span class="title">Closeable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> HikariPool pool;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HikariDataSource</span><span class="params">(HikariConfig configuration)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     configuration.validate();</span><br><span class="line">     configuration.copyStateTo(<span class="keyword">this</span>);</span><br><span class="line">     LOGGER.info(<span class="string">&quot;&#123;&#125; - Starting...&quot;</span>, configuration.getPoolName());</span><br><span class="line">     pool = fastPathPool = <span class="keyword">new</span> HikariPool(<span class="keyword">this</span>);</span><br><span class="line">     LOGGER.info(<span class="string">&quot;&#123;&#125; - Start completed.&quot;</span>, configuration.getPoolName());</span><br><span class="line">     <span class="keyword">this</span>.seal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//这个是最主要的实现逻辑，即通过连接池获得连接的逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (isClosed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;HikariDataSource &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; has been closed.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (fastPathPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fastPathPool.getConnection();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// See http://en.wikipedia.org/wiki/Double-checked_locking#Usage_in_Java</span></span><br><span class="line">     HikariPool result = pool;</span><br><span class="line">     <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           result = pool;</span><br><span class="line">           <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">              validate();</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125; - Starting...&quot;</span>, getPoolName());</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                 pool = result = <span class="keyword">new</span> HikariPool(<span class="keyword">this</span>);</span><br><span class="line">                 <span class="keyword">this</span>.seal();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">catch</span> (PoolInitializationException pie) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (pie.getCause() <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (SQLException) pie.getCause();</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> pie;</span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              LOGGER.info(<span class="string">&quot;&#123;&#125; - Start completed.&quot;</span>, getPoolName());</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result.getConnection();</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的源码可以看到关键的两点问题：</p>
<ol>
<li><p>数据源的关键配置属性有哪些？</p>
</li>
<li><p>连接怎么获得？连接池的作用如何？</p>
</li>
</ol>
<h3 id="Hikari-数据源的关键配置属性有哪些？"><a href="#Hikari-数据源的关键配置属性有哪些？" class="headerlink" title="Hikari 数据源的关键配置属性有哪些？"></a>Hikari 数据源的关键配置属性有哪些？</h3><p>第一个问题，HikariConfig 的配置里面描述了 Hikari 数据源主要的配置属性，我们打开来看一下，如图所示：</p>
<p><img src="http://image.leonote.cn//20201115181335.png" alt=""></p>
<p>通过上面的源码我们可以看到数据源的关键配置信息：用户名、密码、连接池的配置、jdbcUrl、驱动的名字等等</p>
<h3 id="Hikari-数据源的连接怎么获得"><a href="#Hikari-数据源的连接怎么获得" class="headerlink" title="Hikari 数据源的连接怎么获得"></a>Hikari 数据源的连接怎么获得</h3><p>上面提到的第 2 个问题，我们通过 <code>getConnection</code> 方法里面的代码可以看到 HikariPool 的用法，也就是说，是<strong>通过连接池来获得连接的</strong>，这个连接用过之后没有断开，而是重新放回到连接池里面（这个地方你一定要谨记，它也说明了 connection 是可以共享的）。</p>
<p>连接池的用途：</p>
<p>创建连接是非常昂贵的，连接池技术可以共享现有的连接，以增加代码的执行效率。</p>
<h3 id="数据源、驱动、连接、连接池的关系"><a href="#数据源、驱动、连接、连接池的关系" class="headerlink" title="数据源、驱动、连接、连接池的关系"></a>数据源、驱动、连接、连接池的关系</h3><ul>
<li>数据源（DataSource）的作用是给应用程序提供不同 DB 的连接 connection；</li>
</ul>
<ul>
<li>连接（Connection）是通过连接池（Pool）获取的，这主要是出于连接性能的考虑；</li>
<li>创建好连接之后，通过数据库的驱动（Driver）来进行数据库操作；</li>
</ul>
<p>而不同的 DB（MySQL / H2 / Oracle），都有自己的驱动类和相应的驱动 Jar 包。</p>
<p>用一个图来表示一下：</p>
<p><img src="http://image.leonote.cn//20201115182131.png" alt=""></p>
<p>而我们常说的 MySQL 驱动，其实就是 <code>com.mysql.cj.jdbc.Driver</code>，而这个类主要存在于 <code>mysql-connection-java:8.0*</code> 的 jar 里面，也就是我们经常说的不同的数据库所代表的驱动 jar 包。</p>
<p>这里我们用的是 spring boot 2.3.3 版本引用的 <code>mysql-connection-java 8.0</code> 版本驱动 jar 包，不同的数据库引用的 jar 包是不一样的。例如，H2 数据源中，我们用的驱动类是 <code>org.h2.Driver</code>，其包含在 <code>com.h2database:h2:1.4.*jar</code> 包里面。</p>
<h2 id="数据源的加载原理和过程是什么样的？"><a href="#数据源的加载原理和过程是什么样的？" class="headerlink" title="数据源的加载原理和过程是什么样的？"></a>数据源的加载原理和过程是什么样的？</h2><p> <code>spring.factories</code> 文件可以看到 JDBC 数据源相关的自动加载的类 <code>DataSourceAutoConfiguration</code>，那么就从这个类开始分析。</p>
<h3 id="DataSourceAutoConfiguration-数据源的加载过程分析"><a href="#DataSourceAutoConfiguration-数据源的加载过程分析" class="headerlink" title="DataSourceAutoConfiguration 数据源的加载过程分析"></a>DataSourceAutoConfiguration 数据源的加载过程分析</h3><p><code>DataSourceAutoConfiguration</code> 的关键源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将spring.datasource.**的配置放到DataSourceProperties对象里面；</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="comment">//默认集成的数据源，一般指的是H2，方便我们快速启动和上手，一般不在生产环境应用；</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@Conditional(EmbeddedDatabaseCondition.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">   <span class="meta">@Import(EmbeddedDataSourceConfiguration.class)</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedDatabaseConfiguration</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//加载不同的数据源的配置</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">   <span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">         DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</span></span><br><span class="line"><span class="meta">         DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以得到以下三点最关键的信息：<br>第一，通过 <code>@EnableConfigurationProperties(DataSourceProperties.class)</code> 可以看得出来 spring.datasource 的配置项有哪些</p>
<p> <code>DataSourceProperties</code> 关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> generateUniqueName = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line">   <span class="keyword">private</span> String driverClassName;</span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//计算确定 driverName 的值是什么</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">determineDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.driverClassName)) &#123;</span><br><span class="line">      Assert.state(driverClassIsLoadable(), () -&gt; <span class="string">&quot;Cannot load driver class: &quot;</span> + <span class="keyword">this</span>.driverClassName);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.driverClassName;</span><br><span class="line">   &#125;</span><br><span class="line">   String driverClassName = <span class="keyword">null</span>;</span><br><span class="line">   <span class="comment">//此段逻辑是，当我们没有配置自己的 driverName 的时候，它会根据我们配置的 DB 的 url自动计算出来 driverName 的值是什么，所以就会发现我们现在很多 datasource 里面的配置都省去了 driver-name 的配置，这是 Spring Boot 的功劳。</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">      driverClassName = DatabaseDriver.fromJdbcUrl(<span class="keyword">this</span>.url).getDriverClassName();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line">      driverClassName = <span class="keyword">this</span>.embeddedDatabaseConnection.getDriverClassName();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceBeanCreationException(<span class="string">&quot;Failed to determine a suitable driver class&quot;</span>, <span class="keyword">this</span>,</span><br><span class="line">            <span class="keyword">this</span>.embeddedDatabaseConnection);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> driverClassName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过 <code>DatabaseDriver</code> 的源码可以看到 MySQL 的默认驱动 Spring Boot 是采用 <code>com.mysql.cj.jdbc.Driver</code> 来实现的。</p>
<p><img src="http://image.leonote.cn//20201115190314.png" alt=""></p>
<p>同时，<code>@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</code> 也告诉我们，<code>application.properties</code> 里面的 datasource 相关的公共配置可以以 spring.datasource 为开头，这样当启动的时候，<code>DataSourceProperties</code> 就会将 datasource 的一切配置自动加载进来。正如我们前面在 <code>application.properties</code> 里面的配置的一样，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115190449.png" alt=""></p>
<p>这里有 url、username、password、driver-class-name 等关键配置，不同数据源的公共配置也不多。</p>
<p>第二，我们通过下面这一段代码也可以看得出来不同的数据源的配置是什么样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(&#123; </span></span><br><span class="line"><span class="meta">    DataSourceConfiguration.Hikari.class, </span></span><br><span class="line"><span class="meta">    DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">    DataSourceConfiguration.Dbcp2.class, </span></span><br><span class="line"><span class="meta">    DataSourceConfiguration.Generic.class,</span></span><br><span class="line"><span class="meta">    DataSourceJmxConfiguration.class &#125;)</span></span><br></pre></td></tr></table></figure>

<p>打开 <code>DataSourceConfiguration</code> 的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createDataSource</span><span class="params">(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (T) properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tomcat连接池数据源的配置，前提条件需要引入tomcat-jdbc*.jar</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;,</span></span><br><span class="line"><span class="meta">         matchIfMissing = true)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tomcat</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.tomcat&quot;)</span></span><br><span class="line">      org.apache.tomcat.jdbc.pool.<span class="function">DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">         org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,</span><br><span class="line">               org.apache.tomcat.jdbc.pool.DataSource.class);</span><br><span class="line">         DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());</span><br><span class="line">         String validationQuery = databaseDriver.getValidationQuery();</span><br><span class="line">         <span class="keyword">if</span> (validationQuery != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dataSource.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">            dataSource.setValidationQuery(validationQuery);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> dataSource;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Hikari数据源的配置，默认Spring Boot加载的是Hikari数据源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass(HikariDataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span></span><br><span class="line"><span class="meta">         matchIfMissing = true)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hikari</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span></span><br><span class="line">      <span class="function">HikariDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">         HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class);</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">            dataSource.setPoolName(properties.getName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> dataSource;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * DBCP数据源的配置，按照Spring Boot的语法，我们必须引入CommonsDbcp**.jar依赖才有用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">   <span class="meta">@ConditionalOnClass(org.apache.commons.dbcp2.BasicDataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line">   <span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.commons.dbcp2.BasicDataSource&quot;,</span></span><br><span class="line"><span class="meta">         matchIfMissing = true)</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">      <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.dbcp2&quot;)</span></span><br><span class="line">      org.apache.commons.dbcp2.<span class="function">BasicDataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource.class);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过上述源码可以看到最常见的三种数据源的配置：</p>
<ul>
<li><p>HikariDataSource</p>
</li>
<li><p>tomcat的JDBC</p>
</li>
<li><p>apache的dbcp</p>
</li>
</ul>
<p>而最终用哪个，就看你引用了哪个 dataSource 的 jar 包。不过 Spring Boot 2.0 之后就推荐使用 Hikari 数据源了。</p>
<p>第三，通过 <code>@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</code> 和</p>
<p> <code>HikariDataSource dataSource(DataSourceProperties properties)</code> 可以知道，<code>application.properties</code> 里面 spring.datasource.hikari 开头的配置会被映射到 <code>HikariDataSource</code> 对象中， <code>HikariDataSource</code> 继承了 HikariConfig。</p>
<p>所以顺理成章地，就可以知道 Hikari 数据源的配置有哪些了，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115190915.png" alt=""></p>
<p>Hikari 的配置比较多，你实际工作中想要了解详细配置，可以看一下</p>
<p>这里只说一下最需要关心的配置，有如下几个：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 最小空闲链接数量</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimum-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">## 空闲链接存活最大时间，默认600000（10分钟）</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.idle-timeout</span>=<span class="string">180000</span></span><br><span class="line"><span class="comment">## 链接池最大链接数，默认是10</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">## 此属性控制从池返回的链接的默认自动提交行为,默认值：true</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 数据源链接池的名称</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.pool-name</span>=<span class="string">MyHikariCP</span></span><br><span class="line"><span class="comment">## 此属性控制池中链接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.max-lifetime</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">## 数据库链接超时时间,默认30秒，即30000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1mysql</span></span><br></pre></td></tr></table></figure>

<p>这里介绍的主要是针对连接池的配置，连接池我们不能配置得太大，因为<strong>连接池太大的话，会有额外的 CPU 开销，处理连接池的线程切换反而会增加程序的执行时间，减低性能</strong>；相应的，<strong>连接池也不能配置太小，太小的话可能会增加请求的等待时间，也会降低业务处理的吞吐量</strong>。</p>
<h2 id="Hikari-数据源下的-MySQL-配置最佳实践"><a href="#Hikari-数据源下的-MySQL-配置最佳实践" class="headerlink" title="Hikari 数据源下的 MySQL 配置最佳实践"></a>Hikari 数据源下的 MySQL 配置最佳实践</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##数据源的配置：logger=Slf4JLogger&amp;profileSQL=true是用来debug显示sql的执行日志的</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?logger=Slf4JLogger&amp;profileSQL=true</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">E6kroWaR9F</span></span><br><span class="line"><span class="comment">##采用默认的</span></span><br><span class="line"><span class="comment">#spring.datasource.hikari.connectionTimeout=30000</span></span><br><span class="line"><span class="comment">#spring.datasource.hikari.idleTimeout=300000</span></span><br><span class="line"><span class="comment">##指定一个链接池的名字，方便我们分析线程问题</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.pool-name</span>=<span class="string">jpa-hikari-pool</span></span><br><span class="line"><span class="comment">##最长生命周期15分钟够了</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maxLifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.maximumPoolSize</span>=<span class="string">8</span></span><br><span class="line"><span class="comment">##最大和最小相对应减少创建线程池的消耗；</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.minimumIdle</span>=<span class="string">8</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.connectionTestQuery</span>=<span class="string">select 1 from dual</span></span><br><span class="line"><span class="comment">##当释放连接到连接池之后，采用默认的自动提交事务</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.autoCommit</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">##用来显示链接测trace日志</span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari.HikariConfig</span>=<span class="string">DEBUG </span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure>

<p>通过上面的日志配置，我们在启动的时候可以看到连接池的配置结果和 MySQL 的执行日志：</p>
<ol>
<li>如下日志，显示了 Hikari 的 config 配置。</li>
</ol>
<p><img src="http://image.leonote.cn//20201115191251.png" alt=""></p>
<ol start="2">
<li>当我们执行一个方法的时候，到底要在一个 MySQL 的 connection 上面执行哪些 SQL 呢？通过如下日志我们可以看得出来。</li>
</ol>
<p><img src="http://image.leonote.cn//20201115191837.png" alt=""></p>
<ol start="3">
<li><p>通过开启 <code>com.zaxxer.hikari.pool.HikariPool</code> 类的 debug 级别，可以实时看到连接池的使用情况：软件日志如下（上图也有体现）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.zaxxer.hikari.pool.HikariPool        : jpa-hikari-pool - Pool stats (total&#x3D;8, active&#x3D;1, idle&#x3D;7, waiting&#x3D;0)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>通过上面的监控日志，你在实际工作中可以根据主机的 CPU 情况和业务处理的耗时情况，再对连接池做适当的调整，但是注意差距不要太大，不要一下将连接池配置几百个，那是错误的配置。</p>
<h2 id="Hikari-数据通过-Prometheus-的监控指标应用"><a href="#Hikari-数据通过-Prometheus-的监控指标应用" class="headerlink" title="Hikari 数据通过 Prometheus 的监控指标应用"></a>Hikari 数据通过 Prometheus 的监控指标应用</h2><p>就像日志里面打印的一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.zaxxer.hikari.pool.HikariPool        : jpa-hikari-pool - Pool stats (total&#x3D;8, active&#x3D;0, idle&#x3D;8, waiting&#x3D;0)</span><br></pre></td></tr></table></figure>

<p>Hikari 的 Metric 也帮我们提供了 Prometheus 的监控指标，实现方法很简单，代码如下所示：</p>
<ol>
<li><p>gradle 依赖里面添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;io.micrometer:micrometer-registry-prometheus&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>application.properties</code> 里面添加</p>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Metrics related configurations</span></span><br><span class="line"><span class="meta">management.endpoint.metrics.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="meta">management.endpoint.prometheus.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>然后我们启动项目，通过下图中的地址就可以看到，Prometheus 的 Metrics 里面多了很多 HikariCP 的指标。</p>
<p><img src="http://image.leonote.cn//20201115192404.png" alt=""></p>
<p>当看到这些指标之后，就可以根据 Grafana 社区里面提供的 HikariCP 的监控 <a href="https://grafana.com/grafana/dashboards/6083">Dashboards 的配置文档地址</a>，导入到我们自己的 Grafana 里面，可以通过图表看到如下界面：</p>
<p><img src="http://image.leonote.cn//20201115192657.png" alt=""></p>
<p>通过这种标准的模板就可以知道 JDBC 的连接情况、Hikari 的连接情况，以及每个连接请求时间、使用时间。这样对诊断 DB 性能问题非常有帮助。</p>
<p>下面对其中一些关键指标作一下说明：</p>
<ol>
<li><p>totalConnections：总连接数，包括空闲的连接和使用中的连接，即 totalConnections = activeConnection + idleConnections；</p>
</li>
<li><p>idleConnections：空闲连接数，也叫可用连接数，也就是连接池里面现成的 DB 连接数；</p>
</li>
<li><p>activeConnections：活跃连接数，非业务繁忙期一般都是 0，很快就会释放到连接池里面去；</p>
</li>
<li><p>pendingThreads：正在等待连接的线程数量。排查性能问题时，这个指标是一个重要的参考指标，如果正在等待连接的线程在相当长一段时间内数量较多，说明我们的连接没有利用好，是不是占用连接的时间过长了？一旦有 pendingThreads 的数量了可以发个告警，查查原因，或者优化一下连接池；</p>
</li>
<li><p>maxConnections：最大连接数，统计指标，统计到目前为止连接的最大数量。</p>
</li>
<li><p>minConnections：最小连接数，统计指标，统计到目前为止连接的最小数量。</p>
</li>
<li><p>usageTime：每个连接使用的时间，当连接被回收的时候会记录此指标；一般都在 m、s 级别，一旦到 s 级别了可以发个告警；</p>
</li>
<li><p>acquireTime：获取每个连接需要等待时间，一个请求获取数据库连接后或者因为超时失败后，会记录此指标。</p>
</li>
<li><p>connectionCreateTime：连接创建时间。</p>
</li>
</ol>
<p>在 Grafana 图表或者 Prometheus 里面都可以配置一些邮件或者短信等告警，这样当我们 DB 连接池发生问题的时候就能实时知道。</p>
<p>感兴趣可以研究一下 <a href="https://github.com/prometheus-operator/prometheus-operator">Prometheus Operator</a>。</p>
<h2 id="AliDruidDataSource-的配置与介绍"><a href="#AliDruidDataSource-的配置与介绍" class="headerlink" title="AliDruidDataSource 的配置与介绍"></a>AliDruidDataSource 的配置与介绍</h2><p>在实际工作中，由于 HikariCP 和 Druid 各有千秋，国内的很多开发者都使用 AliDruid 作为数据源。</p>
<h3 id="第一步：引入-Gradle-依赖"><a href="#第一步：引入-Gradle-依赖" class="headerlink" title="第一步：引入 Gradle 依赖"></a>第一步：引入 Gradle 依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.alibaba:druid-spring-boot-starter:1.2.1&#39;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：配置数据源"><a href="#第二步：配置数据源" class="headerlink" title="第二步：配置数据源"></a>第二步：配置数据源</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.druid.url</span>= <span class="string"># 或spring.datasource.url= </span></span><br><span class="line"><span class="meta">spring.datasource.druid.username</span>= <span class="string"># 或spring.datasource.username=</span></span><br><span class="line"><span class="meta">spring.datasource.druid.password</span>= <span class="string"># 或spring.datasource.password=</span></span><br><span class="line"><span class="meta">spring.datasource.druid.driver-class-name</span>= <span class="string">#或 spring.datasource.driver-class-name=</span></span><br></pre></td></tr></table></figure>

<h3 id="第三步：配置连接池"><a href="#第三步：配置连接池" class="headerlink" title="第三步：配置连接池"></a>第三步：配置连接池</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.druid.initial-size</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-active</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-idle</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-wait</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.pool-prepared-statements</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-pool-prepared-statement-per-connection-size</span>= <span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-open-prepared-statements</span>= <span class="string">#和上面的等价</span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.validation-query-timeout</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-borrow</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-on-return</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.test-while-idle</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.time-between-eviction-runs-millis</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.min-evictable-idle-time-millis</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.max-evictable-idle-time-millis</span>=<span class="string"></span></span><br><span class="line"><span class="meta">spring.datasource.druid.filters</span>= <span class="string">#配置多个英文逗号分隔</span></span><br><span class="line"><span class="attr">....//more</span></span><br></pre></td></tr></table></figure>

<p>通过以上三步就可以完成 Druid 数据源的配置了，需要注意的是，我们需要把 HikariCP 数据源给排除掉，而其他 Druid 的配置，比如监控，参考<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">官方文档</a>。</p>
<p>其官方的源码也比较简单，按照上面分析 HikariCP 数据源的方法，可以找一下 aliDruid 的源码，<a href="https://github.com/alibaba/druid/blob/master/druid-spring-boot-starter/src/main/java/com/alibaba/druid/spring/boot/autoconfigure/DruidDataSourceAutoConfigure.java">其加载的入口类</a>，一步一步去查看即可。</p>
<h2 id="Naming-命名策略详解及其实践"><a href="#Naming-命名策略详解及其实践" class="headerlink" title="Naming 命名策略详解及其实践"></a>Naming 命名策略详解及其实践</h2><p>在配置 @Entity 时，一定会好奇表名、字段名、外键名、实体字段、@Column 和数据库的字段之间，映射关系是怎么样的？默认规则映射规则又是什么？如果和默认不一样该怎么扩展？</p>
<h3 id="Hibernate-5-的命名策略"><a href="#Hibernate-5-的命名策略" class="headerlink" title="Hibernate 5 的命名策略"></a>Hibernate 5 的命名策略</h3><p>Hibernate 5 里面把实体和数据库的字段名和表名的映射分成了两个步骤</p>
<p>第一步：通过<code>ImplicitNamingStrategy</code>先找到实例里面定义的逻辑的字段名字。</p>
<p>这是通过<code>ImplicitNamingStrategy</code> 的实现类指定逻辑字段查找策略，也就是当实体里面定义了 @Table、@Column 注解的时候，以注解指定名字返回；而当没有这些注解的时候，返回的是实体里面的字段的名字。</p>
<p>其中，<code>org.hibernate.boot.model.naming.ImplicitNamingStrategy</code> 是一个接口，<code>ImplicitNamingStrategyJpaCompliantImpl</code> 这个实现类兼容 JPA 2.0 的字段映射规范。除此之外，还有如下四个实现类：</p>
<ul>
<li><p><code>ImplicitNamingStrategyLegacyHbmImpl</code>：兼容 Hibernate 老版本中的命名规范；</p>
</li>
<li><p><code>ImplicitNamingStrategyLegacyJpaImpl</code>：兼容 JPA 1.0 规范中的命名规范；</p>
</li>
<li><p><code>ImplicitNamingStrategyComponentPathImpl</code>：@Embedded 等注解标志的组件处理是通过 attributePath 完成的，因此如果我们在使用 @Embedded 注解的时候，如果要指定命名规范，可以直接继承这个类来实现；</p>
</li>
<li><p><code>SpringImplicitNamingStrategy</code>：默认的 spring data 2.2.3 的策略，只是扩展了 <code>ImplicitNamingStrategyJpaCompliantImpl</code> 里面的 <code>JoinTableName</code> 的方法，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115193538.png" alt=""></p>
</li>
</ul>
<p>这里只需要关心 <code>SpringImplicitNamingStrategy</code> 就可以了，其他的基本上用不到。</p>
<p> <code>SpringImplicitNamingStrategy</code> 效果如何呢？代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="meta">@Column(name = &quot;myAddress&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String emailAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过第一步可以得到如下逻辑字段的映射结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserInfo -&gt; userInfo</span><br><span class="line">id-&gt;id</span><br><span class="line">ages-&gt;ages</span><br><span class="line">lastName -&gt; lastName</span><br><span class="line">emailAddress -&gt; myAddress</span><br></pre></td></tr></table></figure>

<p>第二步：通过 <code>PhysicalNamingStrategy</code> 将逻辑字段转化成数据库的物理字段名字。</p>
<p>它的实现类负责将逻辑字段转化成带下划线，或者统一给字段加上前缀，又或者加上双引号等格式的数据库字段名字，其主要的接口是：<code>org.hibernate.boot.model.naming.PhysicalNamingStrategy</code>，而它的实现类也只有两个，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115194119.png" alt=""></p>
<ol>
<li><p><code>PhysicalNamingStrategyStandardImpl</code>：这个类什么都没干，即直接将第一个步骤得到的逻辑字段名字当成数据库的字段名字使用。这个主要的应用场景是，如果某些字段的命名格式不是下划线的格式，我们想通过 @Column 的方式显示声明的话，可以把默认第二步的策略改成 <code>PhysicalNamingStrategyStandardImpl</code>。那么如果再套用第一步的例子，经过这个类的转化会变成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userInfo -&gt; userInfo</span><br><span class="line">id-&gt;id</span><br><span class="line">ages-&gt;ages</span><br><span class="line">lastName -&gt; lastName</span><br><span class="line">myAddress -&gt; myAddress</span><br></pre></td></tr></table></figure>

<p>可以看出来逻辑名字到物理名字是保持不变的。</p>
</li>
<li><p><code>SpringPhysicalNamingStrategy</code>：这个类是将第一步得到的逻辑字段名字的大写字母前面加上下划线，并且全部转化成小写，将会标识出是否需要加上双引号。此种是默认策略。我们举个例子，第一步得到的逻辑字段就会变成如下映射：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userInfo -&gt; user_info</span><br><span class="line">id-&gt;id</span><br><span class="line">ages-&gt;ages</span><br><span class="line">lastName -&gt; last_name</span><br><span class="line">myAddress -&gt; my_address</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>把刚才的实体执行一下，可以看到生成的表的结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="keyword">create</span> <span class="keyword">table</span> user_info (id <span class="type">bigint</span> <span class="keyword">not</span> <span class="keyword">null</span>, create_time <span class="type">timestamp</span>, create_user_id <span class="type">integer</span>, last_modified_time <span class="type">timestamp</span>, last_modified_user_id <span class="type">integer</span>, version <span class="type">integer</span>, ages <span class="type">integer</span>, my_address <span class="type">varchar</span>(<span class="number">255</span>), last_name <span class="type">varchar</span>(<span class="number">255</span>), telephone <span class="type">varchar</span>(<span class="number">255</span>), <span class="keyword">primary</span> key (id))；</span><br></pre></td></tr></table></figure>

<p>也可以通过在 <code>SpringPhysicalNamingStrategy</code> 类里面设置断点来验证，如下图所示：</p>
<p><img src="http://image.leonote.cn//20201115194510.png" alt=""></p>
<h3 id="加载原理与自定义方法"><a href="#加载原理与自定义方法" class="headerlink" title="加载原理与自定义方法"></a>加载原理与自定义方法</h3><p>修改默认策略，只需要在 <code>application.properties</code> 里面修改下面代码所示的两个配置，换成自己的自定义的类即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.naming.implicit-strategy</span>=<span class="string">org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.physical-strategy</span>=<span class="string">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span></span><br></pre></td></tr></table></figure>

<p>如果直接搜索：spring.jpa.hibernate 就会发现，其默认配置是在 <code>org.springframework.boot.autoconfigure.orm.jpa.HibernateProerties</code> 这类里面的，如下图所示的方法中进行加载。</p>
<p><img src="http://image.leonote.cn//20201115194653.png" alt=""></p>
<p>其中，IMPLICIT_NAMING_STRATEGY 和 PHYSICAL_NAMING_STRATEGY 的值如下述代码所示，它是 Hibernate 5 的配置变量，用来改变 Hibernate的 naming 的策略。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">String</span> <span class="string">IMPLICIT_NAMING_STRATEGY = &quot;hibernate.implicit_naming_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PHYSICAL_NAMING_STRATEGY = &quot;hibernate.physical_naming_strategy&quot;;</span></span><br></pre></td></tr></table></figure>

<p>如果自定义的话，直接继承 <code>SpringPhysicalNamingStrategy</code> 这个类，然后覆盖需要实现的方法即可。那么它实际的应用场景都有哪些呢？</p>
<h3 id="自定义的实际应用场景"><a href="#自定义的实际应用场景" class="headerlink" title="自定义的实际应用场景"></a>自定义的实际应用场景</h3><p>有时候我们接触到的系统可能是老系统，表和字段的命名规范不一定是下划线形式，有可能驼峰式的命名法，也有可能不同的业务有不同的表名前缀。不管是哪一种，都可以通过修改第二阶段：物理映射的策略，改成 <code>PhysicalNamingStrategyStandardImpl</code> 的形式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.naming.physical-strategy</span>=<span class="string">org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span></span><br></pre></td></tr></table></figure>

<p>这样可以使 @Column/@Table 等注解的自定义值生效，或者改成自定义的 <code>MyPhysicalNamingStrategy</code>。不过<strong>不建议修改</strong> implicit-strategy，因为没有必要，需只要在 physical-strategy 上做文章就足够了。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>DataSource</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 的 Entity 注解</title>
    <url>/2020/10/16/SpringDataJpa%E7%9A%84Entity%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-的-Entity-注解"><a href="#Spring-Data-Jpa-的-Entity-注解" class="headerlink" title="Spring Data Jpa 的 Entity 注解"></a>Spring Data Jpa 的 Entity 注解</h1><h2 id="JPA-协议中关于-Entity-的相关规定"><a href="#JPA-协议中关于-Entity-的相关规定" class="headerlink" title="JPA 协议中关于 Entity 的相关规定"></a>JPA 协议中关于 Entity 的相关规定</h2><p> JPA 协议里面关于实体做了一些规定。（推荐一个查看 <a href="https://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-spec/JavaPersistence.pdf">JPA 协议的官方地址</a>）</p>
<ol>
<li><p>实体是直接进行数据库持久化操作的领域对象（即一个简单的 POJO，可以按照业务领域划分），必须通过 @Entity 注解进行标示。</p>
</li>
<li><p>实体必须有一个 public 或者 protected 的无参数构造方法。</p>
</li>
<li><p>持久化映射的注解可以标示在 Entity 的字段 field 上，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column(length = 20, nullable = false)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>除此之外，也可以将持久化注解运用在 Entity 里面的 get/set 方法上，通常我们是放在 get 方法中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column(length = 20, nullable = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>概括起来，就是 Entity 里面的注解生效只有两种方式：将注解写在字段上或者将注解写在方法上（JPA 里面称 Property）。</p>
<p><strong>注意：在同一个 Entity 里面只能有一种方式生效</strong>。也就是说，注解要么全部写在 field 上面，要么就全部写在 Property 上面。</p>
</blockquote>
<ol>
<li>只要是在 <code>@Entity</code> 的实体里面被注解标注的字段，都会被映射到数据库中，除了使用 <code>@Transient</code> 注解的字段之外。</li>
<li>实体里面必须要有一个主键，主键标示的字段可以是单个字段，也可以是复合主键字段。</li>
</ol>
<blockquote>
<p>🎯有兴趣可以读一读 Java Persistence API 协议，这样在做 JPA 开发的时候就会顺手很多，可以理解很多 Hibernate 里面实现方法。当遇到解决不了的问题时，就去看协议、阅读官方文档，深入挖掘一下，可能就会找到答案。</p>
</blockquote>
<h2 id="JPA-里面支持的哪些注解"><a href="#JPA-里面支持的哪些注解" class="headerlink" title="JPA 里面支持的哪些注解"></a>JPA 里面支持的哪些注解</h2><p>首先，我们利用 IDEA 工具，打开 <code>@Entity</code> 所在的包，就可以看到 JPA 里面支持的注解有哪些。如下所示：</p>
<p><img src="http://image.leonote.cn/20201016130319.png" alt=""></p>
<p>在 jakarta.persistence-api 的包路径下面大概有一百多个注解，没事的时候可以到这里面一个一个地看，也可以到 JPA 的协议里面对照查看文档。</p>
<p>这里只提及一些最常见的，包括 <code>@Entity</code>、<code>@Table</code>、<code>@Access</code>、<code>@Id</code>、<code>@GeneratedValue</code>、<code>@Enumerated</code>、<code>@Basic</code>、<code>@Column</code>、<code>@Transient</code>、<code>@Lob</code>、<code>@Temporal</code> 等。</p>
<ol>
<li><p><code>@Entity</code> 用于定义对象将会成为被 JPA 管理的实体，必填，将字段映射到指定的数据库表中，使用起来很简单，直接用在实体类上面即可，通过源码表达的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(TYPE)</span> <span class="comment">//表示此注解只能用在class上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Entity &#123;</span><br><span class="line">   <span class="comment">//可选，默认是实体类的名字，整个应用里面全局唯一。</span></span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Table</code> 用于指定数据库的表名，表示此实体对应的数据库里面的表名，非必填，默认表名和 entity 名字一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(TYPE)</span> <span class="comment">//一样只能用在类上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">   <span class="comment">//表的名字，可选。如果不填写，系统认为和实体的名字一样为表名。</span></span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//此表所在schema，可选</span></span><br><span class="line">   <span class="function">String <span class="title">schema</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//唯一性约束，在创建表的时候有用，表创建之后后面就不需要了。</span></span><br><span class="line">   UniqueConstraint[] uniqueConstraints() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">   <span class="comment">//索引，在创建表的时候使用，表创建之后后面就不需要了。</span></span><br><span class="line">   Index[] indexes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Access</code> 用于指定 entity 里面的注解是写在字段上面，还是 get/set 方法上面生效，非必填。在默认不填写的情况下，当实体里面的第一个注解出现在字段上或者 get/set 方法上面，就以第一次出现的方式为准；也就是说，一个实体里面的注解既有用在 field 上面，又有用在 properties 上面的时候，看下面的代码你就会明白。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@Column(length = 20, nullable = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么由于 <code>@Id</code> 是实体里面第一个出现的注解，并且作用在字段上面，所以所有写在 get/set 方法上面的注解就会失效。而 <code>@Access</code> 可以干预默认值，指定是在 fields 上面生效还是在 properties 上面生效。我们通过源码看下语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示此注解可以运用在class上(那么这个时候就可以指定此实体的默认注解生效策略了)，也可以用在方法上或者字段上(表示可以独立设置某一个字段或者方法的生效策略)；</span></span><br><span class="line"><span class="meta">@Target( &#123; TYPE, METHOD, FIELD &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Access &#123;</span><br><span class="line">    <span class="comment">//指定是字段上面生效还是方法上面生效</span></span><br><span class="line">    <span class="function">AccessType <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AccessType</span> </span>&#123;</span><br><span class="line">    FIELD,</span><br><span class="line">    PROPERTY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Id</code> 定义属性为数据库的主键，一个实体里面必须有一个主键，但不一定是这个注解，可以和 <code>@GeneratedValue</code> 配合使用或成对出现。</p>
</li>
<li><p><code>@GeneratedValue</code> 主键生成策略，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GeneratedValue &#123;</span><br><span class="line">    <span class="comment">//Id的生成策略</span></span><br><span class="line">    <span class="function">GenerationType <span class="title">strategy</span><span class="params">()</span> <span class="keyword">default</span> AUTO</span>;</span><br><span class="line">    <span class="comment">//通过 Sequences 生成 Id，常见的是 Oracle 数据库 ID 生成规则，</span></span><br><span class="line">    <span class="comment">//这个时候需要配合 @SequenceGenerator 使用</span></span><br><span class="line">    <span class="function">String <span class="title">generator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，GenerationType 一共有以下四个值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenerationType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植</span></span><br><span class="line">    TABLE,</span><br><span class="line">    <span class="comment">//通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line">    <span class="comment">//采用数据库 ID 自增长， 一般用于mysql数据库</span></span><br><span class="line">    IDENTITY,</span><br><span class="line">    <span class="comment">//JPA 自动选择合适的策略，是默认选项</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Enumerated</code> 这个注解很好用，因为它对 enum 提供了下标和 name 两种方式，用法直接映射在 enum 枚举类型的字段上。请看下面源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD&#125;)</span> <span class="comment">//作用在方法和字段上</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Enumerated &#123;</span><br><span class="line">    <span class="comment">//枚举映射的类型，默认是ORDINAL（即枚举字段的下标）。</span></span><br><span class="line">    <span class="function">EnumType <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ORDINAL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//映射枚举字段的下标</span></span><br><span class="line">    ORDINAL,</span><br><span class="line">    <span class="comment">//映射枚举的Name</span></span><br><span class="line">    STRING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看一个 User 里面关于性别枚举的例子，你就会知道 <code>@Enumerated</code> 在这里没什么作用了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有一个枚举类，用户的性别</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    MALE(<span class="string">&quot;男性&quot;</span>), FEMALE(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Gender</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实体类@Enumerated的写法如下</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;tb_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;user_gender&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    .......................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候插入两条数据，数据库里面的值会变成 MALE/FEMALE，而不是“男性” / 女性。</p>
<blockquote>
<p>📌<strong>经验分享：</strong> 如果我们用 <code>@Enumerated（EnumType.ORDINAL）</code>，这时候数据库里面的值是 0、1。但是实际工作中，不建议用数字下标，因为枚举里面的属性值是会不断新增的，如果新增一个，位置变化了就惨了。并且 0、1、2 这种下标在数据库里面看着非常痛苦，时间长了就会一点也看不懂了。</p>
</blockquote>
</li>
<li><p><code>@Basic</code> 表示属性是到数据库表的字段的映射。如果实体的字段上没有任何注解，默认即为 <code>@Basic</code>。也就是说默认所有的字段肯定是和数据库进行映射的，并且默认为 Eager 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Basic &#123;</span><br><span class="line">    <span class="comment">//可选，EAGER（默认）：立即加载；LAZY：延迟加载。（LAZY主要应用在大字段上面）</span></span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line">    <span class="comment">//可选。这个字段是否可以为null，默认是true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">optional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Transient</code> 表示该属性并非一个到数据库表的字段的映射，表示非持久化属性。JPA 映射数据库的时候忽略它，与 <code>@Basic</code> 有相反的作用。也就是每个字段上面 <code>@Transient</code> 和 <code>@Basic</code> 必须二选一，而什么都不指定的话，默认是 <code>@Basic</code>。</p>
</li>
<li><p><code>@Column</code> 定义该属性对应数据库中的列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">//数据库中的表的列名；可选，如果不填写认为字段名和实体属性名一样。</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//是否唯一。默认false，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//数据字段是否允许空。可选，默认true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//执行insert操作的时候是否包含此字段，默认，true，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//执行update的时候是否包含此字段，默认，true，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//表示该字段在数据库中的实际类型。</span></span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//数据库字段的长度，可选，默认255</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Temporal</code> 用来设置 Date 类型的属性映射到对应精度的字段，存在以下三种情况：</p>
<ul>
<li><code>@Temporal(TemporalType.DATE)</code> 映射为日期（<strong>只有日期</strong>）</li>
<li><code>@Temporal(TemporalType.TIME)</code> 映射为日期（<strong>只有时间</strong>）</li>
<li><code>@Temporal(TemporalType.TIMESTAMP)</code> 映射为日期（<strong>日期+时间</strong>）</li>
</ul>
</li>
</ol>
<p>看一个完整的例子，感受一下上面提到的注解的完整用法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user_topic&quot;)</span></span><br><span class="line"><span class="meta">@Access(AccessType.FIELD)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTopic</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;id&quot;, nullable = false)</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="meta">@Column(name = &quot;title&quot;, nullable = true, length = 200)</span></span><br><span class="line">   <span class="keyword">private</span> String title;</span><br><span class="line">   <span class="meta">@Basic</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;create_user_id&quot;, nullable = true)</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@Basic(fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;content&quot;, nullable = true, length = -1)</span></span><br><span class="line">   <span class="meta">@Lob</span></span><br><span class="line">   <span class="keyword">private</span> String content;</span><br><span class="line">   <span class="meta">@Basic(fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;image&quot;, nullable = true)</span></span><br><span class="line">   <span class="meta">@Lob</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">byte</span>[] image;</span><br><span class="line">   <span class="meta">@Basic</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;create_time&quot;, nullable = true)</span></span><br><span class="line">   <span class="meta">@Temporal(TemporalType.TIMESTAMP)</span></span><br><span class="line">   <span class="keyword">private</span> Date createTime;</span><br><span class="line">   <span class="meta">@Basic</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;create_date&quot;, nullable = true)</span></span><br><span class="line">   <span class="meta">@Temporal(TemporalType.DATE)</span></span><br><span class="line">   <span class="keyword">private</span> Date createDate;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="meta">@Column(name = &quot;topic_type&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Type type;</span><br><span class="line">   <span class="meta">@Transient</span></span><br><span class="line">   <span class="keyword">private</span> String transientSimple;</span><br><span class="line">   <span class="comment">//非数据库映射字段，业务类型的字段</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getTransientSimple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> title + <span class="string">&quot;auto:jack&quot;</span> + type;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//有一个枚举类，主题的类型</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">      EN(<span class="string">&quot;英文&quot;</span>), CN(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> String des;</span><br><span class="line">      Type(String des) &#123;</span><br><span class="line">         <span class="keyword">this</span>.des = des;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里面的很多注解都可以省略，直接使用默认的就可以。如 <code>@Basic</code>、<code>@Column</code> 名字有一定的映射策略，所以可以省略。</p>
<p>此外，<code>@Access</code> 也可以省略，我们只要在这些类里面保持一致就可以了。</p>
<h2 id="生成这些注解的小技巧"><a href="#生成这些注解的小技巧" class="headerlink" title="生成这些注解的小技巧"></a>生成这些注解的小技巧</h2><p>有时候老的 Table 非常多，一个一个去写 entity 会特别累，因此可以利用 IDEA 工具直接帮我们生成 Entity 类。关键步骤如下：</p>
<p>首先，<strong>打开 Persistence 视图，点击 Generate Persistence Mapping</strong>，接着<strong>点击选中数据源</strong>，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201016132432.png" alt=""></p>
<p>然后，<strong>选择表和字段，并点击 OK</strong>。</p>
<p><img src="http://image.leonote.cn/20201016132931.png" alt=""></p>
<p>这样就可以生成我们想要的实体了，多简单。如果是新库、新表，我们也可以先定义好实体，通过实体配置 JPA 的 spring.jpa.generate-ddl=true，反向直接生成 DDL 操作数据库生成表结构。</p>
<blockquote>
<p>🎯注意：在生产环境中要把外键关联关系关闭，不然会出现意想不到的 ERROR，毕竟生产环境不同开发环境，我们可以通过在开发环境生成的表导出 DDL 到生产执行。利用生成 DDL 来做测试和写案例，可以省去创建表的时间，只需要关注代码就行了。</p>
</blockquote>
<h2 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h2><p>可以通过 javax.persistence.EmbeddedId 和 javax.persistence.IdClass 两个注解实现联合主键的效果。</p>
<h3 id="如何通过-IdClass-做到联合主键？"><a href="#如何通过-IdClass-做到联合主键？" class="headerlink" title="如何通过 @IdClass 做到联合主键？"></a>如何通过 @IdClass 做到联合主键？</h3><p>第一步：新建一个 UserInfoID 类里面是联合主键。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoID</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name, telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：再新建一个 UserInfo 的实体，采用 @IdClass 引用联合主键类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@IdClass(UserInfoID.class)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：新增一个 UserInfoRepository 类来做 CRUD 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">UserInfoID</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：写一个测试用例，测试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoRepositoryTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span> <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIdClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  userInfoRepository.save(UserInfo.builder().ages(<span class="number">1</span>)</span><br><span class="line">                         .name(<span class="string">&quot;jack&quot;</span>).telephone(<span class="string">&quot;123456789&quot;</span>).build());</span><br><span class="line">    Optional&lt;UserInfo&gt; userInfo =</span><br><span class="line">        userInfoRepository.findById(</span><br><span class="line">            UserInfoID.builder().name(<span class="string">&quot;jack&quot;</span>).telephone(<span class="string">&quot;123456789&quot;</span>).build());</span><br><span class="line">    System.out.println(userInfo.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">create table <span class="title">user_info</span> <span class="params">(name varchar(<span class="number">255</span>)</span> not <span class="keyword">null</span>, telephone <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span> not <span class="keyword">null</span>, ages integer, primary <span class="title">key</span> <span class="params">(name, telephone)</span>)</span></span><br><span class="line"><span class="function">Hibernate: select userinfo0_.name as name1_3_0_, userinfo0_.telephone as telephon2_3_0_, userinfo0_.ages as ages3_3_0_ from user_info userinfo0_ where userinfo0_.name</span>=? and userinfo0_.telephone=?</span><br><span class="line">UserInfo(ages=<span class="number">1</span>, name=jack, telephone=<span class="number">123456789</span>)</span><br></pre></td></tr></table></figure>

<p>上面的例子，表的主键是 (name, telephone)，而 Entity 里面不再是一个 <code>@Id</code> 字段了。</p>
<h3 id="Embeddable-与-EmbeddedId-注解使用"><a href="#Embeddable-与-EmbeddedId-注解使用" class="headerlink" title="@Embeddable 与 @EmbeddedId 注解使用"></a>@Embeddable 与 @EmbeddedId 注解使用</h3><p>第一步：在我们上面例子中的 UserInfoID 里面添加 @Embeddable 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoID</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name, telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：改一下刚才的 User 对象，删除 <code>@IdClass</code>，添加 <code>@EmbeddedId</code> 注解，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="meta">@EmbeddedId</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoID userInfoID;</span><br><span class="line">   <span class="meta">@Column(unique = true)</span></span><br><span class="line">   <span class="keyword">private</span> String uniqueNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：UserInfoRepository 不变，我们直接修改一下测试用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIdClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userInfoRepository.save(</span><br><span class="line">        UserInfo.builder()</span><br><span class="line">            .ages(<span class="number">1</span>)</span><br><span class="line">         	.userInfoID(UserInfoID.builder().name(<span class="string">&quot;jack&quot;</span>)</span><br><span class="line">         			  .telephone(<span class="string">&quot;123456789&quot;</span>).build())</span><br><span class="line">            .build());</span><br><span class="line">    Optional&lt;UserInfo&gt; userInfo =</span><br><span class="line">        userInfoRepository.findById(</span><br><span class="line">            UserInfoID.builder().name(<span class="string">&quot;jack&quot;</span>).telephone(<span class="string">&quot;123456789&quot;</span>).build());</span><br><span class="line">    System.out.println(userInfo.get());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>运行完之后，你可以得到相同的结果。那么 @IdClass 和 @EmbeddedId 的区别是什么？有以下两个方面：</p>
<ol>
<li>在使用的时候，Embedded 用的是对象，而 IdClass 用的是具体的某一个字段；</li>
<li>二者的JPQL 也会不一样：<ul>
<li>用 <code>@IdClass</code> JPQL 的写法：<code>SELECT u.name FROM UserInfo u</code></li>
<li>用 <code>@EmbeddedId</code> 的 JPQL 的写法：<code>select u.userInfoId.name FROM UserInfo u</code></li>
</ul>
</li>
</ol>
<p>联合主键还有需要注意的就是，它与唯一性索引约束的区别是写法不同，如上面所讲，唯一性索引的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column(unique = true)</span></span><br><span class="line"><span class="keyword">private</span> String uniqueNumber;</span><br></pre></td></tr></table></figure>

<h2 id="实体之间的继承关系如何实现"><a href="#实体之间的继承关系如何实现" class="headerlink" title="实体之间的继承关系如何实现"></a>实体之间的继承关系如何实现</h2><p>在 Java 面向对象的语言环境中，<code>@Entity</code> 之间的关系多种多样，而根据 JPA 的规范，大致可以将其分为以下几种：</p>
<ol>
<li>纯粹的继承，和表没关系，对象之间的字段共享。利用注解 <code>@MappedSuperclass</code>，协议规定父类不能是 <code>@Entity</code>。</li>
<li>单表多态问题，同一张 Table，表示了不同的对象，通过一个字段来进行区分。利用<code>@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</code>注解完成，只有父类有 <code>@Table</code>。</li>
<li>多表多态，每一个子类一张表，父类的表拥有所有公用字段。通过<code>@Inheritance(strategy = InheritanceType.JOINED)</code>注解完成，父类和子类都是表，有公用的字段在父表里面。</li>
<li>Object 的继承，数据库里面每一张表是分开的，相互独立不受影响。通过<code>@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</code>注解完成，父类（可以是一张表，也可以不是）和子类都是表，相互之间没有关系。</li>
</ol>
<h3 id="单表多态"><a href="#单表多态" class="headerlink" title="单表多态"></a>单表多态</h3><p><code>InheritanceType.SINGLE_TABLE</code></p>
<p>父类实体对象与各个子实体对象共用一张表，通过一个字段的不同值代表不同的对象。</p>
<p>举例，抽象一个 Book 对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="meta">@Entity(name=&quot;book&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.SINGLE_TABLE)</span></span><br><span class="line"><span class="meta">@DiscriminatorColumn(name=&quot;color&quot;, discriminatorType = DiscriminatorType.STRING)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再新建一个 BlueBook 对象，作为 Book 的子对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.DiscriminatorValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;blue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueBook</span> <span class="keyword">extends</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String blueMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再新建一个 RedBook 对象，作为 Book 的另一子对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//红皮书</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@DiscriminatorValue(&quot;red&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String redMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，一共新建了三个 Entity 对象，其实都是指 book 这一张表，通过 book 表里面的 color 字段来区分红书还是绿书。</p>
<p>测试看看结果，新建一个 RedBookRepository 类，结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RedBookRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">RedBook</span>, <span class="title">Long</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后再新建一个测试用例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.example1.book.RedBook;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.example1.book.RedBookRepository;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBookRepositoryTest</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RedBookRepository redBookRepository;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      RedBook redBook = <span class="keyword">new</span> RedBook();</span><br><span class="line">      redBook.setTitle(<span class="string">&quot;redbook&quot;</span>);</span><br><span class="line">      redBook.setRedMark(<span class="string">&quot;redmark&quot;</span>);</span><br><span class="line">      redBook.setId(<span class="number">1L</span>);</span><br><span class="line">      redBookRepository.saveAndFlush(redBook);</span><br><span class="line">      RedBook r = redBookRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">      System.out.println(r.getId() + <span class="string">&quot;:&quot;</span> + r.getTitle() + <span class="string">&quot;:&quot;</span> + r.getRedMark());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后看一下执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">create table <span class="title">book</span> <span class="params">(color varchar(<span class="number">31</span>)</span> not <span class="keyword">null</span>, id bigint not <span class="keyword">null</span>, title <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span>, blue_mark <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span>, red_mark <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span>, primary <span class="title">key</span> <span class="params">(id)</span>)</span></span><br></pre></td></tr></table></figure>

<p>发现只创建了一张表，insert 了一条数据，但是 color 字段默认给的是 red。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">book</span> <span class="params">(title, red_mark, color, id)</span> <span class="title">values</span> <span class="params">(?, ?, <span class="string">&#x27;red&#x27;</span>, ?)</span></span></span><br></pre></td></tr></table></figure>

<p>那么再看一下打印结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:redbook:redmark</span><br></pre></td></tr></table></figure>

<p>结果完全和预期的一样，这说明了 RedBook、BlueBook、Book，都是一张表，通过字段 color 的值不一样，来区分不同的实体。</p>
<h3 id="多表多态"><a href="#多表多态" class="headerlink" title="多表多态"></a>多表多态</h3><p><code>InheritanceType.JOINED</code></p>
<p>在这种映射策略里面，继承结构中的每一个实体（entity）类都会映射到数据库里一个单独的表中。也就是说，每个实体（entity）都会被映射到数据库中，一个实体（entity）类对应数据库中的一个表。</p>
<p>其中根实体（root entity）对应的表中定义了主键（primary key），所有的子类对应的数据库表都要共同使用 Book 里面的 @ID 这个主键。</p>
<p>首先，我们改一下上面的三个实体，测试一下InheritanceType.JOINED，改动如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="meta">@Entity(name=&quot;book&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.JOINED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，我们 Book 父类、改变 Inheritance 策略、删除 DiscriminatorColumn，你会看到如下结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrimaryKeyJoinColumn;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn(name = &quot;book_id&quot;, referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueBook</span> <span class="keyword">extends</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String blueMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.PrimaryKeyJoinColumn;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@PrimaryKeyJoinColumn(name = &quot;book_id&quot;, referencedColumnName = &quot;id&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String redMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，BlueBook 和 RedBook 也删除 DiscriminatorColumn，新增<code>@PrimaryKeyJoinColumn(name = &quot;book_id&quot;, referencedColumnName = &quot;id&quot;)</code>，和 book 父类共用一个主键值，而 RedBookRepository 和测试用例不变，我们执行看一下结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">create table <span class="title">blue_book</span> <span class="params">(blue_mark varchar(<span class="number">255</span>)</span>, book_id bigint not <span class="keyword">null</span>, primary <span class="title">key</span> <span class="params">(book_id)</span>)</span></span><br><span class="line"><span class="function">Hibernate: create table <span class="title">book</span> <span class="params">(id bigint not <span class="keyword">null</span>, title varchar(<span class="number">255</span>)</span>, primary <span class="title">key</span> <span class="params">(id)</span>)</span></span><br><span class="line"><span class="function">Hibernate: create table <span class="title">red_book</span> <span class="params">(red_mark varchar(<span class="number">255</span>)</span>, book_id bigint not <span class="keyword">null</span>, primary <span class="title">key</span> <span class="params">(book_id)</span>)</span></span><br><span class="line"><span class="function">Hibernate: alter table blue_book add constraint FK9uuwgq7a924vtnys1rgiyrlk7 foreign <span class="title">key</span> <span class="params">(book_id)</span> references book</span></span><br><span class="line"><span class="function">Hibernate: alter table red_book add constraint FKk8rvl61bjy9lgsr9nhxn5soq5 foreign <span class="title">key</span> <span class="params">(book_id)</span> references book</span></span><br></pre></td></tr></table></figure>

<p>上述代码可以看到，我们一共创建了三张表，并且新增了两个外键约束；</p>
<p>而我们 save 的时候也生成了两个 insert 语句，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">book</span> <span class="params">(title, id)</span> <span class="title">values</span> <span class="params">(?, ?)</span></span></span><br><span class="line"><span class="function">Hibernate: insert into <span class="title">red_book</span> <span class="params">(red_mark, book_id)</span> <span class="title">values</span> <span class="params">(?, ?)</span></span></span><br></pre></td></tr></table></figure>

<p>而打印结果依然不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:redbook:redmark</span><br></pre></td></tr></table></figure>

<p>这个方法和上面的 InheritanceType.SINGLE_TABLE 区别在于表的数量和关系不一样，这是表设计的另一种方式。</p>
<h3 id="Object-的继承"><a href="#Object-的继承" class="headerlink" title="Object 的继承"></a>Object 的继承</h3><p><code>InheritanceType.TABLE_PER_CLASS</code> 和 <code>@MappedSuperClass</code> 一样</p>
<p>我们在使用 <code>@MappedSuperClass</code> 主键的时候，如果不指定 @Inheritance，默认就是此种 TABLE_PER_CLASS 模式。当然了，我们也显示指定，要求继承基类的都是一张表，而父类不是表，是 java 对象的抽象类。我们看一个例子。</p>
<p>首先，还是改一下上面的三个实体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"><span class="meta">@Entity(name=&quot;book&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，Book 表采用 TABLE_PER_CLASS 策略，其子实体类都代表各自的表，实体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBook</span> <span class="keyword">extends</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String redMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.book;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper=false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlueBook</span> <span class="keyword">extends</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String blueMark;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，从 RedBook 和 BlueBook 里面去掉 PrimaryKeyJoinColumn，</p>
<p>而 RedBookRepository 和测试用例不变，我们执行看一下结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">create table <span class="title">blue_book</span> <span class="params">(id bigint not <span class="keyword">null</span>, title varchar(<span class="number">255</span>)</span>, blue_mark <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span>, primary <span class="title">key</span> <span class="params">(id)</span>)</span></span><br><span class="line"><span class="function">Hibernate: create table <span class="title">book</span> <span class="params">(id bigint not <span class="keyword">null</span>, title varchar(<span class="number">255</span>)</span>, primary <span class="title">key</span> <span class="params">(id)</span>)</span></span><br><span class="line"><span class="function">Hibernate: create table <span class="title">red_book</span> <span class="params">(id bigint not <span class="keyword">null</span>, title varchar(<span class="number">255</span>)</span>, red_mark <span class="title">varchar</span><span class="params">(<span class="number">255</span>)</span>, primary <span class="title">key</span> <span class="params">(id)</span>)</span></span><br></pre></td></tr></table></figure>

<p>这里可以看到，我们还是创建了三张表，但三张表什么关系也没有。</p>
<p>而 insert 语句也只有一条，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">red_book</span> <span class="params">(title, red_mark, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?)</span></span></span><br></pre></td></tr></table></figure>

<p>打印结果还是不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>:redbook:redmark</span><br></pre></td></tr></table></figure>

<p>这个方法与上面两个相比较，语义更加清晰，是<strong>比较常用的一种做法</strong>。</p>
<h2 id="关于继承关系的经验之谈"><a href="#关于继承关系的经验之谈" class="headerlink" title="关于继承关系的经验之谈"></a>关于继承关系的经验之谈</h2><blockquote>
<p>🎯个人经验来看，@Inheritance 的这种使用方式会逐渐被淘汰，因为这样的表的设计很复杂，本应该在业务层面做的事情（多态），却都在 dataSource 的表级别做了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>Entity 注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa Hibernate 一级缓存</title>
    <url>/2021/01/26/SpringDataJpa%E7%9A%84Hibernate%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="Hibernate-一级缓存"><a href="#Hibernate-一级缓存" class="headerlink" title="Hibernate 一级缓存"></a>Hibernate 一级缓存</h1><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><h3 id="什么是一级缓存"><a href="#什么是一级缓存" class="headerlink" title="什么是一级缓存"></a>什么是一级缓存</h3><p>按照 Hibernate 和 JPA 协议里面的解释，经常说的 First Level Cache（一级缓存）也就是 <code>PersistenceContext</code>，既然如此，那么就意味着一级缓存的载体是 <code>Session</code> 或者 <code>EntityManager</code>；而一级缓存的实体也就是数据库里面对应的实体。</p>
<p>在 <code>SessionImpl</code> 的实现过程中，会发现 <code>PersistenceContext</code> 的实现类 <code>StatefulPersistenceContext</code> 是通过 <code>HashMap</code> 来存储实体信息的。</p>
<p>其关键源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulPersistenceContext</span> <span class="keyword">implements</span> <span class="title">PersistenceContext</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据EntityUniqueKey作为key来储存Entity</span></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;EntityUniqueKey, Object&gt; entitiesByUniqueKey;</span><br><span class="line">  <span class="comment">//根据EntityUniqueKey作为key取当前实体</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getEntity</span><span class="params">(EntityUniqueKey euk)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> entitiesByUniqueKey == <span class="keyword">null</span> ? <span class="keyword">null</span> : entitiesByUniqueKey.get( euk );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//储存实体，如果是第一次，那么创建HashMap&lt;&gt;</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEntity</span><span class="params">(EntityUniqueKey euk, Object entity)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ( entitiesByUniqueKey == <span class="keyword">null</span> ) &#123;</span><br><span class="line">        entitiesByUniqueKey = <span class="keyword">new</span> HashMap&lt;&gt;( INIT_COLL_SIZE );</span><br><span class="line">     &#125;</span><br><span class="line">     entitiesByUniqueKey.put( euk, entity );</span><br><span class="line">  &#125;</span><br><span class="line">......&#125;</span><br></pre></td></tr></table></figure>

<p>其中 EntityUniqueKey 的核心源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EntityUniqueKey</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String uniqueKeyName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String entityName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object key;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Type keyType;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> EntityMode entityMode;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">     EntityUniqueKey that = (EntityUniqueKey) other;</span><br><span class="line">     <span class="keyword">return</span> that != <span class="keyword">null</span> &amp;&amp; that.entityName.equals( entityName )</span><br><span class="line">           &amp;&amp; that.uniqueKeyName.equals( uniqueKeyName )</span><br><span class="line">           &amp;&amp; keyType.isEqual( that.key, key );</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以看到，用 <code>PersistenceContext</code> 来判断实体是不是同一个，可以直接根据实体里面的主键进行。</p>
<h3 id="一级缓存的作用"><a href="#一级缓存的作用" class="headerlink" title="一级缓存的作用"></a>一级缓存的作用</h3><p>由于一级缓存就是 <code>PersistenceContext</code>，那么一级缓存的最大作用就是<strong><em>管理 Entity 的生命周期</em></strong>。</p>
<ol>
<li><p>New（Transient）状态的，不在一级缓存管理之列，这是新创建的；</p>
</li>
<li><p>Detached 游离状态的，不在一级缓存里面，和 New 的唯一区别是它带有主键和 Version 信息；</p>
</li>
<li><p>Manager、Removed 状态的实体在一级缓存管理之列，所有对这两种状态的实体进行的更新操作，都不会立即更新到数据库里面，只有执行了 flush 之后才会同步到数据库里面。</p>
</li>
</ol>
<p>用一张图(注：图片来源于网络)来表示，如下所示。</p>
<p><img src="http://image.leonote.cn/20210129111859.png" alt=""></p>
<p>对于实体 1 来说，新增和更新操作都是先进行一级缓存，只有 flush 的时候才会同步到数据库里面。而当我们执行了 <code>entityManager.clean()</code> 或者是 <code>entityManager.detach(entity1)</code>，那么实体 1 就会变成游离状态，这时再对实体 1 进行修改，如果再执行 flush 的话，就不会同步到 DB 里面了。用代码来说明一下，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">    <span class="meta">@PersistenceContext(properties = &#123;@PersistenceProperty(</span></span><br><span class="line"><span class="meta">            name = &quot;org.hibernate.flushMode&quot;,</span></span><br><span class="line"><span class="meta">            value = &quot;MANUAL&quot;//手动flush</span></span><br><span class="line"><span class="meta">    )&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = UserInfo.builder().name(<span class="string">&quot;new name&quot;</span>).build();</span><br><span class="line">        <span class="comment">//新增一个对象userInfo交给PersistenceContext管理，即一级缓存</span></span><br><span class="line">        entityManager.persist(userInfo);</span><br><span class="line">        <span class="comment">//此时没有detach和clear之前，flush的时候还会产生更新SQL</span></span><br><span class="line">        userInfo.setName(<span class="string">&quot;old name&quot;</span>);</span><br><span class="line">        entityManager.flush();</span><br><span class="line">        entityManager.clear();</span><br><span class="line"><span class="comment">//        entityManager.detach(userInfo);</span></span><br><span class="line">        <span class="comment">// entityManager已经clear，此时已经不会对UserInfo进行更新了</span></span><br><span class="line">        userInfo.setName(<span class="string">&quot;new name 11&quot;</span>);</span><br><span class="line">        entityManager.flush();</span><br><span class="line">        <span class="comment">//由于有cache机制，相同的对象查询只会触发一次查询SQL</span></span><br><span class="line">        UserInfo u1 = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">        <span class="comment">//to do some thing</span></span><br><span class="line">        UserInfo u2 = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 SQL 打印一下，输出到控制台的 SQL 如下所示。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Hibernate: insert into user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, name, telephone, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Hibernate: update user_info <span class="built_in">set</span> create_time=?, create_user_id=?, last_modified_time=?, last_modified_user_id=?, version=?, ages=?, email_address=?, last_name=?, name=?, telephone=? <span class="built_in">where</span> id=? and version=?</span><br><span class="line">Hibernate: <span class="built_in">select</span> userinfo0_.id as id1_2_0_, userinfo0_.create_time as create_t2_2_0_, userinfo0_.create_user_id as create_u3_2_0_, userinfo0_.last_modified_time as last_mod4_2_0_, userinfo0_.last_modified_user_id as last_mod5_2_0_, userinfo0_.version as version6_2_0_, userinfo0_.ages as ages7_2_0_, userinfo0_.email_address as email_ad8_2_0_, userinfo0_.last_name as last_nam9_2_0_, userinfo0_.name as name10_2_0_, userinfo0_.telephone as telepho11_2_0_, rooms1_.user_info_id as user_inf1_3_1_, room2_.id as rooms_id2_3_1_, room2_.id as id1_1_2_, room2_.create_time as create_t2_1_2_, room2_.create_user_id as create_u3_1_2_, room2_.last_modified_time as last_mod4_1_2_, room2_.last_modified_user_id as last_mod5_1_2_, room2_.version as version6_1_2_, room2_.title as title7_1_2_ from user_info userinfo0_ left outer join user_info_rooms rooms1_ on userinfo0_.id=rooms1_.user_info_id left outer join room room2_ on rooms1_.rooms_id=room2_.id <span class="built_in">where</span> userinfo0_.id=?</span><br></pre></td></tr></table></figure>

<p>通过日志可以看到没有第二次更新。</p>
<p><strong>不能设置一级缓存的大小</strong></p>
<p>从底层原理可以分析出：一级缓存依赖 Java 内存堆的大小，所以受到最大堆和最小堆的限制，即清除一级缓存的机制就是利用 JVM 的 GC 机制，清理掉 GC 就会清理掉一级缓存。</p>
<p>所以当请求并发量大的时候，Session 的对象就会变得很多，此时就会需要更多内存。当请求结束之后，随着 GC 的回收，里面就会清除一级缓存留下来的对象。</p>
<p><strong>不能关闭一级缓存</strong></p>
<p>除非不用 Hibernate 或 JPA，改用 Mybatis，因为一级缓存是 JPA 的最大优势之一。</p>
<h2 id="Query-Plan-Cache"><a href="#Query-Plan-Cache" class="headerlink" title="Query Plan Cache"></a>Query Plan Cache</h2><p>JPA 里面大部分的查询都是基于 JPQL 查询语法，从而会有一个过程把 JPQL 转化成真正的 SQL，而后到数据库里执行。而 JPQL 转化成原始的 SQL 时，就会消耗一定的性能，所以 Hibernate 设计了一个 Query Plan Cache 的机制，用来存储 JPQL 或者 Criteria Query 到 Native SQL 中转化的结果，也就是说 Query Plan Cache 里面存储了最终要执行的 SQL，以及参数和返回结果的类型。</p>
<h3 id="QueryPlanCache-是什么"><a href="#QueryPlanCache-是什么" class="headerlink" title="QueryPlanCache 是什么"></a>QueryPlanCache 是什么</h3><p>在 Hibernate 中，<code>QueryPlanCache</code> 就是指具体的某一个类。核心源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.hibernate.engine.query.spi;</span><br><span class="line"><span class="comment">//存储query plan 和 query parameter metdata</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryPlanCache</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//queryPlanCache的存储结构为自定义的HashMap结构，用来存储JPQL到SQL的转化过程及其SQL的执行语句和参数，返回结果的metadata;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundedConcurrentHashMap queryPlanCache;</span><br><span class="line">    <span class="comment">//这个用来存储@Query的nativeQuery = true的query plan，即原始SQL的meta,包含参数和return type的 meta;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BoundedConcurrentHashMap&lt;ParameterMetadataKey,ParameterMetadataImpl&gt; parameterMetadataCache;</span><br><span class="line">    <span class="comment">//QueryPlanCache的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueryPlanCache</span><span class="params">(<span class="keyword">final</span> SessionFactoryImplementor factory, QueryPlanCreator queryPlanCreator)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.factory = factory;</span><br><span class="line">       <span class="keyword">this</span>.queryPlanCreator = queryPlanCreator;</span><br><span class="line">       <span class="comment">//maxParameterMetadata的个数，计算逻辑，可以自定义配置，或者采用默认值</span></span><br><span class="line">       Integer maxParameterMetadataCount = ConfigurationHelper.getInteger(</span><br><span class="line">             Environment.QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE,</span><br><span class="line">             factory.getProperties()</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span> ( maxParameterMetadataCount == <span class="keyword">null</span> ) &#123;</span><br><span class="line">          maxParameterMetadataCount = ConfigurationHelper.getInt(</span><br><span class="line">                Environment.QUERY_PLAN_CACHE_MAX_STRONG_REFERENCES,</span><br><span class="line">                factory.getProperties(),</span><br><span class="line">                DEFAULT_PARAMETER_METADATA_MAX_COUNT</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//maxQueryPlan的个数，计算逻辑，可以自定义配置大小，或者采用默认值</span></span><br><span class="line">       Integer maxQueryPlanCount = ConfigurationHelper.getInteger(</span><br><span class="line">             Environment.QUERY_PLAN_CACHE_MAX_SIZE,</span><br><span class="line">             factory.getProperties()</span><br><span class="line">       );</span><br><span class="line">       <span class="keyword">if</span> ( maxQueryPlanCount == <span class="keyword">null</span> ) &#123;</span><br><span class="line">          maxQueryPlanCount = ConfigurationHelper.getInt(</span><br><span class="line">                Environment.QUERY_PLAN_CACHE_MAX_SOFT_REFERENCES,</span><br><span class="line">                factory.getProperties(),</span><br><span class="line">                DEFAULT_QUERY_PLAN_MAX_COUNT</span><br><span class="line">          );</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//新建一个 BoundedConcurrentHashMap的queryPlanCache，用来存储JPQL和Criteria Query到SQL的转化过程</span></span><br><span class="line">       queryPlanCache = <span class="keyword">new</span> BoundedConcurrentHashMap( maxQueryPlanCount, <span class="number">20</span>, BoundedConcurrentHashMap.Eviction.LIRS );</span><br><span class="line">    <span class="comment">//新建一个 BoundedConcurrentHashMap的parameterMetadataCache，用来存储Native SQL的转化过程</span></span><br><span class="line">       parameterMetadataCache = <span class="keyword">new</span> BoundedConcurrentHashMap&lt;&gt;(</span><br><span class="line">             maxParameterMetadataCount,</span><br><span class="line">             <span class="number">20</span>,</span><br><span class="line">             BoundedConcurrentHashMap.Eviction.LIRS</span><br><span class="line">       );</span><br><span class="line">       nativeQueryInterpreter = factory.getServiceRegistry().getService( NativeQueryInterpreter.class );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认的parameterMetadataCache的HashMap的存储空间大小，默认128条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_PARAMETER_METADATA_MAX_COUNT = <span class="number">128</span>;</span><br><span class="line">    <span class="comment">//默认的queryPlanCache的HashMap存储空间大小，默认2048条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_QUERY_PLAN_MAX_COUNT = <span class="number">2048</span>;</span><br><span class="line">......不重要的代码先省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QueryPlanCache-存储的内容"><a href="#QueryPlanCache-存储的内容" class="headerlink" title="QueryPlanCache 存储的内容"></a>QueryPlanCache 存储的内容</h3><p>新建一个 <code>UserInfoRepository</code>，来测试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//没有用@Query，直接使用method name defining query</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findByNameAndCreateTimeBetween</span><span class="params">(String name, Instant begin, Instant endTime)</span></span>;</span><br><span class="line">   <span class="comment">//演示SpEL根据数组下标取参数，和根据普通的Parma的名字:name取参数</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.lastName like %:#&#123;[0]&#125; and u.name like %:name%&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findContainingEscaped</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">   <span class="comment">//SpEL取Parma的名字customer里面的属性</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.name = :#&#123;#customer.name&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findUsersByCustomersFirstname</span><span class="params">(<span class="meta">@Param(&quot;customer&quot;)</span> UserInfo customer)</span></span>;</span><br><span class="line">   <span class="comment">//利用SpEL根据一个写死的&#x27;jack&#x27;字符串作为参数</span></span><br><span class="line">   <span class="meta">@Query(&quot;select u from UserInfo u where u.name = ?#&#123;&#x27;jack&#x27;&#125;&quot;)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findOliverBySpELExpressionWithoutArgumentsWithQuestionmark</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="meta">@Query(value = &quot;select * from user_info where name=:name&quot;,nativeQuery = true)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findByName</span><span class="params">(<span class="meta">@Param(value = &quot;name&quot;)</span> String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 @Query 定义的 nativeQuery=false 的 JPQL，会在启动成功之后预先放在 <code>QueryPlanCache</code> 里面，设置一个断点就可以看到如下内容：</p>
<p><img src="http://image.leonote.cn/20210129133738.png" alt=""></p>
<p>发现里面 <code>parameterMetadataCache</code> 是空的，也就是没有放置 nativeQuery=true 的 Query SQL，并且可以看到在方法里面定义的其他三个 @Query 的 JPQL 解析过程。打开第一个详细看一下，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129134958.png" alt=""></p>
<p> <code>QueryPlanCache</code> 还是能存挺多东西的：navtive sql、参数、return 等各种 metadata。也可以看出一个简单的 JPQL 查询会有些占用堆内存，所以如果是复杂点的项目，各种查询的 JPQL 多一点的话，启动所需要的最小堆内存会占用 300M、400M 的空间，这是正常现象。</p>
<p>在 <code>UserInfoRepository</code> 的五个方法中，剩下的两个方法分别是 name defining query 和 nativeQuery=true。这两种情况是，当调用的时候发现 <code>QueryPlanCache</code> 里面没有它们，于是就会被增加进去，下次就可以直接从 QueryPlanCache 里面取了。那么在 Controller 里面执行这两个方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userInfoRepository.findByNameAndCreateTimeBetween(<span class="string">&quot;JK&quot;</span>, Instant.now(),Instant.now());</span><br><span class="line">userInfoRepository.findByName(<span class="string">&quot;jack&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后通过断点就会发现 <code>QueryPlanCache</code> 里面多了两个 Cache，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129135226.png" alt=""></p>
<p>同时，<code>parameterMetadataCache</code> 里面就会多一条 key/value 的 nativeQuery=true 的解析记录，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129142257.png" alt=""></p>
<p>总结起来就是，<code>QueryPlanCache</code> 用来存储的 JQPL 或者 SQL 的 Metadata 信息，从而提升了 Hibernate 执行 JPQL 的性能，因为只有第一次需要把 JPQL 转化成 SQL，后面的每次操作就可以直接从 <code>HashMap</code> 中找到对应的 SQL，直接执行就可以了。</p>
<h3 id="QueryPlanCache-和-Session-是什么关系"><a href="#QueryPlanCache-和-Session-是什么关系" class="headerlink" title="QueryPlanCache 和 Session 是什么关系"></a>QueryPlanCache 和 Session 是什么关系</h3><p>在 <code>SessionFactoryImpl</code> 的构造方法里面会 <code>new QueryPlanCache(...)</code>，关键源码如下。</p>
<p><img src="http://image.leonote.cn/20210129142421.png" alt=""></p>
<p>说明这个 application 只需要创建一次 <code>QueryPlanCache</code>，整个项目周期是单例的，也就是可以被不同的 Session 共享，那么可以查看 Session 的关键源码，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129142504.png" alt=""></p>
<p>也就是说，每一个 <code>SessionImpl</code> 的实例在获得 query plan 之前，都会去同一个 <code>QueryPlanCache</code> 里面查询一下 JPQL 对应的执行计划。所以可以看得出来 <code>QueryPlanCache</code> 和 <code>Session</code> 的关系有如下几点。</p>
<ol>
<li><p><code>QueryPlanCache</code> 在整个 Spring Application 周期内就是一个实例</p>
</li>
<li><p>不同的 Session 作用域，可以代表不同的 <code>SessionImpl</code> 实例共享 <code>QueryPlanCache</code></p>
</li>
<li><p><code>QueryPlanCache</code> 和一级缓存完全不是一个概念</p>
</li>
</ol>
<h3 id="QueryPlanCache-中-In-查询引发的内存泄漏问题"><a href="#QueryPlanCache-中-In-查询引发的内存泄漏问题" class="headerlink" title="QueryPlanCache 中 In 查询引发的内存泄漏问题"></a>QueryPlanCache 中 In 查询引发的内存泄漏问题</h3><p>在实际的工作中使用 JPA 的时候，会发现其内存越来越大，而不会被垃圾回收机制给回收掉，现象就是<strong>堆内存随着时间的推移使用量越来越大</strong>，如下图所示，很明显是内存泄漏的问题。</p>
<p><img src="http://image.leonote.cn/20210129145136.png" alt=""></p>
<p>而把堆栈拿出来分析的话会发现，其实是 Hibernate 的 <code>QueryPlanCache</code> 占用了大量的内存，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129145215.png" alt=""></p>
<h4 id="In-查询条件引发内存泄漏的原因"><a href="#In-查询条件引发内存泄漏的原因" class="headerlink" title="In 查询条件引发内存泄漏的原因"></a>In 查询条件引发内存泄漏的原因</h4><p>在 <code>UserInfoRepository</code> 里面新增一个 In 条件的查询方法，模拟一下实际工作中的 In 查询条件的场景，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//测试In查询条件的情况</span></span><br><span class="line"><span class="function">List&lt;UserInfo&gt; <span class="title">findByNameAndUrlIn</span><span class="params">(String name, Collection&lt;String&gt; urls)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有个需求，查询拥有个人博客地址的用户有哪些？ Controller 里面有如下方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">getUserInfos</span><span class="params">(List&lt;String&gt; urls)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//根据urls批量查询，模拟实际工作中的批量查询情况，实际工作中可能会有大量的根据不同的IDS批量查询的场景；</span></span><br><span class="line">  <span class="keyword">return</span> userInfoRepository.findByNameAndUrlIn(<span class="string">&quot;jack&quot;</span>,urls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> debug 看一下 <code>QueryPlanCache</code> 里面的情况，会发现随着 In 查询条件的个数增加，会生成不同的 <code>QueryPlanCache</code>，如下图所示，分别是 1 个参数、3 个参数、6个参数的情况。</p>
<p><img src="http://image.leonote.cn/20210129145613.png" alt=""></p>
<p>从图中可以想象一下，如果业务代码中有各种 In 的查询操作，不同的查询条件的个数肯定在大部分场景中也是不一样的，甚至有些场景能一下查询到几百个 ID 对应的数据，可想而知，那得生成多少个 In 相关的 <code>QueryPlanCache</code> 呀。</p>
<p>而依据 <code>QueryPlanCache</code> 的原理，整个工程都是单例的，放进去之后肯定不会进行内存垃圾回收，那么程序运行时间久了之后就会发生内存泄漏，甚至一段时间之后还会导致内存溢出的现象发生。那么该如何解决此类问题呢？</p>
<h4 id="解决-In-查询条件内存泄漏的方法"><a href="#解决-In-查询条件内存泄漏的方法" class="headerlink" title="解决 In 查询条件内存泄漏的方法"></a>解决 In 查询条件内存泄漏的方法</h4><h5 id="第一种方法：修改缓存的最大条数限制"><a href="#第一种方法：修改缓存的最大条数限制" class="headerlink" title="第一种方法：修改缓存的最大条数限制"></a>第一种方法：修改缓存的最大条数限制</h5><p>正如上面介绍的，默认 DEFAULT_QUERY_PLAN_MAX_COUNT = 2048，也就是 query plan 的最大条数限制是 2048。这样默认值可能有点大了，可以通过如下方式修改默认值，请看代码。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改 默认的plan_cache_max_size，太小会影响JPQL的执行性能，所以根据实际情况可以自由调整，不宜太小，也不宜太大，太大可能会引发内存溢出</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.query.plan_cache_max_size</span>=<span class="string">512</span></span><br><span class="line"><span class="comment">#修改 默认的native query的cache大小</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size</span>=<span class="string">128</span></span><br></pre></td></tr></table></figure>

<h5 id="第二种方法：根据-max-plan-count-适当增加堆内存大小"><a href="#第二种方法：根据-max-plan-count-适当增加堆内存大小" class="headerlink" title="第二种方法：根据 max plan count 适当增加堆内存大小"></a>第二种方法：根据 max plan count 适当增加堆内存大小</h5><p>因为 <code>QueryPlanMaxCount</code> 是有限制的，那么肯定最大堆内存的使用也是有封顶限制的，找到临界值修改最小、最大堆内存即可。</p>
<h5 id="第三种方法：减少-In-的查询-SQL-生成条数"><a href="#第三种方法：减少-In-的查询-SQL-生成条数" class="headerlink" title="第三种方法：减少 In 的查询 SQL 生成条数"></a>第三种方法：减少 In 的查询 SQL 生成条数</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 默认情况下，不同的in查询条件的个数会生成不同的plan query cache，我们开启了in_clause_parameter_padding之后会减少in生成cache的个数，会根据参数的格式运用几何的算法生成QueryCache；</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.query.in_clause_parameter_padding</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>当 In 的时候，参数个数会对应归并 <code>QueryPlanCache</code> 变成 1、2、4、8、16、32、64、128 个参数的 <code>QueryPlanCache</code>。那么再看一下刚才参数个数分别在 1、3、4、5、6、7、8 个的时候生成 <code>QueryPlanCache</code> 的情况，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210129150017.png" alt=""></p>
<p>会发现，In 产生个数是 1 个的时候，它会共享参数为 1 个的 <code>QueryPlanCache</code>；而当参数是 3、4 个 In 参数的时候，它就会使用 4 个参数的 <code>QueryPlanCache</code>；以此类推，当参数是 5、6、7、8 个的时候，会使用 8 个参数的 <code>QueryPlanCache</code>……这种算法可以大大地减少 In 的不同查询参数生成的 <code>QueryPlanCache</code> 个数，占用的内存自然会减少很多。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa Lazy Exception 解决方法</title>
    <url>/2021/01/12/SpringDataJpa%E7%9A%84LazyException%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-Lazy-Exception-解决方法"><a href="#Spring-Data-Jpa-Lazy-Exception-解决方法" class="headerlink" title="Spring Data Jpa Lazy Exception 解决方法"></a>Spring Data Jpa Lazy Exception 解决方法</h1><h2 id="什么是-LazyInitializationException-异常"><a href="#什么是-LazyInitializationException-异常" class="headerlink" title="什么是 LazyInitializationException 异常"></a>什么是 LazyInitializationException 异常</h2><p>通过 4 个步骤看一下什么是 Lazy 异常</p>
<p>第一步：为了方便测试，把 spring.jpa.open-in-view 设置成 false，代码如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>第二步：新建一个一对多的关联实体：UserInfo 用户信息，一个用户有多个地址 Address。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line">   <span class="keyword">private</span> String emailAddress;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="comment">//假设一个用户有多个地址，取数据的方式用 lazy 的模式(默认也是 lazy 的)；采用 CascadeType.PERSIST 方便插入演示数据；</span></span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;, cascade = CascadeType.PERSIST, fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="comment">//维护关联关系的一方，默认都是 lazy 模式</span></span><br><span class="line">   <span class="meta">@ManyToOne</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：再新建一个 Controller，取用户的基本信息，并且查看一下 Address 的地址信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">  UserInfo u1 =  userInfoRepository.findById(id).get();</span><br><span class="line">  <span class="comment">//触发 lazy 加载，取 userInfo 里面的地址信息</span></span><br><span class="line">  System.out.println(u1.getAddressList().get(<span class="number">0</span>).getCity());</span><br><span class="line">  <span class="keyword">return</span> u1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：启动项目，直接发起如下请求：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">### get user info的接口</span><br><span class="line"><span class="keyword">GET</span> <span class="string">/user/info/1</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8087</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure>

<p>然后就可以如期得到 Lazy 异常，如下所示:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.example.jpa.demo.db.UserInfo.addressList, could not initialize proxy - no Session</span><br><span class="line">   at org.hibernate.collection.internal.AbstractPersistentCollection.throwLazyInitializationException(AbstractPersistentCollection.java:<span class="number">606</span>) ~[<span class="type">hibernate</span>-<span class="type">core</span>-<span class="number">5.4</span><span class="type">.20.Final.jar</span>:<span class="number">5.4</span><span class="type">.20.Final</span>]</span><br><span class="line">   at org.hibernate.collection.internal.AbstractPersistentCollection.withTemporarySessionIfNeeded(AbstractPersistentCollection.java:<span class="number">218</span>) ~[<span class="type">hibernate</span>-<span class="type">core</span>-<span class="number">5.4</span><span class="type">.20.Final.jar</span>:<span class="number">5.4</span><span class="type">.20.Final</span>]</span><br><span class="line">   at org.hibernate.collection.internal.AbstractPersistentCollection.initialize(AbstractPersistentCollection.java:<span class="number">585</span>) ~[<span class="type">hibernate</span>-<span class="type">core</span>-<span class="number">5.4</span><span class="type">.20.Final.jar</span>:<span class="number">5.4</span><span class="type">.20.Final</span>]</span><br><span class="line">   at org.hibernate.collection.internal.AbstractPersistentCollection.read(AbstractPersistentCollection.java:<span class="number">149</span>) ~[<span class="type">hibernate</span>-<span class="type">core</span>-<span class="number">5.4</span><span class="type">.20.Final.jar</span>:<span class="number">5.4</span><span class="type">.20.Final</span>]</span><br><span class="line">   at org.hibernate.collection.internal.PersistentBag.get(PersistentBag.java:<span class="number">561</span>) ~[<span class="type">hibernate</span>-<span class="type">core</span>-<span class="number">5.4</span><span class="type">.20.Final.jar</span>:<span class="number">5.4</span><span class="type">.20.Final</span>]</span><br><span class="line">   at com.example.jpa.demo.web.UserInfoController.getUserInfoFromPath(UserInfoController.java:<span class="number">29</span>) ~[<span class="type">main</span>/:<span class="type">na</span>]</span><br></pre></td></tr></table></figure>

<p>通过上面的异常信息基本可以看到， UserInfo 实体对象加载 Address 的时候，产生了 Lazy 异常，是因为 no session。那么发生异常的根本原因是什么呢？它的加载原理是什么样的？</p>
<h2 id="Lazy-加载机制的原理分析"><a href="#Lazy-加载机制的原理分析" class="headerlink" title="Lazy 加载机制的原理分析"></a>Lazy 加载机制的原理分析</h2><p>JPA 里有 Lazy 的机制，所谓的 Lazy 就是指，当我们使用关联关系的时候，只有用到被关联关系的一方才会请求数据库去加载数据，也就是说关联关系的真实数据不是立马加载的，只有用到的时候才会加载。</p>
<p>而 Hibernate 的实现机制中提供了 PersistentCollection 的机制，利用代理机制改变了关联关系的集合类型，从而实现了懒加载机制。</p>
<h3 id="PersistentCollection-集合类"><a href="#PersistentCollection-集合类" class="headerlink" title="PersistentCollection 集合类"></a>PersistentCollection 集合类</h3><p>PersistentCollection 是一个集合类的接口，实现类包括如下几种，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210112100436.png" alt=""></p>
<p>也就是说 Hibernate 通过 PersistentCollection 的实现类 AbstractPersistentCollection 的所有子类，对 JDK 里面提供的 List、Map、SortMap、Array、Set、SortedSet 进行了扩展，从而实现了具有懒加载的特性。所以在 Hibernate 里面支持的关联关系的类型只有下面五种。</p>
<ul>
<li><p>java.util.List</p>
</li>
<li><p>java.util.Set</p>
</li>
<li><p>java.util.Map</p>
</li>
<li><p>java.util.SortedSet</p>
</li>
<li><p>java.util.SortedMap</p>
</li>
</ul>
<p>关于这几种类型，Hibernate 官方也提供了扩展 AbstractPersistentCollection 的方法。</p>
<h3 id="PersistentBag-为例详解原理"><a href="#PersistentBag-为例详解原理" class="headerlink" title="PersistentBag 为例详解原理"></a>PersistentBag 为例详解原理</h3><p>通过 PersistentBag 的关键源码，来看一下集合类 List 是怎么实现的，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PersistentBag 继承 AbstractPersistentCollection，从而继承了 PersistenceCollection 的一些公共功能、session的持有、lazy的特性、entity的状态转化等功能；同时 PersistentBag 也实现了 java.util.List 的所有方法，即对 List 进行读写的时候包装 lazy 逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentBag</span> <span class="keyword">extends</span> <span class="title">AbstractPersistentCollection</span> <span class="keyword">implements</span> <span class="title">List</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PersistentBag构造方法，当初始化实体对象对集合初始化的时候，把当前的Session保持住</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersistentBag</span><span class="params">(SessionImplementor session)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>( (SharedSessionContractImplementor) session );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从这个方法可以看出来其对List和ArrayList的支持</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersistentBag</span><span class="params">(SharedSessionContractImplementor session, Collection coll)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>( session );</span><br><span class="line">       providedCollection = coll;</span><br><span class="line">       <span class="keyword">if</span> ( coll <span class="keyword">instanceof</span> List ) &#123;</span><br><span class="line">          bag = (List) coll;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          bag = <span class="keyword">new</span> ArrayList( coll );</span><br><span class="line">       &#125;</span><br><span class="line">       setInitialized();</span><br><span class="line">       setDirectlyAccessible( <span class="keyword">true</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下是一些关键的 List 的实现方法，基本上都是在原有的 List 功能的基础上增加调用父类 AbstractPersistentCollection 里面的 read() 和 write() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       write();</span><br><span class="line">       <span class="keyword">return</span> bag.remove( i );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, Object o)</span> </span>&#123;</span><br><span class="line">       write();</span><br><span class="line">       <span class="keyword">return</span> bag.set( i, o );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">subList</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       read();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ListProxy( bag.subList( start, end ) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">entryExists</span><span class="params">(Object entry, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> entry != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// toString被调用的时候会触发read()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       read();</span><br><span class="line">       <span class="keyword">return</span> bag.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    .....<span class="comment">//其他方法类似，就不一一举例了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么再看一下 AbstractPersistentCollection 的关键实现，在 AbstractPersistentCollection 中会有大量通过 Session 来初始化关联关系的方法，这些方法基本是利用当前 Session 和当前 Session 中持有的 Connection 来重新操作 DB，从而取到数据库里面的数据。</p>
<p>所以 LazyInitializationExcetion 基本都是从这个类里面抛出来的，从源码里面可以看到其严重依赖当前的 Session，关键源码如下图所示。</p>
<p><img src="http://image.leonote.cn/20210112102325.png" alt=""></p>
<p>所以在默认的情况下，如果把 Session 关闭了，想利用 Lazy 的机制加载管理关系，就会发生异常了。通过实例看一下，在上面例子的 Controller 上加一个 debug 断点，可以看到如下图显示的内容：我们的 Address 指向了 PersistentBag 代理实例类。</p>
<p><img src="http://image.leonote.cn/20210112103341.png" alt=""></p>
<p>同时再设置断点的话也可以看到，PersistentBag 被初始化的时候，会传进来 Session 的上下文，即包含 Datasource 和需要执行 Lazy 的 sql。</p>
<p>而需要执行 Lazy 的 sql，通过 debug 的栈信息可以看到其中有个 instantiate，关键断点信息如下图所示：</p>
<p><img src="http://image.leonote.cn/20210112103519.png" alt=""></p>
<p>再继续 debug 的话，也会看到调用 AbstractPersistentCollection 的初始化 Lazy 的方法，如下所示。</p>
<p><img src="http://image.leonote.cn/20210112103612.png" alt=""></p>
<p>通过源码分析和实例讲解，已经基本上知道了 Lazy 的原理，也就是需要 Lazy 的关联关系会初始化成 PersistentCollection，并且依赖持有的 Session。而当操作 List、Map 等集合类的一些基本方法的时候会触发 read()，并利用当前的 Session 进行懒加载。</p>
<h2 id="Lazy-异常的常见场景与解决方法"><a href="#Lazy-异常的常见场景与解决方法" class="headerlink" title="Lazy 异常的常见场景与解决方法"></a>Lazy 异常的常见场景与解决方法</h2><h3 id="场景一：跨事务，事务之外的场景"><a href="#场景一：跨事务，事务之外的场景" class="headerlink" title="场景一：跨事务，事务之外的场景"></a>场景一：跨事务，事务之外的场景</h3><p> 当 spring.jpa.open-in-view=false 的时候，每个事务就会独立持有 Session；那么在事务之外操作 lazy 的关联关系的时候，就容易发生 Lazy 异常。</p>
<p>正如上面列举的 Demo 一样，一开始就将 open-in-view 设置成了 false，而 userInfoRepository.findById(id) 又是一个独立事务，方法操作结束之后事务结束，事务结束之后 session close。所以再操作 UserInfo 中 Address 对象的时候，就发生了 Lazy 异常。</p>
<p>实际工作中这种情况比较多见，应该如何解决呢？</p>
<p><strong>第一种方式：简单粗暴地设置为 spring.jpa.open-in-view=true</strong></p>
<p>通过上面的分析，可以知道无非就是 Session 的关闭导致了 Lazy 异常，所以简单粗暴的办法就是加大 Session 的生命周期，将 Session 的生命周期和请求的生命周期设置成一样。但是 open-in-view 可能会带来的副作用必须要牢记于心，有以下几点。</p>
<ol>
<li><p>它对 Connection 的影响是什么？连接池有没有很好地监控？利用率是怎么样的？</p>
</li>
<li><p>实体的状态在整个 Session 的生命周期之间的变更都是有效的，数据的更新是不是预期的，你要心里有数。</p>
</li>
<li><p>N+1 的 SQL 是不是我们期望的？（这个下一讲我会详细介绍）性能有没有影响？等等。</p>
</li>
</ol>
<p><strong>第二种方式：也是简单粗暴改成 Eager 模式</strong></p>
<p>直接采用 Eager 的模式，这样也不会有 Lazy 异常的问题。如下述代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="comment">//直接采用eager模式</span></span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br></pre></td></tr></table></figure>

<p>但是这种做法不推荐使用，因为本来不想查 Address 信息，这样会白白地触发对 Address 的查询，导致性能有点浪费。</p>
<p><strong>第三种方式：将可能发生 Lazy 的操作和取数据放在同一个事务里面</strong></p>
<p>改造一下上面 Demo 的 Controller 的写法，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//controller 里面改调用 service 方法，这个 service 明确地返回了 UserInfo 和 Address 信息</span></span><br><span class="line">      UserInfo u1 =  userInfoService.getUserInfoAndAddress(id);</span><br><span class="line">      System.out.println(u1.getAddressList().get(<span class="number">0</span>).getCity());</span><br><span class="line">      <span class="keyword">return</span> u1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Service 的实现如下所示，在里面用事务包装，利用事务，让可能触发 Lazy 的操作提前在事务里面发生。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把逻辑封装在service方法里面，方法名字语义要清晰，就是说这个方法会取UserInfo的信息和Address的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoAndAddress</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">   UserInfo u1 =  userInfoRepository.findById(id).get();</span><br><span class="line">   u1.getAddressList().size();<span class="comment">//在同一个事务里面触发lazy；不需要查询address的地方就不需要触发了</span></span><br><span class="line">   <span class="keyword">return</span> u1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就要求对方法名的语义和注释比较清晰了，这个方法还有个缺点，就是 Service 返回的依然还是 UserInfo 的实体，如果在关联关系多的情况下，依然有犯错的可能性发生。</p>
<p><strong>第四种方式：Service 层之外都用 DTO 或者其他 POJO，而不是 Entity</strong></p>
<p>这种是最复杂的，但却是最有效的、不会出问题的方式，在 Service 层返回 DTO，改造一下 Service 方法，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfoDto <span class="title">getUserInfoAndAddress</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">   UserInfo u1 =  userInfoRepository.findById(id).get();</span><br><span class="line">   <span class="comment">//按照业务要求，需要什么返回什么就可以了，让实体在service层之外是不可见的</span></span><br><span class="line">   <span class="keyword">return</span> UserInfoDto.builder().name(u1.getName()).addressList(u1.getAddressList()).build();/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 UserInfoDto 也就是根据业务需要创建不同的 DTO 即可。例如，只需要 name 和 address 的时候，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 DTO 还可以采用任何语义的 POJO，<strong><em>宗旨就是 Entity 对 Service 层之外是不可见的</em></strong>。也可以采用 Projection 的方式，返回接口类型的 POJO，这样控制的粒度更细，读写都可以分开。将 Entity 控制在 Service 层还有个好处就是，有的时候会使用各种 RPC 框架进行远程方法调度，可以直接调用 Service 方法通过 TCP 协议，例如 Dubbo，这样也就天然支持了。</p>
<h3 id="场景二：异步线程的时候"><a href="#场景二：异步线程的时候" class="headerlink" title="场景二：异步线程的时候"></a>场景二：异步线程的时候</h3><p>既然跨事务容易发生问题，那么异步线程的时候更容易发生 Lazy 异常</p>
<p>异步线程的时候，再套用上面的四种方式，会发现第一种方式就不适用了，因为异步开启的事务和 DB 操作默认是不受 open-in-view 控制的。所以可以明确地知道，开启的异步方法会用到实体参数的哪些关联关系，是否需要按照上面的第三种和第四种方式进行提前处理呢？这些都是需要心中有数的，而不是简单地把异步开启就完事了。</p>
<h3 id="场景三：Controller-直接返回实体也会产生-Lazy-Exception"><a href="#场景三：Controller-直接返回实体也会产生-Lazy-Exception" class="headerlink" title="场景三：Controller 直接返回实体也会产生 Lazy Exception"></a>场景三：Controller 直接返回实体也会产生 Lazy Exception</h3><p>工作中经常为了省事，直接在 Contoller 里面返回 Entity，这个时候很容易发生 Lazy 异常，例如下面这个场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/info/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> userInfoRepository.findById(id).get();<span class="comment">//controller 层直接将 UserInfo 返回给 view 层了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接将 UserInfo 实体对象当成 VO 对象，且直接当成返回结果了，当请求上面的 API 的时候也会发生 Lazy 异常，看下代码。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">o.hibernate.LazyInitializationException  : failed to lazily initialize a collection of role: com.example.jpa.demo.db.UserInfo.addressList, could not initialize proxy - no Session</span><br><span class="line">   org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.example.jpa.demo.db.UserInfo.addressList, could not initialize proxy - no Session</span><br></pre></td></tr></table></figure>

<p>此 VO 发生的异常与其他 Lazy 异常不同的时候，仔细观察，会发现如下信息。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Resolved [<span class="type">org.springframework.http.converter.HttpMessageNotWritableException</span>: <span class="type">Could</span> <span class="type">not</span> <span class="type">write</span> <span class="type">JSON</span>:  <span class="type">failed</span> <span class="type">to</span> <span class="type">lazily</span> <span class="type">initialize</span> <span class="type">a</span> <span class="type">collection</span> <span class="type">of</span> <span class="type">role</span>: <span class="type">com.example.jpa.demo.db.UserInfo.addressList</span></span><br></pre></td></tr></table></figure>

<p>通过日志可以知道，此时发生 Lazy 异常的主要原因是 JSON 系列化的时候会触发 Lazy 加载。这个时候就有了<strong>第五种解决 Lazy 异常的方式，就是利用 @JsonIgnoreProperties(“addressList”) 排除我们不想序列化的属性即可。</strong></p>
<p>但是这种方式的弊端是用这个集合的只能全局配置，没办法有特例配置。因此最佳实践还是采用上面所说的第一种方式和第四种方式。</p>
<h3 id="场景四：自定义的拦截器和-filter-中无意的-toString-操作"><a href="#场景四：自定义的拦截器和-filter-中无意的-toString-操作" class="headerlink" title="场景四：自定义的拦截器和 filter 中无意的 toString 操作"></a>场景四：自定义的拦截器和 filter 中无意的 toString 操作</h3><p>第四个 Lazy 异常的场景就是打印一些日志，或者无意间触发 toString 的操作也会发生 Lazy 异常，这种处理方法也很简单（<strong>第六种处理 Lazy 异常的方式）：toString 里面排除掉不需要 Lazy 加载的关联关系即可。</strong>如果我们用 lombok 的话，直接 @ToString(exclude = “addressList”) 排除掉就好了，完整例子如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString(exclude = &quot;addressList&quot;)</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&quot;addressList&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">......&#125;</span><br></pre></td></tr></table></figure>

<p>以上介绍的四个 Lazy 异常的场景和六种处理方式，在实际工作中可以灵活运用，其中最主要的是要知道背后的原理和触发 Lazy 产生的性能影响是什么（意外的 SQL 执行）。</p>
<p>Hibernate 官方还提供了<strong>第七种处理 Lazy 异常的方式：利用 Hibernate 的配置</strong></p>
<p><strong>hibernate.enable_lazy_load_no_trans 配置</strong></p>
<p>Hibernate 官方提供了 hibernate.enable_lazy_load_no_trans 配置，是否允许在关闭之后依然支持 Lazy 加载，此非 JPA 标准，所以在用的时候需要关注版本变化。</p>
<p>其使用方法很简单，直接在 application.properties 里面增加如下配置即可，请看下面的代码：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 运行在session关闭之后，重新lazy操作</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.enable_lazy_load_no_trans</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>此时不需要做任何其他修改，当在事务之外，甚至是 Session 之外，触发 Lazy 操作的时候也不会报错，也会正常地进行取数据。</p>
<p>但是建议不要用这个方法，因为一旦开启了这个对 Lazy 的操作就不可控了，会发生预期之外的 Lazy 异常，然后只能通过上面所说的处理 Lazy 异常的第三种和第四种方式解决成预期之内的，否则的话，还会带来很多预期之外的 SQL 执行。这就会造成一种误解，即使用 Hibernate 或者 JPA 会导致性能变差，其实本质原因是不了解原理，没能正确使用。</p>
<p>所以到目前为止，Spring Data JPA 中，hibernate.enable_lazy_load_no_trans 默认是 false，这和 spring.jpa.open-in-view 默认是 true 是相同的道理。所以如果都采用 Spring Boot 的默认配置，一般是没有任何问题的；而有的时候为了更优的配置，需要知道底层的原理，这样才能判断出来业务场景的最佳实践是什么。</p>
<h2 id="Javax-persistence-PersistenceException-异常类型"><a href="#Javax-persistence-PersistenceException-异常类型" class="headerlink" title="Javax.persistence.PersistenceException 异常类型"></a>Javax.persistence.PersistenceException 异常类型</h2><p>顺藤摸瓜，可以看到 LazyInitializationException 是 HibernateException 里面的，也可以看到 HibernateException 的父类 Javax.persistence.PersistenceException 下面有很多细分的异常，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210112110903.png" alt=""></p>
<p>当我们遇到异常的时候不要慌张，仔细看日志基本就能知道是什么问题了，不同的异常有不同的处理方式，比如 OptimisticLockException 就需要进行重试；而针对 NoSuchBeanException 的异常，就要检查实体配置是否妥当，遇到实际情况再实际分析即可。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa Persistence Context 所表达的核心概念</title>
    <url>/2020/11/05/SpringDataJpa%E7%9A%84PersistenceContext%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="Persistence-Context-所表达的核心概念"><a href="#Persistence-Context-所表达的核心概念" class="headerlink" title="Persistence Context 所表达的核心概念"></a>Persistence Context 所表达的核心概念</h1><h2 id="EntityManagerFactory-和-Persistence-Unit-是什么"><a href="#EntityManagerFactory-和-Persistence-Unit-是什么" class="headerlink" title="EntityManagerFactory 和 Persistence Unit 是什么"></a>EntityManagerFactory 和 Persistence Unit 是什么</h2><p>按照 JPA 协议里面的定义：persistence unit <strong><em>是一些持久化配置的集合，里面包含了数据源的配置、EntityManagerFactory 的配置</em></strong>，Spring 3.1 之前主要是通过 persistence.xml 的方式来配置一个 persistence unit，而 Spring 3.1 之后已经不再推荐这种方式了，但是还保留了 persistence unit 的概念，只需要在配置 <code>LocalContainerEntityManagerFactory</code> 的时候，指定 persistence unit 的名字即可，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(name = &quot;db2EntityManagerFactory&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">(EntityManagerFactoryBuilder builder, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                                   <span class="meta">@Qualifier(&quot;db2DataSource&quot;)</span> DataSource db2DataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.dataSource(db2DataSource)</span><br><span class="line">            .packages(<span class="string">&quot;com.example.jpa.example1.db2&quot;</span>) <span class="comment">//数据2的实体所在的路径</span></span><br><span class="line">            .persistenceUnit(<span class="string">&quot;db2&quot;</span>)<span class="comment">// persistenceUnit的名字采用db2</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EntityManagerFactory 的用途就比较明显了，即根据不同的数据源，来管理 Entity 和创建 EntityManger，在整个 application 的生命周期中是单例状态。所以在 spring 的 application 里面获得 EntityManagerFactory 有两种方式。</p>
<p><strong>第一种：通过 Spring 的 Bean 的方式注入。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;db2EntityManagerFactory&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> EntityManagerFactory entityManagerFactory;</span><br></pre></td></tr></table></figure>

<p>这种方式是比较推荐的，它利用了 Spring 自身的 Bean 的管理机制。</p>
<p><strong>第二种：利用 java.persistence.PersistenceUnit 注解的方式获取。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceUnit(&quot;db2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> EntityManagerFactory entityManagerFactory;</span><br></pre></td></tr></table></figure>

<h2 id="EntityManager-和-PersistenceContext-是什么"><a href="#EntityManager-和-PersistenceContext-是什么" class="headerlink" title="EntityManager 和 PersistenceContext 是什么"></a>EntityManager 和 PersistenceContext 是什么</h2><p>按照 JPA 协议的规范，PersistenceContext 是用来管理会话里面的 Entity 状态的一个上下文环境，使 Entity 的实例有了不同的状态，也就是常说的实体实例的生命周期。</p>
<p>而这些实体在 PersistenceContext 中的不同状态都是通过 EntityManager 提供的一些方法进行管理的，也就是说：</p>
<ol>
<li><p>PersistenceContext 是持久化上下文，是 JPA 协议定义的，而 Hibernate 的实现是通过 Session 创建和销毁的，也就是说<strong>一个 Session 有且仅有一个 PersistenceContext</strong>；</p>
</li>
<li><p>PersistenceContext 是持久化上下文，里面管理的是 Entity 的状态；</p>
</li>
<li><p><strong>EntityManager 是通过 PersistenceContext 创建的</strong>，用来管理 PersistenceContext 中 Entity 状态的方法，离开 PersistenceContext 持久化上下文，EntityManager 没有意义；</p>
</li>
<li><p><strong>EntityManger 是操作对象的唯一入口，一个请求里面可能会有多个 EntityManger 对象</strong>。</p>
</li>
</ol>
<p>看一下 PersistenceContext 是怎么创建的。直接打开 SessionImpl 的构造方法，就可以知道 PersistenceContext 是和 Session 的生命周期绑定的，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//session实例初始化的入口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SessionImpl</span><span class="params">(SessionFactoryImpl factory, SessionCreationOptions options)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>( factory, options );</span><br><span class="line">   <span class="comment">//Session里面创建了persistenceContext，每次session都是新对象</span></span><br><span class="line">   <span class="keyword">this</span>.persistenceContext = createPersistenceContext();</span><br><span class="line"><span class="comment">// ......省略一些不重要的代码   </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> StatefulPersistenceContext <span class="title">createPersistenceContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> StatefulPersistenceContext( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StatefulPersistenceContext就是PersistenceContext的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulPersistenceContext</span> <span class="keyword">implements</span> <span class="title">PersistenceContext</span> </span>&#123;</span><br><span class="line"><span class="comment">//    ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> EntityManger 需要通过 @PersistenceContext 的方式进行获取，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line"><span class="keyword">private</span> EntityManager em;</span><br></pre></td></tr></table></figure>

<p>而其中 @PersistenceContext 的属性配置有如下这些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PersistenceContext &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//PersistenceContextUnit的名字，多数据源的时候有用</span></span><br><span class="line">    <span class="function">String <span class="title">unitName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//是指创建的EntityManager的生命周期是存在事务内还是可以跨事务，默认为生命周期和事务一样；</span></span><br><span class="line">    <span class="function">PersistenceContextType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> PersistenceContextType.TRANSACTION</span>;</span><br><span class="line">    <span class="comment">//同步的类型：只有SYNCHRONIZED和 UNSYNCHRONIZED 两个值用来表示，但开启事务的时候是否自动加入已开启的事务里面，默认SYNCHRONIZED表示自动加入，不创建新的事务。而UNSYNCHRONIZED表示，不自动加入上下文已经有的事务，自动开启新的事务；这里你使用的时候需要注意看一下事务的日志；</span></span><br><span class="line">    <span class="function">SynchronizationType <span class="title">synchronization</span><span class="params">()</span> <span class="keyword">default</span> SynchronizationType.SYNCHRONIZED</span>;</span><br><span class="line">    <span class="comment">//持久化的配置属性，这里指hibernate中AvailableSettings里面的值</span></span><br><span class="line">    PersistenceProperty[] properties() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般情况下保持默认即可，你也可以根据实际情况自由组合，举个复杂点的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext(</span></span><br><span class="line"><span class="meta">      unitName = &quot;db2&quot;,//采用数据源2的</span></span><br><span class="line"><span class="meta">      //可以跨事务的EntityManager</span></span><br><span class="line"><span class="meta">      type = PersistenceContextType.EXTENDED,</span></span><br><span class="line"><span class="meta">      properties = &#123;</span></span><br><span class="line"><span class="meta">            //通过properties改变一下自动flush的机制</span></span><br><span class="line"><span class="meta">            @PersistenceProperty(</span></span><br><span class="line"><span class="meta">                  name=&quot;org.hibernate.flushMode&quot;,</span></span><br><span class="line"><span class="meta">                  value= &quot;MANUAL&quot;//改成手动刷新方式</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">      &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">private</span> EntityManager entityManager;</span><br></pre></td></tr></table></figure>

<h2 id="实体对象的生命周期"><a href="#实体对象的生命周期" class="headerlink" title="实体对象的生命周期"></a>实体对象的生命周期</h2><p>既然 PersistenceContext 是存储 Entity 的，那么 Entity 在 PersistenceContext 里面肯定有不同的状态。对此，JPA 协议定义了四种状态：new、manager、detached、removed。如下图所示：</p>
<p><img src="http://image.leonote.cn/20201207132405.png" alt=""></p>
<h3 id="第一种：New-状态的对象"><a href="#第一种：New-状态的对象" class="headerlink" title="第一种：New 状态的对象"></a>第一种：New 状态的对象</h3><p>当使用关键字 new 的时候创建的实体对象，称为 new 状态的 Entity 对象。它需要同时满足两个条件：</p>
<ul>
<li>new 状态的实体 Id 和 Version 字段都是 null；</li>
<li>new 状态的实体没有在 PersistenceContext 中出现过。</li>
</ul>
<p>那么如果要把 new 状态的 Entity 放到 PersistenceContext 里面，有两种方法：</p>
<ol>
<li>执行 <code>entityManager.persist(entity)</code> 方法；</li>
<li>通过关联关系的实体关系配置 cascade=PERSIST or cascade=ALL 这种类型，并且关联关系的一方，也执行了 entityManager.persist(entity) 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo userInfo = UserInfo.builder().lastName(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">    <span class="comment">//通过 contains 方法可以验证对象是否在 PersistenceContext 里面，此时不在</span></span><br><span class="line">    Assertions.assertFalse(entityManager.contains(userInfo));</span><br><span class="line">    <span class="comment">//通过 persist 方法把对象放到 PersistenceContext 里面</span></span><br><span class="line">    entityManager.persist(userInfo);</span><br><span class="line">    <span class="comment">//通过 contains 方法可以验证对象是否在 PersistenceContext 里面，此时在</span></span><br><span class="line">    Assertions.assertTrue(entityManager.contains(userInfo));</span><br><span class="line">    Assertions.assertNotNull(userInfo.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二种：Detached（游离）的实体对象"><a href="#第二种：Detached（游离）的实体对象" class="headerlink" title="第二种：Detached（游离）的实体对象"></a>第二种：Detached（游离）的实体对象</h3><p>Detached 状态的对象表示和 PersistenceContext 脱离关系的 Entity 对象。它和 new 状态的对象的不同点在于：</p>
<ul>
<li><p>Detached 有持久化的 ID</p>
</li>
<li><p>变成持久化对象需要进行 merger 操作，merger 操作会 copy 一个新的实体对象，然后把新的实体对象变成 Manager 状态</p>
</li>
</ul>
<p>而 Detached 和 new 状态的对象相同点也有两个方面：</p>
<ul>
<li><p>都和 PersistenceContext 脱离了关系；</p>
</li>
<li><p>当执行 flush 操作或者 commit 操作的时候，不会进行数据库同步。</p>
</li>
</ul>
<p>如果想让 Manager(persist) 状态的对象从 PersistenceContext 里面游离出来变成 Detached 的状态，可以通过 EntityManager 的 Detach 方法实现：<code>entityManager.detach(entity);</code></p>
<p>当执行完 <code>entityManager.clear()</code>、<code>entityManager.close()</code>，或者事务 <code>commit()</code>、事务 <code>rollback()</code> 之后，所有曾经在 PersistenceContext 里面的实体都会变成 Detached 状态。</p>
<p>而游离状态的对象想回到 PersistenceContext 里面变成 manager 状态的话，只能执行 entityManager 的 merge 方法：<code>entityManager.merge(entity);</code></p>
<p>游离状态的实体执行 EntityManager 中 persist 方法的时候就会报异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMergeException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过new的方式构建一个游离状态的对象</span></span><br><span class="line">    UserInfo userInfo = UserInfo.builder().id(<span class="number">1L</span>).lastName(<span class="string">&quot;jack&quot;</span>).version(<span class="number">1</span>).build();</span><br><span class="line">    <span class="comment">//验证是否存在于persistence context 里面，new的肯定不存在</span></span><br><span class="line">    Assertions.assertFalse(entityManager.contains(userInfo));</span><br><span class="line">    <span class="comment">//当执行persist方法的时候就会报异常</span></span><br><span class="line">    Assertions.assertThrows(PersistentObjectException.class,()-&gt;entityManager.persist(userInfo));</span><br><span class="line">    <span class="comment">//detached状态的实体通过merge的方式保存在了persistence context里面</span></span><br><span class="line">   UserInfo user2 = entityManager.merge(userInfo);</span><br><span class="line">    <span class="comment">//验证一下存在于持久化上下文里面</span></span><br><span class="line">    Assertions.assertTrue(entityManager.contains(user2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三种：Manager（persist）-状态的实体"><a href="#第三种：Manager（persist）-状态的实体" class="headerlink" title="第三种：Manager（persist） 状态的实体"></a>第三种：Manager（persist） 状态的实体</h3><p>Manager 状态的实体，是指在 PersistenceContext 里面管理的实体，而此种状态的实体当我们执行事务的 commit()，或者 entityManager 的 flush 方法的时候，就会进行数据库的同步操作。可以说是和数据库的数据有映射关系。</p>
<p>New 状态如果要变成 Manager 的状态，需要执行 persist 方法；而 Detached 状态的实体如果想变成 Manager 的状态，则需要执行 merge 方法。在 session 的生命周期中，任何从数据库里面查询到的 Entity 都会自动成为 Manager 的状态，如 entityManager.findById(id)、entityManager.getReference 等方法。</p>
<p>而 Manager 状态的 Entity 要同步到数据库里面，必须执行 EntityManager 里面的 flush 方法。也就是说我们对 Entity 对象做的任何增删改查，必须通过 entityManager.flush() 执行之后才会变成 SQL 同步到 DB 里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Rollback(value = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testManagerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo userInfo = UserInfo.builder().lastName(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">    entityManager.persist(userInfo);</span><br><span class="line">    System.out.println(<span class="string">&quot;没有执行 flush()方法，没有产生insert sql&quot;</span>);</span><br><span class="line">    entityManager.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了flush()方法，产生了insert sql&quot;</span>);</span><br><span class="line">    Assertions.assertTrue(entityManager.contains(userInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">没有执行 flush()方法，没有产生insert sql</span><br><span class="line">Hibernate: insert into user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">执行了flush()方法，产生了insert sql</span><br></pre></td></tr></table></figure>

<h3 id="第四种：Removed-的实体状态"><a href="#第四种：Removed-的实体状态" class="headerlink" title="第四种：Removed 的实体状态"></a>第四种：Removed 的实体状态</h3><p>Removed 的状态，是指删除了的实体，但是此实体还在 PersistenceContext 里面，只是在其中表示为 Removed 的状态，它和 Detached 状态的实体最主要的区别就是在不在 PersistenceContext 里面，但都有 ID 属性。</p>
<p>而 Removed 状态的实体，当我们执行 entityManager.flush() 方法的时候，就会生成一条 delete 语句到数据库里面。Removed 状态的实体，在执行 flush() 方法之前，执行 entityManger.persist(removedEntity) 方法时候，就会去掉删除的表示，变成 Managed 的状态实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo userInfo = UserInfo.builder().lastName(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">    entityManager.persist(userInfo);</span><br><span class="line">    entityManager.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了flush()方法，产生了insert sql&quot;</span>);           </span><br><span class="line">    entityManager.remove(userInfo);</span><br><span class="line">    entityManager.flush();</span><br><span class="line">    System.out.println(<span class="string">&quot;执行了flush()方法之后，又产生了delete sql&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Hibernate: insert into user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">执行了flush()方法，产生了insert sql</span><br><span class="line">Hibernate: delete from user_info <span class="built_in">where</span> id=? and version=?</span><br><span class="line">执行了flush()方法之后，又产生了delete sql</span><br></pre></td></tr></table></figure>

<p>MyBatis 是对数据库的操作所见即所得的模式；而使用 JPA，你的任何操作都不会产生 DB 的sql</p>
<h2 id="EntityManager-的-flush-方法"><a href="#EntityManager-的-flush-方法" class="headerlink" title="EntityManager 的 flush() 方法"></a>EntityManager 的 flush() 方法</h2><p>flush 方法的用法很简单，就是在需要 DB 同步 sql 执行的时候，执行 entityManager.flush() 即可</p>
<h3 id="Flush-的作用"><a href="#Flush-的作用" class="headerlink" title="Flush 的作用"></a>Flush 的作用</h3><p>flush 重要的、唯一的作用，就是将 Persistence Context 中变化的实体转化成 sql 语句，同步执行到数据库里面。换句话来说，如果我们不执行 flush() 方法的话，通过 EntityManager 操作的任何 Entity 过程都不会同步到数据库里面。</p>
<p>而 flush() 方法很多时候不需要我们手动操作，这里我直接通过 entityManager 操作 flush() 方法，仅仅是为了演示执行过程。实际工作中很少会这样操作，而是会直接利用 JPA 和 Hibernate 底层框架帮我们实现的自动 flush 的机制。</p>
<h3 id="Flush-的机制"><a href="#Flush-的机制" class="headerlink" title="Flush 的机制"></a>Flush 的机制</h3><p>JPA 协议规定了 EntityManager 可以通过如下方法修改 FlushMode。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//entity manager 里面提供的修改FlushMode的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlushMode</span><span class="params">(FlushModeType flushMode)</span></span>;</span><br><span class="line"><span class="comment">//FlushModeType只有两个值，自动和事务提交之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FlushModeType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事务commit之前</span></span><br><span class="line">   COMMIT,</span><br><span class="line">    <span class="comment">//自动规则，默认</span></span><br><span class="line">   AUTO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Hibernate 还提供了一种手动触发的机制，可以通过如下代码的方式进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext(properties = &#123;@PersistenceProperty(</span></span><br><span class="line"><span class="meta">        name = &quot;org.hibernate.flushMode&quot;,</span></span><br><span class="line"><span class="meta">        value = &quot;MANUAL&quot;//手动flush</span></span><br><span class="line"><span class="meta">)&#125;)</span></span><br><span class="line"><span class="keyword">private</span> EntityManager entityManager;</span><br></pre></td></tr></table></figure>

<p>手动和 commit 的时候很好理解，就是手动执行 flush 方法；事务就是代码在执行事务 commit 的时候，必须要执行 flush() 方法</p>
<h3 id="Flush-的自动机制"><a href="#Flush-的自动机制" class="headerlink" title="Flush 的自动机制"></a>Flush 的自动机制</h3><p>默认情况下，JPA 和 Hibernate 都是采用的 AUTO 的 Flush 机制，自动触发的规则如下：</p>
<ol>
<li><p>事务 commit 之前，即指执行 <code>transactionManager.commit()</code> 之前都会触发，这个很好理解；</p>
</li>
<li><p>执行任何的 JPQL 或者 native SQL（代替直接操作 Entity 的方法）都会触发 flush。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = UserInfo.builder().lastName(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">        <span class="comment">//通过contains方法可以验证对象是否在PersistenceContext里面，此时不在</span></span><br><span class="line">        Assertions.assertFalse(entityManager.contains(userInfo));</span><br><span class="line">        <span class="comment">//通过persist方法把对象放到PersistenceContext里面</span></span><br><span class="line">        entityManager.persist(userInfo);<span class="comment">//是直接操作Entity的，不会触发flush操作</span></span><br><span class="line">        <span class="comment">//entityManager.remove(userInfo);//是直接操作Entity的，不会触发flush操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;没有执行 flush()方法，没有产生insert sql&quot;</span>);</span><br><span class="line">        UserInfo userInfo2 = entityManager.find(UserInfo.class,<span class="number">2L</span>);<span class="comment">//是直接操作Entity的，这个就不会触发flush操作</span></span><br><span class="line"><span class="comment">//        userInfoRepository.queryByFlushTest();//是操作JPQL的，这个就会先触发flush操作；</span></span><br><span class="line">        System.out.println(<span class="string">&quot;flush()方法，产生insert sql&quot;</span>);</span><br><span class="line">        <span class="comment">//通过contains方法可以验证对象是否在 PersistenceContext 里面，此时在</span></span><br><span class="line">        Assertions.assertTrue(entityManager.contains(userInfo));</span><br><span class="line">        Assertions.assertNotNull(userInfo.getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而只有执行类似 .queryByFlushTest() 这个方法的时候，才会触发 flush，因为它是用的 JPQL 的机制执行的。</p>
<p>上面的方法触发了 flush 的日志，会输出如下格式，你可以看到这里多了一个 insert 语句。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">没有执行 flush()方法，没有产生insert sql</span><br><span class="line">Hibernate: insert into user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br><span class="line">Hibernate: <span class="built_in">select</span> userinfo0_.id as id1_0_, userinfo0_.create_time as create_t2_0_, userinfo0_.create_user_id as create_u3_0_, userinfo0_.last_modified_time as last_mod4_0_, userinfo0_.last_modified_user_id as last_mod5_0_, userinfo0_.version as version6_0_, userinfo0_.ages as ages7_0_, userinfo0_.email_address as email_ad8_0_, userinfo0_.last_name as last_nam9_0_, userinfo0_.telephone as telepho10_0_ from user_info userinfo0_ <span class="built_in">where</span> userinfo0_.id=<span class="number">2</span></span><br><span class="line">flush()方法，产生insert sql</span><br></pre></td></tr></table></figure>

<p>没有触发 flush 的日志输出的是如下格式，其中没有 insert 语句。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">没有执行 flush()方法，没有产生insert sql</span><br><span class="line">Hibernate: <span class="built_in">select</span> userinfo0_.id as id1_0_0_, userinfo0_.create_time as create_t2_0_0_, userinfo0_.create_user_id as create_u3_0_0_, userinfo0_.last_modified_time as last_mod4_0_0_, userinfo0_.last_modified_user_id as last_mod5_0_0_, userinfo0_.version as version6_0_0_, userinfo0_.ages as ages7_0_0_, userinfo0_.email_address as email_ad8_0_0_, userinfo0_.last_name as last_nam9_0_0_, userinfo0_.telephone as telepho10_0_0_ from user_info userinfo0_ <span class="built_in">where</span> userinfo0_.id=?</span><br><span class="line">flush()方法，产生insert sql</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Flush-会改变-SQL-的执行顺序"><a href="#Flush-会改变-SQL-的执行顺序" class="headerlink" title="Flush 会改变 SQL 的执行顺序"></a>Flush 会改变 SQL 的执行顺序</h3><p>flush() 方法调用之后，同一个事务内，sql 的执行顺序会变成如下模式：</p>
<ul>
<li>insert 的先执行</li>
<li>delete 的第二个执行</li>
<li>update 的第三个执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">entityManager.remove(u3);</span><br><span class="line">UserInfo userInfo = UserInfo.builder().lastName(<span class="string">&quot;jack&quot;</span>).build();</span><br><span class="line">entityManager.persist(userInfo);</span><br></pre></td></tr></table></figure>

<p>看一下执行的 sql 会变成如下模样，即先 insert 后 delete。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Hibernate: insert into user_info 。。。。。。</span><br><span class="line">Hibernate: delete from user_info <span class="built_in">where</span> id=? and version=?</span><br></pre></td></tr></table></figure>

<p>这种会改变顺序的现象，主要是由 persistence context 的实体状态机制导致的，所以在 Hibernate 的环境中，顺序会变成如下的 ActionQueue 的模式：</p>
<ul>
<li><p>OrphanRemovalAction</p>
</li>
<li><p>EntityInsertAction</p>
</li>
<li><p>EntityIdentityInsertAction</p>
</li>
<li><p>EntityUpdateAction</p>
</li>
<li><p>CollectionRemoveAction</p>
</li>
<li><p>CollectionUpdateAction</p>
</li>
<li><p>CollectionRecreateAction</p>
</li>
<li><p>EntityDeleteAction</p>
</li>
</ul>
<h3 id="Flush-与事务-Commit-的关系"><a href="#Flush-与事务-Commit-的关系" class="headerlink" title="Flush 与事务 Commit 的关系"></a>Flush 与事务 Commit 的关系</h3><p>大概有以下几点：</p>
<ol>
<li><p>在当前的事务执行 commit 的时候，会触发 flush 方法；</p>
</li>
<li><p>在当前的事务执行完 commit 的时候，如果隔离级别是可重复读的话，flush 之后执行的 update、insert、delete 的操作，会被其他的新事务看到最新结果；</p>
</li>
<li><p>假设当前的事务是可重复读的，当我们手动执行 flush 方法之后，没有执行事务 commit 方法，那么其他事务是看不到最新值变化的，但是最新值变化对当前没有 commit 的事务是有效的；</p>
</li>
<li><p>如果执行了 flush 之后，当前事务发生了 rollback 操作，那么数据将会被回滚（数据库的机制）。</p>
</li>
</ol>
<h3 id="saveAndFlush-和-save-的区别"><a href="#saveAndFlush-和-save-的区别" class="headerlink" title="saveAndFlush 和 save 的区别"></a>saveAndFlush 和 save 的区别</h3><p>**Repository 里面有一个 saveAndFlush(entity); 的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">saveAndFlush</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//执行了save方法之后，调用了flush()方法</span></span><br><span class="line">   S result = save(entity);</span><br><span class="line">   flush();</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而另一个 **Repository 里面的 save 的方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有做 flush 操作，只是，执行了 persist 或者 merge 的操作</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (entityInformation.isNew(entity)) &#123;</span><br><span class="line">      em.persist(entity);</span><br><span class="line">      <span class="keyword">return</span> entity;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> em.merge(entity);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区别有如下几点：</p>
<ol>
<li><p>saveAndFlush 执行完save，再执行 flush，会<strong>刷新整个 PersistenceContext 里面的实体</strong>并进入到数据库里面，那么<strong>当我们频繁调用 saveAndFlush 就失去了 cache 的意义</strong>，这个时候就和执行 mybatis 的 saveOrUpdate 是一样的效果；</p>
</li>
<li><p>当多次调用相同的 save 方法的时候，最终 flush 执行只会产生一条 sql，在性能上会比 saveAndFlush 高一点；</p>
</li>
<li><p>不管是 saveAndFlush 还是 save，都受当前事务控制，事务在没有 commit 之前，都只会影响当前事务的操作；</p>
</li>
</ol>
<p>综上，两种本质的区别就是 flush 执行的时机不一样而已，对数据库中数据的事务一致性没有任何影响。然而有的时候，即使我们调用了 flush 的方法也是一条 sql 都没有，为什么呢？再来了解一个概念：Dirty。</p>
<h2 id="Entity-的-Dirty-判断逻辑及其作用"><a href="#Entity-的-Dirty-判断逻辑及其作用" class="headerlink" title="Entity 的 Dirty 判断逻辑及其作用"></a>Entity 的 Dirty 判断逻辑及其作用</h2><p>在 PersistenceContext 里面还有一个重要概念，就是<strong>当实体不是 Dirty 状态，也就是没有任何变化的时候，是不会进行任何 db 操作的</strong>。所以即使我们执行 flush 和 commit，实体没有变化，就没有必要执行，这也能大大减少数据库的压力。Dirty 的效果的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们假设数据库里面存在一条id=1的数据，我们不做任何改变执行save或者saveAndFlush，除了select之外，不会产生任何sql语句；</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback(value = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo userInfo = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">    userInfoRepository.saveAndFlush(userInfo);</span><br><span class="line">    userInfoRepository.save(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当我们尝试改变一下 userInfo 里面的值，当执行如下方法的时候就会产生 update 的 sql。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback(value = false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserInfo userInfo = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">    userInfo.setLastName(<span class="string">&quot;jack_test_dirty&quot;</span>);</span><br><span class="line">    userInfoRepository.saveAndFlush(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entity-判断-Dirty-的过程"><a href="#Entity-判断-Dirty-的过程" class="headerlink" title="Entity 判断 Dirty 的过程"></a>Entity 判断 Dirty 的过程</h3><p><code>DefaultFlushEntityEventListener</code> 的源码里面 isUpdateNecessary 的关键方法如下所示：</p>
<p><img src="http://image.leonote.cn/20201207145648.png" alt=""></p>
<p>看 dirtyCheck 的实现，可以看发现如下关键点，从而找出发生变化的 properties。</p>
<p><img src="http://image.leonote.cn/20201207145808.png" alt=""></p>
<p>再仔细看 <code>persister.findDirty（values, loadedState, entity, session）</code>，可以看出来源码里面是通过一个字段一个字段比较的，所以可以知道 PersistenceContext 中的前后两个 Entity 的哪些字段发生了变化。因此当我们执行完 save 之后，没有产生任何 sql（因为没有变化）。</p>
<blockquote>
<p>总结：在 flush 的时候，Hibernate 会一个个判断实体的前后对象中哪个属性发生变化了，如果没有发生变化，则不产生 update 的 sql 语句；只有变化才会才生 update sql，并且可以做到同一个事务里面的多次 update 合并，从而在一定程度上可以减轻 DB 的压力。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 对 WebMVC 的支持</title>
    <url>/2020/11/11/SpringDataJpa%E5%AF%B9WebMVC%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-对-WebMVC-的支持"><a href="#Spring-Data-Jpa-对-WebMVC-的支持" class="headerlink" title="Spring Data Jpa 对 WebMVC 的支持"></a>Spring Data Jpa 对 WebMVC 的支持</h1><p>Spring Data 对 Spring MVC 做了很好的支持，体现在以下几个方面：</p>
<ul>
<li><p>支持在 Controller 层直接返回实体，而不使用其显式的调用方法；</p>
</li>
<li><p>对 MVC 层支持标准的分页和排序功能；</p>
</li>
<li><p>扩展的插件支持 Querydsl，可以帮忙进行一些通用的查询逻辑。</p>
</li>
</ul>
<p>正常情况下，我们开启 Spring Data 对 Spring Web MVC 支持需要在 <code>@Configuration</code> 的配置文件里面添加 <code>@EnableSpringDataWebSupport</code> 这一注解，如下面这种形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="comment">//开启支持Spring Data Web的支持</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们用了 Spring Boot，其有自动加载机制，会自动加载 <code>SpringDataWebAutoConfiguration</code> 类，发生如下变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; PageableHandlerMethodArgumentResolver.class, WebMvcConfigurer.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(PageableHandlerMethodArgumentResolver.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(SpringDataWebProperties.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(RepositoryRestMvcAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataWebAutoConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>从类上面可以看出来，<code>@EnableSpringDataWebSupport</code> <strong>会自动开启</strong>，所以当我们用 Spring Boot + JPA + MVC 的时候，什么都不需要做，因为 Spring Boot 利用 Spring Data 对 Spring MVC 做了很多 Web 开发的天然支持。支持的组件有 DomainConverter、Page、Sort、DataBinding、Dynamic Param 等。</p>
<h2 id="DomainClassConverter-组件"><a href="#DomainClassConverter-组件" class="headerlink" title="DomainClassConverter 组件"></a>DomainClassConverter 组件</h2><p>这个组件的主要作用是帮我们把 Path 中 ID 的变量，或 Request 参数中的变量 ID 的参数值，直接转化成实体对象注册到 Controller 方法的参数里面。怎么理解呢？我们看个例子，就很好懂了。</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>首先，写一个 MVC 的 Controller，分别从 Path 和 Param 变量里面，根据 ID 转化成实体，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从path变量里面获得参数ID的值，然后直接转化成UserInfo实体</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userInfo</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将request的param中的ID变量值，转化成UserInfo实体</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> userInfo</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> userInfo;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后，我们运行起来，看一下结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/user/1</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;version&quot;: 0,</span><br><span class="line">  &quot;ages&quot;: 10,</span><br><span class="line">  &quot;telephone&quot;: &quot;123456789&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果来看，Controller 里面的 getUserInfoFromRequestParam 方法会自动根据 ID 查询实体对象 UserInfo，然后注入方法的参数里面。那它是怎么实现的呢？</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><code>DomainClassConverter</code> 类里面有个 <code>ToEntityConverter</code> 的内部转化类的 Matches 方法，它会判断参数的类型是不是实体，并且有没有对应的实体 Repository 存在。如果不存在，就会直接报错说找不到合适的参数转化器。</p>
<p><code>DomainClassConverter</code> 里面的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainClassConverter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">ConversionService</span> &amp; <span class="title">ConverterRegistry</span>&gt;</span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断参数的类型是不是实体</span></span><br><span class="line">      <span class="keyword">if</span> (sourceType.isAssignableTo(targetType)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; domainType = targetType.getType();</span><br><span class="line">      <span class="comment">//有没有对应的实体的 Repository 存在</span></span><br><span class="line">      <span class="keyword">if</span> (!repositories.hasRepositoryFor(domainType)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Optional&lt;RepositoryInformation&gt; repositoryInformation = repositories.getRepositoryInformationFor(domainType);</span><br><span class="line">      <span class="keyword">return</span> repositoryInformation.map(it -&gt; &#123;</span><br><span class="line">         Class&lt;?&gt; rawIdType = it.getIdType();</span><br><span class="line">         <span class="keyword">return</span> sourceType.equals(TypeDescriptor.valueOf(rawIdType))</span><br><span class="line">               || conversionService.canConvert(sourceType.getType(), rawIdType);</span><br><span class="line">      &#125;).orElseThrow(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">&quot;Couldn&#x27;t find RepositoryInformation for %s!&quot;</span>, domainType)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们上面的例子其实是需要有 UserInfoRepository 的，否则会失败。</p>
<p>通过源码我们也可以看到，如果 matches=true，那么就会执行下面的 convert 方法，最终调用 <code>findById</code> 的方法帮我们执行查询动作，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201112134125.png" alt=""></p>
<p>而 <code>DomainClassConverter</code> 是 Spring MVC 自定义 Formatter 的一种机制，加载进去，可以看到如下界面：</p>
<p><img src="http://image.leonote.cn/20201112134341.png" alt=""></p>
<p>而 <code>SpringDataWebConfiguration</code> 是因为实现了 WebMvcConfigurer 的 addFormatters 所有加载了自定义参数转化器的功能，所以才有了 <code>DomainClassConverter</code> 组件的支持。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataWebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上我们也可以看到，<code>DomainClassConverter</code> 只会根据 ID 来查询实体，很有局限性，没有更加灵活的参数转化功能，不过你也可以<strong><em>根据源码自己进行扩展</em></strong>。</p>
<h2 id="Page-和-Sort-的参数支持"><a href="#Page-和-Sort-的参数支持" class="headerlink" title="Page 和 Sort 的参数支持"></a>Page 和 Sort 的参数支持</h2><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>首先，新建一个 UserInfoController，里面添加如下两个方法，分别测试分页和排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;UserInfo&gt; <span class="title">queryByPage</span><span class="params">(Pageable pageable, UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.findAll(Example.of(userInfo),pageable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/users/sort&quot;)</span></span><br><span class="line"><span class="keyword">public</span> HttpEntity&lt;List&lt;UserInfo&gt;&gt; queryBySort(Sort sort) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HttpEntity&lt;&gt;(userInfoRepository.findAll(sort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，queryByPage 方法中，两个参数可以分别接收分页参数和查询条件，我们请求一下，看看效果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users?size=2&amp;page=0&amp;ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<p>参数里面可以支持分页大小为 2、页码 0、排序（按照 ID 倒序）</p>
<p>ages=10 所有结果，如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;ages&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">&quot;telephone&quot;</span>: <span class="string">&quot;123456789&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;version&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;ages&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">&quot;telephone&quot;</span>: <span class="string">&quot;123456789&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;pageable&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sort&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;sorted&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;unsorted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;empty&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;offset&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;pageNumber&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;pageSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;unpaged&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;paged&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;totalPages&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;totalElements&quot;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">&quot;last&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;number&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;numberOfElements&quot;</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sorted&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;unsorted&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;empty&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;first&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;empty&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，可以得出结论：Pageable 既支持分页参数，也支持排序参数。并且从下面这行代码可以看出其也可以单独调用 Sort 参数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users/sort?ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>和 DomainClassConverter 组件的支持是一样的，由于 <code>SpringDataWebConfiguration</code> 实现了 WebMvcConfigurer 接口，通过 addArgumentResolvers 方法，扩展了 Controller 方法的参数 HandlerMethodArgumentResolver ，从下面图片中你就可以看出来。</p>
<p><img src="http://image.leonote.cn/20201112133652.png" alt=""></p>
<p>我们通过箭头的地方分析一下 <code>SortHandlerMethodArgumentResolver</code> 的类，会看到如下界面：</p>
<p><img src="http://image.leonote.cn/20201112134714.png" alt=""></p>
<p>这个类里面最关键的就是下面两个方法：</p>
<ul>
<li><p>supportsParameter：表示只处理类型为 Sort.class 的参数；</p>
</li>
<li><p>resolveArgument：可以把请求里面参数的值，转换成该方法里面的参数 Sort 对象。</p>
</li>
</ul>
<p>这里还要提到的是另外一个类：<code>PageableHandlerMethodArgumentResolver</code> 类。</p>
<p><img src="http://image.leonote.cn/20201112144556.png" alt=""></p>
<p>这个类里面也有两个最关键的方法：</p>
<ul>
<li>supportsParameter：表示我只处理类型是 Pageable.class 的参数；</li>
</ul>
<ul>
<li>resolveArgument：把请求里面参数的值，转换成该方法里面的参数 Pageable 的实现类 PageRequest。</li>
</ul>
<h2 id="Web-DataBinding-Support"><a href="#Web-DataBinding-Support" class="headerlink" title="Web DataBinding Support"></a>Web DataBinding Support</h2><p>Spring Data JPA 里面，也可以通过 <code>@ProjectedPayload</code> 和 <code>@JsonPath</code> 对接口进行注解支持，不过要注意这与 Jackson 注解的区别在于，此时用的是接口。</p>
<h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>第一步：如果要支持 Projection，必须要在 gradle 里面引入 jsonpath 依赖才可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.jayway.jsonpath:json-path&#39;</span><br></pre></td></tr></table></figure>

<p>第二步：新建一个 UserInfoInterface 接口类，用来接收接口传递的 json 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.web.JsonPath;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.web.ProjectedPayload;</span><br><span class="line"><span class="meta">@ProjectedPayload</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoInterface</span> </span>&#123;</span><br><span class="line">   <span class="meta">@JsonPath(&quot;$.ages&quot;)</span> <span class="comment">// 第一级参数/JSON里面找ages字段</span></span><br><span class="line"><span class="comment">// @JsonPath(&quot;$..ages&quot;) $..代表任意层级找ages字段</span></span><br><span class="line">   <span class="function">Integer <span class="title">getAges</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="meta">@JsonPath(&quot;$.telephone&quot;)</span> <span class="comment">//第一级找参数/JSON里面的telephone字段</span></span><br><span class="line"><span class="comment">// @JsonPath(&#123; &quot;$.telephone&quot;, &quot;$.user.telephone&quot; &#125;) //第一级或者user下面的telephone都可以</span></span><br><span class="line">   <span class="function">String <span class="title">getTelephone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：在 Controller 里面新建一个 post 方法，通过接口获得 RequestBody 参数对象里面的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users/projected&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfoInterface <span class="title">saveUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfoInterface userInfoInterface)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoInterface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：我们发送一个 post 请求，代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST http://localhost:8089/users/projected</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">   &quot;ages&quot;:10,</span><br><span class="line">   &quot;telephone&quot;:&quot;123456789&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时可以正常得到如下结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;ages&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">&quot;telephone&quot;</span>: <span class="string">&quot;123456789&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个响应结果说明了接口可以正常映射。</p>
<h3 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h3><blockquote>
<p> Spring 里面是如何通过 HttpMessageConverter 对 Projected 进行的支持</p>
</blockquote>
<p>查看<code>SpringDataWebConfiguration</code>类，其中实现的 WebMvcConfigurer 接口里面有个 extendMessageConverters 方法，方法里面加了一个 <code>ProjectingJackson2HttpMessageConverter</code> 的类，这个类会把带 ProjectedPayload.class 注解的接口进行 Converter。</p>
<p>其中主要的两个方法：</p>
<ol>
<li><p>加载 <code>ProjectingJackson2HttpMessageConverter</code>，用来做 Projecting 的接口转化。通过源码看一下是在哪里被加载进去的，如下：</p>
<p><img src="http://image.leonote.cn/20201112171750.png" alt=""></p>
</li>
</ol>
<ul>
<li><p>而 <code>ProjectingJackson2HttpMessageConverter</code> 主要是继承了 <code>MappingJackson2HttpMessageConverter</code>，并且实现了 <code>HttpMessageConverter</code> 的接口里面的两个重要方法，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201112171920.png" alt=""></p>
<p>其中，</p>
<ul>
<li>canRead 通过判断参数的实体类型里面是否有接口，以及是否有 ProjectedPayload.class 注解后，才进行解析；</li>
<li>read 方法负责把 HttpInputMessage 转化成 Projected 的映射代理对象。</li>
</ul>
</li>
</ul>
<h2 id="QueryDSL-Web-Support"><a href="#QueryDSL-Web-Support" class="headerlink" title="QueryDSL Web Support"></a>QueryDSL Web Support</h2><p>实际工作中，经常有人会用 Querydsl 做一些复杂查询，方便生成 Rest 的 API 接口，那么这种方法有什么好处，又会暴露什么缺点呢？</p>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>第一步：需要 gradle 引入 querydsl 的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;com.querydsl:querydsl-apt&#39;</span><br><span class="line">implementation &#39;com.querydsl:querydsl-jpa&#39;</span><br><span class="line">annotationProcessor(&quot;com.querydsl:querydsl-apt:4.3.1:jpa&quot;,</span><br><span class="line">        &quot;org.hibernate.javax.persistence:hibernate-jpa-2.1-api:1.0.2.Final&quot;,</span><br><span class="line">        &quot;javax.annotation:javax.annotation-api:1.3.2&quot;,</span><br><span class="line">        &quot;org.projectlombok:lombok&quot;)</span><br><span class="line">annotationProcessor(&quot;org.springframework.boot:spring-boot-starter-data-jpa&quot;)</span><br><span class="line">annotationProcessor &#39;org.projectlombok:lombok&#39;</span><br></pre></td></tr></table></figure>

<p>第二步：UserInfoRepository 继承 <code>QuerydslPredicateExecutor</code> 接口，就可以实现 QueryDSL 的查询方法了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt;, <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">UserInfo</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：Controller 里面直接利用 <code>@QuerydslPredicate</code> 注解接收 Predicate 参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;user/dsl&quot;)</span></span><br><span class="line"><span class="function">Page&lt;UserInfo&gt; <span class="title">queryByDsl</span><span class="params">(<span class="meta">@QuerydslPredicate(root = UserInfo.class)</span> com.querydsl.core.types.Predicate predicate, Pageable pageable)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里面用的是 userInfoRepository 里面的 QuerydslPredicateExecutor 里面的方法</span></span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.findAll(predicate, pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：直接请求我们的 user / dsl 即可，这里利用 queryDsl 的语法 ，使 &amp;ages=10 作为我们的请求参数。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/user/dsl?size=2&amp;page=0&amp;ages=10&amp;sort=id%2Cdesc&amp;ages=10</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;content&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 2,</span><br><span class="line">      &quot;version&quot;: 0,</span><br><span class="line">      &quot;ages&quot;: 10,</span><br><span class="line">      &quot;telephone&quot;: &quot;123456789&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: 1,</span><br><span class="line">      &quot;version&quot;: 0,</span><br><span class="line">      &quot;ages&quot;: 10,</span><br><span class="line">      &quot;telephone&quot;: &quot;123456789&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;pageable&quot;: &#123;</span><br><span class="line">    &quot;sort&quot;: &#123;</span><br><span class="line">      &quot;sorted&quot;: true,</span><br><span class="line">      &quot;unsorted&quot;: false,</span><br><span class="line">      &quot;empty&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;offset&quot;: 0,</span><br><span class="line">    &quot;pageNumber&quot;: 0,</span><br><span class="line">    &quot;pageSize&quot;: 2,</span><br><span class="line">    &quot;unpaged&quot;: false,</span><br><span class="line">    &quot;paged&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;totalPages&quot;: 1,</span><br><span class="line">  &quot;totalElements&quot;: 2,</span><br><span class="line">  &quot;last&quot;: true,</span><br><span class="line">  &quot;size&quot;: 2,</span><br><span class="line">  &quot;number&quot;: 0,</span><br><span class="line">  &quot;sort&quot;: &#123;</span><br><span class="line">    &quot;sorted&quot;: true,</span><br><span class="line">    &quot;unsorted&quot;: false,</span><br><span class="line">    &quot;empty&quot;: false</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;numberOfElements&quot;: 2,</span><br><span class="line">  &quot;first&quot;: true,</span><br><span class="line">  &quot;empty&quot;: false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response code: 200; Time: 721ms; Content length: 425 bytes</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论:</p>
<p>QueryDSL 可以帮我们省去创建 Predicate 的过程，简化了操作流程。但是它依然存在一些局限性，比如多了一些模糊查询、范围查询、大小查询，它对这些方面的支持不是特别友好。可能未来会更新、优化</p>
</blockquote>
<h3 id="原理分析-2"><a href="#原理分析-2" class="headerlink" title="原理分析"></a>原理分析</h3><p>QueryDSL 也是主要利用自定义 Spring MVC 的 <code>HandlerMethodArgumentResolver</code> 实现类，根据请求的参数字段，转化成 Controller 里面所需要的参数，请看一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuerydslPredicateArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">      NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure>


<p>在实际开发中，关于 insert 和 update 的接口是“逃不掉”的，但不是每次的字段都会全部传递过来，那这个时候我们应该怎么做呢？这就涉及了上述实例里面的两个注解 <code>@DynamicUpdate</code> 和 <code>@DynamicInsert</code>，下面来详细介绍一下。</p>
<h2 id="DynamicUpdate-amp-DynamicInsert-详解"><a href="#DynamicUpdate-amp-DynamicInsert-详解" class="headerlink" title="@DynamicUpdate &amp; @DynamicInsert 详解"></a>@DynamicUpdate &amp; @DynamicInsert 详解</h2><p><code>@DynamicInsert</code>：这个注解表示 insert 的时候，会动态生产 insert SQL 语句</p>
<p>其生成 SQL 的规则是：<strong>只有非空的字段才能生成 SQL</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target( TYPE )</span></span><br><span class="line"><span class="meta">@Retention( RUNTIME )</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DynamicInsert &#123;</span><br><span class="line">   <span class="comment">//默认是true，如果设置成false，就表示空的字段也会生成sql语句；</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个注解主要是用在 @Entity 的实体中，如果加上这个注解，就表示生成的 insert SQL 的 Columns 只包含非空的字段；如果实体中不加这个注解，默认的情况是空的，字段也会作为 insert 语句里面的 Columns。</p>
<p><code>@DynamicUpdate</code>：和 insert 是一个意思，只不过这个注解指的是在 update 的时候，会动态产生 update SQL 语句</p>
<p>生成 SQL 的规则是：只有非空的字段才生成到 update SQL 里面。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target( TYPE )</span></span><br><span class="line"><span class="meta">@Retention( RUNTIME )</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DynamicUpdate &#123;</span><br><span class="line">   <span class="comment">//和insert里面一个意思，默认true;</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和上一个注解的原理类似，这个注解也是用在 @Entity 的实体中，如果加上这个注解，就表示生成的 update SQL 的 Columns 只包含非空的字段；<strong>如果不加这个注解，默认的情况是空的字段也会作为 update 语句里面的 Columns</strong>。</p>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>第一步：为了方便测试，我们修改一下 User 实体：加上 <code>@DynamicInsert</code> 和 <code>@DynamicUpdate</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DynamicInsert</span></span><br><span class="line"><span class="meta">@DynamicUpdate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">......&#125;<span class="comment">//其他不变的信息省略</span></span><br></pre></td></tr></table></figure>

<p>第二步：UserInfo 实体还保持不变，即没有加上 <code>@DynamicInsert</code> 和 <code>@DynamicUpdate</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：我们在 UserController 里面添加如下方法，用来测试新增和更新 User。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：在 UserInfoController 里面添加如下方法，用来测试新增和更新 UserInfo。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">saveUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.save(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第五步：测试一下 UserController的 post 的 user 情况，看一下 insert 的情况。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### 通过post测试insert</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8089</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>56d8dc02-7f3e-7b95-7ff1-572a4bb7d102</span><br><span class="line">&#123;&quot;ages&quot;:10, &quot;name&quot;:&quot;jack&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这时，发送一个 post 请求，只带 ages 和 name 字段，而并没有带上 User 实体里面的其他字段，生成的 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> (create_time, last_modified_time, version, name, id) <span class="keyword">values</span> (?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>除了 BaseEntity 里面的一些基础字段，而其他字段并没有生成到 insert 语句里面。</p>
<p>第六步：我们再测试一下 user 的 update 情况。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### 还是发生post请求，带上ID和version执行update操作</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8089</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>56d8dc02-7f3e-7b95-7ff1-572a4bb7d102</span><br><span class="line">&#123;&quot;ages&quot;:10,&quot;name&quot;:&quot;jack1&quot;,&quot;id&quot;:1,&quot;version&quot;:0&#125;</span><br></pre></td></tr></table></figure>

<p>此时看到，update 和 insert 的唯一区别就是，当 Entity 里面有 version 字段的时候，我们再带上 version 和 id 就会显示为 update，再看一下调用完之后的 sql：用一条 select 查询一下实体是否存在，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="keyword">select</span> user0_.id <span class="keyword">as</span> id1_1_0_, user0_.create_time <span class="keyword">as</span> create_t2_1_0_, user0_.create_user_id <span class="keyword">as</span> create_u3_1_0_, user0_.last_modified_time <span class="keyword">as</span> last_mod4_1_0_, user0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_0_, user0_.version <span class="keyword">as</span> version6_1_0_, user0_.age <span class="keyword">as</span> age7_1_0_, user0_.deleted <span class="keyword">as</span> deleted8_1_0_, user0_.email <span class="keyword">as</span> email9_1_0_, user0_.name <span class="keyword">as</span> name10_1_0_, user0_.sex <span class="keyword">as</span> sex11_1_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_ <span class="keyword">where</span> user0_.id<span class="operator">=</span>?</span><br></pre></td></tr></table></figure>

<p>其中一条 update 动态更新了我们传递的那些值，而不更新 null 的字段，并且只更新有变化的字段，操作如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: update <span class="keyword">user</span> <span class="keyword">set</span> last_modified_time<span class="operator">=</span>?, version<span class="operator">=</span>?, name<span class="operator">=</span>? <span class="keyword">where</span> id<span class="operator">=</span>? <span class="keyword">and</span> version<span class="operator">=</span>?</span><br></pre></td></tr></table></figure>

<p>第七步：那么我们再看一下 UserInfo 的 insert 方法。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### insert</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user/info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8089</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>56d8dc02-7f3e-7b95-7ff1-572a4bb7d102</span><br><span class="line">&#123;&quot;ages&quot;:10&#125;</span><br></pre></td></tr></table></figure>

<p>发送一个 post 的 insert 操作，我们看一下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="keyword">insert</span> <span class="keyword">into</span> user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, telephone, id) <span class="keyword">values</span> (?, ?, ?, ?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>发现无论有没有传递值，每个字段都做了 insert，没有传递的话会用 null 代替。<br>第八步：我们再看一下 UserInfo 的 update 方法。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### update</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user/info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8089</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>56d8dc02-7f3e-7b95-7ff1-572a4bb7d102</span><br><span class="line">&#123;&quot;ages&quot;:10,&quot;id&quot;:1,&quot;version&quot;:0&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: update user_info <span class="keyword">set</span> create_time<span class="operator">=</span>?, create_user_id<span class="operator">=</span>?, last_modified_time<span class="operator">=</span>?, last_modified_user_id<span class="operator">=</span>?, version<span class="operator">=</span>?, ages<span class="operator">=</span>?, telephone<span class="operator">=</span>? <span class="keyword">where</span> id<span class="operator">=</span>? <span class="keyword">and</span> version<span class="operator">=</span>?</span><br></pre></td></tr></table></figure>

<p>通过 update 的 SQL 可以看出，即使只传递了 ages 的值，它也会把我们没有传递的 telephone 更新成 null。</p>
<p>通过上面的两个例子应该能弄清楚 <code>@DynamicInsert</code> 和 <code>@DynamicUpdate</code> 注解作用，在写 API 的时候就要考虑一下是否需要对 null 的字段进行操作。</p>
<h2 id="Spring-Data-对系统监控做了哪些支持？"><a href="#Spring-Data-对系统监控做了哪些支持？" class="headerlink" title="Spring Data 对系统监控做了哪些支持？"></a>Spring Data 对系统监控做了哪些支持？</h2><p>我们既然做了 MVC，一定也免不了要对系统进行监控，那么怎么看监控指标呢？</p>
<p>对数据层面的系统进行监控，主要有两个方法。</p>
<p>方法一：/actuator/health 的支持，里面会检查 DB 的状态。</p>
<p><img src="http://image.leonote.cn/20201112173642.png" alt=""></p>
<p>方法二：/actuator/prometheus 里面会包含一些 Hibernate 和 Datasource 的 metric。</p>
<p><img src="http://image.leonote.cn/20201112173723.png" alt=""></p>
<p>这个方法在我们做 grafana 图表的时候会很有用，不过需要注意的是：</p>
<ol>
<li><p>开启 prometheus 需要 gradle 额外引入下面这个包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">implementation &#39;io.micrometer:micrometer-registry-prometheus&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启 Hibernate 的 statistics 需要配置如下操作：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate.generate_statistics</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.endpoint.prometheus.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa Session 的 OpenInView 对事务的影响</title>
    <url>/2021/01/08/SpringDataJpa%E7%9A%84Session%E7%9A%84OpenInView%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h1 id="Session-的-OpenInView-对事务的影响"><a href="#Session-的-OpenInView-对事务的影响" class="headerlink" title="Session 的 OpenInView 对事务的影响"></a>Session 的 OpenInView 对事务的影响</h1><p>Spring 新增了一个 spring.jpa.open-in-view 的配置，但是 Hibernate 本身却没有这个配置，不过其又是和 Hibernate 中的 Session 相关的</p>
<h2 id="Session-是什么"><a href="#Session-是什么" class="headerlink" title="Session 是什么"></a>Session 是什么</h2><p><img src="http://image.leonote.cn/20201209151809.png" alt=""></p>
<p>其中，SessionImpl 是 Hibernate 实现 JPA 协议的 EntityManager 的一种实现方式，即实现类；而 Session 是 Hibernate 中的概念，完全符合 EntityManager 的接口协议，同时又完成了 Hibernate 的特殊实现。</p>
<p>在 Spring Data JPA 的框架中，可以狭隘地把 Session 理解为 EntityManager，因为其对于 JPA 的任何操作都是通过 EntityManager 的接口进行的，可以把 Session 里面的复杂逻辑当成一个黑盒子。即使 SessionImpl 能够实现 Hibernate 的 Session 接口，但如果使用的是 Spring Data JPA，那么实现再多的接口也和 Spring Data JPA 没有任何关系。</p>
<p>除非不用 JPA 的接口，直接用 Hibernate 的 Native 来实现，但是不建议这么做，因为过程太复杂了。</p>
<h2 id="SessionImpl-解决了什么问题？"><a href="#SessionImpl-解决了什么问题？" class="headerlink" title="SessionImpl 解决了什么问题？"></a>SessionImpl 解决了什么问题？</h2><p>通过源码来看一下，请看下面这张图。</p>
<p><img src="http://image.leonote.cn/20210108144559.png" alt=""></p>
<p>通过 SessionImpl 的源码和 Structure 的视图，可以“简单粗暴”地得出如下结论。</p>
<p>SessionImpl 是 EntityManager 的实现类，其实现了 JPA 协议规定的 EntityManager 的所有功能；如：EntityManager 暴露的 flushModel 的设置；EntityManager 对 Transaction 做了“是否开启新事务”“是否关闭当前事务”的逻辑。</p>
<p>如上图所示，SessionImpl 实现了 PersistenceContext 对象实例化的过程，使得 PersistenceContext 生命周期就是 Session 的生命周期。所以可以抽象地理解为，Session 是对一些数据库的操作，需要放在同一个上下文的集合中，就是常说的一级缓存。</p>
<p>Session 的 open 和 close 操作：</p>
<ul>
<li>open 的时候做了“是否开启事务”“是否获取连接”等逻辑；</li>
<li>close 的时候做了“是否关闭事务”“释放连接”等动作；</li>
</ul>
<p>Session 的任何操作都离不开事务和连接，那么肯定用当前线程保存了这些资源。</p>
<h2 id="JPA-里面的-open-in-view-是做什么的？"><a href="#JPA-里面的-open-in-view-是做什么的？" class="headerlink" title="JPA 里面的 open-in-view 是做什么的？"></a>JPA 里面的 open-in-view 是做什么的？</h2><p>open-in-view 是 Spring Boot 自动加载 Spring Data JPA 提供的一个配置，全称为 spring.jpa.open-in-view=true，它只有 true 和 false 两个值，默认是 true。</p>
<h3 id="open-in-view-的作用"><a href="#open-in-view-的作用" class="headerlink" title="open-in-view 的作用"></a>open-in-view 的作用</h3><p>在 <code>JpaBaseConfiguration</code> 中找到关键源码，通过源码来看一下 open-in-view 都做了哪些事情，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaBaseConfiguration</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(WebMvcConfigurer.class)</span></span><br><span class="line"><span class="comment">//这个提供了一种自定义注册 OpenEntityManagerInViewInterceptor 或者 OpenEntityManagerInViewFilter 的可能，同时我们可以看到在 Web 的 MVC 层打开 session 的两种方式，一种是 Interceptor，另外一种是 Filter；这两个类任选其一即可，默认用的是 OpenEntityManagerInViewInterceptor.class;</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)</span></span><br><span class="line"><span class="comment">//这里使用了 spring.jpa.open-in-view 的配置，只有为 true 的时候才会执行这个配置类，当什么都没配置的时候，默认就是 true，也就是默认此配置文件就会自动加载；我们可以设置成 false，关闭加载；</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.jpa&quot;, name = &quot;open-in-view&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaWebConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(JpaWebConfiguration.class);</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> JpaProperties jpaProperties;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">JpaWebConfiguration</span><span class="params">(JpaProperties jpaProperties)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.jpaProperties = jpaProperties;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关键逻辑在 OpenEntityManagerInViewInterceptor 类里面；加载 OpenEntityManagerInViewInterceptor 用来在MVC的拦截器里面打开 EntityManager，而当我们没有配置 spring.jpa.open-in-view 的时候，看下面代码 spring 容器会打印 warn 日志警告我们，默认开启了 open-in-view，提醒我们需要注意影响面。</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> OpenEntityManagerInViewInterceptor <span class="title">openEntityManagerInViewInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.jpaProperties.getOpenInView() == <span class="keyword">null</span>) &#123;</span><br><span class="line">         logger.warn(<span class="string">&quot;spring.jpa.open-in-view is enabled by default. &quot;</span></span><br><span class="line">               + <span class="string">&quot;Therefore, database queries may be performed during view &quot;</span></span><br><span class="line">               + <span class="string">&quot;rendering. Explicitly configure spring.jpa.open-in-view to disable this warning&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> OpenEntityManagerInViewInterceptor();</span><br><span class="line">   &#125; </span><br><span class="line">  <span class="comment">//利用 WebMvcConfigurer 加载上面的 OpenEntityManagerInViewInterceptor 拦截器进入到MVC里面；</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">openEntityManagerInViewInterceptorConfigurer</span><span class="params">(  OpenEntityManagerInViewInterceptor interceptor)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">            registry.addWebRequestInterceptor(interceptor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....<span class="comment">//其他不重要的代码省略</span></span><br></pre></td></tr></table></figure>

<p>通过上面的源码可以看到，spring.jpa.open-in-view 的主要作用就是帮我们加载 <code>OpenEntityManagerInViewInterceptor</code> 这个类</p>
<h3 id="OpenEntityManagerInViewInterceptor-源码分析"><a href="#OpenEntityManagerInViewInterceptor-源码分析" class="headerlink" title="OpenEntityManagerInViewInterceptor 源码分析"></a>OpenEntityManagerInViewInterceptor 源码分析</h3><p>打开这一源码后，可以看到下图所示的界面。</p>
<p><img src="http://image.leonote.cn/20210108145528.png" alt=""></p>
<p>可以发现，<code>OpenEntityManagerInViewInterceptor</code> 实现了 <code>WebRequestInterceptor</code> 的接口中的两个方法：</p>
<ul>
<li><p>public void preHandle(WebRequest request) ：里面实现了在每次的 Web MVC 请求之前，通过 createEntityManager 方法创建 EntityManager 和 EntityManagerHolder 的逻辑；</p>
</li>
<li><p>public void afterCompletion(WebRequest request, @Nullable Exception ex) ：里面实现了在每次 Web MVC 的请求结束之后，关闭 EntityManager 的逻辑。</p>
</li>
</ul>
<p>继续看 createEntityManager 方法的实现，找到如下关键代码：</p>
<p><img src="http://image.leonote.cn/20210108150225.png" alt=""></p>
<p>上图可以看到，通过 <code>SessionFactoryImpl</code> 中的 createEntityManager() 方法，</p>
<ol>
<li>创建了一个 <code>EntityManager</code> 的实现 Session；</li>
<li>通过拦截器创建了 EntityManager 事务处理逻辑，默认是 Join 类型（即有事务存在会加入）；</li>
<li>builder.openSession() 逻辑就是 new SessionImpl(sessionFactory, this)。</li>
</ol>
<blockquote>
<p>所以：通过 open-in-view 配置的拦截器，会帮我们的每个请求都创建一个 SessionImpl 实例；而 SessionImpl 里面存储了整个 PersistenceContext 和各种事务连接状态，可以判断出来 Session 的实例对象<strong>比较大</strong>。并且，我们打开 spring.jap.open-in-view=true 会发现，如果一个请求处理的逻辑比较耗时，牵涉到的对象比较多，这个时候就比较考验我们对 jvm 的内存配置策略了，如果配置不好就会经常出现内存溢出的现象。因此当处理比较耗时的请求和批量处理请求的时候，需要考虑到这一点。</p>
</blockquote>
<h3 id="EntityManager-Session-的打开时机及扩展场景"><a href="#EntityManager-Session-的打开时机及扩展场景" class="headerlink" title="EntityManager(Session) 的打开时机及扩展场景"></a>EntityManager(Session) 的打开时机及扩展场景</h3><p>通过 IDEA ，直接点击右键查 public Session createEntityManager() 此方法被使用到的地方即可，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210108151000.png" alt=""></p>
<p>其中，<code>EntityManagerFactoryAccessor</code> 是 <code>OpenEntityManagerInViewInterceptor</code> 的父类，从图上可以看得出来，Session 的创建（也可以说是 EntityManager 的创建）对我们有用的时机，目前就有三种。</p>
<ul>
<li><p>第一种：Web View Interceptor，通过 spring.jpa.open-in-view 控制。</p>
</li>
<li><p>第二种：Web Filter，这种方式是 Spring 给我们提供的另外一种应用场景，比如有些耗时的、批量处理的请求，我们不想在请求的时候开启 Session，而是想在处理简单逻辑后，需要用到延迟加载机制的请求时 Open Session。因为开启 Session 后，我们写框架代码的时候可以利用 lazy 机制。而这个时候我们就可以考虑使用 <code>OpenEntityManagerInViewFilter</code>，配置请求 filter 的过滤机制，实现不同的请求以及不同 Open Session 的逻辑了。</p>
</li>
<li><p>第三种：JPA Transaction，这种方式就是利用 <code>JpaTransactionManager</code>，实现在事务开启的时候打开 Session，在事务结束的时候关闭 Session。</p>
</li>
</ul>
<blockquote>
<p>默认情况下</p>
<p>Session 的开启时机有两个：</p>
<ul>
<li>每个请求之前</li>
<li>新的事务开启之前</li>
</ul>
<p>Session 的关闭时机是两个：</p>
<ul>
<li>每个请求结束之后</li>
<li>事务关闭之后</li>
</ul>
</blockquote>
<p>此外，<strong>EntityManager(Session) 打开之后，资源存储在当前线程里面 （ThreadLocal</strong>），所以一个 Session 中即使开启了多个事务，也不会创建多个 EntityManager 或者 Session。</p>
<p>而事务在关闭之前，也会检查一下此 EntityManager / Session 是不是我这个事务创建的，如果是就关闭，如果不是就不关闭，不过其不会关闭在事务范围之外创建的 EntityManager / Session。</p>
<p>这个机制其实还给我们一些额外思考：我们是不是可以自由选择开启 / 关闭 Session 呢？不一定是 view / filter / 事务，任何多事务组合的代码模块都可以。只要我们知道什么时间开启，保证一定能 close 就没有问题。</p>
<p>下面通过日志来看一下两种打开、关闭 EntityManager 的时机。</p>
<h3 id="验证-EntityManager-的创建和释放的日志"><a href="#验证-EntityManager-的创建和释放的日志" class="headerlink" title="验证 EntityManager 的创建和释放的日志"></a>验证 EntityManager 的创建和释放的日志</h3><p>第一步：新建一个 UserController 的方法，用来模拟请求两段事务的情况，代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">saveUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">   UserInfo u2 = userInfoRepository.findById(<span class="number">1L</span>).orElse(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (u2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">      u2.setLastName(<span class="string">&quot;jack&quot;</span>+userInfo.getLastModifiedTime());</span><br><span class="line">      <span class="comment">//更新u2，新开启一个事务</span></span><br><span class="line">      userInfoRepository.save(u2);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//更新userInfo，新开启一个事务</span></span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.save(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，里面调用了两个 save 操作，没有指定事务。因为 userInfoRepository 的实现类 SimpleJpaRepository 的 save 方法上面有 @Transactional 注解，所以每个 userInfoRepository.save() 方法就会开启新的事务。我们利用这个机制在上面的 Controller 里面模拟了两个事务。</p>
<p>第二步：打开 open-in-view，同时修改一些日志级别，方便观察，配置如下述代码所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 打开open-in-view</span></span><br><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 修改日志级别</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm.jpa.JpaTransactionManager</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.internal</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.engine.transaction.internal</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<p>第三步：启动项目，发送如下请求。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### update</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user/info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8087</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line">&#123;&quot;ages&quot;:10,&quot;id&quot;:3,&quot;version&quot;:0&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看一下日志，关键日志如下图所示。</p>
<p><img src="http://image.leonote.cn/20210108151724.png" alt=""></p>
<p>可以看到，我们请求了 user/info 之后就开启了 Session，然后在 Controller 方法执行的过程中开启了两段事务，每个事务结束之后都没有关闭 Session，而是等两个事务都结束之后，并且 Controller 方法执行完毕之后，才 Closing Session 的。中间过程只创建了一次 Session。</p>
<p>第四步：其他都不变的前提下，我们把 open-in-view 改成 false，如下面这行代码所示。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<p>我们再执行刚才的请求，会得到如下日志。</p>
<p><img src="http://image.leonote.cn/20210108151941.png" alt=""></p>
<p>通过日志可以看到，其中开启了两次事务，每个事务创建之后都会创建一个 Session，即开启了两个 Session，每个 Session 的 ID 是不一样的；在每个事务结束之后关闭了 Session，关闭了 EntityManager。</p>
<p>通过上面的事例和日志，我们可以看到 spring.jpa.open-in-view 对 session 和事务的影响，那么它对数据库的连接有什么影响呢？</p>
<h2 id="hibernate-connection-handling-mode-详解"><a href="#hibernate-connection-handling-mode-详解" class="headerlink" title="hibernate.connection.handling_mode 详解"></a>hibernate.connection.handling_mode 详解</h2><p>AvailableSettings 类，可以找到如下三个关键配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定获得 db 连接的方式，hibernate5.2 之后已经不推荐使用，改用 hibernate.connection.handling_mode 配置形式</span></span><br><span class="line">String ACQUIRE_CONNECTIONS = <span class="string">&quot;hibernate.connection.acquisition_mode&quot;</span>;</span><br><span class="line"><span class="comment">// 释放连接的模式有哪些？hibernate5.2 之后也不推荐使用，改用 hibernate.connection.handling_mode 配置形式</span></span><br><span class="line">String RELEASE_CONNECTIONS = <span class="string">&quot;hibernate.connection.release_mode&quot;</span>;</span><br><span class="line"><span class="comment">//指定获取连接和释放连接的模式，hibernate5.2 之后新增的配置项，代替上面两个旧的配置</span></span><br><span class="line">String CONNECTION_HANDLING = <span class="string">&quot;hibernate.connection.handling_mode&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>那么 hibernate.connection.handling_mode 对应的配置有哪些呢？Hibernate 5 提供了五种模式。</p>
<h3 id="PhysicalConnectionHandlingMode-的五种模式"><a href="#PhysicalConnectionHandlingMode-的五种模式" class="headerlink" title="PhysicalConnectionHandlingMode 的五种模式"></a>PhysicalConnectionHandlingMode 的五种模式</h3><p>在 Hibernate 5.2 里面，hibernate.connection.handling_mode 这个 Key 对应的值在 <code>PhysicalConnectionHandlingMode</code> 枚举类里面有定义，核心代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">PhysicalConnectionHandlingMode</span> </span>&#123;</span><br><span class="line">   IMMEDIATE_ACQUISITION_AND_HOLD( IMMEDIATELY, ON_CLOSE ),</span><br><span class="line">   DELAYED_ACQUISITION_AND_HOLD( AS_NEEDED, ON_CLOSE ),</span><br><span class="line">   DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT( AS_NEEDED, AFTER_STATEMENT ),</span><br><span class="line">   DELAYED_ACQUISITION_AND_RELEASE_BEFORE_TRANSACTION_COMPLETION( AS_NEEDED, BEFORE_TRANSACTION_COMPLETION ),</span><br><span class="line">   DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION( AS_NEEDED, AFTER_TRANSACTION )</span><br><span class="line">   ;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConnectionAcquisitionMode acquisitionMode;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConnectionReleaseMode releaseMode;</span><br><span class="line">   PhysicalConnectionHandlingMode(</span><br><span class="line">      ConnectionAcquisitionMode acquisitionMode,</span><br><span class="line">      ConnectionReleaseMode releaseMode) &#123;</span><br><span class="line">      <span class="keyword">this</span>.acquisitionMode = acquisitionMode;</span><br><span class="line">      <span class="keyword">this</span>.releaseMode = releaseMode;</span><br><span class="line">   &#125;</span><br><span class="line">......<span class="comment">//不重要代码先省略&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到一共有五组值，也就是把原来的 ConnectionAcquisitionMode 和 ConnectionReleaseMode 分开配置的模式进行了组合配置管理</p>
<p><strong>IMMEDIATE_ACQUISITION_AND_HOLD：立即获取，一直保持连接到 Session 关闭。</strong> 其可以代表如下几层含义：</p>
<ul>
<li><p>Session 一旦打开就会获取连接；</p>
</li>
<li><p>Session 关闭的时候释放连接；</p>
</li>
</ul>
<ul>
<li><p>如果 open-in-view=true 的时候，也就是说即使我们的请求里面没有做任何操作，或者有一些耗时操作，会导致数据库的连接释放不及时，从而导致 DB 连接不够用，如果请求频繁的话，会产生不必要的 DB 连接的上下文切换，浪费 CPU 性能；</p>
</li>
<li><p><em>容易产生 DB 连接获取时间过长的现象，从而导致请求响应时间变长</em>。</p>
</li>
</ul>
<p><strong>DELAYED_ACQUISITION_AND_HOLD：延迟获取，一直保持连接到 Session 关闭。</strong> 其可以代表如下几层含义：</p>
<ul>
<li><p>表示需要的时候再获取连接，需要的时候是指进行 DB 操作的时候，这里主要是指事务打开的时候，就需要获取连接了（因为开启事务的时候要执行“AUTOCOMMIT=0”的操作，所以这里的按需就是指开启事务；我们也可以关闭事务开启的时候改变 AUTOCOMMIT 的行为，那么这个时候的按需就是指执行 DB 操作的时候，不一定开启事务就会获得 DB 的连接）；</p>
</li>
<li><p>关闭连接的时机是 Session Close 的时候；</p>
</li>
<li><p>一个 Session 里面只有一个连接，而一个连接里面可以有多段事务；比较适合一个请求有多段事务的场景；</p>
</li>
<li><p>这个配置解决了，当没有 DB 操作的时候，即没有事务的时候不会获取数据库连接的问题；从而可以减少不必要的 DB 连接切换；</p>
</li>
<li><p>但是一旦一个 Session 在进行了 DB 操作之后，又做了一些耗时的操作才关闭，那么也会导致 DB 连接释放不及时，从而导致 DB 连接的利用率低、高并发的时候请求性能下降。</p>
</li>
</ul>
<p><strong>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT：延迟获取，Statement 执行完释放。</strong> 其可以代表如下几层含义：</p>
<ul>
<li><p>表示等需要的时候再获取连接，不是 Session 一打开就会获取连接；</p>
</li>
<li><p>在每个 Statement 的 SQL 执行完就释放连接，一旦有事务每个 SQL 执行完释放满足不了业务逻辑，我们常用的事务模式就不生效了；</p>
</li>
<li><p>这种方式适合没有事务的情景，工作中不常见，可能分布式事务中有场景需要。</p>
</li>
</ul>
<p><strong>DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION：延迟获取，事务执行之后释放。</strong> 其可以代表如下几层含义：</p>
<ul>
<li><p>表示等需要的时候再获取连接，不是 Session 一打开就会获取连接；</p>
</li>
<li><p>在事务执行完之后释放连接，同一个事务共享一个连接；</p>
</li>
<li><p>这种情况下 open-in-view 的模式对 DB 连接的持有和事务一样了，比较适合一个请求里面事务模块不多请求的情况；</p>
</li>
<li><p>如果事务都控制在 Service 层，这个配置就非常好用，其对 Connection 的利用率比较高，基本上可以做到不浪费；</p>
</li>
<li><p>这个配置不适合一个 Session 生命周期里面有很多独立事务的业务模块，因为这样就会使一个请求里面产生大量没必要的获取连接、释放连接的过程。</p>
</li>
</ul>
<p><strong>DELAYED_ACQUISITION_AND_RELEASE_BEFORE_TRANSACTION_COMPLETION：延迟获取，事务执行之前释放。</strong> 其可以代表如下几层含义：</p>
<ul>
<li><p>表示等需要的时候再获取连接，不是 Session 一打开就会获取连接；</p>
</li>
<li><p>在事务执行完之前释放连接，这种不保险，也比较少用。</p>
</li>
</ul>
<h3 id="默认的模式是哪个？如何修改默认值？"><a href="#默认的模式是哪个？如何修改默认值？" class="headerlink" title="默认的模式是哪个？如何修改默认值？"></a>默认的模式是哪个？如何修改默认值？</h3><p>打开源码 <code>HibernateJpaVendorAdapter</code> 类里面可以看到如下加载方式。</p>
<p><img src="http://image.leonote.cn/20210108153036.png" alt=""></p>
<p>Hibernate 5.2 以上使用的是 DELAYED_ACQUISITION_AND_HOLD 模式，即按需获取、Session 关闭释放，如下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jpaProperties.put(<span class="string">&quot;hibernate.connection.handling_mode&quot;</span>, <span class="string">&quot;DELAYED_ACQUISITION_AND_HOLD&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而 Hibernate 5.1 以前是通过设置 release_mode 等于 ON_CLOSE 的方式，也是 Session 关闭释放，如下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">jpaProperties.put(<span class="string">&quot;hibernate.connection.release_mode&quot;</span>, <span class="string">&quot;ON_CLOSE&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>那么，如何修改默认值呢？直接在 application.properties 文件里面做如下修改即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 我们可以修改成按需获取连接，事务执行完之后释放连接</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.connection.handling_mode</span>=<span class="string">DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION</span></span><br></pre></td></tr></table></figure>

<h3 id="handling-mode-的配置对连接的影响"><a href="#handling-mode-的配置对连接的影响" class="headerlink" title="handling_mode 的配置对连接的影响"></a>handling_mode 的配置对连接的影响</h3><p>第一步：验证一下 DELAYED_ACQUISITION_AND_HOLD，即默认情况下，连接池的情况是什么样的？</p>
<p>我们对配置文件做如下配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 在拦截MVC层开启 Session，模拟默认情况，这条可以不需要配置</span></span><br><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## 采用默认情况 DELAYED_ACQUISITION_AND_HOLD，这条也不需要配置</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.connection.handling_mode</span>=<span class="string">DELAYED_ACQUISITION_AND_HOLD</span></span><br><span class="line"><span class="comment">## 开启 hikari 的数据库连接池的监控：</span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure>

<p>在 UserInfoController 的如下方法里面，通过 Thread.sleep（2 分钟）模拟耗时操作，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/user/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">saveUserInfo</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userInfo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   UserInfo u2 = userInfoRepository.findById(<span class="number">1L</span>).orElse(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (u2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">      u2.setLastName(<span class="string">&quot;jack&quot;</span>+userInfo.getLastModifiedTime());</span><br><span class="line">      userInfoRepository.save(u2);</span><br><span class="line">      System.out.println(<span class="string">&quot;模拟事务执行完之后耗时操作........&quot;</span>);</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">2L</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;耗时操作执行完毕.......&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.save(userInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目启动，我们做如下请求。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#### update</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/user/info</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>127.0.0.1:8087</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line">&#123;&quot;ages&quot;:10,&quot;id&quot;:3,&quot;version&quot;:0&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候打开日志控制台，可以看到如下日志。</p>
<p><img src="http://image.leonote.cn/20210108153456.png" alt=""></p>
<p>在 save 之后，即事务提交之后，HikariPool 里面的数据库连接一直没有归还，而如果我们继续等待的话，在整个 Session 关闭之后，数据库连接才会归还到连接池里面。</p>
<p>试想一下，如果我们实际工作中有这样的耗时操作，是不是用不了几个这样的请求，连接池就不够用了？但其实数据库连接没做任何 DB 相关的操作，白白被浪费了。</p>
<p>第二步：验证一下 DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION 模式。</p>
<p>只需要对配置文件做如下修改。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate.connection.handling_mode</span>=<span class="string">DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION</span></span><br></pre></td></tr></table></figure>

<p>其他代码都不变，我们再请求刚才的 API 请求，这个时候可以得到如下日志。</p>
<p><img src="http://image.leonote.cn/20210108153632.png" alt=""></p>
<p>从日志中可以看到，当执行完 save(u2)，事务提交之后，做一些耗时操作的时候，发现此时整个 Session 生命周期是没有持有数据库连接的，也就是事务结束之后就进行了释放，这样大大提高了数据库连接的利用率，即使大量请求也不会造成数据库连接不够用。</p>
<p>下面是一些 Hikari 数据源连接池下， DB 连接获得的时间参考值。</p>
<p>其中，对连接的池的持有情况如下图所示，这是正常情况，几乎监控不到 DB 连接不够用的情况。</p>
<p><img src="http://image.leonote.cn/20210108154152.png" alt=""></p>
<p>对 DB 连接利用率的监控，如下图所示，连接的 Creation、Acquire 基本上是正常的，但是连接的 Usage &gt; 500ms 就有些不正常了，说明里面有一些耗时操作。</p>
<p><img src="http://image.leonote.cn/20210108154259.png" alt=""></p>
<blockquote>
<p>🎯所以，一般在实际工作中，我们会在 DELAYED_ACQUISITION_AND_HOLD 和 DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION 之间做选择；通过日志和监控，也可以看得出来 DELAYED_ACQUISITION_AND_HOLD 比较适合一个 Session 里面有大量事务的业务场景，这样不用频繁切换数据库连接。</p>
<p>而 DELAYED_ACQUISITION_AND_RELEASE_AFTER_TRANSACTION 比较适合日常的 API 业务请求，没有大量的事务，事务结束就释放连接的场景。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Connection-和-Transaction-的关系"><a href="#Connection-和-Transaction-的关系" class="headerlink" title="Connection 和 Transaction 的关系"></a>Connection 和 Transaction 的关系</h3><ol>
<li><p>事务是建立在 Connection 之上的，没有连接就没有事务。</p>
</li>
<li><p>以 MySQL InnoDB 为例，新开一个连接默认开启事务，默认每个 SQL 执行完之后自动提交事务。</p>
</li>
<li><p>一个连接里面可以有多次串行的事务段；一个事务只能属于一个 Connection。</p>
</li>
<li><p>事务与事务之间是相互隔离的，那么自然不同连接的不同事务也是隔离的。</p>
</li>
</ol>
<h3 id="EntityManager、Connection-和-Transaction-的关系"><a href="#EntityManager、Connection-和-Transaction-的关系" class="headerlink" title="EntityManager、Connection 和 Transaction 的关系"></a>EntityManager、Connection 和 Transaction 的关系</h3><ol>
<li><p>EntityManager 里面有 DataSource，当 EntityManager 里面开启事务的时候，先判断当前线程里面是否有数据库连接，如果有直接用。</p>
</li>
<li><p>开启事务之前先开启连接；关闭事务，不一定关闭连接。</p>
</li>
<li><p>开启 EntityManager，不一定立马获得连接；获得连接，不一定立马开启事务。</p>
</li>
<li><p>关闭 EntityManager，一定关闭事务，释放连接；反之不然。</p>
</li>
</ol>
<h3 id="Session、EntityManager、Connection-和-Transaction-的关系"><a href="#Session、EntityManager、Connection-和-Transaction-的关系" class="headerlink" title="Session、EntityManager、Connection 和 Transaction 的关系"></a>Session、EntityManager、Connection 和 Transaction 的关系</h3><ol>
<li>Session 是 EntityManager 的子类，SessionImpl 是 Session 和 EntityManager 的实现类。那么自然 EntityManager 和 Connection、Transaction 的关系同样适用 Session、EntityManager、Connection 和 Transaction 的关系。</li>
<li>Session 的生命周期决定了 EntityManager 的生命周期。</li>
</ol>
<h3 id="Session-和-Transaction-的关系"><a href="#Session-和-Transaction-的关系" class="headerlink" title="Session 和 Transaction 的关系"></a>Session 和 Transaction 的关系</h3><ol>
<li><p>在 Hibernate 的 JPA 实现里面，开启 Transaction 之前，必须要先开启 Session。</p>
</li>
<li><p>默认情况下，Session 的生命周期由 open-in-view 决定是请求之前开启，还是事务之前开启。</p>
</li>
<li><p>事务关闭了，Session 不一定关闭。</p>
</li>
<li><p>Session 关闭了，事务一定关闭。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 自定义参数解析器</title>
    <url>/2020/11/13/SpringDataJpa%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="自定义-HandlerMethodArgumentResolver"><a href="#自定义-HandlerMethodArgumentResolver" class="headerlink" title="自定义 HandlerMethodArgumentResolver"></a>自定义 HandlerMethodArgumentResolver</h1><p>参数解析器 – Method Argument Resolver</p>
<ul>
<li><code>SpringDataWebConfiguration</code> 类是如何被加载的</li>
<li><code>PageableHandlerMethodArgumentResolver</code> 是如何生效的</li>
<li><code>SortHandlerMethodArgumentResolver</code> 是如何生效的</li>
<li>如何定义自己的 <code>HandlerMethodArgumentResolvers</code> 类</li>
<li>还有没有其他 Web 场景需要我们自定义呢</li>
</ul>
<h2 id="Page-和-Sort-参数原理"><a href="#Page-和-Sort-参数原理" class="headerlink" title="Page 和 Sort 参数原理"></a>Page 和 Sort 参数原理</h2><p>是 <code>@EnableSpringDataWebSupport</code> 注解将<code>SpringDataWebConfiguration</code>这个类加载进去的，这个类里面把分页和排序的参数加载进去，关键代码如下所示：</p>
<p><img src="http://image.leonote.cn/20201113141756.png" alt=""></p>
<p>其中，<code>@EnableSpringDataWebSupport</code> 注解是 Spring Data JPA 对 Web 支持需要开启的入口，由于我们使用的是 Spring Boot，所以 <code>@EnableSpringDataWebSupport</code> 不需要我们手动去指定。这是由于 Spring Boot 有自动加载的机制，<code>SpringDataWebAutoConfiguration</code> 类里面引用了 <code>@EnableSpringDataWebSupport</code> 的注解，所以也不需要手动去引用了。关键代码如下所示：</p>
<p><img src="http://image.leonote.cn/20201113142007.png" alt=""></p>
<p>而 Spring Boot 的自动加载的核心文件就是 <code>spring.factories</code> 文件，那么我们打开 spring-boot-autoconfigure-2.3.3.jar 包，看一下 <code>spring.factories</code> 文件内容，可以找到 <code>SpringDataWebAutoConfiguration</code> 这个配置类，如下：</p>
<p><img src="http://image.leonote.cn/20201116125713.png" alt=""></p>
<blockquote>
<p>结论：只要是 Spring Boot 项目，什么都不需要做，它会天然地让 Spring Data JPA 支持 Web 相关的操作。</p>
</blockquote>
<p><img src="http://image.leonote.cn/20201116125905.png" alt=""></p>
<p>因为 <code>PageableHandlerMethodArgumentResolver</code> 和 <code>SortHandlerMethodArgumentResolver</code>  两个类是通过 <code>SpringDataWebConfiguration</code> 加载进去的，所以基本可以知道 Spring Data JPA 的 Page 和 Sort 参数是因为 <code>SpringDataWebConfiguration</code> 里面 @Bean 的注入才生效的。</p>
<p><img src="http://image.leonote.cn/20201116131624.png" alt=""></p>
<p>通过 <code>PageableHandlerMethodArgumentResolver</code> 和 <code>SortHandlerMethodArgumentResolver</code> 这两个类的源码，可以知道它们实现了 <code>org.springframework.web.method.support.HandlerMethodArgumentResolver</code> 这个接口，从而对 Request 里面的 Page 和 Sort 的参数做了处理逻辑和解析逻辑。</p>
<p>在实际工作中，可能存在特殊情况需要对其进行扩展，比如 Page 的参数可能需要支持多种 Key 的情况，那么应该怎么做呢？</p>
<h2 id="HandlerMethodArgumentResolver-用法"><a href="#HandlerMethodArgumentResolver-用法" class="headerlink" title="HandlerMethodArgumentResolver 用法"></a>HandlerMethodArgumentResolver 用法</h2><h3 id="接口方法详解"><a href="#接口方法详解" class="headerlink" title="接口方法详解"></a>接口方法详解</h3><p>熟悉 MVC 的人都知道，HandlerMethodArgumentResolvers 在 Spring MVC 中的主要作用是对 Controller 里面的方法参数做解析，即可以把 Request 里面的值映射到方法的参数中。打开此类的源码会发现只有两个方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">   <span class="comment">//检查方法的参数是否支持处理和转化</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line">   <span class="comment">//根据request上下文，解析方法的参数</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, <span class="meta">@Nullable</span> ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			NativeWebRequest webRequest, <span class="meta">@Nullable</span> WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接口的应用场景非常广泛，可以看到其子类非常多，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201116135238.png" alt=""></p>
<p>其中几个类的作用如下：</p>
<ul>
<li><p><code>PathVariableMapMethodArgumentResolver</code> 专门解析 @PathVariable 里面的值；</p>
</li>
<li><p><code>RequestResponseBodyMethodProcessor</code> 专门解析 @RequestBody 注解的方法参数的值；</p>
</li>
<li><p><code>RequestParamMethodArgumentResolver</code> 专门解析 @RequestParam 的注解参数的值，当方法的参数中没有任何注解的时候，默认是 @RequestParam；</p>
</li>
<li><p><code>PageableHandlerMethodArgumentResolver</code> 专门解析 @PageableDefault Pageable 的值</p>
</li>
<li><p><code>SortHandlerMethodArgumentResolver</code></p>
</li>
</ul>
<h3 id="与-HttpMessageConverter-的关系"><a href="#与-HttpMessageConverter-的关系" class="headerlink" title="与 HttpMessageConverter 的关系"></a>与 HttpMessageConverter 的关系</h3><p>打开 <code>RequestResponseBodyMethodProcessor</code> 就会发现，这个类中主要处理的是，方法里面带 @RequestBody 注解的参数，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201117095947.png" alt=""></p>
<p>而其中的 <code>readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType())</code> 方法，如果我们点进去继续观察，发现里面<strong>会根据 Http 请求的 MediaType，来选择不同的 HttpMessageConverter 进行转化</strong>。</p>
<blockquote>
<p>不同的 <code>HttpMessageConverter</code> 都是由 <code>RequestResponseBodyMethodProcessor</code> 进行调用的</p>
</blockquote>
<h2 id="HttpMessageConverter-的执行顺序"><a href="#HttpMessageConverter-的执行顺序" class="headerlink" title="HttpMessageConverter 的执行顺序"></a>HttpMessageConverter 的执行顺序</h2><p>当我们自定义 HandlerMethodArgumentResolver 时，通过下面的方法加载进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">   resolvers.add(myPageableHandlerMethodArgumentResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>List&lt;HandlerMethodArgumentResolver&gt;</code> 里面<strong>自定义的 resolver 的优先级是最高的</strong>，也就是会优先执行 <code>HandlerMethodArgumentResolver</code> 之后，才会按照顺序执行系统里面自带的那一批 <code>HttpMessageConverter</code>，按照 List 的顺序执行。</p>
<p>Spring 里面有个执行效率问题，就是一旦一次执行找到了需要的 <code>HandlerMethodArgumentResolver</code> 的时候，利用 <strong>Spring 中的缓存机制</strong>，执行过程中就不会再遍历 <code>List&lt;HandlerMethodArgumentResolver&gt;</code> 了，而是直接用上次找到的 <code>HandlerMethodArgumentResolver</code>，这样提升了执行效率。</p>
<p>如果想要了解更多的 Resolver，可以看下图这个类的代码：</p>
<p><img src="http://image.leonote.cn/20201117100937.png" alt=""></p>
<h2 id="如何自定义-HandlerMethodArgumentResolver"><a href="#如何自定义-HandlerMethodArgumentResolver" class="headerlink" title="如何自定义 HandlerMethodArgumentResolver"></a>如何自定义 HandlerMethodArgumentResolver</h2><p>在实际的工作中，可能会遇到对老项目进行改版的工作，如果要我们把旧的 API 接口改造成 JPA 的技术实现，那么可能会出现需要新、老参数的问题。假设在实际场景中，我们 Page 的参数是 page[number]，而 page size 的参数是 page[size]，看看应该怎么做。</p>
<p><strong>第一步：新建 MyPageableHandlerMethodArgumentResolver</strong></p>
<p>这个类的作用有两个：</p>
<ul>
<li><p>用来兼容 ?page[size]=2&amp;page[number]=0 的参数情况；</p>
</li>
<li><p>支持 JPA 新的参数形式 ?size=2&amp;page=0。</p>
</li>
</ul>
<p>通过自定义的 <code>MyPageableHandlerMethodArgumentResolver</code> 来实现这个需求，请看下面这段代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过<span class="doctag">@Component</span>把此类加载到Spring的容器里面去 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageableHandlerMethodArgumentResolver</span> <span class="keyword">extends</span> <span class="title">PageableHandlerMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">   <span class="comment">//我们假设sort的参数没有发生变化，采用PageableHandlerMethodArgumentResolver里面的写法</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SortHandlerMethodArgumentResolver DEFAULT_SORT_RESOLVER = <span class="keyword">new</span> SortHandlerMethodArgumentResolver();</span><br><span class="line">   <span class="comment">//给定两个默认值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_PAGE = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer DEFAULT_SIZE = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">//兼容新版，引入JPA的分页参数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JPA_PAGE_PARAMETER = <span class="string">&quot;page&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JPA_SIZE_PARAMETER = <span class="string">&quot;size&quot;</span>;</span><br><span class="line">   <span class="comment">//兼容原来老的分页参数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE_PARAMETER = <span class="string">&quot;page[number]&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SIZE_PARAMETER = <span class="string">&quot;page[size]&quot;</span>;</span><br><span class="line">   <span class="keyword">private</span> SortArgumentResolver sortResolver;</span><br><span class="line">   <span class="comment">//模仿 PageableHandlerMethodArgumentResolver 里面的构造方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyPageableHandlerMethodArgumentResolver</span><span class="params">(<span class="meta">@Nullable</span> SortArgumentResolver sortResolver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.sortResolver = sortResolver == <span class="keyword">null</span> ? DEFAULT_SORT_RESOLVER : sortResolver;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    假设用我们自己的类 MyPageRequest 接收参数</span></span><br><span class="line">      <span class="keyword">return</span> MyPageRequest.class.equals(parameter.getParameterType());</span><br><span class="line">      <span class="comment">//同时我们也可以支持通过Spring Data JPA里面的Pageable参数进行接收，两种效果是一样的</span></span><br><span class="line"><span class="comment">//    return Pageable.class.equals(parameter.getParameterType());</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 参数封装逻辑page和sort，JPA参数的优先级高于page[number]和page[size]参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//public Pageable resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) &#123; //这种是Pageable的方式</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> MyPageRequest <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> </span>&#123;</span><br><span class="line">      String jpaPageString = webRequest.getParameter(JPA_PAGE_PARAMETER);</span><br><span class="line">      String jpaSizeString = webRequest.getParameter(JPA_SIZE_PARAMETER);</span><br><span class="line">      <span class="comment">//我们分别取参数里面page、sort和 page[number]、page[size]的值</span></span><br><span class="line">      String pageString = webRequest.getParameter(DEFAULT_PAGE_PARAMETER);</span><br><span class="line">      String sizeString = webRequest.getParameter(DEFAULT_SIZE_PARAMETER);</span><br><span class="line">      <span class="comment">//当两个都有值时候的优先级，及其默认值的逻辑</span></span><br><span class="line">      Integer page = jpaPageString != <span class="keyword">null</span> ? Integer.valueOf(jpaPageString) : pageString != <span class="keyword">null</span> ? Integer.valueOf(pageString) : DEFAULT_PAGE;</span><br><span class="line">      <span class="comment">//在这里同时可以计算 page+1的逻辑;如：page=page+1;</span></span><br><span class="line">      Integer size = jpaSizeString != <span class="keyword">null</span> ? Integer.valueOf(jpaSizeString) : sizeString != <span class="keyword">null</span> ? Integer.valueOf(sizeString) : DEFAULT_SIZE;</span><br><span class="line">       <span class="comment">//我们假设，sort排序的取值方法先不发生改变</span></span><br><span class="line">      Sort sort = sortResolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line"><span class="comment">//    如果使用 Pageable 参数接收值，我们也可以不用自定义 MyPageRequest 对象，直接返回 PageRequest;</span></span><br><span class="line"><span class="comment">//    return PageRequest.of(page,size,sort);</span></span><br><span class="line">      <span class="comment">//将 page 和 size 计算出来的记过封装到我们自定义的 MyPageRequest 类里面去</span></span><br><span class="line">      MyPageRequest myPageRequest = <span class="keyword">new</span> MyPageRequest(page, size,sort);</span><br><span class="line">      <span class="comment">//返回 controller 里面的参数需要的对象；</span></span><br><span class="line">      <span class="keyword">return</span> myPageRequest;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的逻辑就是取 Request 的 Page 相关的参数，封装到对象中返回给 Controller 的方法参数里面。</p>
<p>其中 MyPageRequest 不是必需的，只是为了演示不同的做法。</p>
<p><strong>第二步：新建 MyPageRequest</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承父类，可以省掉很多计算 page 和 index 的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPageRequest</span> <span class="keyword">extends</span> <span class="title">PageRequest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">MyPageRequest</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> size, Sort sort)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(page, size, sort);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此类，我们用来接收 Page 相关的参数值，也不是必需的。</p>
<p><strong>第三步：implements WebMvcConfigurer 加载 myPageableHandlerMethodArgumentResolver</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 WebMvcConfigurer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MyPageableHandlerMethodArgumentResolver myPageableHandlerMethodArgumentResolver;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 覆盖这个方法，把我们自定义的 myPageableHandlerMethodArgumentResolver 加载到原始的 mvc 的 resolvers 里面去</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resolvers</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">      resolvers.add(myPageableHandlerMethodArgumentResolver);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里利用 Spring MVC 的机制加载我们自定义的 <code>myPageableHandlerMethodArgumentResolver</code>，由于自定义的优先级是最高的，所以用 MyPageRequest.class 和 Pageable.class 都是可以的</p>
<p><strong>第四步： Controller 里面的写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用 Pageable 这种方式也是可以的</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;UserInfo&gt; <span class="title">queryByPage</span><span class="params">(Pageable pageable, UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.findAll(Example.of(userInfo),pageable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用 MyPageRequest 进行接收</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/users/mypage&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;UserInfo&gt; <span class="title">queryByMyPage</span><span class="params">(MyPageRequest pageable, UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.findAll(Example.of(userInfo),pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里利用 Pageable 和 MyPageRequest 两种方式都是可以的。</p>
<p><strong>第五步：启动项目测试一下</strong></p>
<p>依次可以测试下面两种情况，发现都是可以正常工作的。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users?page[size]=2&amp;page[number]=0&amp;ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users?size=2&amp;page=0&amp;ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users/mypage?page[size]=2&amp;page[number]=0&amp;ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/users/mypage?size=2&amp;page=0&amp;ages=10&amp;sort=id,desc</span><br></pre></td></tr></table></figure>

<p>演示的 Controller 方法里面有多个参数的，每个参数都各司其职，找到自己对应的 <code>HandlerMethodArgumentResolver</code>，这正是 Spring MVC 框架的优雅之处。</p>
<h2 id="实际工作的建议"><a href="#实际工作的建议" class="headerlink" title="实际工作的建议"></a>实际工作的建议</h2><p>自定义 HandlerMethodArgumentResolver 到底对我们的工作起到哪些作用呢？</p>
<h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>当我们在 Controller 里面处理某些参数时，重复的步骤非常多，那么我们就可以考虑写一下自己的框架，来处理请求里面的参数，而 Controller 里面的代码就会变得非常优雅，不需要关心其他框架代码，只要知道方法的参数有值就可以了。</p>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>再举个例子，在实际工作中需要注意的是，默认 JPA 里面的 Page 是从 0 开始，而我们可能有些老的代码也要维护，因为老的代码大多数的 Page 都会从 1 开始。如果我们不自定义 <code>HandlerMethodArgumentResolver</code>，那么在用到分页时，每个 Controller 的方法里面都需要关心这个逻辑。那么这个时候你就应该想到上面列举的自定义 <code>MyPageableHandlerMethodArgumentResolver</code> 的 resolveArgument 方法的实现，使用这种方法我们只需要在里面修改 Page 的计算逻辑即可。</p>
<h3 id="场景三"><a href="#场景三" class="headerlink" title="场景三"></a>场景三</h3><p>再举个例子，在实际的工作中，还经常会遇到“取当前用户”的应用场景。此时，普通做法是，当使用到当前用户的 UserInfo 时，每次都需要根据请求 header 的 token 取到用户信息，伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;user/info&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="meta">@RequestHeader</span> String token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 伪代码</span></span><br><span class="line">    Long userId = redisTemplate.get(token);</span><br><span class="line">    UserInfo useInfo = userInfoRepository.getById(userId);</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们使用 <code>HandlerMethodArgumentResolver</code> 接口来实现，代码就会变得优雅许多。伪代码如下：</p>
<ol>
<li><p><strong>实现 HandlerMethodArgumentResolver 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate redisTemplate;<span class="comment">//伪代码，假设我们token是放在redis里面的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">UserInfoArgumentResolver</span><span class="params">(RedisTemplate redisTemplate, UserInfoRepository userInfoRepository)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.redisTemplate = redisTemplate;<span class="comment">//伪代码，假设我们token是放在redis里面的</span></span><br><span class="line">      <span class="keyword">this</span>.userInfoRepository = userInfoRepository;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> UserInfo.class.isAssignableFrom(parameter.getParameterType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                          NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      HttpServletRequest nativeRequest = (HttpServletRequest) webRequest.getNativeRequest();</span><br><span class="line">      String token = nativeRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">      Long userId = (Long) redisTemplate.opsForValue().get(token);<span class="comment">//伪代码，假设我们token是放在redis里面的</span></span><br><span class="line">      UserInfo useInfo = userInfoRepository.getOne(userId);</span><br><span class="line">      <span class="keyword">return</span> useInfo;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只需要在 MyWebMvcConfigurer 里面把 userInfoArgumentResolver 添加进去即可</strong>，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MyPageableHandlerMethodArgumentResolver myPageableHandlerMethodArgumentResolver;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoArgumentResolver userInfoArgumentResolver;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">      resolvers.add(myPageableHandlerMethodArgumentResolver);</span><br><span class="line">      <span class="comment">//我们只需要把userInfoArgumentResolver加入resolvers中即可</span></span><br><span class="line">      resolvers.add(userInfoArgumentResolver);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 Controller 中使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得当前用户的信息</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;user/info&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> userInfo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//给当前用户 say hello</span></span><br><span class="line">  <span class="meta">@PostMapping(&quot;sayHello&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + userInfo.getTelephone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上述代码可以看到，在 Controller 里面可以完全省掉根据 token 从 redis 取当前用户信息的过程，优化了操作流程。</p>
<h3 id="场景四"><a href="#场景四" class="headerlink" title="场景四"></a>场景四</h3><p>有的时候我们也会更改 Pageable 的默认值和参数的名字，也可以在 application.properties 的文件里面通过如下的 Key 值对自定义进行配置，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201117104905.png" alt=""></p>
<h2 id="思路拓展"><a href="#思路拓展" class="headerlink" title="思路拓展"></a>思路拓展</h2><h3 id="WebMvcConfigurer-介绍"><a href="#WebMvcConfigurer-介绍" class="headerlink" title="WebMvcConfigurer 介绍"></a>WebMvcConfigurer 介绍</h3><p>当我们做 Spring 的 MVC 开发的时候，可能会通过实现 <code>WebMvcConfigurer</code> 去做一些公用的业务逻辑，下面我列举几个常见的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 拦截器配置 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry var1)</span></span>;</span><br><span class="line"><span class="comment">/** 视图跳转控制器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 静态资源处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 默认静态资源处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span></span>;</span><br><span class="line"><span class="comment">/** 这里配置视图解析器 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 配置内容裁决的一些选项 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span></span>;</span><br><span class="line"><span class="comment">/** 解决跨域问题 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span></span>;</span><br><span class="line"><span class="comment">/** 添加对 controller 的 Return 的结果的处理 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; handlers)</span></span>;</span><br></pre></td></tr></table></figure>

<p>当我们实现 Restful 风格的 API 协议时，会经常看到其对 json 响应结果进行了统一的封装，我们也可以采用 <code>HandlerMethodReturnValueHandler</code> 来实现，再来看一个例子。</p>
<h3 id="用-Result-对-JSON-的返回结果进行统一封装"><a href="#用-Result-对-JSON-的返回结果进行统一封装" class="headerlink" title="用 Result 对 JSON 的返回结果进行统一封装"></a>用 Result 对 JSON 的返回结果进行统一封装</h3><p>下面通过五个步骤来实现一个通过自定义注解，利用<code>HandlerMethodReturnValueHandler</code> 实现 JSON 结果封装的例子。</p>
<p><strong>第一步：我们自定义一个注解 @WarpWithData</strong>，表示此注解包装的返回结果用 Data 进行包装，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">/** 自定义一个注解对返回结果进行包装 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WarpWithData &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：自定义 MyWarpWithDataHandlerMethodReturnValueHandler，并继承 RequestResponseBodyMethodProcessor 来实现 HandlerMethodReturnValueHandler 接口</strong>，用来处理 Data 包装的结果，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义自己的 return 的处理类，我们直接继承 RequestResponseBodyMethodProcessor，这样父类里面的方法我们直接使用就可以了</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWarpWithDataHandlerMethodReturnValueHandler</span> <span class="keyword">extends</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line">   <span class="comment">//参考父类 RequestResponseBodyMethodProcessor 的做法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyWarpWithDataHandlerMethodReturnValueHandler</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(converters);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//只处理需要包装的注解的方法</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> returnType.hasMethodAnnotation(WarpWithData.class);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将返回结果包装一层 Data</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line">      Map&lt;String,Object&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      res.put(<span class="string">&quot;data&quot;</span>,returnValue);</span><br><span class="line">      <span class="keyword">super</span>.handleReturnValue(res,methodParameter,modelAndViewContainer,nativeWebRequest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步：在 MyWebMvcConfigurer 里面直接把 myWarpWithDataHandlerMethodReturnValueHandler 加入 handlers 里面即可</strong>，也是通过覆盖父类 WebMvcConfigurer 里面的 addReturnValueHandlers 方法完成的，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebMvcConfigurer</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> MyWarpWithDataHandlerMethodReturnValueHandler myWarpWithDataHandlerMethodReturnValueHandler;</span><br><span class="line">   <span class="comment">//把我们自定义的 myWarpWithDataHandlerMethodReturnValueHandler 加入 handlers 里面即可</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addReturnValueHandlers</span><span class="params">(List&lt;HandlerMethodReturnValueHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">      handlers.add(myWarpWithDataHandlerMethodReturnValueHandler);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RequestMappingHandlerAdapter requestMappingHandlerAdapter;</span><br><span class="line">  <span class="comment">//由于 HandlerMethodReturnValueHandler 处理的优先级问题，通过如下方法，把我们自定义的 myWarpWithDataHandlerMethodReturnValueHandler 放到第一个；</span></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = Lists.newArrayList(myWarpWithDataHandlerMethodReturnValueHandler);</span><br><span class="line">     <span class="comment">// 取出原始列表，重新覆盖进去；</span></span><br><span class="line">     returnValueHandlers.addAll(requestMappingHandlerAdapter.getReturnValueHandlers());</span><br><span class="line">     requestMappingHandlerAdapter.setReturnValueHandlers(returnValueHandlers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，我们利用 @PostConstruct 调整了一下 HandlerMethodReturnValueHandler 加载的优先级，使其生效。</p>
<p><strong>第四步：Controller 方法中直接加上 @WarpWithData 注解</strong>，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@WarpWithData</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfoFromPath</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> userInfoRepository.getOne(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：我们测试一下</strong>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET http://localhost:8089/user/1</span><br></pre></td></tr></table></figure>

<p>就会得到如下结果，返回的 JSON 结果多了一个 Data 包装。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;createUserId&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;createTime&quot;</span>: <span class="string">&quot;2020-10-23T00:23:10.185Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastModifiedUserId&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;lastModifiedTime&quot;</span>: <span class="string">&quot;2020-10-23T00:23:10.185Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ages&quot;</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">&quot;telephone&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hibernateLazyInitializer&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA 自定义返回值</title>
    <url>/2020/09/27/SpringDataJpa%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h1 id="Spring-Data-JPA-自定义返回值"><a href="#Spring-Data-JPA-自定义返回值" class="headerlink" title="Spring Data JPA 自定义返回值"></a>Spring Data JPA 自定义返回值</h1><p>打开 SimpleJpaRepository 直接看它的 Structure ，从它实现的方法以及父类接口的方法看到，返回类型包括：Optional、Iterable、List、Page、Long、Boolean、Entity 等，如下图所示：</p>
<p><img src="http://image.leonote.cn//20200926195205.png" alt=""></p>
<p>而实际上支持的返回类型还要多一些。</p>
<p>由于 Repository 里面支持 Iterable，所以 java 标准的 List、Set 都可以作为返回结果，并且也会支持其子类。</p>
<h2 id="查询结果的返回值"><a href="#查询结果的返回值" class="headerlink" title="查询结果的返回值"></a>查询结果的返回值</h2><h3 id="Streamable"><a href="#Streamable" class="headerlink" title="Streamable"></a>Streamable</h3><p>Spring Data 里面定义了一个特殊的子类 Streamable，Streamable 可以替代 Iterable 或任何集合类型。它还提供了方便的方法来访问 Stream，可以直接在元素上进行 ….filter(…) 和 ….map(…) 操作，并将 Streamable 连接到其他元素。</p>
<p>我们看个关于 UserRepository 直接继承 JpaRepository 的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserRepository 类，在测试类里面做如下调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = userRepository.save(</span><br><span class="line">    	User.builder().name(<span class="string">&quot;jackxx&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">    	.sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">Assert.assertNotNull(user);</span><br><span class="line">Streamable&lt;User&gt; userStreamable = userRepository</span><br><span class="line">    .findAll(PageRequest.of(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">    .and(User.builder().name(<span class="string">&quot;jack222&quot;</span>).build());</span><br><span class="line">userStreamable.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User(id=<span class="number">1</span>, name=jackxx, email=<span class="number">123456</span>@<span class="number">126.</span>com, sex=man, address=shanghai)</span><br><span class="line">User(id=<span class="keyword">null</span>, name=jack222, email=<span class="keyword">null</span>, sex=<span class="keyword">null</span>, address=<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<p>这个例子 Streamable<code>&lt;User&gt;</code> userStreamable，实现了 Streamable 的返回结果。</p>
<h3 id="自定义-Streamable"><a href="#自定义-Streamable" class="headerlink" title="自定义 Streamable"></a>自定义 Streamable</h3><p>官方给我们提供了自定义 Streamable 的方法，不过在实际工作中很少出现要自定义保证结果类的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">  <span class="function">MonetaryAmount <span class="title">getPrice</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequiredArgConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">Product</span>&gt; </span>&#123; (<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">private</span> Streamable&lt;Product&gt; streamable;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> MonetaryAmount <span class="title">getTotal</span><span class="params">()</span> </span>&#123; (<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> streamable.stream() <span class="comment">//</span></span><br><span class="line">      .map(Priced::getPrice)</span><br><span class="line">      .reduce(Money.of(<span class="number">0</span>), MonetaryAmount::add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Products <span class="title">findAllByDescriptionContaining</span><span class="params">(String text)</span></span>; (<span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上四个步骤介绍了自定义 Streamable 的方法，分别为：</p>
<p>（1）Product 实体，公开 API 以访问产品价格。</p>
<p>（2）Streamable<code>&lt;Product&gt;</code> 的包装类型可以通过 Products.of(…) 构造（通过 Lombok 注解创建的工厂方法）。</p>
<p>（3）包装器类型在 Streamable<code>&lt;Product&gt;</code> 上公开了计算新值的其他 API。</p>
<p>（4）可以将包装器类型直接用作查询方法返回类型。无须返回 Streamable<code>&lt;Product&gt;</code> 并将其手动包装在存储库 Client 端中。</p>
<p>其原理很简单，就是实现 Streamable接口，自己定义自己的实现类即可。</p>
<p>源码在 QueryExecutionResultHandler ，它里面有对 Streamable 子类的判断，来支持自定义 Streamable，关键源码如下：</p>
<p><img src="http://image.leonote.cn//20200926200136.png" alt=""></p>
<p>通过源码你会发现 Streamable 为什么生效，下面来看看常见的集合类的返回实现。</p>
<h3 id="List-Stream-Page-Slice"><a href="#List-Stream-Page-Slice" class="headerlink" title="List/Stream/Page/Slice"></a>List/Stream/Page/Slice</h3><p>首先，新建我们的 UserRepository：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.Query;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//自定义一个查询方法，返回Stream对象，并且有分页属性</span></span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line">    <span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">    <span class="comment">//测试Slice的返回结果</span></span><br><span class="line">    <span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line">    <span class="function">Slice&lt;User&gt; <span class="title">findAllByCustomQueryAndSlice</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，修改一下我们的测试用例类，如下，验证一下结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.assertj.core.util.Lists;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Slice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.util.Streamable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">//我们新增7条数据方便测试分页结果</span></span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack1&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack2&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack3&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack4&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack5&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack6&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        userRepository.save(User.builder().name(<span class="string">&quot;jack7&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                            .sex(<span class="string">&quot;man&quot;</span>).address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">        <span class="comment">//我们利用ObjectMapper将我们的返回结果Json to String</span></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">//返回Stream类型结果（1）</span></span><br><span class="line">        Stream&lt;User&gt; userStream = userRepository.findAllByCustomQueryAndStream(PageRequest.of(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">        userStream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">//返回分页数据（2）</span></span><br><span class="line">        Page&lt;User&gt; userPage = userRepository.findAll(PageRequest.of(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(userPage));</span><br><span class="line">        <span class="comment">//返回Slice结果（3）</span></span><br><span class="line">        Slice&lt;User&gt; userSlice = userRepository.findAllByCustomQueryAndSlice(PageRequest.of(<span class="number">0</span>,<span class="number">3</span>));</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(userSlice));</span><br><span class="line">        <span class="comment">//返回List结果（4）</span></span><br><span class="line">        List&lt;User&gt; userList = userRepository.findAllById(Lists.newArrayList(<span class="number">1L</span>,<span class="number">2L</span>));</span><br><span class="line">        System.out.println(objectMapper.writeValueAsString(userList));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们分别看下四种测试结果：</p>
<h4 id="第一种：通过-Stream-lt-User-gt-取第二页的数据"><a href="#第一种：通过-Stream-lt-User-gt-取第二页的数据" class="headerlink" title="第一种：通过 Stream&lt;User&gt;取第二页的数据"></a>第一种：通过 Stream<code>&lt;User&gt;</code>取第二页的数据</h4><p>得到结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User(id=<span class="number">4</span>, name=jack4, email=<span class="number">123456</span>@<span class="number">126.</span>com, sex=man, address=shanghai)</span><br><span class="line">User(id=<span class="number">5</span>, name=jack5, email=<span class="number">123456</span>@<span class="number">126.</span>com, sex=man, address=shanghai)</span><br><span class="line">User(id=<span class="number">6</span>, name=jack6, email=<span class="number">123456</span>@<span class="number">126.</span>com, sex=man, address=shanghai)</span><br></pre></td></tr></table></figure>

<p>Spring Data 的支持可以通过使用 Java 8 Stream 作为返回类型来逐步处理查询方法的结果。<strong>需要注意的是：流的关闭问题</strong>，try cache 是一种常用的关闭方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;User&gt; stream;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   stream = repository.findAllByCustomQueryAndStream()</span><br><span class="line">   stream.forEach(…);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (stream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stream.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第二种：返回-Page-lt-User-gt-的分页数据结果"><a href="#第二种：返回-Page-lt-User-gt-的分页数据结果" class="headerlink" title="第二种：返回 Page&lt;User&gt; 的分页数据结果"></a>第二种：返回 Page<code>&lt;User&gt;</code> 的分页数据结果</h4><p>得到结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;content&quot;</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack1&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">2</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack2&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">3</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack3&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;pageable&quot;</span>:&#123;</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>:&#123;</span><br><span class="line">   <span class="attr">&quot;sorted&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">   <span class="attr">&quot;unsorted&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">   <span class="attr">&quot;empty&quot;</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;pageNumber&quot;</span>:<span class="number">0</span>, <span class="comment">// 当前页码</span></span><br><span class="line">  <span class="attr">&quot;pageSize&quot;</span>:<span class="number">3</span>, <span class="comment">// 页码大小</span></span><br><span class="line">  <span class="attr">&quot;offset&quot;</span>:<span class="number">0</span>, <span class="comment">// 偏移量</span></span><br><span class="line">  <span class="attr">&quot;paged&quot;</span>:<span class="literal">true</span>, <span class="comment">// 是否分页了</span></span><br><span class="line">  <span class="attr">&quot;unpaged&quot;</span>:<span class="literal">false</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;totalPages&quot;</span>:<span class="number">3</span>, <span class="comment">// 一共有多少页</span></span><br><span class="line"> <span class="attr">&quot;last&quot;</span>:<span class="literal">false</span>, <span class="comment">// 是否是到最后</span></span><br><span class="line"> <span class="attr">&quot;totalElements&quot;</span>:<span class="number">7</span>, <span class="comment">// 总记录数</span></span><br><span class="line"> <span class="attr">&quot;numberOfElements&quot;</span>:<span class="number">3</span>, <span class="comment">// 当前数据下标</span></span><br><span class="line"> <span class="attr">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="attr">&quot;sorted&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;unsorted&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;empty&quot;</span>:<span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;size&quot;</span>:<span class="number">3</span>, <span class="comment">// 当前content大小</span></span><br><span class="line"> <span class="attr">&quot;number&quot;</span>:<span class="number">0</span>, <span class="comment">// 当前页面码的索引</span></span><br><span class="line"> <span class="attr">&quot;first&quot;</span>:<span class="literal">true</span>, <span class="comment">// 是否是第一页</span></span><br><span class="line"> <span class="attr">&quot;empty&quot;</span>:<span class="literal">false</span> <span class="comment">// 是否有数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们可以看到 Page<code>&lt;User&gt;</code> 返回了第一个页的数据，并且告诉我们一共有三个部分的数据：</p>
<ul>
<li><strong>content</strong>：数据的内容，现在指 User 的 List 3 条。</li>
<li><strong>pageable</strong>：分页数据，包括排序字段是什么及其方向、当前是第几页、一共多少页、是否是最后一条等。</li>
<li><strong>当前数据的描述</strong>：<ul>
<li>“size”：3，当前 content 大小</li>
<li>“number”：0，当前页面码的索引</li>
<li>“first”：true，是否是第一页</li>
<li>“empty”：false，是否没有数据</li>
</ul>
</li>
</ul>
<h4 id="第三种：返回-Slice-lt-User-gt-结果"><a href="#第三种：返回-Slice-lt-User-gt-结果" class="headerlink" title="第三种：返回 Slice&lt;User&gt; 结果"></a>第三种：返回 Slice<code>&lt;User&gt;</code> 结果</h4><p>得到结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;content&quot;</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">4</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack4&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">5</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack5&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="attr">&quot;id&quot;</span>:<span class="number">6</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack6&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="attr">&quot;pageable&quot;</span>:&#123;</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>:&#123;</span><br><span class="line">   <span class="attr">&quot;sorted&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">   <span class="attr">&quot;unsorted&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">   <span class="attr">&quot;empty&quot;</span>:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;pageNumber&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;pageSize&quot;</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;offset&quot;</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="attr">&quot;paged&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;unpaged&quot;</span>:<span class="literal">false</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;numberOfElements&quot;</span>:<span class="number">3</span>,</span><br><span class="line"> <span class="attr">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="attr">&quot;sorted&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;unsorted&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;empty&quot;</span>:<span class="literal">true</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">&quot;size&quot;</span>:<span class="number">3</span>,</span><br><span class="line"> <span class="attr">&quot;number&quot;</span>:<span class="number">1</span>,</span><br><span class="line"> <span class="attr">&quot;first&quot;</span>:<span class="literal">false</span>,</span><br><span class="line"> <span class="attr">&quot;last&quot;</span>:<span class="literal">false</span>,</span><br><span class="line"> <span class="attr">&quot;empty&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们发现上面的 Page 返回结果少了，少了跟记录数相关的内容</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;totalPages&quot;:3, // 一共有多少页</span><br><span class="line">&quot;last&quot;:false, // 是否是到最后</span><br><span class="line">&quot;totalElements&quot;:7, // 总记录数</span><br><span class="line">&quot;numberOfElements&quot;:3, // 当前数据下标</span><br></pre></td></tr></table></figure>

<p>再比较一下第二种和第三种测试结果的执行 SQL：</p>
<p>第二种执行的是普通的分页查询 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询分页数据</span></span><br><span class="line">Hibernate: <span class="keyword">select</span> user0_.id <span class="keyword">as</span> id1_0_, user0_.address <span class="keyword">as</span> address2_0_, user0_.email <span class="keyword">as</span> email3_0_, user0_.name <span class="keyword">as</span> name4_0_, user0_.sex <span class="keyword">as</span> sex5_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_ limit ?</span><br><span class="line"><span class="comment">-- 计算分页数据</span></span><br><span class="line">Hibernate: <span class="keyword">select</span> <span class="built_in">count</span>(user0_.id) <span class="keyword">as</span> col_0_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_</span><br></pre></td></tr></table></figure>

<p>第三种执行的 SQL 如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="keyword">select</span> user0_.id <span class="keyword">as</span> id1_0_, user0_.address <span class="keyword">as</span> address2_0_, user0_.email <span class="keyword">as</span> email3_0_, user0_.name <span class="keyword">as</span> name4_0_, user0_.sex <span class="keyword">as</span> sex5_0_ <span class="keyword">from</span> <span class="keyword">user</span> user0_ limit ? <span class="keyword">offset</span> ?</span><br></pre></td></tr></table></figure>

<p>通过对比可以看出，只查询偏移量，不计算分页数据，这就是 Page 和 Slice 的主要区别。我们接着看第四种测试结果。</p>
<h4 id="第四种：返回-List-lt-User-gt"><a href="#第四种：返回-List-lt-User-gt" class="headerlink" title="第四种：返回 List&lt;User&gt;"></a>第四种：返回 List<code>&lt;User&gt;</code></h4><p>得到结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;jack2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>:<span class="string">&quot;123456@126.com&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;address&quot;</span>:<span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>可以很简单地查询出来 ID=1 和 ID=2 的数据，没有分页信息。</p>
<p>上面四种方法介绍了常见的多条数据返回结果的形式，单条的查询无非就是对 JDK8 的 Optional 的支持。比如支持了 Null 的优雅判断，再一个就是支持直接返回 Entity，或者一些存在 / 不存在的 Boolean 的结果和一些 count 条数的返回结果而已。</p>
<h2 id="异步查询返回值"><a href="#异步查询返回值" class="headerlink" title="异步查询返回值"></a>异步查询返回值</h2><h3 id="Feature-CompletableFuture-ListenableFuture"><a href="#Feature-CompletableFuture-ListenableFuture" class="headerlink" title="Feature/CompletableFuture/ListenableFuture"></a>Feature/CompletableFuture/ListenableFuture</h3><p>我们可以使用 Spring 的异步方法执行Repository查询，这意味着方法将在调用时立即返回，并且实际的查询执行将发生在已提交给 Spring TaskExecutor 的任务中，比较适合定时任务的实际场景。异步使用起来比较简单，直接加@Async 注解即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>; (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; (<span class="number">2</span>)</span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>上述三个异步方法的返回结果，分别做如下解释：</p>
<ul>
<li>第一处：使用 java.util.concurrent.Future 的返回类型；</li>
<li>第二处：使用 java.util.concurrent.CompletableFuture 作为返回类型；</li>
<li>第三处：使用 org.springframework.util.concurrent.ListenableFuture 作为返回类型。</li>
</ul>
<p>以上是对 @Async 的支持，关于实际使用需要注意以下三点内容：</p>
<ul>
<li>在实际工作中，直接在 Repository 这一层使用异步方法的场景不多，一般都是把异步注解放在 Service 的方法上面，这样的话，可以有一些额外逻辑，如发短信、发邮件、发消息等配合使用；</li>
<li>使用异步的时候一定要配置线程池，这点切记，否则“死”得会很难看；</li>
</ul>
<blockquote>
<p>📌 万一失败要怎么处理？关于事务是怎么处理的呢?</p>
</blockquote>
<p>接下来看看 Repository 对 Reactive 是如何支持的。</p>
<h2 id="对-Reactive-支持-flux-与-Mono"><a href="#对-Reactive-支持-flux-与-Mono" class="headerlink" title="对 Reactive 支持 flux 与 Mono"></a>对 Reactive 支持 flux 与 Mono</h2><p>Spring Data Common 里面对 Reactive 还是有支持的，但是 Common 里面提供的只是接口，而 JPA 里面没有做相关的 Reactive 的实现，所以Spring Data JPA 不支持 Reactive</p>
<p>其他子模块，如 mongo实现了该接口</p>
<p>下面我们在 gradle 里面引用一个 Spring Data Common 的子模块 implementation ‘org.springframework.boot:spring-boot-starter-data-mongodb’ 来加载依赖，这时候我们打开 Repository 看 Hierarchy 就可以看到，这里多了一个 Mongo 的 Repository 的实现，天然地支持着 Reactive 这条线。</p>
<p><img src="http://image.leonote.cn//20200926201459.png" alt=""></p>
<p>相信到这里你能感受到 Spring Data Common 的强大支持，对 Repository 接口的不同实现也有了一定的认识。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面打开 ResultProcessor 类的源码看一下支持的类型有哪些。</p>
<p><img src="http://image.leonote.cn//20200926201742.png" alt=""></p>
<p>从上图可以看出 processResult 的时候分别对 PageQuery、Stream、Reactive 有了各自的判断，我们 debug 到这里的时候来看一下 convert，进入到类里面。</p>
<p><img src="http://image.leonote.cn//20200926201819.png" alt=""></p>
<p>可以看到 QueryExecutorConverters 里面对 JDK8、Guava、vavr 也做了各种支持，自行阅读源码</p>
<p>下表列出了 Spring Data JPA Query Method 机制支持的方法的返回值类型：</p>
<blockquote>
<p>📌 Geospatial types (such as <code>GeoResult</code>, <code>GeoResults</code>, and <code>GeoPage</code>) are available only for data stores that support geospatial queries.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Return type</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void</code></td>
<td align="left">不返回结果，一般是更新操作</td>
</tr>
<tr>
<td align="left">Primitives</td>
<td align="left">Java 的基本类型，一般常见的是统计操作 （如 long、boolean 等）</td>
</tr>
<tr>
<td align="left">Wrapper types</td>
<td align="left">Wrapper types Java 的包装类</td>
</tr>
<tr>
<td align="left"><code>T</code></td>
<td align="left">返回唯一的实体，没有查询结果返回<code>null</code> ，超过一个结果会抛出<code>IncorrectResultSizeDataAccessException</code></td>
</tr>
<tr>
<td align="left"><code>Iterator&lt;T&gt;</code></td>
<td align="left">An <code>Iterator</code>.</td>
</tr>
<tr>
<td align="left"><code>Collection&lt;T&gt;</code></td>
<td align="left">A <code>Collection</code>.</td>
</tr>
<tr>
<td align="left"><code>List&lt;T&gt;</code></td>
<td align="left">A <code>List</code>.</td>
</tr>
<tr>
<td align="left"><code>Optional&lt;T&gt;</code></td>
<td align="left">A Java 8 or Guava <code>Optional</code>. Expects the query method to return one result at most. If no result is found, <code>Optional.empty()</code> or <code>Optional.absent()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Option&lt;T&gt;</code></td>
<td align="left">Either a Scala or Vavr <code>Option</code> type. Semantically the same behavior as Java 8’s <code>Optional</code>, described earlier.</td>
</tr>
<tr>
<td align="left"><code>Stream&lt;T&gt;</code></td>
<td align="left">A Java 8 <code>Stream</code>.</td>
</tr>
<tr>
<td align="left"><code>Streamable&lt;T&gt;</code></td>
<td align="left">A convenience extension of <code>Iterable</code> that directly exposes methods to stream, map and filter results, concatenate them etc.</td>
</tr>
<tr>
<td align="left">Types that implement <code>Streamable</code> and take a <code>Streamable</code> constructor or factory method argument</td>
<td align="left">Types that expose a constructor or <code>….of(…)</code>/<code>….valueOf(…)</code> factory method taking a <code>Streamable</code> as argument. See <a href="https://docs.spring.io/spring-data/jpa/docs/2.3.4.RELEASE/reference/html/#repositories.collections-and-iterables.streamable-wrapper">Returning Custom Streamable Wrapper Types</a> for details.</td>
</tr>
<tr>
<td align="left">Vavr <code>Seq</code>, <code>List</code>, <code>Map</code>, <code>Set</code></td>
<td align="left">Vavr collection types. See <a href="https://docs.spring.io/spring-data/jpa/docs/2.3.4.RELEASE/reference/html/#repositories.collections-and-iterables.vavr">Support for Vavr Collections</a> for details.</td>
</tr>
<tr>
<td align="left"><code>Future&lt;T&gt;</code></td>
<td align="left">A <code>Future</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>CompletableFuture&lt;T&gt;</code></td>
<td align="left">A Java 8 <code>CompletableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>ListenableFuture</code></td>
<td align="left">A <code>org.springframework.util.concurrent.ListenableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td align="left"><code>Slice</code></td>
<td align="left">A sized chunk of data with an indication of whether there is more data available. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td align="left"><code>Page&lt;T&gt;</code></td>
<td align="left">A <code>Slice</code> with additional information, such as the total number of results. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td align="left"><code>GeoResult&lt;T&gt;</code></td>
<td align="left">A result entry with additional information, such as the distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>GeoResults&lt;T&gt;</code></td>
<td align="left">A list of <code>GeoResult&lt;T&gt;</code> with additional information, such as the average distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>GeoPage&lt;T&gt;</code></td>
<td align="left">A <code>Page</code> with <code>GeoResult&lt;T&gt;</code>, such as the average distance to a reference location.</td>
</tr>
<tr>
<td align="left"><code>Mono&lt;T&gt;</code></td>
<td align="left">A Project Reactor <code>Mono</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Flux&lt;T&gt;</code></td>
<td align="left">A Project Reactor <code>Flux</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flux</code> can emit also an infinite number of elements.</td>
</tr>
<tr>
<td align="left"><code>Single&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Single</code> emitting a single element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Maybe&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Maybe</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td align="left"><code>Flowable&lt;T&gt;</code></td>
<td align="left">A RxJava <code>Flowable</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flowable</code> can emit also an infinite number of elements.</td>
</tr>
</tbody></table>
<h3 id="常见的-DTO-返回结果的支持方法"><a href="#常见的-DTO-返回结果的支持方法" class="headerlink" title="常见的 DTO 返回结果的支持方法"></a>常见的 DTO 返回结果的支持方法</h3><p><strong>Projections 的概念</strong></p>
<p>Spring JPA 对 Projections 扩展的支持，这是个非常好的东西，从字面意思上理解就是映射，指的是和 DB 的查询结果的字段映射关系。一般情况下，返回的字段和 DB 的查询结果的字段是一一对应的；但有的时候，需要返回一些指定的字段，或者返回一些复合型的字段，而不需要全部返回。</p>
<p>一般的做法是自己写各种 entity 到 view 的各种 convert 的转化逻辑，而 Spring Data 正是考虑到了这一点，允许对专用返回类型进行建模，有选择地返回同一个实体的不同视图对象。</p>
<p>下面还以 User 查询对象为例，看看怎么自定义返回 DTO：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="keyword">private</span> String sex;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上面的原始 User 实体代码，如果我们只想返回 User 对象里面的 name 和 email，应该怎么做？下面介绍三种方法。</p>
<h4 id="第一种：同一张-Table，不同-Entity"><a href="#第一种：同一张-Table，不同-Entity" class="headerlink" title="第一种：同一张 Table，不同 Entity"></a>第一种：同一张 Table，不同 Entity</h4><p>首先，我们新增一个Entity类：通过 @Table 指向同一张表，这张表和 User 实例里面的表一样都是 user，完整内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserOnlyNameEmailEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，新增一个 UserOnlyNameEmailEntityRepository，做单独的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserOnlyNameEmailEntityRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserOnlyNameEmailEntity</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们的测试用例里面的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProjections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  userRepository.save(User.builder().id(<span class="number">1L</span>)</span><br><span class="line">  .name(<span class="string">&quot;jack12&quot;</span>)</span><br><span class="line">  .email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>)</span><br><span class="line">  .address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">    List&lt;User&gt; users= userRepository.findAll();</span><br><span class="line">    System.out.println(users);</span><br><span class="line">    UserOnlyNameEmailEntity uName = userOnlyNameEmailEntityRepository.getOne(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(uName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: <span class="function">insert into <span class="title">user</span> <span class="params">(address, email, name, sex, id)</span> <span class="title">values</span> <span class="params">(?, ?, ?, ?, ?)</span></span></span><br><span class="line"><span class="function">Hibernate: select user0_.id as id1_0_, user0_.address as address2_0_, user0_.email as email3_0_, user0_.name as name4_0_, user0_.sex as sex5_0_ from user user0_</span></span><br><span class="line"><span class="function">[<span class="title">User</span><span class="params">(id=<span class="number">1</span>, name=jack12, email=<span class="number">123456</span>@<span class="number">126.</span>com, sex=man, address=shanghai)</span>]</span></span><br><span class="line"><span class="function">Hibernate: select useronlyna0_.id as id1_0_0_, useronlyna0_.email as email3_0_0_, useronlyna0_.name as name4_0_0_ from user useronlyna0_ where useronlyna0_.id</span>=?</span><br><span class="line">UserOnlyNameEmailEntity(id=<span class="number">1</span>, name=jack12, email=<span class="number">123456</span>@<span class="number">126.</span>com)</span><br></pre></td></tr></table></figure>

<p>上述结果可以看到，当在 user 表里面插入了一条数据，而 userRepository 和 userOnlyNameEmailEntityRepository 查询的都是同一张表 user。</p>
<blockquote>
<p>好处：简单、方便，很容易可以想到；</p>
<p>缺点：通过两个实体都可以进行 update 操作，如果同一个项目里面这种实体比较多，</p>
<p>  到时候就容易不知道是谁更新的，从而导致出 bug 不好定位，</p>
<p>  实体职责划分不明确。</p>
</blockquote>
<h4 id="第二种：定义-DTO-类"><a href="#第二种：定义-DTO-类" class="headerlink" title="第二种：定义 DTO 类"></a>第二种：定义 DTO 类</h4><p>首先，我们新建一个 DTO 类来返回我们想要的字段，它是 UserOnlyNameEmailDto，用来接收 name、email 两个字段的值，具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserOnlyNameEmailDto</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name, email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，在 UserRepository 里面做如下用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//测试只返回name和email的DTO</span></span><br><span class="line">    <span class="function">UserOnlyNameEmailDto <span class="title">findByEmail</span><span class="params">(String email)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，测试用例里面写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProjections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userRepository.save(User.builder().id(<span class="number">1L</span>)</span><br><span class="line">                    .name(<span class="string">&quot;jack12&quot;</span>).email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>)</span><br><span class="line">                    .address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">UserOnlyNameEmailDto userOnlyNameEmailDto = userRepository.findByEmail(<span class="string">&quot;123456@126.com&quot;</span>);</span><br><span class="line">System.out.println(userOnlyNameEmailDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: select user0_.name as col_0_0_, user0_.email as col_1_0_ from user user0_ where user0_.email=?</span><br><span class="line">UserOnlyNameEmailDto(name=jack12, email=<span class="number">123456</span>@<span class="number">126.</span>com)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，如果我们去看源码的话，看关键的 PreferredConstructorDiscoverer 类时会发现，<strong>UserDTO 里面只能有一个全参数构造方法</strong>，如下所示：</p>
<p><img src="http://image.leonote.cn//20200926202327.png" alt=""></p>
<p>如上图所示，Constructor 选择的时候会帮我们做构造参数的选择，如果 DTO 里面有多个构造方法，就会报转化错误的异常，这一点需要注意，异常是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">No converter found capable of converting from type [com.example.jpa.example1.User] to type [com.example.jpa.example1.UserOnlyNameEmailDto </span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点：返回的结果不需要是个实体对象，对 DB 不能进行除了查询之外的任何操作；</p>
<p>缺点：有 set 方法还可以改变里面的值，构造方法不能更改，必须全参数，</p>
<p> 这样如果是不熟悉 JPA 的新人操作的时候很容易引发 Bug。</p>
</blockquote>
<h4 id="第三种：定义-DTO-接口"><a href="#第三种：定义-DTO-接口" class="headerlink" title="第三种：定义 DTO 接口"></a>第三种：定义 DTO 接口</h4><p>我们再来学习一种返回不同字段的方式，这种方式与上面两种的区别是只需要定义接口，它的好处是只读，不需要添加构造方法，我们使用起来非常灵活，一般很难产生 Bug，那么它怎么实现呢？</p>
<p>首先，定义一个 UserOnlyName 的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserOnlyName</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getEmail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口的方式返回DTO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">UserOnlyName <span class="title">findByAddress</span><span class="params">(String address)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，测试用例的写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProjections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userRepository.save(User.builder().name(<span class="string">&quot;jack12&quot;</span>)</span><br><span class="line">					.email(<span class="string">&quot;123456@126.com&quot;</span>).sex(<span class="string">&quot;man&quot;</span>)</span><br><span class="line">					.address(<span class="string">&quot;shanghai&quot;</span>).build());</span><br><span class="line">UserOnlyName userOnlyName = userRepository.findByAddress(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">System.out.println(userOnlyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们的运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hibernate: select user0_.name as col_0_0_, user0_.email as col_1_0_ from user user0_ where user0_.address=?</span><br><span class="line">org.springframework.data.jpa.repository.query.AbstractJpaQuery$TupleConverter$TupleBackedMap@1d369521</span><br></pre></td></tr></table></figure>

<p>这个时候会发现我们的 userOnlyName 接口成了一个代理对象，里面通过 Map 的格式包含了我们的要返回字段的值（如：name、email），我们用的时候直接调用接口里面的方法即可，如 userOnlyName.getName() 即可；这种方式的优点是接口为只读，并且语义更清晰，所以这种是我比较推荐的做法。</p>
<p>其中源码是如何实现的，我来说一个类，你可以通过 debug，看一下最终 DTO 和接口转化执行的 query 有什么不同，看下图中 debug 显示的 Query 语句的位置：</p>
<p>图一：是返回 DTO 接口形式的 query 生成的 JPQL：</p>
<p><img src="http://image.leonote.cn//20200926202547.png" alt=""></p>
<p>图二：是返回 DTO 类的时候 QueryStructure 生成的 JPQL 语句：</p>
<p><img src="http://image.leonote.cn//20200926202709.png" alt=""></p>
<p>两种最大的区别是 DTO 类需要构造方法 new 一个对象出来，这就是我们第二种方法里面需要注意的 DTO 构造函数的问题；而通过图一我们可以看到接口直接通过 as 别名，映射成 hashmap 即可，非常灵活。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>自定义返回值</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream API</title>
    <url>/2020/11/05/Stream%20API/</url>
    <content><![CDATA[<h1 id="Stream-简介"><a href="#Stream-简介" class="headerlink" title="Stream 简介"></a>Stream 简介</h1><h2 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h2><p><em>Stream</em> 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。</p>
<blockquote>
<p><strong>与Iterator的异同</strong></p>
<p>​    相同点： 单向的，数据只能遍历一次。</p>
<p>​    不同点： <em>stream</em>可以并行操作</p>
</blockquote>
<p><em>Stream</em> 的另外一个特点是，==数据源本身可以是无限的==。</p>
<p><em>Stream</em> 的并行操作依赖于 Java7 中引入的 Fork/Join 框架来拆分任务和加速处理过程。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java 的并行API演变历程基本如下：</span><br><span class="line">	1. 1.0-1.4 中的 java.lang.Thread</span><br><span class="line">	2. 5.0 中的 java.util.concurrent</span><br><span class="line">	3. 6.0 中的 Phasers 等</span><br><span class="line">	4. 7.0 中的 Fork&#x2F;Join 框架</span><br><span class="line">	5. 8.0 中的 Lambda</span><br></pre></td></tr></table></figure>



<h2 id="生成-Stream-Source方式"><a href="#生成-Stream-Source方式" class="headerlink" title="生成 Stream Source方式"></a>生成 Stream Source方式</h2><h3 id="Collection-and-Array"><a href="#Collection-and-Array" class="headerlink" title="Collection and Array"></a>Collection and Array</h3><ul>
<li><code>Collection.stream()</code></li>
<li><code>Collection.parallelStream()</code></li>
<li><code>Arrays.stream(T array)</code> or <code>Stream.of()</code></li>
</ul>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><ul>
<li><code>java.io.BufferedReader.lines()</code></li>
</ul>
<h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><ul>
<li><code>java.util.stream.IntStream.range()</code></li>
<li><code>java.nio.file.Files.walk()</code></li>
</ul>
<h3 id="自己构建"><a href="#自己构建" class="headerlink" title="自己构建"></a>自己构建</h3><ul>
<li><code>java.util.Spliterator</code></li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul>
<li><code>Random.ints()</code></li>
<li><code>BitSet.stream()</code></li>
<li><code>Pattern.splitAsStream(java.lang.CharSequence)</code></li>
<li><code>JarFile.stream()</code></li>
</ul>
<p><strong>常见的<em>stream</em>接口继承关系如图</strong></p>
<p><img src="image/1.png" alt="img"></p>
<p>对于基本数值型，目前有三种对应的包装类型 Stream：</p>
<p><code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code>。当然我们也可以用 <code>Stream&lt;Integer&gt;</code>、<code>Stream&lt;Long&gt;</code>、<code>Stream&lt;Double&gt;</code>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</p>
<blockquote>
<p><strong>为什么为不同数据类型设置不同<em>stream</em>接口</strong></p>
<ol>
<li>提高性能</li>
<li>增加特定接口函数</li>
</ol>
<p><strong>为什么不把<code>IntStream</code>等设计成<code>Stream</code>的子接口？毕竟这接口中的方法名大部分是一样的。</strong></p>
<p>​    虽然这些方法的名字相同，但是返回类型不同，如果设计成父子接口关系，这些方法将不能共存，</p>
<p>​    因为Java不允许只有返回类型不同的方法重载。</p>
</blockquote>
<p>虽然大部分情况下<em>stream</em>是容器调用<code>Collection.stream()</code>方法得到的，但<em>stream</em>和<em>collections</em>有以下不同：</p>
<ul>
<li><strong>无存储</strong>。<em>stream</em>不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li><strong>为函数式编程而生</strong>。对<em>stream</em>的任何修改都不会修改背后的数据源，比如对<em>stream</em>执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新<em>stream</em>。</li>
<li><strong>惰式执行</strong>。<em>stream</em>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li><strong>可消费性</strong>。<em>stream</em>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<h1 id="Stream-操作"><a href="#Stream-操作" class="headerlink" title="Stream 操作"></a>Stream 操作</h1><p>对<em>stream</em>的操作分为为两类，<strong>中间操作(intermediate)和结束操作(terminal)</strong>，二者特点是：</p>
<ol>
<li><strong>中间操作总是会惰式执行</strong>，调用中间操作只会生成一个标记了该操作的新<em>stream</em>，仅此而已。</li>
<li><strong>结束操作会触发实际计算</strong>，计算发生时会把所有中间操作积攒的操作以<em>pipeline</em>的方式执行，这样可以减少迭代次数。计算完成之后<em>stream</em>就会失效。</li>
</ol>
<p><strong><code>Stream</code>接口的部分常见方法</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>接口方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>intermediate</strong></td>
<td><code>concat()</code> 、<code>distinct()</code>、 <code>filter()</code>、 <code>flatMap()</code>、 <code>limit()</code>、 <code>map()</code>、 <code>peek()</code>、  <code>skip()</code>、 <code>sorted()</code> 、<code>parallel()</code> 、<code>sequential()</code>、 <code>unordered()</code></td>
</tr>
<tr>
<td><strong>terminal</strong></td>
<td><code>forEach()</code>、<code>forEachOrdered()</code>、<code>findFirst()</code>、 <code>findAny()</code> 、<code>count()</code>  、<code>max()</code>、 <code>min()</code>、<code>anyMatch()</code>、<code>allMatch()</code> 、<code>noneMatch()</code>、<code>toArray()</code>、 <code>collect()</code>、<code>reduce()</code></td>
</tr>
<tr>
<td><strong>short-circuiting</strong></td>
<td><code>anyMatch()</code>、 <code>allMatch()</code>、 <code>noneMatch()</code>、 <code>findFirst()</code>、 <code>findAny()</code>、 <code>limit()</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>区分中间操作和结束操作最简单的方法</strong></p>
<p>​    就是看方法的返回值，返回值为<em>stream</em>的大都是中间操作，否则是结束操作。</p>
</blockquote>
<h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><h3 id="forEach-forEachOrdered"><a href="#forEach-forEachOrdered" class="headerlink" title="forEach() / forEachOrdered()"></a>forEach() / forEachOrdered()</h3><p><code>void forEach(Consumer&lt;? super E&gt; action)</code></p>
<p><code>void forEachOrdered(Consumer&lt;? super E&gt; action)</code></p>
<p>作用是对容器中的每个元素执行<code>action</code>指定的动作，也就是对元素进行遍历。</p>
<p>由于<code>forEach()</code> / <code>forEachOrdered()</code> 是结束方法，上述代码会立即执行，输出所有字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line"> Stream.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>).parallel().forEach(System.out::println);</span><br><span class="line"> Stream.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>).parallel().forEachOrdered(System.out::println);</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>区别</strong></p>
<p>​    在并行流中，<code>forEachOrdered()</code>会保证是顺序执行，而<code>forEach()</code>不会。</p>
</blockquote>
<h3 id="findFirst-findAny"><a href="#findFirst-findAny" class="headerlink" title="findFirst() / findAny()"></a>findFirst() / findAny()</h3><p>这是一个 terminal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p>
<p>返回值类型：Optional</p>
<p>目的是尽可能避免 <code>NullPointerException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String strA = <span class="string">&quot; abcd &quot;</span>;</span><br><span class="line">	String strB = <span class="keyword">null</span>;</span><br><span class="line">    print(strA);</span><br><span class="line">	print(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	print(strB);</span><br><span class="line">	getLength(strA);</span><br><span class="line">	getLength(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	getLength(strB);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Java 8</span></span><br><span class="line">     Optional.ofNullable(text).ifPresent(System.out::println);</span><br><span class="line">     <span class="comment">// Pre-Java 8</span></span><br><span class="line">     <span class="keyword">if</span> (text != <span class="keyword">null</span>) &#123;</span><br><span class="line">         System.out.println(text);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Java 8</span></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(text).map(String::length).orElse(-<span class="number">1</span>);</span><br><span class="line">     <span class="comment">// Pre-Java 8</span></span><br><span class="line">    <span class="comment">// return if (text != null) ? text.length() : -1;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>



<h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>求结果的个数，类似于list的size()方法</p>
<p>返回值：long型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = Stream.of(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;33&quot;</span>).filter(s -&gt; s.length() == <span class="number">1</span>).count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure>



<h3 id="max-min"><a href="#max-min" class="headerlink" title="max() / min()"></a>max() / min()</h3><p>求最大值，最小值</p>
<p>参数：Comparator接口</p>
<p>返回值：optional</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = Stream.of(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;33&quot;</span>).max((s1, s2) -&gt; s1.length() - s2.length()).get();</span><br><span class="line">String str2 = Stream.of(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;33&quot;</span>).max(Comparator.comparingInt(String::length)).get();</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line">String str3 = Stream.of(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;33&quot;</span>).min((s1, s2) -&gt; s1.length() - s2.length()).get();</span><br><span class="line">String str4 = Stream.of(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;33&quot;</span>).min(Comparator.comparingInt(String::length)).get();</span><br><span class="line">System.out.println(str3);</span><br><span class="line">System.out.println(str4);</span><br></pre></td></tr></table></figure>



<h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch()"></a>anyMatch()</h3><p>查找<em>stream</em>中是否存在任何一个元素满足匹配条件，如果条件为true 就停止遍历，否则继续遍历。</p>
<p>参数：Predicate接口</p>
<p>返回值：boolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isStartWithA = Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">		.map(String::toUpperCase)</span><br><span class="line">		.anyMatch(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">System.out.println(isStartWithA);</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>上述例子</strong></p>
<p>​    遍历到a2，则满足<code>anyMatch</code>的条件，则退出遍历，并返回true。</p>
</blockquote>
<h3 id="allMatch-noneMatch"><a href="#allMatch-noneMatch" class="headerlink" title="allMatch() / noneMatch()"></a>allMatch() / noneMatch()</h3><p><code>allMatch()</code>:  查找<em>stream</em>中的所有元素是否==都满足==给定的匹配条件，如果条件为 false 就停止遍历，否则继续遍历。</p>
<p><code>noneMatch()</code>:  查找<em>stream</em>中的所有元素是否==都不满足==给定的匹配条件，如果条件为 true 就停止遍历，否则继续遍历。</p>
<p>参数：Predicate 接口</p>
<p>返回值：boolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isStartWithA = Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">		.map(String::toUpperCase)</span><br><span class="line">		.allMatch(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">	  <span class="comment">//.noneMatch(s -&gt; s.startsWith(&quot;A&quot;));</span></span><br><span class="line">System.out.println(isStartWithA);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>查看执行流程，可以选择在表达式里输出检验：</p>
<p>​    如 <code>allMatch()</code>，可以替换成<code>noneMatch()</code> 和<code>anyMatch()</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;)</span><br><span class="line">    .allMatch(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;allMatch: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray()"></a>toArray()</h3><p><code>toArray()</code> 将流转换为数组，有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray()</span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</span><br></pre></td></tr></table></figure>



<p>无参的，返回一个object对象数组，一般没什么用。</p>
<p>有参的，需要写一个<code>funcation&lt;T,R&gt;</code>接口， 而<code>IntFuncation&lt;R&gt;</code> 是<code>funcation&lt;T,R&gt;</code>接口的子接口，规定了输入是<code>int</code>类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// :: 表示引用，一种是方法(静态，实例)的引用;</span></span><br><span class="line"><span class="comment">//            一种的构造方法的引用(构造的需要反着写,如new String[] &gt; String[]::new)</span></span><br><span class="line"></span><br><span class="line">IntFunction&lt;String[]&gt; function = String[]::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">String[] as = Stream.of(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>).parallel().toArray(function);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(as));</span><br></pre></td></tr></table></figure>



<h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p><strong>1. Collection, Collections, collect, Collector, Collectors</strong></p>
<p><code>Collection</code>是Java集合的祖先接口。<br><code>Collections</code>是<code>java.util</code>包下的一个工具类，内涵各种处理集合的静态方法。<br><code>java.util.stream.Stream#collect(java.util.stream.Collector&lt;? super T,A,R&gt;)</code>是Stream的一个函数，负责收集流。<br><code>java.util.stream.Collector</code> 是一个收集函数的接口, 声明了一个收集器的功能。<br><code>java.util.stream.Collectos</code>则是一个收集器的工具类，内置了一系列收集器实现。</p>
<p>将 stream 转换成 收集器，有两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span></span><br></pre></td></tr></table></figure>



<p>第一种构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>, <span class="string">&quot;333&quot;</span>, <span class="string">&quot;444&quot;</span>, <span class="string">&quot;555&quot;</span>);</span><br><span class="line">        <span class="comment">//Supplier&lt;R&gt;接口 用来创建并返回一个指定数据类型的对象</span></span><br><span class="line">        <span class="comment">//BiConsumer&lt;R, ? super T&gt; accumulator接口 用来声明一些操作。</span></span><br><span class="line">            <span class="comment">//	* 参数R 是指supplier创建出来的对象，</span></span><br><span class="line">            <span class="comment">//	* 参数T 是指每次迭代的对象</span></span><br><span class="line">        <span class="comment">//BiConsumer&lt;R, R&gt; combiner接口 指定执行的参数类型，以及返回值类型</span></span><br><span class="line"></span><br><span class="line"> HashMap&lt;String, String&gt; map = list.stream()</span><br><span class="line">     .collect(HashMap::<span class="keyword">new</span>,</span><br><span class="line">             (hashMap, str) -&gt; hashMap.put(str, str),</span><br><span class="line"><span class="comment">//           (hashMap, hashMap2) -&gt; hashMap.putAll(hashMap2));</span></span><br><span class="line"><span class="comment">//           HashMap::putAll);</span></span><br><span class="line">             Map::putAll);</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>解释</strong></p>
<p>​    1、每次循环都创建一个hashMap</p>
<p>​    2、每次循环都把当前遍历的值，存储在创建出来的hashMap中</p>
<p>​    3、最后再用上一次的hashMap，putAll这次遍历的hashMap，最后遍历完后就会返回一个总的Map</p>
</blockquote>
<p>第二种构造方法：</p>
<p>​    使用Collectors工具类</p>
<p><strong>2.Collectors</strong></p>
<p>collect里面的操作稍微复杂一点。</p>
<p>可以把stream，使用某些数据结构存储起来。而collectors就是方便我们构造收集器的。</p>
<p><code>Collectors.toList()</code> ： 构造一个list</p>
<p><code>Collectors.toSet()</code> ： 构造一个set</p>
<p><code>Collectors.toCollection(ArrayList::new)</code> ： 构造一个自定义收集器，参数用自定义收集器，这里用list只是方便举例</p>
<p><code>Collectors.joining()</code> ： ==构造一个string==，参数是分割符，前缀，后缀</p>
<p><code>Collectors.toMap()</code>  和 <code>Collectors.toConcurrentMap()</code> 有三个方法</p>
<p>构造方法差不多，这里只列举toMap的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                                   Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper)</span><br><span class="line">    </span><br><span class="line">Collector&lt;T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                                   Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">                                   BinaryOperator&lt;U&gt; mergeFunction)</span><br><span class="line">    </span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">                               Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">                               BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                               Supplier&lt;M&gt; mapSupplier)</span><br></pre></td></tr></table></figure>

<p>​    </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">        <span class="comment">//Function.identity() : 代表当前遍历的对象</span></span><br><span class="line">        <span class="comment">//第一种构造方法</span></span><br><span class="line">        <span class="comment">//Function&lt;T, K&gt; : 接口，第一个参数是输入，第二个参数是输出 </span></span><br><span class="line">		<span class="comment">//如 Function&lt;Party,String&gt; fun = party -&gt; party.getPartyType()</span></span><br><span class="line"> Map&lt;String, String&gt; collect = list.stream()</span><br><span class="line">    .collect(Collectors.toMap(Function.identity(), Function.identity()));</span><br><span class="line"></span><br><span class="line"> Map&lt;String, String&gt; collect1 = list.stream()</span><br><span class="line">     .collect(Collectors.toMap(String::toUpperCase, String::toLowerCase));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果key,value是空的话，会报空指针异常，</span></span><br><span class="line">		<span class="comment">//因为Collectors.toMap()底层使用Map.merge()，merge中key, value不能为空</span></span><br><span class="line"> Map&lt;String, String&gt; collect2 = list.stream()</span><br><span class="line"><span class="comment">//   .collect(Collectors.toMap(String::toUpperCase, null));</span></span><br><span class="line">     .collect(Collectors.toMap(<span class="keyword">null</span>, String::toUpperCase));</span><br><span class="line"> System.out.println(collect2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种构造方法</span></span><br><span class="line">        <span class="comment">// 定义当key重复时的操作，Collectors.toMap()方法如果key相同，会报异常，可以自定义当key重复时的操作</span></span><br><span class="line">        <span class="comment">// BinaryOperator&lt;U&gt; mergeFunction</span></span><br><span class="line"> Map&lt;String, String&gt; collect3 = list.stream()</span><br><span class="line">     .collect(Collectors.toMap(</span><br><span class="line">                String::toUpperCase,</span><br><span class="line">                String::toLowerCase,</span><br><span class="line">                (oldValue, newValue) -&gt; oldValue));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种构造方法</span></span><br><span class="line">        <span class="comment">//Supplier&lt;M&gt; mapSupplier :自定义使用Map的类型</span></span><br><span class="line"> Map&lt;String, String&gt; collect4 = list.stream()</span><br><span class="line">     .collect(Collectors.toMap(</span><br><span class="line">                String::toUpperCase,</span><br><span class="line">                String::toLowerCase,</span><br><span class="line">                (oldValue, newValue) -&gt; oldValue,</span><br><span class="line"><span class="comment">//              HashMap::new));</span></span><br><span class="line"><span class="comment">//              ConcurrentHashMap::new));</span></span><br><span class="line">                LinkedHashMap::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>toMap 和 toConcurrentMap 的异同</p>
</blockquote>
<p><code>Collectors.summarizingInt(String::length)</code></p>
<p>​    同理有Double，Long</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">IntSummaryStatistics collect = list.stream()</span><br><span class="line">.collect(Collectors.summarizingInt(String::length));</span><br><span class="line">System.out.println(collect.getMax());</span><br><span class="line">System.out.println(collect.getMin());</span><br><span class="line">System.out.println(collect.getSum());</span><br><span class="line">System.out.println(collect.getAverage());</span><br><span class="line">System.out.println(collect.getCount());</span><br></pre></td></tr></table></figure>

<p>可以统一求长度最大值，最小值，平均数，求和，求个数</p>
<p><code>Collectors.groupingBy()</code> 有三个构造方法，列表分组</p>
<p>按function的条件，分成多个组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br><span class="line"></span><br><span class="line">Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                         Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) </span><br><span class="line">                                         </span><br><span class="line">Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                 Supplier&lt;M&gt; mapFactory,</span><br><span class="line">                                 Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>



<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; collect =  list.stream()</span><br><span class="line">     .collect(Collectors.groupingBy(String::length));</span><br><span class="line">Map&lt;Integer, Long&gt; collect1 =  list.stream()</span><br><span class="line">     .collect(Collectors.groupingBy(String::length, counting()));</span><br></pre></td></tr></table></figure>



<p><code>Collectors.partitioningBy()</code> 两个构造方法，列表分割</p>
<p>按照Predicate，分割成两组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt;)</span><br><span class="line">Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">                                                Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) </span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分割数据块</span></span><br><span class="line">Map&lt;Boolean, List&lt;Integer&gt;&gt; collectParty = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">		.collect(Collectors.partitioningBy(it -&gt; it % <span class="number">2</span> == <span class="number">0</span>));</span><br><span class="line">List&lt;Integer&gt; integers = collectParty.get(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(integers);</span><br><span class="line"></span><br><span class="line">Map&lt;Boolean, Long&gt; partiCount = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">           .collect(Collectors.partitioningBy(it -&gt; it % <span class="number">2</span> == <span class="number">0</span>,</span><br><span class="line">           Collectors.counting()));</span><br><span class="line">System.out.println(<span class="string">&quot;partiCount: &quot;</span> + partiCount);</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="comment">// partiCount: &#123;false=2, true=2&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>收集器的构成</strong></p>
<p><strong>1.</strong> 创建一个新的结果容器(supplier())</p>
<p><strong>2.</strong>  将一个新的数据元素合并到一个结果容器中(accumulator())</p>
<p><strong>3.</strong> 将两个结果容器合并成一个(combiner())</p>
<p><strong>4.</strong> 在容器上执行一个可选的最终转换 (finisher()) </p>
<table>
<thead>
<tr>
<th>收集器参数列表</th>
</tr>
</thead>
<tbody><tr>
<td><code>toList()</code></td>
</tr>
<tr>
<td><code>toSet()</code></td>
</tr>
<tr>
<td><code>toCollection(Supplier&lt;C&gt;)</code></td>
</tr>
<tr>
<td><code>counting()</code></td>
</tr>
<tr>
<td><code>collectingAndThen(Collector&lt;T, A, R&gt;, Function&lt;R, RR&gt;)</code></td>
</tr>
<tr>
<td><code>summingInt(ToIntFunction&lt;? super T&gt;)</code>                                                                                                       <code>summingLong(ToLongFunction&lt;? super T&gt;)</code>                                                                                  <code>summingDouble(ToDoubleFunction&lt;? super T&gt;)</code></td>
</tr>
<tr>
<td><code>maxBy(Comparator&lt;? super T&gt;)</code></td>
</tr>
<tr>
<td><code>minBy(Comparator&lt;? super T&gt;)</code></td>
</tr>
<tr>
<td><code>reducing(BinaryOperator&lt;T&gt;)</code>                                                                                                                                                                        <code>reducing(T, BinaryOperator&lt;T&gt;)</code>                                                                                                                                                                  <code>reducing(U, Function&lt;? super T, ? extends U&gt;, BinaryOperator&lt;U&gt;)</code></td>
</tr>
<tr>
<td><code>joining()</code>                                                                                                                                                                                           <code>joining(CharSequence)</code>                                                                                                                                                               <code>joining(CharSequence, CharSequence, CharSequence)</code></td>
</tr>
<tr>
<td><code>mapping(Function&lt;? super T, ? extends U&gt;, Collector&lt;? super U, A, R&gt;)</code></td>
</tr>
<tr>
<td><code>toMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;)</code>                                                              <code>toMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;, BinaryOperator&lt;U&gt;)</code>                     <code>toMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;, BinaryOperator&lt;U&gt;, Supplier&lt;M&gt;)</code> <code>toConcurrentMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;)</code>                          <code>toConcurrentMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;, BinaryOperator&lt;U&gt;)</code> <code>toConcurrentMap(Function&lt;? super T, ? extends K&gt;, Function&lt;? super T, ? extends U&gt;, BinaryOperator&lt;U&gt;, Supplier&lt;M&gt;)</code></td>
</tr>
<tr>
<td><code>groupingBy(Function&lt;? super T, ? extends K&gt;)</code>                                                                                                             <code>groupingBy(Function&lt;? super T, ? extends K&gt;, Supplier&lt;M&gt;, Collector&lt;? super T, A, D&gt;)</code>                                                          <code>groupingBy(Function&lt;? super T, ? extends K&gt;, Collector&lt;? super T, A, D&gt;)</code>                                   <code>groupingByConcurrent(Function&lt;? super T, ? extends K&gt;)</code>                                                                    <code>groupingByConcurrent(Function&lt;? super T, ? extends K&gt;, Supplier&lt;M&gt;, Collector&lt;? super T, A, D&gt;)</code> <code>groupingByConcurrent(Function&lt;? super T, ? extends K&gt;, Collector&lt;? super T, A, D&gt;)</code></td>
</tr>
<tr>
<td><code>partitioningBy(Predicate&lt;? super T&gt;)</code>                                                                                                                         <code>partitioningBy(Predicate&lt;? super T&gt;, Collector&lt;? super T, A, D&gt;)</code></td>
</tr>
<tr>
<td><code>averagingDouble(ToDoubleFunction&lt;? super T&gt;)</code>                                                                                            <code>averagingInt(ToIntFunction&lt;? super T&gt;)</code>                                                                                                          <code>averagingLong(ToLongFunction&lt;? super T&gt;)</code></td>
</tr>
<tr>
<td><code>summarizingDouble(ToDoubleFunction&lt;? super T&gt;)</code>                                                                             <code>summarizingInt(ToIntFunction&lt;? super T&gt;)</code>                                                                                     <code>summarizingLong(ToLongFunction&lt;? super T&gt;)</code></td>
</tr>
</tbody></table>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>方式一：</p>
<p>第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional accResult = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">        .reduce((acc, item) -&gt; &#123;</span><br><span class="line">            acc += item;</span><br><span class="line">            <span class="keyword">return</span> acc;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>方式二：在方式一的基础上，加上初始化的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> accResult = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">            .reduce(<span class="number">0</span>, (acc, item) -&gt; &#123;</span><br><span class="line">                acc += item;</span><br><span class="line">                <span class="keyword">return</span> acc;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>





<h2 id="Intermediate"><a href="#Intermediate" class="headerlink" title="Intermediate"></a>Intermediate</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></p>
<p>作用是返回一个只包含满足predicate条件元素的Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>)</span><br><span class="line">      .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>



<blockquote>
<p><strong>注意</strong></p>
<p>​    由于filter()是个中间操作，如果只调用filter()不会有实际计算，因此也不会输出任何信息。</p>
<p>​    filter 保留条件为true的元素。</p>
</blockquote>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p><code>Stream&lt;T&gt; distinct()</code></p>
<p>作用是返回一个去除重复元素之后的Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.distinct()</span><br><span class="line">	  .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>



<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h3><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序</p>
<p><code>分别为Stream&lt;T&gt;　sorted()和Stream&lt;T&gt;　sorted(Comparator&lt;? super T&gt; comparator)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length())</span><br><span class="line">      .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>上述代码将输出按照长度升序排序后的字符串</p>
</blockquote>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)，</code></p>
<p>作用是返回一个对当前所有元素执行mapper之后的结果组成的Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase())</span><br><span class="line">      .forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>上述代码将输出原字符串的大写形式。</p>
</blockquote>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code></p>
<p>作用是对每个元素执行mapper指定的操作，并用所有mapper返回的<em>stream</em>中的元素组成一个新的<em>stream</em>作为最终返回结果。</p>
<p>通俗的讲<code>flatMap()</code>的作用就相当于把原<em>stream</em>中的所有元素都”摊平”之后组成的<em>stream</em>，转换前后元素的个数和类型都可能会改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream())</span><br><span class="line">      .forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>



<blockquote>
<p>上述代码中，原来的<em>stream</em>中有两个元素，分别是两个<code>List&lt;Integer&gt;</code>，执行<code>flatMap()</code>之后，将每个List都“摊平”成了一个个的数字，所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字。</p>
</blockquote>
<p><strong>图示</strong></p>
<p><img src="image/2.png" alt="Stream flatMap"></p>
<h3 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h3><p>跳过前面 n 个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = list.stream().skip(<span class="number">3</span>).collect(toList());</span><br><span class="line">System.out.println(list2); <span class="comment">//[DDD, EEE]</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; first = list.stream().skip(<span class="number">2</span>).findFirst();</span><br><span class="line">System.out.println(first.get());<span class="comment">//CCCC</span></span><br></pre></td></tr></table></figure>



<h3 id="limit"><a href="#limit" class="headerlink" title="limit()"></a>limit()</h3><p>获取限定个数的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = list.stream().limit(<span class="number">2</span>).collect(toList());</span><br><span class="line">System.out.println(list2); <span class="comment">//[A, BBB]</span></span><br><span class="line"></span><br><span class="line">Optional&lt;String&gt; first = list.stream().limit(<span class="number">2</span>).findFirst();</span><br><span class="line">System.out.println(first.get());<span class="comment">//A</span></span><br></pre></td></tr></table></figure>



<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>静态方法，把两个Stream拼在一起</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">List&lt;String&gt; list2 = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">List&lt;String&gt; collect = </span><br><span class="line">             Stream.concat(list.stream(), list2.stream())</span><br><span class="line">    		  .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect); <span class="comment">//[A, BBB, CCCC, DDD, EEE, A, BBB, CCCC, DDD, EEE]</span></span><br></pre></td></tr></table></figure>



<h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p>可以做一些即时的操作，功能和forEach相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">       <span class="comment">//ABBBCCCCDDDEEE</span></span><br><span class="line">List&lt;String&gt; collect = list.stream()</span><br><span class="line">				.peek(System.out::print)</span><br><span class="line">				.filter(s -&gt; s.length() == <span class="number">3</span>)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(collect);<span class="comment">//[BBB, DDD, EEE]</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>和foreach的不同点：</p>
<p>​    peek: 生成一个包含原<em>stream</em>的所有元素的新<em>stream</em>，同时会提供一个消费函数（Consumer实例），</p>
<p>​           新<em>stream</em>每个元素被消费的时候都会执行给定的消费函数；</p>
<p>​    通俗的讲：peek是个中间操作，它提供了一种对流中所有元素操作的方法，而不会把这个流消费掉</p>
<p>​                （foreach会把流消费掉）</p>
</blockquote>
<h3 id="parallel"><a href="#parallel" class="headerlink" title="parallel()"></a>parallel()</h3><p>将<em>stream<em>变成 并行</em>stream</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Lists.newArrayList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCCC&quot;</span>, <span class="string">&quot;DDD&quot;</span>, <span class="string">&quot;EEE&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> isParallel = list.stream().parallel().isParallel();</span><br><span class="line">System.out.println(isParallel);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> parallel = list.parallelStream().isParallel();</span><br><span class="line">System.out.println(parallel); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h3 id="sequential"><a href="#sequential" class="headerlink" title="sequential()"></a>sequential()</h3><h3 id="unordered"><a href="#unordered" class="headerlink" title="unordered()"></a>unordered()</h3>]]></content>
      <categories>
        <category>JDK</category>
        <category>JDK8</category>
      </categories>
      <tags>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 事务与连接池</title>
    <url>/2020/11/18/SpringDataJpa%E4%BA%8B%E5%8A%A1%E4%B8%8E%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-事务与连接池"><a href="#Spring-Data-Jpa-事务与连接池" class="headerlink" title="Spring Data Jpa 事务与连接池"></a>Spring Data Jpa 事务与连接池</h1><h2 id="事务的基本原理"><a href="#事务的基本原理" class="headerlink" title="事务的基本原理"></a>事务的基本原理</h2><p>以 MySQL 5.7 为例：</p>
<p>当 MySQL 使用 InnoDB 数据库引擎的时候，数据库是对事务有支持的。而事务最主要的作用是保证数据 ACID 的特性，即原子性（<strong>A</strong>tomicity）、一致性（<strong>C</strong>onsistency）、隔离性（<strong>I</strong>solation）、持久性（<strong>D</strong>urability）。分别做如下解释：</p>
<ul>
<li><strong>原子性</strong>： 是指一个事务（Transaction）中的所有操作，要么全部完成，要么全部回滚，而不会有中间某个数据单独更新的操作。事务在执行过程中一旦发生错误，会被回滚（Rollback）到此次事务开始之前的状态，就像这个事务从来没有执行过一样。</li>
<li><strong>一致性</strong>： 是指事务操作开始之前，和操作异常回滚以后，数据库的完整性没有被破坏。数据库事务 commit 之后，数据也是按照我们预期正确执行的。即要通过事务保证数据的正确性。</li>
<li><strong>持久性</strong>： 是指事务处理结束后，对数据的修改进行了持久化的永久保存，即便系统故障也不会丢失，其实就是保存到硬盘。</li>
<li><strong>隔离性</strong>： 是指数据库允许多个连接，同时并发多个事务，又对同一个数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据不一致的现象。而 MySQL 里面就是我们经常说的事务的四种隔离级别，即读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
</ul>
<h3 id="MySQL-事务的隔离级别"><a href="#MySQL-事务的隔离级别" class="headerlink" title="MySQL 事务的隔离级别"></a>MySQL 事务的隔离级别</h3><ul>
<li><p><strong>Read Uncommitted（读取未提交内容）</strong>：此隔离级别，表示所有正在进行的事务都可以看到其他未提交事务的执行结果。不同事务之间读取到其他事务中未提交的数据，通常这种情况也被称之为脏读（Dirty Read），会造成数据的逻辑处理错误，也就是我们在多线程里面经常说的数据不安全了。在业务开发中，几乎很少见到使用的，因为它的性能也不比其他级别要好多少。</p>
</li>
<li><p><strong>Read Committed（读取提交内容）</strong>： 此隔离级别是指，在一个事务相同的两次查询可能产生的结果会不一样，也就是第二次查询能读取到其他事务已经提交的最新数据。也就是我们常说的不可重复读（Unrepeatable Read）的事务隔离级别。因为同一事务的其他实例在该实例处理期间，可能会对其他事务进行新的 commit，所以在同一个事务中的同一 select 上，多次执行可能返回不同结果。这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的隔离级别）。</p>
</li>
<li><p><strong>Repeatable Read（可重读）</strong>： 这是 MySQL 的默认事务隔离级别，它确保同一个事务多次查询相同的数据，能读到相同的数据。即使多个事务的修改已经 commit，本事务如果没有结束，永远读到的是相同数据，要注意它与Read Committed 的隔离级别的区别，是正好相反的。这会导致另一个棘手的问题：幻读 （Phantom Read），即读到的数据可能不是最新的。这个是最常见的，举个例子来说明。</p>
<p><strong>第一步：用工具打开一个数据库的 DB 连接，如图所示。</strong></p>
<p><img src="http://image.leonote.cn/20201118125513.png" alt=""></p>
<p>查看一下数据库的事务隔离级别。</p>
<p><img src="http://image.leonote.cn/20201118125737.png" alt=""></p>
<p>然后开启一个事务，查看一下 user_info 的数据，我们在 user_info 表里面插入了三条数据，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201118130241.png" alt=""></p>
<p><strong>第二步：我们打开另外一个相同数据库的 DB 连接，删除一条数据，SQL 如下：</strong></p>
<p><img src="http://image.leonote.cn/20201118130356.png" alt=""></p>
<p>当删除执行成功之后，我们可以开启第三个连接，看一下数据库里面确实少了一条 ID=1 的数据。那么这个时候我们再返回第一个连接，第二次执行 select * from user_info，如下图所示，查到的还是三条数据。这就是我们经常说的可重复读。</p>
<p><img src="http://image.leonote.cn/20201118130515.png" alt=""></p>
</li>
<li><p><strong>Serializable（可串行化）</strong>：这是最高的隔离级别，它保证了每个事务是串行执行的，即强制事务排序，所有事务之间不可能产生冲突，从而解决幻读问题。如果配置在这个级别的事务，处理时间比较长，并发比较大的时候，就会导致大量的 db 连接超时现象和锁竞争，从而降低了数据处理的吞吐量。也就是这个性能比较低，所以除了某些财务系统之外，用的人不是特别多。</p>
</li>
</ul>
<h3 id="MySQL-事务与连接的关系"><a href="#MySQL-事务与连接的关系" class="headerlink" title="MySQL 事务与连接的关系"></a>MySQL 事务与连接的关系</h3><p>要搞清楚事务和连接池的关系，必须要先知道二者存在的前提条件。</p>
<ol>
<li><p>事务必须在同一个连接里面的，离开连接没有事务可言；</p>
</li>
<li><p>MySQL 数据库默认 autocommit=1，即每一条 SQL 执行完自动提交事务；</p>
</li>
<li><p>数据库里面的每一条 SQL 执行的时候必须有事务环境；</p>
</li>
<li><p>MySQL 创建连接的时候默认开启事务，关闭连接的时候如果存在事务没有 commit 的情况，则自动执行 rollback 操作；</p>
</li>
<li><p>不同的 connect 之间的事务是相互隔离的。</p>
</li>
</ol>
<p>知道了这些条件，就可以继续探索二者的关系了。在 connection 当中，操作事务的方式只有两种。</p>
<h3 id="MySQL-事务的两种操作方式"><a href="#MySQL-事务的两种操作方式" class="headerlink" title="MySQL 事务的两种操作方式"></a>MySQL 事务的两种操作方式</h3><p>第一种：用 BEGIN、ROLLBACK、COMMIT 来实现。</p>
<ul>
<li><strong>BEGIN</strong> 开始一个事务</li>
<li><strong>ROLLBACK</strong> 事务回滚</li>
<li><strong>COMMIT</strong> 事务确认</li>
</ul>
<p>第二种：直接用 SET 来改变 MySQL 的自动提交模式。</p>
<ul>
<li><strong>SET AUTOCOMMIT=0</strong> 禁止自动提交</li>
<li><strong>SET AUTOCOMMIT=1</strong> 开启自动提交</li>
</ul>
<h3 id="MySQL-数据库的最大连接数是什么？"><a href="#MySQL-数据库的最大连接数是什么？" class="headerlink" title="MySQL 数据库的最大连接数是什么？"></a>MySQL 数据库的最大连接数是什么？</h3><p>而<strong>任何数据库的连接数都是有限的</strong>，受内存和 CPU 限制。</p>
<ul>
<li>查看数据库最大连接数： <code>show variables like &#39;max_connections&#39;</code> </li>
<li>查看正在使用的连接数： <code>show global status like &#39;Max_used_connections&#39;</code> </li>
<li>设置数据库最大连接数： <code>set global max_connections=1500</code> </li>
</ul>
<blockquote>
<p>注意：</p>
<p>再观察数据库的连接数的的同时，需要观察CPU和内存的使用情况，以此来判断当前系统数据库中server的连接数最佳大小是多少</p>
<p>MySQL 连接的超时时间，默认是 8 小时</p>
</blockquote>
<h2 id="Spring-里面事务的配置方法"><a href="#Spring-里面事务的配置方法" class="headerlink" title="Spring 里面事务的配置方法"></a>Spring 里面事务的配置方法</h2><p>Spring Boot会通过 <code>TransactionAutoConfiguration</code> 加载 @EnableTransactionManagement 注解帮我们默认开启事务，关键代码如下图所示：</p>
<p><img src="http://image.leonote.cn/20201118132724.png" alt=""></p>
<p>Spring 里面的事务有两种使用方式，常见的是<strong>直接通过 @Transaction 的方式进行配置</strong>，打开 SimpleJpaRepository 源码类会看到如下界面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Repository</span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">JpaRepositoryImplementation</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(Iterable&lt;? extends T&gt; entities)</span> </span>&#123;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认情况下，所有 SimpleJpaRepository 里面的方法都是只读事务，而一些更新的方法都是读写事务。</p>
</blockquote>
<p>所以每个 Repository 的方法是都是有事务的，即使没有使用任何加 @Transactional 注解的方法，按照上面所讲的 MySQL 的 Transactional 开启原理，也会有数据库的事务。</p>
<h3 id="默认-Transactional-注解式事务"><a href="#默认-Transactional-注解式事务" class="headerlink" title="默认 @Transactional 注解式事务"></a>默认 @Transactional 注解式事务</h3><p>注解式事务又称<strong>显式事务</strong>，需要手动显式注解声明，@Transactional 的源码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">   <span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">   <span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line">   <span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">   Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Transactional 注解中常用的参数：</p>
<table>
<thead>
<tr>
<th><strong>参数名称</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>readOnly</strong></td>
<td>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：@Transactional(readOnly=true)</td>
</tr>
<tr>
<td><strong>rollbackFor</strong></td>
<td>该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor=RuntimeException.class)指定多个异常类：@Transactional(rollbackFor={RuntimeException.class, Exception.class})</td>
</tr>
<tr>
<td><strong>rollbackForClassName</strong></td>
<td>该属性用于设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。例如：指定单一异常类名称：@Transactional(rollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(rollbackForClassName={“RuntimeException”,”Exception”})</td>
</tr>
<tr>
<td><strong>noRollbackFor</strong></td>
<td>该属性用于设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。例如：指定单一异常类：@Transactional(noRollbackFor=RuntimeException.class)指定多个异常类：@Transactional(noRollbackFor={RuntimeException.class, Exception.class})</td>
</tr>
<tr>
<td><strong>noRollbackForClassName</strong></td>
<td>该属性用于设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。例如：指定单一异常类名称：@Transactional(noRollbackForClassName=”RuntimeException”)指定多个异常类名称：@Transactional(noRollbackForClassName={“RuntimeException”,”Exception”})</td>
</tr>
<tr>
<td><strong>propagation</strong></td>
<td>该属性用于设置事务的传播行为。例如：@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true)</td>
</tr>
<tr>
<td><strong>isolation</strong></td>
<td>该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置</td>
</tr>
<tr>
<td><strong>timeout</strong></td>
<td>该属性用于设置事务的超时秒数，默认值为-1表示永不超时</td>
</tr>
</tbody></table>
<h4 id="隔离级别和事务的传播机制"><a href="#隔离级别和事务的传播机制" class="headerlink" title="隔离级别和事务的传播机制"></a>隔离级别和事务的传播机制</h4><p><strong>隔离级别 Isolation isolation() default Isolation.DEFAULT</strong>：默认采用数据库的事务隔离级别。其中，Isolation 是个枚举值：</p>
<ul>
<li>READ_UNCOMMITTED：读取未提交数据(会出现脏读, 不可重复读) 基本不使用</li>
<li>READ_COMMITTED：读取已提交数据(会出现不可重复读和幻读)</li>
<li>REPEATABLE_READ：可重复读(会出现幻读)</li>
<li>SERIALIZABLE：串行化</li>
</ul>
<blockquote>
<p>MYSQL：默认为 REPEATABLE_READ 级别<br>SQLSERVER：默认为 READ_COMMITTED</p>
</blockquote>
<p><strong>propagation</strong>：代表的是事务的传播机制，这个是 Spring 事务的核心业务逻辑，是 Spring 框架独有的，它和 MySQL 数据库没有一点关系。所谓事务的传播行为是指在同一线程中，在开始当前事务之前，需要判断一下当前线程中是否有另外一个事务存在，如果存在，提供了七个选项来指定当前事务的发生行为。 <code>org.springframework.transaction.annotation.Propagation</code> 这类有 7 个表示传播行为的枚举值如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line">	REQUIRED(<span class="number">0</span>),</span><br><span class="line">	SUPPORTS(<span class="number">1</span>),</span><br><span class="line">	MANDATORY(<span class="number">2</span>),</span><br><span class="line">	REQUIRES_NEW(<span class="number">3</span>),</span><br><span class="line">	NOT_SUPPORTED(<span class="number">4</span>),</span><br><span class="line">	NEVER(<span class="number">5</span>),</span><br><span class="line">	NESTED(<span class="number">6</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这个值是默认的。</li>
<li>SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>
<li>REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED。</li>
</ul>
<p>设置方法：通过使用 propagation 属性设置，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br></pre></td></tr></table></figure>

<h4 id="Transactional-的局限性"><a href="#Transactional-的局限性" class="headerlink" title="@Transactional 的局限性"></a>@Transactional 的局限性</h4><p>列举一个当前对象调用对象自己里面的方法不起作用的场景。</p>
<p>在 UserInfoServiceImpl 的 save 方法中调用了带事务的 calculate 方法，请看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据UserId产生的一些业务计算逻辑</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional(transactionManager = &quot;db2TransactionManager&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">calculate</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      UserInfo userInfo = userInfoRepository.findById(userId).get();</span><br><span class="line">      userInfo.setAges(userInfo.getAges()+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//.....等等一些复杂事务内的操作</span></span><br><span class="line">      userInfo.setTelephone(Instant.now().toString());</span><br><span class="line">      <span class="keyword">return</span> userInfoRepository.saveAndFlush(userInfo);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 此方法调用自身对象的方法，就会发现calculate方法上面的事务是失效的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfo <span class="title">save</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.calculate(userId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在 UserInfoServiceImpl 类的外部调用 save 方法的时候，此时 save 方法里面调用了自身的 calculate 方法，就会发现 calculate 方法上面的事务是没有效果的，这个是 Spring 的代理机制的问题。那么我们应该如何解决这个问题呢？可以引入一个类 TransactionTemplate，我们看下它的用法。</p>
<h4 id="TransactionTemplate-的用法"><a href="#TransactionTemplate-的用法" class="headerlink" title="TransactionTemplate 的用法"></a>TransactionTemplate 的用法</h4><p>此类是通过 <code>TransactionAutoConfiguration</code> 加载配置进去的，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201119170236.png" alt=""></p>
<p>通过源码可以看到此类提供了一个关键 execute 方法，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201119170457.png" alt=""></p>
<p>这里面会帮我们处理事务开始、rollback、commit 的逻辑，所以用的时候就非常简单，把上面的方法做如下改动：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">save</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> transactionTemplate.execute(status -&gt; <span class="keyword">this</span>.calculate(userId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时外部再调用 save 方法的时候，calculate 就会进入事务管理里面去了。也可以通过下面代码中的方法设置事务的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transactionTemplate = <span class="keyword">new</span> TransactionTemplate(transactionManager);</span><br><span class="line"><span class="comment">//设置隔离级别</span></span><br><span class="line">transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);</span><br><span class="line"><span class="comment">//设置传播机制</span></span><br><span class="line">transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line"><span class="comment">//设置超时时间</span></span><br><span class="line">transactionTemplate.setTimeout(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//设置是否只读</span></span><br><span class="line">transactionTemplate.setReadOnly(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>可以根据 transactionTemplate 的实现原理，自己实现一个 TransactionHelper</p>
<h4 id="自定义-TransactionHelper"><a href="#自定义-TransactionHelper" class="headerlink" title="自定义 TransactionHelper"></a>自定义 TransactionHelper</h4><p><strong>第一步：新建一个 TransactionHelper 类，进行事务管理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用spring进行管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionHelper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用spring 的机制和jdk8的function机制实现事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span> <span class="comment">//可以根据实际业务情况，指定明确的回滚异常</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">R <span class="title">transactional</span><span class="params">(Function&lt;T, R&gt; function, T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步：直接在 service 中就可以使用了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionHelper transactionHelper;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用外部的transactionHelper类，利用transactionHelper方法上面的<span class="doctag">@Transaction</span>注解使事务生效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">save</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> transactionHelper.transactional((uid)-&gt;<span class="keyword">this</span>.calculate(uid), userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐式事务-AspectJ-事务配置"><a href="#隐式事务-AspectJ-事务配置" class="headerlink" title="隐式事务 / AspectJ 事务配置"></a>隐式事务 / AspectJ 事务配置</h3><p>只需要在项目中新增一个类 AspectjTransactionConfig 即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectjTransactionConfig</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String transactionExecution = <span class="string">&quot;execution (* com.example..service.*.*(..))&quot;</span>;<span class="comment">//指定拦截器作用的包路径</span></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DefaultPointcutAdvisor <span class="title">defaultPointcutAdvisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//指定一般要拦截哪些类</span></span><br><span class="line">      AspectJExpressionPointcut pointcut = <span class="keyword">new</span> AspectJExpressionPointcut();</span><br><span class="line">      pointcut.setExpression(transactionExecution);</span><br><span class="line">      <span class="comment">//配置advisor</span></span><br><span class="line">      DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor();</span><br><span class="line">      advisor.setPointcut(pointcut);</span><br><span class="line">      <span class="comment">//根据正则表达式，指定上面的包路径里面的方法的事务策略</span></span><br><span class="line">      Properties attributes = <span class="keyword">new</span> Properties();</span><br><span class="line">      attributes.setProperty(<span class="string">&quot;get*&quot;</span>, <span class="string">&quot;PROPAGATION_REQUIRED,-Exception&quot;</span>);</span><br><span class="line">      attributes.setProperty(<span class="string">&quot;add*&quot;</span>, <span class="string">&quot;PROPAGATION_REQUIRED,-Exception&quot;</span>);</span><br><span class="line">      attributes.setProperty(<span class="string">&quot;save*&quot;</span>, <span class="string">&quot;PROPAGATION_REQUIRED,-Exception&quot;</span>);</span><br><span class="line">      attributes.setProperty(<span class="string">&quot;update*&quot;</span>, <span class="string">&quot;PROPAGATION_REQUIRED,-Exception&quot;</span>);</span><br><span class="line">      attributes.setProperty(<span class="string">&quot;delete*&quot;</span>, <span class="string">&quot;PROPAGATION_REQUIRED,-Exception&quot;</span>);</span><br><span class="line">      <span class="comment">//创建Interceptor</span></span><br><span class="line">      TransactionInterceptor txAdvice = <span class="keyword">new</span> TransactionInterceptor(transactionManager, attributes);</span><br><span class="line">      advisor.setAdvice(txAdvice);</span><br><span class="line">      <span class="keyword">return</span> advisor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式，只要符合我们上面的正则表达规则的 service 方法，就会自动添加事务了；如果我们在方法上添加 @Transactional，也可以覆盖上面的默认规则。</p>
<p>不过这种方法近两年使用的团队越来越少了，因为注解的方式其实很方便，并且注解 @Transactional 的方式更容易让人理解，代码也更简单。</p>
<h2 id="通过日志分析配置方法的过程"><a href="#通过日志分析配置方法的过程" class="headerlink" title="通过日志分析配置方法的过程"></a>通过日志分析配置方法的过程</h2><p>一个方法经历的 SQL 和过程大致可以分为以下几个步骤。</p>
<p><strong>第一步，我们在数据连接中加上 logger=Slf4JLogger&amp;profileSQL=true，用来显示 MySQL 执行的 SQL 日志</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##########datasource1 采用Mysql数据库</span></span><br><span class="line"><span class="meta">spring.datasource1.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?logger=Slf4JLogger&amp;profileSQL=true</span></span><br></pre></td></tr></table></figure>

<p><strong>第二步，打开 Spring 的事务处理日志，用来观察事务的执行过程</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Log Transactions Details</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm.jpa</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.transaction</span>=<span class="string">TRACE</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.engine.transaction.internal.TransactionImpl</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="comment"># 监控连接的情况</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.resource.jdbc</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p><strong>第三步，执行一个 saveOrUpdate 的操作</strong>，请看详细的执行日志。</p>
<p><img src="http://image.leonote.cn/20201119172605.png" alt=""></p>
<p>通过日志可以发现，执行一个 saveUserInfo 的动作，由于在其中配置了一个事务，所以可以看到 JpaTransactionManager 获得事务的过程，图上黄色的部分是同一个连接里面执行的 SQL 语句，其执行的整体过程如下：</p>
<ol>
<li><p>get connection：从事务管理里面，获得连接就 begin 开始事务了。没有看到显示的 begin 的 SQL，基本上可以断定它利用了 MySQL 的 connection 初始化事务的特性。</p>
</li>
<li><p>set autocommit=0：关闭自动提交模式，这个时候必须要在程序里面 commit 或者 rollback。</p>
</li>
<li><p>select user_info：看看 user_info 数据库里面是否存在我们要保存的数据。</p>
</li>
<li><p>update user_info：发现数据库里面存在，执行更新操作。</p>
</li>
<li><p>commit：执行提交事务。</p>
</li>
<li><p>set autocommit=1：事务执行完，改回 autocommit 的默认值，每条 SQL 是独立的事务。</p>
</li>
</ol>
<p>这里采用的是数据库默认的隔离级别，如果通过下面这行代码，改变默认隔离级别的话，再观察日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn/20201119172832.png" alt=""></p>
<p>而在事务结束之后，它还会还原此链接的事务隔离级别，又如下图所示。</p>
<p><img src="http://image.leonote.cn/20201119173301.png" alt=""></p>
<h2 id="Spring-事务的实现原理"><a href="#Spring-事务的实现原理" class="headerlink" title="Spring 事务的实现原理"></a>Spring 事务的实现原理</h2><p>@Transactional 的工作机制主要是利用的 Spring 的 AOP 原理，在加载所有类的时候，容器就会知道某些类需要对应地进行哪些 Interceptor 的处理。</p>
<h3 id="Spring-事务源码分析"><a href="#Spring-事务源码分析" class="headerlink" title="Spring 事务源码分析"></a>Spring 事务源码分析</h3><h4 id="事务获得连接的关键时机"><a href="#事务获得连接的关键时机" class="headerlink" title="事务获得连接的关键时机"></a>事务获得连接的关键时机</h4><p>在 <code>TransactionManagementConfigurationSelector</code> 里面设置一个断点</p>
<p>就会知道代理的加载类 <code>ProxyTransactionManagementConfiguration</code> 对事务的处理机制。关键源码如下图所示：</p>
<p><img src="http://image.leonote.cn/20201120105157.png" alt=""></p>
<p>打开 <code>ProxyTransactionManagementConfiguration</code> 的话，就会加载 <code>TransactionInterceptor</code> 的处理类，关键源码如下图：</p>
<p><img src="http://image.leonote.cn/20201120110226.png" alt=""></p>
<p>如果继续加载的话，里面就会加载带有 @Transactional 注解的类或者方法。关键源码如下图所示：</p>
<p><img src="http://image.leonote.cn/20201120110420.png" alt=""></p>
<p>加载期间，通过 @Transactional 注解来确定哪些方法需要进行事务处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name</span><br></pre></td></tr></table></figure>

<p>而运行期间通过上面这条日志，就可以找到 JpaTransactionManager 里面通过 getTransaction 方法创建的事务，然后再通过 debug 模式的 IDEA 线程栈进行分析，就能知道创建事务的整个过程。如下图所示：</p>
<p><img src="http://image.leonote.cn/20201120110637.png" alt=""></p>
<p>如上图， createTransactionIfNecessary 是用来判断是否需要创建事务的，如下图所示：</p>
<p><img src="http://image.leonote.cn/20201120110908.png" alt=""></p>
<p>继续往下面 debug 的话，就会找到创建事务的关键代码，它会通过调用 <code>AbstractPlatformTransactionManager</code> 里面的 startTransaction 方法开启事务。请看下图：</p>
<p><img src="http://image.leonote.cn/20201120110958.png" alt=""></p>
<p>然后继续往下断点进行分析，当断点走到最后的时候就是开启事务的时候，必须要从数据源里面获得连接。</p>
<p>看一下断点的栈信息，这里有几个关键的 debug 点。如下图所示。</p>
<p><img src="http://image.leonote.cn/20201120111143.png" alt=""></p>
<p>其中，</p>
<p>第一处：是处理带 @Transactional 的注解的方法，利用 CGLIB 进行事务拦截处理；</p>
<p>第二处：是根据 Spring 的事务传播机制，来判断是用现有的事务，还是创建新的事务；</p>
<p>第七处：是用来判断是否现有连接，如果有直接用，如果没有就从第八处的数据源里面的连接池中获取连接，第七处的关键代码如下：</p>
<p><img src="http://image.leonote.cn/20201120111235.png" alt=""></p>
<h4 id="什么时间释放连接到连接池"><a href="#什么时间释放连接到连接池" class="headerlink" title="什么时间释放连接到连接池"></a>什么时间释放连接到连接池</h4><p>在 <code>LogicalConnectionManagedImpl</code> 的 releaseConnection 方法中设置一个断点，如下图所示。</p>
<p><img src="http://image.leonote.cn/20201120111931.png" alt=""></p>
<p>在事务执行之后，它会将连接释放到连接池里面。</p>
<p>通过上面的 saveOrUpdate 的详细执行日志，可以观察出来：</p>
<ul>
<li>事务是在什么时机开启的</li>
<li>数据库连接是什么时机开启的</li>
<li>事务是在什么时机关闭的</li>
<li>数据库连接是在什么时机释放的</li>
</ul>
<blockquote>
<p>Spring 中的事务和连接的关系是，开启事务的同时获取 DB 连接；事务完成的时候释放 DB 连接。</p>
</blockquote>
<h2 id="事务和连接池在-JPA-中的注意事项"><a href="#事务和连接池在-JPA-中的注意事项" class="headerlink" title="事务和连接池在 JPA 中的注意事项"></a>事务和连接池在 JPA 中的注意事项</h2><p>数据源的连接池不能配置过大，否则连接之间切换就会非常耗费应用内部的 CPU 和内存，从而降低应用对外提供 API 的吞吐量。</p>
<p>所以当我们使用事务的时候，需要注意如下几个事项：</p>
<ol>
<li><p><strong>事务内的逻辑不能执行时间太长</strong>，否则就会导致占用 db 连接的时间过长，会造成数据库连接不够用的情况；</p>
</li>
<li><p><strong>跨应用的操作，如 API 调用等，尽量不要在有事务的方法里面进行；</strong></p>
</li>
<li><p>如果在真实业务场景中有耗时的操作，也需要带事务时（如扣款环节），那么请注意增加数据源配置的连接池数；</p>
</li>
<li><p>通过 MVC 的应用请求连接池数量，也要根据连接池的数量和事务的耗时情况灵活配置；而 tomcat 默认的请求连接池数量是 200 个，可以根据实际情况来增加或者减少请求的连接池数量，从而减少并发处理对事务的依赖。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 的审计功能</title>
    <url>/2020/11/05/SpringDataJpa%E7%9A%84%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h1 id="JPA-的审计功能"><a href="#JPA-的审计功能" class="headerlink" title="JPA 的审计功能"></a>JPA 的审计功能</h1><p> JPA 的审计功能，即 Auditing</p>
<h2 id="Auditing-指的是什么"><a href="#Auditing-指的是什么" class="headerlink" title="Auditing 指的是什么"></a>Auditing 指的是什么</h2><p>Auditing 是帮我们做审计用的，当我们操作一条记录的时候，需要知道这是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候，甚至需要修改记录……这些都是 Spring Data JPA 里面的 Auditing 支持的，它为我们提供了四个注解来完成上面说的一系列事情，如下：</p>
<p><code>@CreatedBy</code> 是哪个用户创建的。</p>
<p><code>@CreatedDate</code> 创建的时间。</p>
<p><code>@LastModifiedBy</code> 最后修改实体的用户。</p>
<p><code>@LastModifiedDate</code> 最后一次修改的时间。</p>
<p>这就是 Auditing 了</p>
<h2 id="Auditing-如何实现"><a href="#Auditing-如何实现" class="headerlink" title="Auditing 如何实现"></a>Auditing 如何实现</h2><p>利用上面的四个注解实现方法，一共有三种方式实现 Auditing。</p>
<h3 id="方式一：直接在实例里面添加注解"><a href="#方式一：直接在实例里面添加注解" class="headerlink" title="方式一：直接在实例里面添加注解"></a>方式一：直接在实例里面添加注解</h3><p>在 User 实体添加四个字段，分别记录创建人、创建时间、最后修改人、最后修改时间。</p>
<p>第一步：在 User 里面添加四个注解，并且新增 <code>@EntityListeners(AuditingEntityListener.class)</code> 注解。</p>
<p>添加完之后，User 的实体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addresses&quot;)</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;user&quot;)</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;UserAddress&gt; addresses;</span><br><span class="line">   <span class="keyword">private</span> Boolean deleted;</span><br><span class="line">   <span class="meta">@CreatedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@CreatedDate</span></span><br><span class="line">   <span class="keyword">private</span> Date createTime;</span><br><span class="line">   <span class="meta">@LastModifiedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="meta">@LastModifiedDate</span></span><br><span class="line">   <span class="keyword">private</span> Date lastModifiedTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 @Entity 实体中我们需要做两点操作：</p>
<ol>
<li><p>其中最主要的四个字段分别记录创建人、创建时间、最后修改人、最后修改时间，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CreatedBy</span></span><br><span class="line"><span class="keyword">private</span> Integer createUserId;</span><br><span class="line"><span class="meta">@CreatedDate</span></span><br><span class="line"><span class="keyword">private</span> Date createTime;</span><br><span class="line"><span class="meta">@LastModifiedBy</span></span><br><span class="line"><span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line"><span class="meta">@LastModifiedDate</span></span><br><span class="line"><span class="keyword">private</span> Date lastModifiedTime;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中 <code>AuditingEntityListener</code> 不能少，必须通过这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在 Entity 的实体上面进行注解。</p>
<p>第二步：实现 <code>AuditorAware</code> 接口，告诉 JPA 当前的用户是谁。</p>
<p>需要实现 <code>AuditorAware</code> 接口，以及 <code>getCurrentAuditor</code> 方法，并返回一个 Integer 的 user ID。这里可以自定义返回修改用户的信息，也可以是用户名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuditorAware</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//需要实现AuditorAware接口，返回当前的用户ID</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ServletRequestAttributes servletRequestAttributes =</span><br><span class="line">            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">      Integer userId = (Integer) servletRequestAttributes.getRequest().getSession().getAttribute(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(userId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里关键的一步，是实现 <code>AuditorAware</code> 接口的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuditorAware</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">getCurrentAuditor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🎯注意：这里获得用户 ID 的方法不止这一种，实际工作中，我们可能将当前的 user 信息放在 Session 中，可能把当前信息放在 Redis 中，也可能放在 Spring 的 security 里面管理。</p>
</blockquote>
<p>此外，这里的实现会有略微差异，我们以 security 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Authentication authentication =  SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="keyword">if</span> (authentication == <span class="keyword">null</span> || !authentication.isAuthenticated()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer userId = ((LoginUserInfo) authentication.getPrincipal()).getUser().getId();</span><br></pre></td></tr></table></figure>

<p>这时获取 <code>userId</code> 的代码可能会变成上面这样子。</p>
<p>第三步：通过 <code>@EnableJpaAuditing</code> 注解开启 JPA 的 Auditing 功能。</p>
<p>第三步是最重要的一步，如果想使上面的配置生效，我们需要开启 JPA 的 Auditing 功能（默认没开启）。这里需要用到的注解是 <code>@EnableJpaAuditing</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(JpaAuditingRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableJpaAuditing &#123;</span><br><span class="line"><span class="comment">//auditor用户的获取方法，默认是找AuditorAware的实现类；</span></span><br><span class="line"><span class="function">String <span class="title">auditorAwareRef</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//是否在创建修改的时候设置时间，默认是true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">setDates</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//在创建的时候是否同时作为修改，默认是true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">modifyOnCreate</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//时间的生成方法，默认是取当前时间(为什么提供这个功能呢？因为测试的时候有可能希望时间保持不变，它提供了一种自定义的方法)；</span></span><br><span class="line"><span class="function">String <span class="title">dateTimeProviderRef</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解了<code>@EnableJpaAuditing</code>注解之后，我们需要创建一个Configuration 文件，添加 <code>@EnableJpaAuditing</code> 注解，并且把我们的 <code>MyAuditorAware</code> 加载进去即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(name = &quot;myAuditorAware&quot;)</span></span><br><span class="line">   <span class="function">MyAuditorAware <span class="title">myAuditorAware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyAuditorAware();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经验之谈</p>
<ul>
<li>这里说一个 Configuration 的最佳实践的写法。我们为什么要单独写一个Configuration 的配置文件，而不是把<code>@EnableJpaAuditing</code> 放在 Application 的类里面呢？因为这样的话 Configuration 文件可以单独加载、单独测试，如果都放在 Application 类里面的话，岂不是每次测试都要启动整个应用吗？</li>
</ul>
<ul>
<li><code>MyAuditorAware</code> 也可以通过 <code>@Componen</code>t 注解进行加载，我为什么推荐 @Bean 的方式呢？因为这种方式可以让使用的人直接通过我们的配置文件知道我们自定义了哪些组件，不会让用的人产生不必要的惊讶，这是一点写 framework 的经验，供你参考。</li>
</ul>
<p>第四步：我们写个测试用例测试一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@Import(JpaConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    MyAuditorAware myAuditorAware;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAuditing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于测试用例模拟web context环境不是我们的重点，我们这里利用@MockBean，mock掉我们的方法，期待返回13这个用户ID</span></span><br><span class="line">        Mockito.when(myAuditorAware.getCurrentAuditor()).thenReturn(Optional.of(<span class="number">13</span>));</span><br><span class="line">        <span class="comment">//我们没有显式的指定更新时间、创建时间、更新人、创建人</span></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                .name(<span class="string">&quot;jack&quot;</span>)</span><br><span class="line">                .email(<span class="string">&quot;123456@126.com&quot;</span>)</span><br><span class="line">                .sex(SexEnum.BOY)</span><br><span class="line">                .age(<span class="number">20</span>)</span><br><span class="line">                .build();</span><br><span class="line">        userRepository.save(user);</span><br><span class="line">        <span class="comment">//验证是否有创建时间、更新时间，UserID是否正确；</span></span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">        Assertions.assertEquals(<span class="number">13</span>,users.get(<span class="number">0</span>).getCreateUserId());</span><br><span class="line">        Assertions.assertNotNull(users.get(<span class="number">0</span>).getLastModifiedTime());</span><br><span class="line">        System.out.println(users.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">需要注意的是：</span><br></pre></td></tr></table></figure>

<p>我们利用 <code>@MockBean</code> 模拟 <code>MyAuditorAware</code> 返回结果 13 这个 User ID；</p>
<p>我们测试并验证 create_user_id 是否是我们预期的。</p>
<p>测试结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">User(id=1, name=jack, email=123456@126.com, sex=BOY, age=20, deleted=null, createUserId=13, createTime=Sat Oct 03 21:19:57 CST 2020, lastModifiedUserId=13, lastModifiedTime=Sat Oct 03 21:19:57 CST 2020)</span><br></pre></td></tr></table></figure>

<p>结果完全符合我们的预期。</p>
<h3 id="方式二：实体里面实现Auditable-接口"><a href="#方式二：实体里面实现Auditable-接口" class="headerlink" title="方式二：实体里面实现Auditable 接口"></a>方式二：实体里面实现Auditable 接口</h3><p>我们改一下上面的 User 实体对象，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addresses&quot;)</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Auditable</span>&lt;<span class="title">Integer</span>,<span class="title">Long</span>, <span class="title">Instant</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;user&quot;)</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;UserAddress&gt; addresses;</span><br><span class="line">   <span class="keyword">private</span> Boolean deleted;</span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="keyword">private</span> Instant createTime;</span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="keyword">private</span> Instant lastModifiedTime;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title">getCreatedBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.createUserId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreatedBy</span><span class="params">(Integer createdBy)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.createUserId = createdBy;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Optional&lt;Instant&gt; <span class="title">getCreatedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.createTime);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreatedDate</span><span class="params">(Instant creationDate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.createTime = creationDate;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Optional&lt;Integer&gt; <span class="title">getLastModifiedBy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.lastModifiedUserId);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastModifiedBy</span><span class="params">(Integer lastModifiedBy)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastModifiedUserId = lastModifiedBy;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastModifiedDate</span><span class="params">(Instant lastModifiedDate)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.lastModifiedTime = lastModifiedDate;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Optional&lt;Instant&gt; <span class="title">getLastModifiedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.lastModifiedTime);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id==<span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与第一种方式的差异是，这里我们要去掉上面说的四个注解，并且要实现接口 Auditable 的方法，代码会变得很冗余和啰唆。</p>
<p>而其他都不变，我们再跑一次刚才的测试用例，发现效果是一样的。从代码的复杂程度来看，这种方式<strong>不推荐使用</strong>。</p>
<h3 id="方式三：利用-MappedSuperclass-注解"><a href="#方式三：利用-MappedSuperclass-注解" class="headerlink" title="方式三：利用 @MappedSuperclass 注解"></a>方式三：利用 @MappedSuperclass 注解</h3><p>它主要是用来解决公共 BaseEntity 的问题，而且其代表的是继承它的每一个类都是一个独立的表。</p>
<p>我们先看一下 <code>@MappedSuperclass</code> 的语法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MappedSuperclass &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它注解里面什么都没有，其实就是代表了抽象关系，即所有子类的公共字段而已。那么接下来我们看一下实例。</p>
<p>第一步：创建一个 BaseEntity，里面放一些实体的公共字段和注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.example1.base;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.*;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.MappedSuperclass;</span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@CreatedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@CreatedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant createTime;</span><br><span class="line">   <span class="meta">@LastModifiedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="meta">@LastModifiedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant lastModifiedTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： BaseEntity 里面需要用上面提到的四个注解，并且加上<code>@EntityListeners(AuditingEntityListener.class)</code>，这样所有的子类就不需要加了。</p>
<p>第二步：实体直接继承 BaseEntity 即可。</p>
<p>我们修改一下上面的 User 实例继承 BaseEntity，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addresses&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">   <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">   <span class="keyword">private</span> Integer age;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;user&quot;)</span></span><br><span class="line">   <span class="meta">@JsonIgnore</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;UserAddress&gt; addresses;</span><br><span class="line">   <span class="keyword">private</span> Boolean deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，User 实体就不需要关心太多，我们只关注自己需要的逻辑即可，如下：</p>
<p>去掉了 <code>@EntityListeners(AuditingEntityListener.class)</code>；</p>
<p>去掉了 <code>@CreatedBy</code>、<code>@CreatedDate</code>、<code>@LastModifiedBy</code>、<code>@LastModifiedDate</code> 四个注解的公共字段。</p>
<p>接着我们再跑一下上面的测试用例，发现效果还是一样的。</p>
<p>这种方式，是我<strong>最推荐</strong>的，也是实际工作中使用最多的一种方式。它的好处显而易见就是公用性强，代码简单，需要关心的少。</p>
<p>通过上面的实际案例，我们其实也能很容易发现 Auditing 帮我们解决了什么问题，下面总结一下。</p>
<h2 id="JPA-的审计功能解决了哪些问题？"><a href="#JPA-的审计功能解决了哪些问题？" class="headerlink" title="JPA 的审计功能解决了哪些问题？"></a>JPA 的审计功能解决了哪些问题？</h2><ol>
<li><p>可以很容易地让我们写自己的 BaseEntity，把一些公共的字段放在里面，不需要我们关心太多和业务无关的字段，更容易让我们公司的表更加统一和规范，就是统一加上 <code>@CreatedBy</code>、<code>@CreatedDate</code>、<code>@LastModifiedBy</code>、<code>@LastModifiedDate</code> 等。</p>
<p>实际工作中，BaseEntity 可能还更复杂一点，比如说把 ID 和 @Version 加进去，会变成如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy= GenerationType.AUTO)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">   <span class="meta">@CreatedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer createUserId;</span><br><span class="line">   <span class="meta">@CreatedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant createTime;</span><br><span class="line">   <span class="meta">@LastModifiedBy</span></span><br><span class="line">   <span class="keyword">private</span> Integer lastModifiedUserId;</span><br><span class="line">   <span class="meta">@LastModifiedDate</span></span><br><span class="line">   <span class="keyword">private</span> Instant lastModifiedTime;</span><br><span class="line">   <span class="meta">@Version</span></span><br><span class="line">   <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Auditing 在实战应用场景中，比较适合做后台管理项目，对应纯粹的 RESTAPI 项目，提供给用户直接查询的 API 的话，可以考虑一个特殊的 User ID。</p>
</li>
</ol>
<h2 id="Auditing-的实现原理"><a href="#Auditing-的实现原理" class="headerlink" title="Auditing 的实现原理"></a>Auditing 的实现原理</h2><p>第一步：还是从 <code>@EnableJpaAuditing</code> 入手分析。</p>
<p>我们前面讲了它的使用方法，这次我们分析一下其加载原理，看下面的图：</p>
<p><img src="http://image.leonote.cn/20201106150940.png" alt=""></p>
<p>我们可以知道，首先 Auditing 这套封装是 Spring Data JPA 实现的，而不是 Java Persistence API 规定的，其注解里面还有一项重要功能就是 <code>@Import(JpaAuditingRegistrar.class)</code> 这个类，它帮我们处理 Auditing 的逻辑。</p>
<p>我们看其源码，一步一步地 debug 下去可以发现如下所示：</p>
<p><img src="http://image.leonote.cn/20201106151104.png" alt=""></p>
<p>进一步进入到如下方法中：</p>
<p><img src="http://image.leonote.cn/20201106151437.png" alt=""></p>
<p>可以看到 Spring 容器给 <code>AuditingEntityListener.class</code> 注入了一个 <code>AuditingHandler</code> 的处理类。</p>
<p>第二步：打开 <code>AuditingEntityListener.class</code> 的源码分析 debug 一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditingEntityListener</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="meta">@Nullable</span> ObjectFactory&lt;AuditingHandler&gt; handler;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuditingHandler</span><span class="params">(ObjectFactory&lt;AuditingHandler&gt; auditingHandler)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(auditingHandler, <span class="string">&quot;AuditingHandler must not be null!&quot;</span>);</span><br><span class="line">      <span class="keyword">this</span>.handler = auditingHandler;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PrePersist</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touchForCreate</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(target, <span class="string">&quot;Entity must not be null!&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">         AuditingHandler object = handler.getObject();</span><br><span class="line">         <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            object.markCreated(target);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@PreUpdate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touchForUpdate</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      Assert.notNull(target, <span class="string">&quot;Entity must not be null!&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">         AuditingHandler object = handler.getObject();</span><br><span class="line">         <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">            object.markModified(target);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码我们可以看到，<code>AuditingEntityListener</code> 的实现还是比较简单的，利用了 Java Persistence API 里面的<code>@PrePersist</code>、<code>@PreUpdate</code> 回调函数，在更新和创建之前通过<code>AuditingHandler</code> 添加了用户信息和时间信息。</p>
<h3 id="原理分析结论"><a href="#原理分析结论" class="headerlink" title="原理分析结论"></a>原理分析结论</h3><p>查看 Auditing 的实现源码，其实给我们提供了一个思路，就是怎么利用 <code>@PrePersist</code>、<code>@PreUpdate</code> 等回调函数和 <code>@EntityListeners</code> 定义自己的框架代码。这是值得我们学习和参考的，比如说 Auditing 的操作日志场景等。</p>
<p>想成功配置 Auditing 功能，必须将 <code>@EnableJpaAuditing</code> 和 <code>@EntityListeners(AuditingEntityListener.class)</code> 一起使用才有效。</p>
<p>我们是不是可以不通过 Spring data JPA 给我们提供的 Auditing 功能，而是直接使用 <code>@PrePersist</code>、<code>@PreUpdate</code> 回调函数注解在实体上，也可以达到同样的效果呢？答案是肯定的，因为回调函数是实现的本质。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
        <tag>Auditing</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 的单元测试和集成测试</title>
    <url>/2021/01/31/SpringDataJpa%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="如何利用单元测试和集成测试让你开发效率翻倍？"><a href="#如何利用单元测试和集成测试让你开发效率翻倍？" class="headerlink" title="如何利用单元测试和集成测试让你开发效率翻倍？"></a>如何利用单元测试和集成测试让你开发效率翻倍？</h1><p>Spring boot 2.1，里面默认集成了 junit5，先从数据库层开始</p>
<h2 id="Spring-Data-JPA-单元测试的最佳实践"><a href="#Spring-Data-JPA-单元测试的最佳实践" class="headerlink" title="Spring Data JPA 单元测试的最佳实践"></a>Spring Data JPA 单元测试的最佳实践</h2><h3 id="Spring-Data-JPA-Repository-的测试用例"><a href="#Spring-Data-JPA-Repository-的测试用例" class="headerlink" title="Spring Data JPA Repository 的测试用例"></a>Spring Data JPA Repository 的测试用例</h3><p>第一步：引入 test 的依赖，gradle 的语法如下所示。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;com.h2database:h2&#x27;</span></span><br><span class="line">testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第二步：利用项目里面的实体和 Repository，假设项目里面有 Address 和 AddressRepository，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Repository的DAO层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：新建 RepsitoryTest，@DataJpaTest 即可，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressRepository addressRepository;</span><br><span class="line">    <span class="comment">//测试一下保存和查询</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Address address = Address.builder().city(<span class="string">&quot;shanghai&quot;</span>).build();</span><br><span class="line">        addressRepository.save(address);</span><br><span class="line">        List&lt;Address&gt; address1 = addressRepository.findAll();</span><br><span class="line">        address1.stream().forEach(address2 -&gt; System.out.println(address2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的测试用例可以看到，直接添加了 <code>@DataJpaTest</code> 注解，然后利用 Spring 的注解 <code>@Autowired</code>，引入了 spring context 里面管理的 AddressRepository 实例。换句话说，在这里面使用了集成测试，即直接连接的数据库来完成操作。</p>
<p>第四步：直接运行上面的测试用例，可以得到如下图所示的结果。</p>
<p><img src="http://image.leonote.cn//20210131101904.jpg" alt=""></p>
<p>通过测试结果可以发现：</p>
<ol>
<li><p><strong>测试方法默认都会开启一个事务，测试完了之后就会进行回滚</strong>；</p>
</li>
<li><p>里面执行了 insert 和 select 两种操作；</p>
</li>
<li><p>如果开启了 Session Metrics 的日志的话，也可以观察出来其发生了一次 connection。</p>
</li>
</ol>
<p>通过这个案例，可以知道 Repository 的测试用例写起来还是比较简单的，其中主要利用了 <code>@DataJpaTest</code> 的注解。下面打开 <code>@DataJpaTest</code> 的源码，看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@BootstrapWith(DataJpaTestContextBootstrapper.class)</span> <span class="comment">//测试环境的启动方式</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="comment">//加载了Spring测试环境</span></span><br><span class="line"><span class="meta">@OverrideAutoConfiguration(enabled = false)</span></span><br><span class="line"><span class="meta">@TypeExcludeFilters(DataJpaTypeExcludeFilter.class)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@AutoConfigureCache</span></span><br><span class="line"><span class="meta">@AutoConfigureDataJpa</span><span class="comment">//加载了依赖Spring Data JPA的原有配置</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase</span> <span class="comment">//加载默认的测试数据库，这里面采用默认的H2</span></span><br><span class="line"><span class="meta">@AutoConfigureTestEntityManager</span><span class="comment">//加载测试所需要的EntityManager，主要是事务处理机制不一样</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataJpaTest &#123;</span><br><span class="line">   <span class="comment">//默认打开sql的控制台输出</span></span><br><span class="line">   <span class="meta">@PropertyMapping(&quot;spring.jpa.show-sql&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">showSql</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">......&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Repository-的测试场景"><a href="#Repository-的测试场景" class="headerlink" title="Repository 的测试场景"></a>Repository 的测试场景</h3><p>可能在工作中，有的同事会说没有必要写 Repository 的测试用例，因为好多方法都是框架里面提供的，况且这个东西没有什么逻辑，写的时候有点浪费时间。</p>
<p>其实不然，如果能把 Repository 的测试用写好的话，这对我们的开发效率绝对是有提高的。否则当给你一个项目，让你直接改里面的代码，你可能就会比较慌，不敢改。所有你就要知道都有哪些场景是必须要写 Repository 的测试用例。</p>
<ul>
<li><p><strong>场景一</strong>：当新增一个 Entity 和实体对应的 Repository 的时候，需要写个简单的 save 和查询测试用例，主要目的是检查实体配置是否正确，否则当你写了一大堆 Repository 和 Entity 的时候，启动报错，不知道哪里配置得有问题，这样反而会降低开发效率；</p>
</li>
<li><p><strong>场景二</strong>：当实体里面有一些 POJO 的逻辑，或者某些字段必须要有的时候，就需要写一些测试用例，假设 Address 实体里面不需要有 address 属性字段，并且有一个 @Transient 的字段和计算逻辑，这时就需要写一些测试用例去验证一下了。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@JsonProperty(&quot;myCity&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="keyword">private</span> String address; <span class="comment">//必要字段</span></span><br><span class="line">   <span class="meta">@Transient</span> <span class="comment">//非数据库字段，有一些简单运算</span></span><br><span class="line">   <span class="keyword">private</span> String addressAndCity;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getAddressAndCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> address+<span class="string">&quot;一些简单逻辑&quot;</span>+city;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景三</strong>：当有自定义的方法的时候，就可能需要测试一下，看看返回结果是否满足需求，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function">Page&lt;Address&gt; <span class="title">findByAddress</span><span class="params">(<span class="meta">@Param(&quot;address&quot;)</span> String address, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景四</strong>：当利用 @Query 注解，写了一些 JPQL 或者 SQL 的时候，就需要写一次测试用例来验证一下，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//通过@Query注解自定的JPQL或Navicat SQL</span></span><br><span class="line">    <span class="meta">@Query(value = &quot;FROM Address where deleted=false &quot;)</span></span><br><span class="line">    <span class="function">Page&lt;Address&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么对应的复杂一点的测试用例就要变成如下面这段代码所示的样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AddressRepository addressRepository;</span><br><span class="line">    <span class="meta">@BeforeAll</span> <span class="comment">//利用 @BeforeAll准备一些Repositroy需要的测数据</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span><span class="comment">// 由于每个方法都是有事务回滚机制的，为了测试 Repository 可能需要模拟一些数据，所以改变回滚机制</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Address address = Address.builder().city(<span class="string">&quot;shanghaiDeleted&quot;</span>).deleted(<span class="keyword">true</span>).build();</span><br><span class="line">        addressRepository.save(address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试没有包含删除的记录</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testFindAllNoDeleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Address&gt; address1 = addressRepository.findAll();</span><br><span class="line">        <span class="keyword">int</span> deleteSize = address1.stream().filter(d-&gt;d.equals(<span class="string">&quot;shanghaiDeleted&quot;</span>)).collect(Collectors.toList()).size();</span><br><span class="line">        Assertions.assertTrue(deleteSize==<span class="number">0</span>); <span class="comment">//测试一下不包含删除的条数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>场景五</strong>：当测试一些 JPA 或者 Hibernate 的底层特性的时候，测试用例可以很好地帮助我们。因为如果依赖项目启动来做测试，效率太低了，例如之前讲的一些 <code>@PersistenceContext</code> 特性，那么就可以通过类似如下的测试用例完成测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Import(TestConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoRepositoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">    <span class="comment">//测试一些手动flush的机制</span></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">            (properties = &#123;<span class="meta">@PersistenceProperty(</span></span><br><span class="line"><span class="meta">                    name = &quot;org.hibernate.flushMode&quot;,</span></span><br><span class="line"><span class="meta">                    value = &quot;MANUAL&quot;//手动flush</span></span><br><span class="line"><span class="meta">            )</span>&#125;)</span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提前准备一些数据方便测试</span></span><br><span class="line">        UserInfo u1 = UserInfo.builder().id(<span class="number">1L</span>).lastName(<span class="string">&quot;jack&quot;</span>).version(<span class="number">1</span>).build();</span><br><span class="line">        userInfoRepository.save(u1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = UserInfo.builder().name(<span class="string">&quot;new name&quot;</span>).build();</span><br><span class="line">        <span class="comment">//新增一个对象userInfo交给PersistenceContext管理，即一级缓存</span></span><br><span class="line">        entityManager.persist(userInfo);</span><br><span class="line">        <span class="comment">//此时没有detach和clear之前，flush的时候还会产生更新SQL</span></span><br><span class="line">        userInfo.setName(<span class="string">&quot;old name&quot;</span>);</span><br><span class="line">        entityManager.flush();</span><br><span class="line">        entityManager.clear();</span><br><span class="line"><span class="comment">//        entityManager.detach(userInfo);</span></span><br><span class="line"><span class="comment">// 		  entityManager已经clear，此时已经不会对UserInfo进行更新了</span></span><br><span class="line">        userInfo.setName(<span class="string">&quot;new name 11&quot;</span>);</span><br><span class="line">        entityManager.flush();</span><br><span class="line">        <span class="comment">//由于有cache机制，相同的对象查询只会触发一次查询SQL</span></span><br><span class="line">        UserInfo u1 = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">        <span class="comment">//to do some thing</span></span><br><span class="line">        UserInfo u2 = userInfoRepository.findById(<span class="number">1L</span>).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="集成测试和单元测试的区别"><a href="#集成测试和单元测试的区别" class="headerlink" title="集成测试和单元测试的区别"></a>集成测试和单元测试的区别</h2><h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h3><p>通俗来讲，就是不依赖本类之外的任何方法完成本类里面的所有方法的测试，也就是常说的依赖本类之外的，都通过 Mock 的方式进行。。</p>
<p><strong>Service 层单元测试</strong></p>
<p>首先，模拟一个业务中的 Service 方法，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserInfoService</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">   <span class="comment">//假设有个 findByUserId 的方法经过一些业务逻辑计算返回了一个业务对象 UserInfoDto</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfoDto <span class="title">findByUserId</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">      UserInfo userInfo = userInfoRepository.findById(userId).orElse(<span class="keyword">new</span> UserInfo());</span><br><span class="line">      <span class="comment">//模拟一些业务计算改变一下name的值返回</span></span><br><span class="line">      UserInfoDto userInfoDto = UserInfoDto.builder().name(userInfo.getName()+<span class="string">&quot;_HELLO&quot;</span>).id(userInfo.getId()).build();</span><br><span class="line">      <span class="keyword">return</span> userInfoDto;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，service 通过 Spring 的 @Component 注解进行加载，UserInfoRepository 通过 spring 的 @Autowired 注入进来，来测试一下 findByUserId 这个业务 service 方法，单元测试写法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="comment">//通过这个注解利用Spring的容器</span></span><br><span class="line"><span class="meta">@Import(UserInfoServiceImpl.class)</span><span class="comment">//导入要测试的UserInfoServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//利用spring的容器，导入要测试的UserInfoService</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    <span class="meta">@MockBean</span> <span class="comment">//里面@MockBean模拟service中用到的userInfoRepository，这样避免真实请求数据库</span></span><br><span class="line">    <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">    <span class="comment">// 利用单元测试的思想，mock userInfoService 里面的 UserInfoRepository，这样Service层就不用连接数据库，就可以测试自己的业务逻辑了</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserInfoDto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//利用 Mockito 模拟当调用 findById(1) 的时候，返回模拟数据</span></span><br><span class="line">         Mockito.when(userInfoRepository.findById(<span class="number">1L</span>))</span><br><span class="line">                    .thenReturn(java.util.Optional.ofNullable(UserInfo.builder().name(<span class="string">&quot;jack&quot;</span>).id(<span class="number">1L</span>).build()));</span><br><span class="line">        UserInfoDto userInfoDto = userInfoService.findByUserId(<span class="number">1L</span>);</span><br><span class="line">        <span class="comment">//经过一些service里面的逻辑计算，验证一下返回结果是否正确</span></span><br><span class="line">        Assertions.assertEquals(<span class="string">&quot;jack&quot;</span>,userInfoDto.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以完成 Service 层的测试了。</p>
<p>其中 <code>@ExtendWith(SpringExtension.class)</code> 是 spring boot 与 Junit 5 结合使用的时候，当利用 Spring 的 TestContext 进行 mock 测试时要使用的。有的时候如果做一些简单 Util 的测试，就不一定会用到 SpringExtension.class。</p>
<p>在 service 的单元测试中，主要用到的知识点有四个。</p>
<ol>
<li><p>通过 <code>@ExtendWith(SpringExtension.class)</code> 加载 Spring 的测试框架及其 TestContext；</p>
</li>
<li><p>通过 <code>@Import(UserInfoServiceImpl.class)</code> 导入具体要测试的类，这样 SpringTestContext 就不用加载项目里面的所有类，只需要加载 UserInfoServiceImpl.class 就可以了，这样可以大大提高测试用例的执行速度；</p>
</li>
<li><p>通过 <code>@MockBean</code> 模拟 UserInfoServiceImpl 依赖的 userInfoRepository，并且自动注入 Spring test context 里面，这样 Service 里面就自动有依赖了；</p>
</li>
<li><p>利用 <code>Mockito.when().thenReturn()</code> 的机制，模拟测试方法。</p>
</li>
</ol>
<p>这样就可以通过 Assertions 里面的断言来测试 service 方法里面的逻辑是否符合预期了。</p>
<p><strong>Controller 层单元测试</strong></p>
<p>新增一个 UserInfoController 跟进 Id 获得 UserInfoDto 的信息，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">   <span class="comment">//跟进UserId取用户的详细信息</span></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> UserInfoDto <span class="title">findByUserId</span><span class="params">(<span class="meta">@PathVariable</span> Long userId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> userInfoService.findByUserId(userId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Controller 里面完整的测试用例，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.jpa.demo;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.demo.service.UserInfoService;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.demo.service.dto.UserInfoDto;</span><br><span class="line"><span class="keyword">import</span> com.example.jpa.demo.web.UserInfoController;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.MockBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.mock.web.MockHttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebMvcTest(UserInfoController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoControllerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line">    <span class="meta">@MockBean</span> <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单元测试mvc的controller的方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetUserDto</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//利用 @MockBean，当调用 userInfoService的findByUserId(1)的时候返回一个模拟的UserInfoDto数据</span></span><br><span class="line">        Mockito.when(userInfoService.findByUserId(<span class="number">1L</span>))</span><br><span class="line">            .thenReturn(UserInfoDto.builder().name(<span class="string">&quot;jack&quot;</span>).id(<span class="number">1L</span>).build());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//利用mvc验证一下Controller里面的解决是否OK</span></span><br><span class="line">        MockHttpServletResponse response = mvc</span><br><span class="line">                .perform(MockMvcRequestBuilders</span><br><span class="line">                        .get(<span class="string">&quot;/user/1/&quot;</span>)<span class="comment">//请求的path</span></span><br><span class="line">                        .accept(MediaType.APPLICATION_JSON)<span class="comment">//请求的mediaType，这里面可以加上各种需要的Header</span></span><br><span class="line">                )</span><br><span class="line">                .andDo(print())<span class="comment">//打印一下</span></span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;jack&quot;</span>))</span><br><span class="line">                .andReturn().getResponse();</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中主要利用了 <code>@WebMvcTest</code> 注解，来引入要测试的 Controller。打开 <code>@WebMvcTest</code> 可以看到关键源码，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131104539.jpg" alt=""></p>
<p><code>@WebMvcTest</code> 加载了 <code>@ExtendWith(SpringExtension.class)</code>，所以不需要额外指定，就拥有了 Spring 的 test context，并且也自动加载了 mvc 所需要的上下文 <code>WebMvctestContextbootstrapper</code>。</p>
<p>有的时候可能有一些全局的 Filter，也可以通过此注解里面的 <code>includeFilters</code> 和 <code>excluedeFilters</code> 加载和排除需要的 <code>WebMvcFilter</code> 进行测试。</p>
<p>当通过 <code>@WebMvcTest(UserInfoController.class)</code> 导入需要测试的 Controller 之后，就可以再通过 <code>MockMvc</code> 请求到加载的 Controller 里面的 path 了，并且可以通过 <code>MockMvc</code> 提供的一些方法发送请求，验证 Controller 的响应结果。</p>
<p>下面概括一下 Controller 层单元测试主要用到的三个知识点。</p>
<ol>
<li><p>利用 <code>@WebMvcTest</code> 注解，加载要测试的 Controller，同时生成 mvc 所需要的 Test Context；</p>
</li>
<li><p>利用 <code>@MockBean</code> 默认 Controller 里面的依赖，如 Service，并通过 <code>Mockito.when().thenReturn()；</code>的语法 mock 依赖的测试数据；</p>
</li>
<li><p>利用 <code>MockMvc</code> 中提供的方法，发送 Controller 的 Rest 风格的请求，并验证返回结果和状态码。</p>
</li>
</ol>
<h3 id="什么是集成测试"><a href="#什么是集成测试" class="headerlink" title="什么是集成测试"></a>什么是集成测试</h3><p>顾名思义，就是指多个模块放在一起测试，和单元测试正好相反，并非采用 mock 的方式测试，而是通过直接调用的方式进行测试。也就是说依赖 spring 容器进行开发，所有的类之间直接调用，模拟应用真实启动时候的状态。</p>
<p><strong>Service 层的基层测试用例写法</strong></p>
<p>还用刚才的例子，看一下 UserInfoService 里面的 findByUserId 通过集成测试如何进行。测试用例的写法如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses= UserInfoServiceImpl.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoServiceIntegrationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> UserInfoService userInfoService;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> UserInfoRepository userInfoRepository;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Rollback(false)</span><span class="comment">//如果事务回滚设置成false的话，数据库可以真实看到这条数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntegtation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfo u1 = UserInfo.builder().name(<span class="string">&quot;jack-db&quot;</span>).ages(<span class="number">20</span>).id(<span class="number">1L</span>).telephone(<span class="string">&quot;1233456&quot;</span>).build();</span><br><span class="line">        <span class="comment">//数据库真实加一条数据</span></span><br><span class="line">        userInfoRepository.save(u1);<span class="comment">//数据库里面真实保存一条数据</span></span><br><span class="line">        UserInfoDto userInfoDto =  userInfoService.findByUserId(<span class="number">1L</span>);</span><br><span class="line">        userInfoDto.getName();</span><br><span class="line">        Assertions.assertEquals(userInfoDto.getName(),u1.getName()+<span class="string">&quot;_HELLO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行一下测试用例，结果如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131105144.jpg" alt=""></p>
<p>这时会发现数据已经不再回滚，也会正常地执行 SQL，而不是通过 Mock 的方式测试。</p>
<p><strong>Controller 层的集成测试用例的写法</strong></p>
<p>用集成测试把刚才 UserInfoCotroller 写的 user/1/ 接口测试一下，将集成测试的代码做如下改动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = DemoApplication.class,</span></span><br><span class="line"><span class="meta">        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span> <span class="comment">//加载 DemoApplication，指定一个随机端口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoControllerIntegrationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@LocalServerPort</span> <span class="comment">//获得模拟的随机端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//利用 RestTemplate，发送一个请求</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAllUserDtoIntegration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserInfoDto userInfoDto = <span class="keyword">this</span>.restTemplate</span><br><span class="line">                .getForObject(<span class="string">&quot;http://localhost:&quot;</span> + port + <span class="string">&quot;/user/1&quot;</span>, UserInfoDto.class);<span class="comment">//真实请求有一个后台的API</span></span><br><span class="line">        Assertions.assertNotNull(userInfoDto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看日志的话，会发现此次的测试用例会在内部启动一个 tomcat 容器，然后再利用 TestResTemplate 进行真实请求，返回测试结果进行测试。</p>
<p>而其中会涉及一个注解 <code>@SpringBootTest</code>，它用来指定 Spring 应用的类是哪个，也就是真实项目的 Application 启动类；然后会指定一个端口，此处必须使用随机端口，否则可能会有冲突（如果启动的集成测试有点多的情况）。日志如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131105947.jpg" alt=""></p>
<p>如果看 <code>@SprintBootTest</code> 源码的话，会发现这个注解也是加载了 Spring 的测试环境 SpringExtension.class，并且里面有很多属性可以设置，测试的时候的配置文件 properties 和一些启动的环境变量 WebEnv；然后又利用了 Spring Boot Test 提供的 <code>@LocalServerPort</code> 获得启动时候的端口。源码如下图所示。</p>
<p><img src="http://image.leonote.cn//20210131112459.jpg" alt=""></p>
<p><strong>集成测试的一些思考</strong></p>
<ol>
<li><p>所有的方法都需要集成测试吗？</p>
<p>这是写集成测试用的时候需要思考的，因为集成测试用例需要内部启动 Tomcat 容器，所以可能会启动得慢一点。如果项目加载的配置文件越来越多，势必会导致测试也会变慢。假设测试一个简单的逻辑就需要启动整个 Application，那么显然是不妥的。</p>
<p>那么整个 Application 不需要集成测试吗？也显然不是的，因为有些时候只有集成在一起才会发生问题，最简单的一个集成测试是需要测试是否能正常启动，所以一个项目里面会有个 ApplicationTests 来测试项目是否能正常启动。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 测试项目是否能正常启动</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一定是非集成测试就是单元测试吗？</p>
<p>实际工作中并没有划分那么清楚，有的时候集成了 N 个组件一起测试，可能就是不连数据库。比如可能会使用 Feign-Client 根据第三方的接口获取一些数据，那么正常的做法就是新建一个 Service，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试普通JSON返回结果，根据第三方接口取一个数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(name = &quot;aocFeignTest&quot;, url = &quot;http://room-api.staging.jack.net&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AppSettingService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/api/v1/app/globalSettings&quot;)</span></span><br><span class="line">    <span class="function">HashMap&lt;String,Object&gt; <span class="title">getAppSettings</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这个时候如果要测试，显然不需要启动整个 Application 来完成，但是需要按需加载一些 Configuration 才能测试，那么测试用例会变成如下情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span><span class="comment">//利用Spring上下文</span></span><br><span class="line"><span class="meta">@Import(&#123;FeignSimpleConfiguration.class, FeignAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class, JacksonAutoConfiguration.class&#125;)</span><span class="comment">//导入此处Fegin-Client测试所需要的配置文件</span></span><br><span class="line"><span class="meta">@EnableFeignClients(clients = AppSettingService.class)</span><span class="comment">//通过FeignClient的注解加载AppSettingService客户端。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依赖HTTPMessageConverter的使用方法(import FeignSimpleConfiguration junit)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignJsonTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 利用Spring的上下文注入appSettingService</span></span><br><span class="line">    <span class="keyword">private</span> AppSettingService appSettingService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJsonFeignClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String,Object&gt;  r = .getAppSettings();</span><br><span class="line">        Assert.assertNotNull(r.get(<span class="string">&quot;data&quot;</span>));<span class="comment">//测试一下接口返回的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候其实并没有启动这个 Application，但是我们也集成了 Fegin-Client 所需要的上下文 Configuration，从而利用 SpringExtension 加载所需要依赖的类，完成一次测试。</p>
<p>所以一定要根据自己的实际需要选择性地加载一些类来完成测试用例，而不是每次测试的时候都需要把所有类都加载一遍，这样返回会使测试用例的时间变长，从而降低工作效率。</p>
</li>
</ol>
<h2 id="Junit-4-和-Junit-5-在-Spring-Boot-中的区别"><a href="#Junit-4-和-Junit-5-在-Spring-Boot-中的区别" class="headerlink" title="Junit 4 和 Junit 5 在 Spring Boot 中的区别"></a>Junit 4 和 Junit 5 在 Spring Boot 中的区别</h2><p>第一，Spring Boot 2.2+ 以上的版本默认导入的是 Junit 5 的 jar 包依赖，以下的版本默认导入的是 Junit 4 的 jar 包依赖的版本，所以在使用不同版本的 Spring Boot 的时候需要注意一下依赖的 jar 包是否齐全。</p>
<p>第二，org.junit.junit.Test 变成了 org.junit.jupiter.api.Test。</p>
<p>第三，一些注解发生了变化：</p>
<ul>
<li><code>@Before</code> 变成了 <code>@BeforeEach</code></li>
<li><code>@After</code> 变成了 <code>@AfterEach</code></li>
<li><code>@BeforeClass</code> 变成了 <code>@BeforeAll</code></li>
<li><code>@AfterClass</code> 变成了 <code>@AfterAll</code></li>
<li><code>@Ignore</code> 变成了 <code>@Disabled</code></li>
<li><code>@Category</code> 变成了 <code>@Tag</code></li>
<li><code>@Rule</code> 和 <code>@ClassRule</code> 没有了，用 <code>@ExtendWith</code> 和 <code>@RegisterExtension</code> 代替</li>
</ul>
<p>第四，引用 Spring 的上下文 <code>@RunWith(SpringRunner.class)</code> 变成了 <code>@ExtendWith(SpringExtension.class)</code>。</p>
<p>第五，org.junit.Assert 下面的断言都移到了org.junit.jupiter.api.Assertions 下面，所以一些断言的写法会发生如下变化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//junit4断言的写法</span></span><br><span class="line">Assert.assertEquals(<span class="number">200</span>, result.getStatusCodeValue());</span><br><span class="line">Assert.assertEquals(<span class="keyword">true</span>, result.getBody().contains(<span class="string">&quot;employeeList&quot;</span>));</span><br><span class="line"><span class="comment">//junit5断言的写法</span></span><br><span class="line">Assertions.assertEquals(<span class="number">400</span>, ex.getRawStatusCode());</span><br><span class="line">Assertions.assertEquals(<span class="keyword">true</span>, ex.getResponseBodyAsString().contains(<span class="string">&quot;Missing request header&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>第六，Junit 5 提供 <code>@DisplayName(&quot;Test MyClass&quot;)</code> <a href="">用来标识此次单元测试的名字</a>，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;Test MyClass&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;Verify MyClass.myMethod returns true&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMyMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;    </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-Memcached的原理及架构剖析</title>
    <url>/2021/02/08/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Memcached%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Memcached-的原理及架构剖析"><a href="#Memcached-的原理及架构剖析" class="headerlink" title="Memcached 的原理及架构剖析"></a>Memcached 的原理及架构剖析</h1><p>众所周知，用户体验可以说是互联网企业最看重的指标，而在用户体验中，请求响应速度是首要的。因此互联网系统对性能的追求是永无止境的。性能争霸，缓存为王，Memcached，作为互联网系统使用最广泛、影响最大的标配缓存组件，可以说的上是王中之王。</p>
<h2 id="Memcached-原理及特性"><a href="#Memcached-原理及特性" class="headerlink" title="Memcached 原理及特性"></a>Memcached 原理及特性</h2><p><strong>原理</strong></p>
<p>Memcached 是一个开源的、高性能的分布式 key/value 内存缓存系统。它以 key/value 键值对的方式存储数据，是一个键值类型的 NoSQL 组件。</p>
<p>NoSQL 即 Not SQL，泛指非关系型数据存储。NoSQL 是通过聚合模型来进行数据处理的。其聚合模型主要分为：key/value 键值对、列族、图形等几种方式。其中 key/value 键值类似我们平常使用的 map，只能通过 key 来进行查找和变更操作。我们使用的 Memcached、Redis 等都是 key/value 类型的 NoSQL 存储组件。</p>
<p>Memcached 简称 Mc，是一个典型的内存型缓存组件，这就意味着，Mc 一旦重启就会丢失所有的数据。如下图所示，Mc 组件之间相互不通信，完全由 client 对 key 进行 Hash 后分布和协同。Mc 采用多线程处理请求，由一个主线程和任意多个工作线程协作，从而充分利用多核，提升 IO 效率。</p>
<p><img src="http://image.leonote.cn//20210207102810.jpg" alt=""></p>
<p><strong>slab 机制</strong> </p>
<p>Mc 并不是将所有数据放在一起来进行管理的，而是将内存划分为一系列相同大小的 slab 空间后，每个 slab 只管理一定范围内的数据存储。也就是说 Mc 内部采用 slab 机制来管理内存分配。Mc 内的内存分配以 slab 为单位，默认情况下<strong>一个 slab 是 1MB</strong>，可以通过 -I 参数在启动时指定其他数值。</p>
<p>slab 空间内部，会被进一步划分为一系列固定大小的 chunk。每个 chunk 内部存储一个 Item，利用 Item 结构存储数据。因为 chunk 大小固定，而 key/value 数据的大小随机。所以，Item存储完 key/value 数据后，一般还会有多余的空间，这个多余的空间就被浪费了。为了提升内存的使用效率，chunk size 就不能太大，而要尽量选择与 key/value size 接近的 ，从而减少 chunk 内浪费的空间。</p>
<p>Mc 在分配内存时，先将内存按固定大小划分成 slab，然后再将不同 slab 分拆出固定 size 的 chunk。虽然 slab 内的 chunk 大小相同，但不同 slab 的 chunk size 并不同，Mc 会按照一个固定比例，使划分的 chunk size 逐步增大，从而满足不同大小 key/value 存储的需要。</p>
<p>如下图，一组具有相同 chunk size 的所有 slab，就组成一个 slabclass。不同 slabclass 的 chunk size 按递增因子一次增加。Mc 就通过 slabclass 来管理一组 slab 内的存储空间的。每个 slabclass 内部有一个 freelist ，包含这组 slab 里所有空闲的 chunk，当需要存储数据时，从这个 freelist 里面快速分配一个 chunk 做存储空间。当 Item 数据淘汰剔除时，这个 Item 所在的 chunk 又被回收至这个 freelist。</p>
<p><img src="http://image.leonote.cn//20210207103148.jpg" alt=""></p>
<p>Mc 在通过 slab 机制管理内存分配时，实际 key/value 是存在 Item 结构中，所以对 key/value 的存储空间分配就转换为对 Item 的分配。而 Item 空间的分配有 2 种方式，如果 Mc 有空闲空间，则从 slabclass 的 freelist 分配；如果没有空闲空间，则从对应 slabclass id 对应的 LRU 中剔除一个 Item，来复用这个 Item 的空间。</p>
<p>在查找或变更一个 key 时，首先要定位这个 key 所在的存储位置。Mc 是通过哈希表 Hash table 来定位 key 的。Hash table 可以看作是一个内存空间连续的大数组，而这个大数据的每一个槽位对应一个 key 的 Hash 值，这个槽位也称 bucket。由于不同 key 的 Hash 值可能相同，所以 Mc 在 Hash table 的每个捅内部再用一个单向链表，来解决 Hash 冲突的问题。</p>
<p>Mc 内部是通过 LRU 来管理存储 Item 数据的，当内存不足时，会从 LRU 队尾中剔除一个过期或最不活跃的 key，供新的 Item 使用。</p>
<p><strong>特性</strong></p>
<ul>
<li><p>Mc 最大的特性是<strong>高性能</strong>，单节点压测性能能达到百万级的 QPS。</p>
</li>
<li><p>其次因为 Mc 的访问协议很简单，只有 get/set/cas/touch/gat/stats 等有限的几个命令。Mc 的访问协议简单，跟它的存储结构也有关系。</p>
</li>
<li><p>Mc 存储结构很简单，只存储简单的 key/value 键值对，而且对 value 直接以二进制方式存储，不识别内部存储结构，所以有限几个指令就可以满足操作需要。</p>
</li>
<li><p>Mc 完全基于内存操作，在系统运行期间，在有新 key 写进来时，如果没有空闲内存分配，就会对最不活跃的 key 进行 eviction 剔除操作。</p>
</li>
<li><p>最后，Mc 服务节点运行也特别简单，不同 Mc 节点之间互不通信，由 client 自行负责管理数据分布。</p>
</li>
</ul>
<h2 id="Memcached-系统架构"><a href="#Memcached-系统架构" class="headerlink" title="Memcached 系统架构"></a>Memcached 系统架构</h2><p>如下图所示，Mc 的系统架构主要包括<strong>网络处理模块</strong>、<strong>多线程处理模块</strong>、<strong>哈希表</strong>、<strong>LRU</strong>、<strong>slab 内存分配模块</strong> 5 部分。Mc 基于 Libevent 实现了网络处理模块，通过多线程并发处理用户请求；基于哈希表对 key 进行快速定位，基于 LRU 来管理冷数据的剔除淘汰，基于 slab 机制进行快速的内存分配及存储。</p>
<p><img src="http://image.leonote.cn//20210207104454.jpg" alt=""></p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>Mc 基于 Libevent 开发实现了多线程网络模型。Mc 的多线程网络模型分为主线程、工作线程。这些线程通过多路复用 IO 来进行网络 IO 接入以及读写处理。在 Linux 下，通常使用 epoll。通过多路复用 IO，特别是 epoll 的使用，Mc 线程无须遍历整个被侦听的描述符集，只要在被通知后遍历 Ready 队列的描述符集合就 OK 了。这些描述符是在各项准备工作完成之后，才被内核 IO 事件异步通知。也就是说，只在连接做好准备后，系统才会进行事件通知，Mc 才会进行 I/O 操作。这样就不会发生阻塞，使 Mc 在支持高并发的同时，拥有非常高的 IO 吞吐效率。</p>
<p>Mc 除了用于 IO 的主线程和工作线程外，还用于多个辅助线程，如 Item 爬虫线程、LRU 维护线程、哈希表维护线程等，通过多线程并发工作，Mc 可以充分利用机器的多个核心，实现很好的网络 IO 性能和数据处理能力。</p>
<p>Mc 通过哈希表即 Hash table 来快速定位 key。数据存储时，数据 Item 结构在存入 slab 中的 chunk 后，也会被存放到 Hash table 中。同时，Mc 的哈希表会在每个桶，通过 Item 记录一个单向链表，以此来解决不同 key 在哈希表中的 Hash 冲突问题。 当需要查找给定 key 的 Item 时，首先计算 key 的 Hash 值，然后对哈希表中与 Hash 值对应的 bucket 中进行搜索，通过轮询 bucket 里的单向链表，找到该 key 对应的 Item 指针，这样就找到了 key 对应的存储 Item，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210207104946.jpg" alt=""></p>
<p>正常情况下，Mc 对哈希表的插入、查找操作都是在主表中进行的。当表中 Item 数量大于哈希表 bucket 节点数的 1.5 倍时，就对哈希表进行扩容。如下图所示，扩容时，Mc 内部使用两张 Hash table，一个主哈希表 primary_hashtable，一个是旧哈希表 old_hashtable。当扩容开始时，原来的主哈希表就成为旧哈希表，而新分配一个 2 倍容量的哈希表作为新的主表。扩容过程中，维护线程会将旧表的 Item 指针，逐步复制插入到新主哈希表。迁移过程中，根据迁移位置，用户请求会同时查旧表和新的主表，当数据全部迁移完成，所有的操作就重新回到主表中进行。</p>
<p><img src="http://image.leonote.cn//20210207105104.jpg" alt=""></p>
<h4 id="LRU-机制"><a href="#LRU-机制" class="headerlink" title="LRU 机制"></a>LRU 机制</h4><p>Mc 主要通过 LRU 机制，来进行冷数据淘汰的。自 1.4.24 版本之后，Mc 不断优化 LRU 算法，当前 Mc 版本已默认启用<strong>分段 LRU</strong> 了。在启用分段 LRU 之前，每个 slabclass id 只对应一个 COLD  LRU，在内存不足时，会直接从 COLD LRU 剔除数据。而在启用分段 LRU 之后，每个 slabclass id 就有 <strong>TEMP</strong>、<strong>HOT</strong>、<strong>WARM</strong> 和 <strong>COLD</strong>  四个 LRU。</p>
<p>如下图所示，<strong>TEMP LRU 中 Item 剩余过期时间通常很短，默认是 61 秒以内</strong>。该列队中的 Item 永远不会发生在队列内搬运，也不会迁移到其他队列。在插入新 key/value 时，如果 key 的剩余过期时间小于 61 秒，则直接进入 TEMP LRU。后面，在必要时直接进行过期即可。这样避免了锁竞争，性能也更高。</p>
<p><img src="http://image.leonote.cn//20210207105242.jpg" alt=""></p>
<p>对于 HOT LRU，内部不搬运，当队列满时，如果队尾 Item 是 Active 状态，即被访问过，那么会迁移到 WARM 队列，否则迁移到 COLD 队列。</p>
<p>对于 WARM LRU，如果队列的 Item 被再次访问，就搬到队首，否则迁移到 COLD 队列。</p>
<p>对于 COLD LRU，存放的是最不活跃的 Item，一旦内存满了，队尾的 Item 会被剔除。如果 COLD LRU 里的 Item 被再次访问，会迁移到 WARM LRU。</p>
<h4 id="slab-分配机制"><a href="#slab-分配机制" class="headerlink" title="slab 分配机制"></a>slab 分配机制</h4><p>一般应用系统的内存分配是直接采用 malloc 和 free 来进行分配及回收的。长时间运行后，内存碎片越来越多，严重增加系统内存管理器的负担。碎片的不断产生，不仅导致大量的内存浪费，而且碎片整理越来越复杂，会导致内存分配越来越慢，进而导致系统分配速度和存储效率越来越差。Mc 的 slab 分配机制的出现，碎片问题迎刃而解。下面先来简单了解一下 Mc 的 slab 分配机制。</p>
<p>Mc 通过 slab 机制来分配管理内存的，如下图所示。可以说，slab 分配机制的使用，是 Mc 分配及存储高性能的关键所在。在 Mc 启动时，会创建 <strong>64 个 slabclass</strong>，但<strong>索引为 0 的 slabclass 做 slab 重新分配之用</strong>，基本不参与其他 slabclass 的日常分配活动。<strong>每个 slabclass 会根据需要不断分配默认大小为 1MB 的 slab</strong>。</p>
<p>每个 slab 又被分为相同大小的 chunk。<strong>chunk 就是 Mc 存储数据的基本存储单位</strong>。<strong>slabclass 1 的 chunk size 最小，默认最小 chunk 的大小是 102 字节</strong>，后续的 slabclass 会按照增长因子逐步增大 chunk size，具体数值会进一步对 8 取整。<strong>Mc 默认的增长因子是 1.25</strong>，启动时可以通过 -f 将增长因子设为其他值。比如采用默认值，slabclass 1 的 chunk size 是 102，slabclass 2 的 chunk size 是 102×1.25，再对 8 取整后是 128。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// size = 127.5 = 102 * 1.25</span></span><br><span class="line"><span class="comment">// CHUNK_ALIGN_BYTES = 8</span></span><br><span class="line"><span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES) &#123;</span><br><span class="line"> 	size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://image.leonote.cn//20210207105558.jpg" alt=""></p>
<p>Mc slab 中的 chunk 中通过 Item 结构存 key/value 键值对，Item 结构体的头部存链表的指针、flag、过期时间等，然后存 key 及 value。一般情况下，Item 并不会将 chunk 填满，但由于每个 key/value 在存储时，都会根据 kev/value size，选择最接近的 slabclass，所以 chunk 浪费的字节非常有限，基本可以忽略。</p>
<p>每次新分配一个 slab 后，会将 slab 空间等分成相同 size 的 chunk，这些 chunk 会被加入到 slabclass 的 freelist 中，在需要时进行分配。分配出去的 chunk 存储 Item 数据，在过期被剔除后，会再次进入 freelist，供后续使用。</p>
<h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><p><strong>主线程</strong></p>
<p>Mc 基于 Libevent 实现多线程网络 IO 模型。Mc 的 IO 处理线程分主线程和工作线程，每个线程各有一个 event_base，来监听网络事件。</p>
<ul>
<li>主线程负责<strong>监听及建立连接</strong>。</li>
<li>工作线程负责对建立的连接进行<strong>网络 IO 读取、命令解析、处理及响应</strong>。</li>
</ul>
<p>Mc 主线程在监听端口时，当有连接到来，主线程 accept 该连接，并将连接调度给工作线程。调度处理逻辑，主线程先将 fd 封装成一个 CQ_ITEM 结构，并存入新连接队列中，然后轮询一个工作线程，并通过管道向该工作线程发送通知。工作线程监听到通知后，会从新连接队列获取一个连接，然后开始从这个连接读取网络 IO 并处理，如下图所示。主线程的这个处理逻辑主要在状态机中执行，对应的连接状态为 <code>conn_listening</code>。</p>
<p><img src="http://image.leonote.cn//20210207165431.jpg" alt=""></p>
<p><strong>工作线程</strong></p>
<p>工作线程监听到主线程的管道通知后，会从连接队列弹出一个新连接，然后就会创建一个 conn 结构体，注册该 conn 读事件，然后继续监听该连接上的 IO 事件。后续这个连接有命令进来时，工作线程会读取 client 发来的命令，进行解析并处理，最后返回响应。工作线程的主要处理逻辑也是在状态机中，一个名叫 <code>drive_machine</code> 的函数。</p>
<p><strong>状态机</strong></p>
<p>这个状态机由主线程和工作线程共享，实际是采用 switch-case 来实现的。状态机函数如下图所示，switch 连接的 state，然后根据连接的不同状态，执行不同的逻辑操作，并进行状态转换。</p>
<p><img src="http://image.leonote.cn//20210207170035.jpg" alt=""></p>
<p><strong>主线程状态机</strong></p>
<p>如下图所示，主线程在状态机中只处理 <code>conn_listening</code> 状态，负责 accept 新连接和调度新连接给工作线程。状态机中其他状态处理基本都在工作线程中进行。由于 Mc 同时支持 TCP、UDP 协议，而互联网企业大多使用 TCP 协议，并且通过文本协议，来访问 Mc，所以后面状态机的介绍，将主要结合 TCP 文本协议来进行重点分析。</p>
<p><img src="http://image.leonote.cn//20210207170811.jpg" alt=""></p>
<p><strong>工作线程状态机</strong></p>
<p>工作线程的状态机处理逻辑，如下图所示，包括刚建立 conn 连接结构体时进行的一些重置操作，然后注册读事件，在有数据进来时，读取网络数据，并进行解析并处理。如果是读取指令或统计指令，至此就基本处理完毕，接下来将响应写入连接缓冲。如果是更新指令，在进行初步处理后，还会继续读取 value 部分，再进行存储或变更，待变更完毕后将响应写入连接缓冲。最后再将响应写给 client。响应 client 后，连接会再次重置连接状态，等待进入下一次的命令处理循环中。这个过程主要包含了 <code>conn_new_cmd</code>、<code>conn_waiting</code>、<code>conn_read</code>、<code>conn_parse_cmd</code>、<code>conn_nread</code>、<code>conn_write</code>、<code>conn_mwrite</code>、<code>conn_closing</code> 这 8 个状态事件。</p>
<h5 id="工作线程状态事件及逻辑处理"><a href="#工作线程状态事件及逻辑处理" class="headerlink" title="工作线程状态事件及逻辑处理"></a>工作线程状态事件及逻辑处理</h5><ul>
<li><p><code>conn_new_cmd</code></p>
<p>主线程通过调用 dispatch_conn_new，把新连接调度给工作线程后，worker 线程创建 conn 对象，这个连接初始状态就是 <code>conn_new_cmd</code>。除了通过新建连接进入 <code>conn_new_cmd</code> 状态之外，如果连接命令处理完毕，准备接受新指令时，也会将连接的状态设置为 <code>conn_new_cmd</code> 状态。</p>
<p>进入 <code>conn_new_cmd</code> 后，工作线程会调用 reset_cmd_handler 函数，重置 conn 的 cmd 和 substate 字段，并在必要时对连接 buf 进行收缩。因为连接在处理 client 来的命令时，对于写指令，需要分配较大的读 buf 来存待更新的 key value，而对于读指令，则需要分配较大的写 buf 来缓冲待发送给 client 的 value 结果。持续运行中，随着大 size value 的相关操作，这些缓冲会占用很多内存，所以需要设置一个阀值，超过阀值后就进行缓冲内存收缩，避免连接占用太多内存。在后端服务以及中间件开发中，这个操作很重要，因为线上服务的连接很容易达到万级别，如果一个连接占用几十 KB 以上的内存，后端系统仅连接就会占用数百 MB 甚至数 GB 以上的内存空间。</p>
<p>工作线程处理完 <code>conn_new_cmd</code> 状态的主要逻辑后，如果读缓冲区有数据可以读取，则进入 <code>conn_parse_cmd</code> 状态，否则就会进入到 <code>conn_waiting</code> 状态，等待网络数据进来。</p>
</li>
<li><p><code>conn_waiting</code></p>
<p>连接进入 <code>conn_waiting</code> 状态后，处理逻辑很简单，直接通过 update_event 函数注册读事件即可，之后会将连接状态更新为 <code>conn_read</code>。</p>
</li>
<li><p><code>conn_read</code></p>
<p>当工作线程监听到网络数据进来，连接就进入 <code>conn_read</code> 状态。对 <code>conn_read</code> 的处理，是通过 try_read_network 从 socket 中读取网络数据。如果读取失败，则进入 <code>conn_closing</code> 状态，关闭连接。如果没有读取到任何数据，则会返回 <code>conn_waiting</code>，继续等待 client 端的数据到来。如果读取数据成功，则会将读取的数据存入 conn 的 rbuf 缓冲，并进入 <code>conn_parse_cmd</code> 状态，准备解析 cmd。</p>
</li>
<li><p><code>conn_parse_cmd</code></p>
<p><code>conn_parse_cmd</code> 状态的处理逻辑就是解析命令。工作线程首先通过 try_read_command 读取连接的读缓冲，并通过 \n 来分隔数据报文的命令。如果命令首行长度大于 1024，关闭连接，这就意味着 key 长度加上其他各项命令字段的总长度要小于 1024字节。当然对于 key，Mc 有个默认的最大长度，key_max_length，默认设置为 250字节。校验完毕首行报文的长度，接下来会在 process_command 函数中对首行指令进行处理。</p>
<p>process_command 用来处理 Mc 的所有协议指令，所以这个函数非常重要。process_command 会首先按照空格分拆报文，确定命令协议类型，分派给 process_XX_command 函数处理。</p>
<p>Mc 的命令协议从直观逻辑上可以分为获取类型、变更类型、其他类型。但从实际处理层面区分，则可以细分为 get 类型、update 类型、delete 类型、算术类型、touch 类型、stats 类型，以及其他类型。对应的处理函数为，process_get_command, process_update_command, process_arithmetic_command, process_touch_command等。每个处理函数能够处理不同的协议，具体参见下图所示思维导图。</p>
<p><img src="http://image.leonote.cn//20210207171745.jpg" alt=""></p>
</li>
</ul>
<blockquote>
<p>注意:</p>
<p><code>conn_parse_cmd</code> 的状态处理，只有读取到 \n，有了完整的命令首行协议，才会进入 process_command，否则会跳转到 <code>conn_waiting</code>，继续等待客户端的命令数据报文。在 process_command 处理中，如果是获取类命令，在获取到 key 对应的 value 后，则跳转到 <code>conn_mwrite</code>，准备写响应给连接缓冲。而对于 update 变更类型的指令，则需要继续读取 value 数据，此时连接会跳转到 <code>conn_nread</code> 状态。在 <code>conn_parse_cmd</code> 处理过程中，如果遇到任何失败，都会跳转到 <code>conn_closing</code> 关闭连接。</p>
</blockquote>
<ul>
<li><p><code>complete_nread</code></p>
<p>对于 update 类型的协议指令，从 conn 继续读取 value 数据。读取到 value 数据后，会调用 <code>complete_nread</code>，进行数据存储处理；数据处理完毕后，向 conn 的 wbuf 写响应结果。然后 update 类型处理的连接进入到 <code>conn_write</code> 状态。</p>
</li>
<li><p><code>conn_write</code></p>
<p>连接 <code>conn_write</code> 状态处理逻辑很简单，直接进入 <code>conn_mwrite</code> 状态。或者当 conn 的 iovused 为 0 或对于 udp 协议，将响应写入 conn 消息缓冲后，再进入 <code>conn_mwrite</code> 状态。</p>
</li>
<li><p><code>conn_mwrite</code><br>进入 <code>conn_mwrite</code> 状态后，工作线程将通过 transmit 来向客户端写数据。如果写数据失败，跳转到 <code>conn_closing</code>，关闭连接退出状态机。如果写数据成功，则跳转到 <code>conn_new_cmd</code>，准备下一次新指令的获取。</p>
</li>
<li><p><code>conn_closing</code><br>最后一个 <code>conn_closing</code> 状态，前面提到过很多次，在任何状态的处理过程中，如果出现异常，就会进入到这个状态，关闭连接，这个连接也就 Game Over了。</p>
</li>
</ul>
<h5 id="Mc-命令处理全流程"><a href="#Mc-命令处理全流程" class="headerlink" title="Mc 命令处理全流程"></a>Mc 命令处理全流程</h5><p><img src="http://image.leonote.cn//20210207172216.jpg" alt=""></p>
<ul>
<li><p>Mc 启动后，主线程监听并准备接受新连接接入。当有新连接接入时，主线程进入 <code>conn_listening</code> 状态，accept 新连接，并将新连接调度给工作线程。</p>
</li>
<li><p>Worker 线程监听管道，当收到主线程通过管道发送的消息后，工作线程中的连接进入 <code>conn_new_cmd</code> 状态，创建 conn 结构体，并做一些初始化重置操作，然后进入 <code>conn_waiting</code> 状态，注册读事件，并等待网络 IO。</p>
</li>
<li><p>有数据到来时，连接进入 <code>conn_read</code> 状态，读取网络数据。</p>
</li>
<li><p>读取成功后，就进入 <code>conn_parse_cmd</code> 状态，然后根据 Mc 协议解析指令。</p>
</li>
<li><p>对于读取指令，获取到 value 结果后，进入 <code>conn_mwrite</code> 状态。</p>
</li>
<li><p>对于变更指令，则进入 <code>conn_nread</code>，进行 value 的读取，读取到 value 后，对 key 进行变更，当变更完毕后，进入 <code>conn_write</code>，然后将结果写入缓冲。然后和读取指令一样，也进入 <code>conn_mwrite</code> 状态。</p>
</li>
<li><p>进入到 <code>conn_mwrite</code> 状态后，将结果响应发送给 client。发送响应完毕后，再次进入到 <code>conn_new_cmd</code> 状态，进行连接重置，准备下一次命令处理循环。</p>
</li>
<li><p>在读取、解析、处理、响应过程，遇到任何异常就进入 <code>conn_closing</code>，关闭连接。</p>
</li>
</ul>
<p>为了方便理解，提供思维导图，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210207172334.jpg" alt=""></p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-Redis原理、协议及使用</title>
    <url>/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Redis%E5%8E%9F%E7%90%86%E3%80%81%E5%8D%8F%E8%AE%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Redis原理、协议及使用"><a href="#Redis原理、协议及使用" class="headerlink" title="Redis原理、协议及使用"></a>Redis原理、协议及使用</h1><h2 id="Redis是如何运行的"><a href="#Redis是如何运行的" class="headerlink" title="Redis是如何运行的"></a>Redis是如何运行的</h2><h3 id="Redis-基本原理"><a href="#Redis-基本原理" class="headerlink" title="Redis 基本原理"></a>Redis 基本原理</h3><h4 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h4><p>Redis 是一款基于 ANSI C 语言编写的，BSD 许可的，日志型 key-value 存储组件，它的所有数据结构都存在内存中，可以用作缓存、数据库和消息中间件。</p>
<p>Redis 是 Remote dictionary server 即远程字典服务的缩写，一个 Redis 实例可以有多个存储数据的字典，客户端可以通过 select 来选择字典即 DB 进行数据存储。</p>
<h4 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h4><p>同为 key-value 存储组件，Memcached 只能支持二进制字节块这一种数据类型。而 Redis 的数据类型却丰富的多，它具有 8 种核心数据类型，每种数据类型都有一系列操作指令对应。Redis 性能很高，单线程压测可以达到 10~11w 的 QPS。</p>
<p>虽然 Redis 所有数据的读写操作，都在内存中进行，但也可以将所有数据进行落盘做持久化。Redis 提供了 2 种持久化方式。</p>
<ul>
<li><p>快照方式，将某时刻所有数据都写入硬盘的 RDB 文件；</p>
</li>
<li><p>追加文件方式，即将所有写命令都以追加的方式写入硬盘的 AOF 文件中。</p>
</li>
</ul>
<p>线上 Redis 一般会同时使用两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。 </p>
<p>对于互联网系统的线上流量，读操作远远大于写操作。以微博为例，读请求占总体流量的 90%左右。大量的读请求，通常会远超 Redis 的可承载范围。此时，可以使用 Redis 的复制特性，让一个 Redis 实例作为 master，然后通过复制挂载多个不断同步更新的副本，即多个 slave。通过读写分离，把所有写操作落在 Redis 的 master，所有读操作随机落在 Redis 的多个 slave 中，从而大幅提升 Redis 的读写能力。</p>
<p>Lua 是一个高效、简洁、易扩展的脚本语言，可以方便的嵌入其他语言中使用。Redis 自 2.6 版本开始支持 Lua。通过支持 client 端自定义的 Lua 脚本，Redis 可以减少网络开销，提升处理性能，还可以把脚本中的多个操作作为一个整体来操作，实现原子性更新。</p>
<p>Redis 还支持事务，在 multi 指令后，指定多个操作，然后通过 exec 指令一次性执行，中途如果出现异常，则不执行所有命令操作，否则，按顺序一次性执行所有操作，执行过程中不会执行任何其他指令。</p>
<p>Redis 还支持 Cluster 特性，可以通过自动或手动方式，将所有 key 按哈希分散到不同节点，在容量不足时，还可以通过 Redis 的迁移指令，把其中一部分 key 迁移到其他节点。</p>
<p><strong>思维导图</strong></p>
<p><img src="http://image.leonote.cn/20210714221853.png" alt=""></p>
<p>作为缓存组件，Redis 的最大优势是支持丰富的数据类型。目前，Redis 支持 8 种核心数据类型，包括 string、list、set、sorted set、hash、bitmap、geo、hyperloglog。</p>
<p>Redis 的所有内存数据结构都存在全局的 dict 字典中，dict 类似 Memcached 的 hashtable。Redis 的 dict 也有 2 个哈希表，插入新 key 时，一般用 0 号哈希表，随着 key 的插入或删除，当 0 号哈希表的 keys 数大于哈希表桶数，或 kyes 数小于哈希桶的 1/10 时，就对 hash 表进行扩缩。dict 中，哈希表解决冲突的方式，与 Memcached 相同，也是使用桶内单链表，来指向多个 hash 相同的 key/value 数据。</p>
<h4 id="Redis-高性能"><a href="#Redis-高性能" class="headerlink" title="Redis 高性能"></a>Redis 高性能</h4><p>Redis 一般被看作单进程/单线程组件，因为 Redis 的网络 IO 和命令处理，都在核心进程中由单线程处理。Redis 基于 Epoll 事件模型开发，可以进行非阻塞网络 IO，同时由于单线程命令处理，整个处理过程不存在竞争，不需要加锁，没有上下文切换开销，所有数据操作都是在内存中操作，所以 Redis 的性能很高，单个实例即可以达到 10w 级的 QPS。核心线程除了负责网络 IO 及命令处理外，还负责写数据到缓冲，以方便将最新写操作同步到 AOF、slave。</p>
<p>除了主进程，Redis 还会 fork 一个子进程，来进行重负荷任务的处理。Redis fork 子进程主要有 3 种场景。</p>
<ul>
<li><p>收到 bgrewriteaof 命令时，Redis 调用 fork，构建一个子进程，子进程往临时 AOF文件中，写入重建数据库状态的所有命令，当写入完毕，子进程则通知父进程，父进程把新增的写操作也追加到临时 AOF 文件，然后将临时文件替换老的 AOF 文件，并重命名。</p>
</li>
<li><p>收到 bgsave 命令时，Redis 构建子进程，子进程将内存中的所有数据通过快照做一次持久化落地，写入到 RDB 中。</p>
</li>
<li><p>当需要进行全量复制时，master 也会启动一个子进程，子进程将数据库快照保存到 RDB 文件，在写完 RDB 快照文件后，master 就会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave。</p>
</li>
</ul>
<p><img src="http://image.leonote.cn/20210714221918.png" alt=""></p>
<p>主进程中，除了主线程处理网络 IO 和命令操作外，还有 3 个辅助 BIO 线程。这 3 个 BIO 线程分别负责处理，文件关闭、AOF 缓冲数据刷新到磁盘，以及清理对象这三个任务队列。</p>
<p>Redis 在启动时，会同时启动这三个 BIO 线程，然后 BIO 线程休眠等待任务。当需要执行相关类型的后台任务时，就会构建一个 bio_job 结构，记录任务参数，然后将 bio_job 追加到任务队列尾部。然后唤醒 BIO 线程，即可进行任务执行。</p>
<h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><p>Redis 的持久化是通过 RDB 和 AOF 文件进行的。RDB 只记录某个时间点的快照，可以通过设置指定时间内修改 keys 数的阀值，超过则自动构建 RDB 内容快照，不过线上运维，一般会选择在业务低峰期定期进行。RDB 存储的是构建时刻的数据快照，内存数据一旦落地，不会理会后续的变更。而 AOF，记录是构建整个数据库内容的命令，它会随着新的写操作不断进行追加操作。由于不断追加，AOF 会记录数据大量的中间状态，AOF 文件会变得非常大，此时，可以通过 bgrewriteaof 指令，对 AOF 进行重写，只保留数据的最后内容，来大大缩减 AOF 的内容。</p>
<p><img src="http://image.leonote.cn/20210714221944.png" alt=""><br>为了提升系统的可扩展性，提升读操作的支撑能力，Redis 支持 master-slave 的复制功能。当 Redis 的 slave 部署并设置完毕后，slave 会和 master 建立连接，进行全量同步。</p>
<p>第一次建立连接，或者长时间断开连接后，缺失的指令超过 master 复制缓冲区的大小，都需要先进行一次全量同步。全量同步时，master 会启动一个子进程，将数据库快照保存到文件中，然后将这个快照文件发给 slave，同时将快照之后的写指令也同步给 slave。</p>
<p>全量同步完成后，如果 slave 短时间中断，然后重连复制，缺少的写指令长度小于 master 的复制缓冲大小，master 就会把 slave 缺失的内容全部发送给 slave，进行增量复制。</p>
<p>Redis 的 master 可以挂载多个 slave，同时 slave 还可以继续挂载 slave，通过这种方式，可以有效减轻 master 的压力，同时在 master 挂掉后，可以在 slave 通过 slaveof no one 指令，使当前 slave 停止与 master 的同步，转而成为新的 master。</p>
<h4 id="Redis-集群管理"><a href="#Redis-集群管理" class="headerlink" title="Redis 集群管理"></a>Redis 集群管理</h4><p>Redis 的集群管理有 3 种方式。</p>
<ul>
<li><p>client 分片访问，client 对 key 做 hash，然后按取模或一致性 hash，把 key 的读写分散到不同的 Redis 实例上。</p>
</li>
<li><p>在 Redis 前加一个 proxy，把路由策略、后端 Redis 状态维护的工作都放到 proxy 中进行，client 直接访问 proxy，后端 Redis 变更，只需修改 proxy 配置即可。</p>
</li>
<li><p>直接使用 Redis cluster。Redis 创建之初，使用方直接给 Redis 的节点分配 slot，后续访问时，对 key 做 hash 找到对应的 slot，然后访问 slot 所在的 Redis 实例。在需要扩容缩容时，可以在线通过 cluster setslot 指令，以及 migrate 指令，将 slot 下所有 key 迁移到目标节点，即可实现扩缩容的目的。</p>
</li>
</ul>
<h2 id="如何使用Redis核心数据类型"><a href="#如何使用Redis核心数据类型" class="headerlink" title="如何使用Redis核心数据类型"></a>如何使用Redis核心数据类型</h2><h3 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h3><p>Redis 有 8 种核心数据类型，分别是 ：</p>
<ul>
<li><p>string 字符串类型；</p>
</li>
<li><p>list 列表类型；</p>
</li>
<li><p>set 集合类型；</p>
</li>
<li><p>sorted set 有序集合类型；</p>
</li>
<li><p>hash 类型；</p>
</li>
<li><p>bitmap 位图类型； </p>
</li>
<li><p>geo 地理位置类型；</p>
</li>
<li><p>HyperLogLog 基数统计类型。</p>
</li>
</ul>
<h4 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h4><p>string 是 Redis 的最基本数据类型。可以把它理解为 Mc 中 key 对应的 value 类型。string 类型是二进制安全的，即 string 中可以包含任何数据。</p>
<p>Redis 中的普通 string 采用 raw encoding 即原始编码方式，该编码方式会动态扩容，并通过提前预分配冗余空间，来减少内存频繁分配的开销。</p>
<p>在字符串长度小于 1MB 时，按所需长度的 2 倍来分配，超过 1MB，则按照每次额外增加 1MB 的容量来预分配。</p>
<p>Redis 中的数字也存为 string 类型，但编码方式跟普通 string 不同，数字采用整型编码，字符串内容直接设为整数值的二进制字节序列。</p>
<p>在存储普通字符串，序列化对象，以及计数器等场景时，都可以使用 Redis 的字符串类型，字符串数据类型对应使用的指令包括 set、get、mset、incr、decr 等。</p>
<h4 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h4><p>Redis 的 list 列表，是一个快速双向链表，存储了一系列的 string 类型的字串值。list 中的元素按照插入顺序排列。插入元素的方式，可以通过 lpush 将一个或多个元素插入到列表的头部，也可以通过 rpush 将一个或多个元素插入到队列尾部，还可以通过 lset、linsert 将元素插入到指定位置或指定元素的前后。</p>
<p>list 列表的获取，可以通过 lpop、rpop 从对头或队尾弹出元素，如果队列为空，则返回 nil。还可以通过 Blpop、Brpop 从队头/队尾阻塞式弹出元素，如果 list 列表为空，没有元素可供弹出，则持续阻塞，直到有其他 client 插入新的元素。这里阻塞弹出元素，可以设置过期时间，避免无限期等待。最后，list 列表还可以通过 LrangeR 获取队列内指定范围内的所有元素。Redis 中，list 列表的偏移位置都是基于 0 的下标，即列表第一个元素的下标是 0，第二个是 1。偏移量也可以是负数，倒数第一个是 -1，倒数第二个是 -2，依次类推。</p>
<p><img src="http://image.leonote.cn/20210714222016.png" alt=""></p>
<p>list 列表，对于常规的 pop、push 元素，性能很高，时间复杂度为 O(1)，因为是列表直接追加或弹出。但对于通过随机插入、随机删除，以及随机范围获取，需要轮询列表确定位置，性能就比较低下了。</p>
<p>feed timeline 存储时，由于 feed id 一般是递增的，可以直接存为 list，用户发表新 feed，就直接追加到队尾。另外消息队列、热门 feed 等业务场景，都可以使用 list 数据结构。</p>
<p>操作 list 列表时，可以用 lpush、lpop、rpush、rpop、lrange 来进行常规的队列进出及范围获取操作，在某些特殊场景下，也可以用 lset、linsert 进行随机插入操作，用 lrem 进行指定元素删除操作；最后，在消息列表的消费时，还可以用 Blpop、Brpop 进行阻塞式获取，从而在列表暂时没有元素时，可以安静的等待新元素的插入，而不需要额外持续的查询。</p>
<h4 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h4><p>set 是 string 类型的无序集合，set 中的元素是唯一的，即 set 中不会出现重复的元素。Redis 中的集合一般是通过 dict 哈希表实现的，所以插入、删除，以及查询元素，可以根据元素 hash 值直接定位，时间复杂度为 O(1)。</p>
<p>对 set 类型数据的操作，除了常规的添加、删除、查找元素外，还可以用以下指令对 set 进行操作。</p>
<ul>
<li><p>sismember 指令判断该 key 对应的 set 数据结构中，是否存在某个元素，如果存在返回 1，否则返回 0；</p>
</li>
<li><p>sdiff 指令来对多个 set 集合执行差集；</p>
</li>
<li><p>sinter 指令对多个集合执行交集；</p>
</li>
<li><p>sunion 指令对多个集合执行并集；</p>
</li>
<li><p>spop 指令弹出一个随机元素；</p>
</li>
<li><p>srandmember 指令返回一个或多个随机元素。</p>
</li>
</ul>
<p>set 集合的特点是查找、插入、删除特别高效，时间复杂度为 O(1)，所以在社交系统中，可以用于存储关注的好友列表，用来判断是否关注，还可以用来做好友推荐使用。另外，还可以利用 set 的唯一性，来对服务的来源业务、来源 IP 进行精确统计。</p>
<h4 id="sorted-set-有序集合"><a href="#sorted-set-有序集合" class="headerlink" title="sorted set 有序集合"></a>sorted set 有序集合</h4><p>Redis 中的 sorted set 有序集合也称为 zset，有序集合同 set 集合类似，也是 string 类型元素的集合，且所有元素不允许重复。</p>
<p>但有序集合中，每个元素都会关联一个 double 类型的 score 分数值。有序集合通过这个 score 值进行由小到大的排序。有序集合中，元素不允许重复，但 score 分数值却允许重复。</p>
<p>有序集合除了常规的添加、删除、查找元素外，还可以通过以下指令对 sorted set 进行操作。</p>
<ul>
<li><p>zscan 指令：按顺序获取有序集合中的元素；</p>
</li>
<li><p>zscore 指令：获取元素的 score 值；</p>
</li>
<li><p>zrange指令：通过指定 score 返回指定 score 范围内的元素；</p>
</li>
</ul>
<ul>
<li><p>在某个元素的 score 值发生变更时，还可以通过 zincrby 指令对该元素的 score 值进行加减。</p>
</li>
<li><p>通过 zinterstore、zunionstore 指令对多个有序集合进行取交集和并集，然后将新的有序集合存到一个新的 key 中，如果有重复元素，重复元素的 score 进行相加，然后作为新集合中该元素的 score 值。</p>
</li>
</ul>
<p>sorted set 有序集合的特点是：</p>
<ul>
<li><p>所有元素按 score 排序，而且不重复；</p>
</li>
<li><p>查找、插入、删除非常高效，时间复杂度为 O(1)。</p>
</li>
</ul>
<p>因此，可以用有序集合来统计排行榜，实时刷新榜单，还可以用来记录学生成绩，从而轻松获取某个成绩范围内的学生名单，还可以用来对系统统计增加权重值，从而在 dashboard 实时展示。</p>
<h4 id="hash-哈希"><a href="#hash-哈希" class="headerlink" title="hash 哈希"></a>hash 哈希</h4><p>Redis 中的哈希实际是 field 和 value 的一个映射表。</p>
<p>hash 数据结构的特点是在单个 key 对应的哈希结构内部，可以记录多个键值对，即 field 和 value 对，value 可以是任何字符串。而且这些键值对查询和修改很高效。</p>
<p>所以可以用 hash 来存储具有多个元素的复杂对象，然后分别修改或获取这些元素。hash 结构中的一些重要指令，包括：hmset、hmget、hexists、hgetall、hincrby 等。</p>
<ul>
<li><p>hmset 指令批量插入多个 field、value 映射；</p>
</li>
<li><p>hmget 指令获取多个 field 对应的 value 值；</p>
</li>
<li><p>hexists 指令判断某个 field 是否存在；</p>
</li>
</ul>
<ul>
<li>如果 field 对应的 value 是整数，还可以用 hincrby 来对该 value 进行修改。</li>
</ul>
<h4 id="bitmap-位图"><a href="#bitmap-位图" class="headerlink" title="bitmap 位图"></a>bitmap 位图</h4><p>Redis 中的 bitmap 位图是一串连续的二进制数字，底层实际是基于 string 进行封装存储的，按 bit 位进行指令操作的。bitmap 中每一 bit 位所在的位置就是 offset 偏移，可以用 setbit、bitfield 对 bitmap 中每个 bit 进行置 0 或置 1 操作，也可以用 bitcount 来统计 bitmap 中的被置 1 的 bit 数，还可以用 bitop 来对多个 bitmap 进行求与、或、异或等操作。</p>
<p><img src="http://image.leonote.cn/20210714222040.png" alt=""></p>
<p>bitmap 位图的特点是按位设置、求与、求或等操作很高效，而且存储成本非常低，用来存对象标签属性的话，一个 bit 即可存一个标签。可以用 bitmap，存用户最近 N 天的登录情况，每天用 1 bit，登录则置 1。个性推荐在社交应用中非常重要，可以对新闻、feed 设置一系列标签，如军事、娱乐、视频、图片、文字等，用 bitmap 来存储这些标签，在对应标签 bit 位上置 1。对用户，也可以采用类似方式，记录用户的多种属性，并可以很方便的根据标签来进行多维度统计。bitmap 位图的重要指令包括：setbit、 getbit、bitcount、bitfield、 bitop、bitpos 等。</p>
<p>在移动社交时代，LBS 应用越来越多，比如微信、陌陌中附近的人，美团、大众点评中附近的美食、电影院，滴滴、优步中附近的专车等。要实现这些功能，就得使用地理位置信息进行搜索。地球的地理位置是使用二维的经纬度进行表示的，只要确定一个点的经纬度，就可以确认它在地球的位置。</p>
<p>Redis 在 3.2 版本之后增加了对 GEO 地理位置的处理功能。Redis 的 GEO 地理位置本质上是基于 sorted set 封装实现的。在存储分类 key 下的地理位置信息时，需要对该分类 key 构建一个 sorted set 作为内部存储结构，用于存储一系列位置点。</p>
<p>在存储某个位置点时，首先利用 Geohash 算法，将该位置二维的经纬度，映射编码成一维的 52 位整数值，将位置名称、经纬度编码 score 作为键值对，存储到分类 key 对应的 sorted set 中。</p>
<p>需要计算某个位置点 A 附近的人时，首先以指定位置 A 为中心点，以距离作为半径，算出 GEO 哈希 8 个方位的范围， 然后依次轮询方位范围内的所有位置点，只要这些位置点到中心位置 A 的距离在要求距离范围内，就是目标位置点。轮询完所有范围内的位置点后，重新排序即得到位置点 A 附近的所有目标。</p>
<ul>
<li><p>使用 geoadd，将位置名称（如人、车辆、店名）与对应的地理位置信息添加到指定的位置分类 key 中；</p>
</li>
<li><p>使用 geopos 方便地查询某个名称所在的位置信息；</p>
</li>
<li><p>使用 georadius 获取指定位置附近，不超过指定距离的所有元素；</p>
</li>
<li><p>使用 geodist 来获取指定的两个位置之间的距离。</p>
</li>
</ul>
<p>这样，是不是就可以实现，找到附近的餐厅，算出当前位置到对应餐厅的距离，这样的功能了？</p>
<p>Redis GEO 地理位置，利用 Geohash 将大量的二维经纬度转一维的整数值，这样可以方便的对地理位置进行查询、距离测量、范围搜索。但由于地理位置点非常多，一个地理分类 key 下可能会有大量元素，在 GEO 设计时，需要提前进行规划，避免单 key 过度膨胀。</p>
<p>Redis 的 GEO 地理位置数据结构，应用场景很多，比如查询某个地方的具体位置，查当前位置到目的地的距离，查附近的人、餐厅、电影院等。GEO 地理位置数据结构中，重要指令包括 geoadd、geopos、geodist、georadius、georadiusbymember 等。</p>
<h4 id="hyperLogLog-基数统计"><a href="#hyperLogLog-基数统计" class="headerlink" title="hyperLogLog 基数统计"></a>hyperLogLog 基数统计</h4><p>Redis 的 hyperLogLog 是用来做基数统计的数据类型，当输入巨大数量的元素做统计时，只需要很小的内存即可完成。HyperLogLog 不保存元数据，只记录待统计元素的估算数量，这个估算数量是一个带有 0.81% 标准差的近似值，在大多数业务场景，对海量数据，不足 1% 的误差是可以接受的。</p>
<p>Redis 的 HyperLogLog 在统计时，如果计数数量不大，采用稀疏矩阵存储，随着计数的增加，稀疏矩阵占用的空间也会逐渐增加，当超过阀值后，则改为稠密矩阵，稠密矩阵占用的空间是固定的，约为12KB字节。</p>
<p>通过 hyperLoglog 数据类型，你可以利用 pfadd 向基数统计中增加新的元素，可以用 pfcount 获得 hyperLogLog 结构中存储的近似基数数量，还可以用 hypermerge 将多个 hyperLogLog 合并为一个 hyperLogLog 结构，从而可以方便的获取合并后的基数数量。</p>
<p>hyperLogLog 的特点是统计过程不记录独立元素，占用内存非常少，非常适合统计海量数据。在大中型系统中，统计每日、每月的 UV 即独立访客数，或者统计海量用户搜索的独立词条数，都可以用 hyperLogLog 数据类型来进行处理。</p>
<h2 id="Redis协议的请求和响应有哪些“套路”可循？"><a href="#Redis协议的请求和响应有哪些“套路”可循？" class="headerlink" title="Redis协议的请求和响应有哪些“套路”可循？"></a>Redis协议的请求和响应有哪些“套路”可循？</h2><h3 id="Redis-协议"><a href="#Redis-协议" class="headerlink" title="Redis 协议"></a>Redis 协议</h3><p>Redis 支持 8 种核心数据结构，每种数据结构都有一系列的操作指令，除此之外，Redis 还有事务、集群、发布订阅、脚本等一系列相关的指令。为了方便以一种统一的风格和原则来设计和使用这些指令，Redis 设计了 RESP，即 Redis Serialization Protocol，中文意思是 Redis 序列化协议。RESP 是二进制安全协议，可以供 Redis 或其他任何 Client-Server 使用。在 Redis 内部，还会基于 RESP 进一步扩展细节。</p>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>Redis 序列化协议的设计原则有三个：</p>
<ol>
<li><p>第一是实现简单；</p>
</li>
<li><p>第二是可快速解析；</p>
</li>
<li><p>第三是便于阅读。</p>
</li>
</ol>
<p>Redis 协议的请求响应模型有三种，除了 2 种特殊模式，其他基本都是 ping-pong 模式，即 client 发送一个请求，server 回复一个响应，一问一答的访问模式。</p>
<p>2 种特殊模式：</p>
<ul>
<li><p>pipeline 模式，即 client 一次连续发送多个请求，然后等待 server 响应，server 处理完请求后，把响应返回给 client。</p>
</li>
<li><p>pub/sub 模式。即发布订阅模式，client 通过 subscribe 订阅一个 channel，然后 client 进入订阅状态，静静等待。当有消息产生时，server 会持续自动推送消息给 client，不需要 client 的额外请求。而且客户端在进入订阅状态后，只可接受订阅相关的命令如 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE 和 PUNSUBSCRIBE，除了这些命令，其他命令一律失效。</p>
</li>
</ul>
<p>Redis 协议的请求和响应也是有固定套路的。</p>
<p>对于请求指令，格式有 2 种类型。</p>
<ol>
<li><p>当你没有 redis-client，但希望可以用通用工具 telnet，直接与 Redis 交互时，Redis 协议虽然简单易于阅读，但在交互式会话中使用，并不容易拼写，此时可以用第一种格式，即 inline cmd 内联命令格式。使用 inline cmd 内联格式，只需要用空格分隔请求指令及参数，简单快速，一个简单的例子如 mget key1 key2\r\n。</p>
</li>
<li><p>第二种格式是 Array 数组格式类型。请求指令用的数组类型，与 Redis 响应的数组类型相同。</p>
</li>
</ol>
<h4 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h4><p>Redis 协议的响应格式有 5 种，分别是：</p>
<ol>
<li><p>simple strings 简单字符串类型，以 + 开头，后面跟字符串，以 CRLF（即 \r\n）结尾。这种类型不是二进制安全类型，字符串中不能包含 \r 或者 \n。比如许多响应回复以 OK 作为操作成功的标志，协议内容就是 +OK\r\n 。</p>
</li>
<li><p>Redis 协议将错误作为一种专门的类型，格式同简单字符串类型，唯一不同的是以 -（减号）开头。Redis 内部实现对 Redis 协议做了进一步规范，减号后面一般先跟 ERR 或者 WRONGTYPE，然后再跟其他简单字符串，最后以 CRLF（回车换行）结束。这里给了两个示例，client 在解析响应时，一旦发现 - 开头，就知道收到 Error 响应。</p>
</li>
<li><p>Integer 整数类型。整数类型以 ：开头，后面跟字符串表示的数字，最后以回车换行结尾。Redis 中许多命令都返回整数，但整数的含义要由具体命令来确定。比如，对于 incr 指令，：后的整数表示变更后的数值；对于 llen 表示 list 列表的长度，对于 exists 指令，1 表示 key 存在，0 表示 key 不存在。这里给个例子，：后面跟了个 1000，然后回车换行结束。</p>
</li>
<li><p>bulk strings 字符串块类型。字符串块分头部和真正字符串内容两部分。字符串块类型的头部， 为 $ 开头，随后跟真正字符串内容的字节长度，然后以 CRLF 结尾。字符串块的头部之后，跟随真正的字符串内容，最后以 CRLF 结束字符串块。字符串块用于表示二进制安全的字符串，最大长度可以支持 512MB。一个常规的例子，“$6\r\nfoobar\r\n”，对于空字串，可以表示为 “$0\r\n\r\n”，NULL字串： “$-1\r\n”。</p>
</li>
<li><p>Arrays 数组类型，如果一个命令需要返回多条数据就需要用数组格式类型，另外，前面提到 client 的请求命令也是主要采用这种格式。</p>
</li>
</ol>
<p>Arrays 数组类型，以 * 开头，随后跟一个数组长度 N，然后以回车换行结尾；然后后面跟随 N 个数组元素，每个数组元素的类型，可以是 Redis 协议中除内联格式外的任何一种类型。</p>
<p>比如一个字符串块的数组实例，<em>2\r\n$3\r\nget\r\n$3\r\nkey\r\n。整数数组实例：”<em>3\r\n:1\r\n:2\r\n:3\r\n”，混合数组实例：”</em>3\r\n :1\r\n-Bar\r\n$6\r\n foobar\r\n”，空数组：”*0\r\n”，NULL数组：”</em>-1\r\n”。</p>
<h4 id="协议分类"><a href="#协议分类" class="headerlink" title="协议分类"></a>协议分类</h4><p>Redis 协议主要分为 16 种，其中 8 种协议对应 8 种数据类型，选择了使用什么数据类型，就使用对应的响应操作指令即可。</p>
<p>剩下 8 种协议如下所示：</p>
<ol>
<li><p>pub-sub 发布订阅协议，client 可以订阅 channel，持续等待 server 推送消息。</p>
</li>
<li><p>事务协议，事务协议可以用 multi 和 exec 封装一些列指令，来一次性执行。</p>
</li>
<li><p>脚本协议，关键指令是 eval、evalsha 和 script等。</p>
</li>
<li><p>连接协议，主要包括权限控制，切换 DB，关闭连接等。</p>
</li>
<li><p>复制协议，包括 slaveof、role、psync 等。</p>
</li>
<li><p>配置协议，config set/get 等，可以在线修改/获取配置。</p>
</li>
<li><p>调试统计协议，如 slowlog，monitor，info 等。</p>
</li>
<li><p>其他内部命令，如 migrate，dump，restore 等。</p>
</li>
</ol>
<h4 id="Redis-client-的使用及改进"><a href="#Redis-client-的使用及改进" class="headerlink" title="Redis client 的使用及改进"></a>Redis client 的使用及改进</h4><p>由于 Redis 使用广泛，几乎所有主流语言都有对 Redis 开发了对应的 client。以 Java 语言为例，广泛使用的有 Jedis、Redisson 等。对于 Jedis client，它的优势是轻量，简洁，便于集成和改造，它支持连接池，提供指令维度的操作，几乎支持 Redis 的所有指令，但它不支持读写分离。Redisson 基于 Netty 实现，非阻塞 IO，性能较高，而且支持异步请求和连接池，还支持读写分离、读负载均衡，它内建了 tomcat Session ，支持 spring session 集成，但 redisson 实现相对复杂。</p>
<p>在新项目启动时，如果只是简单的 Redis 访问业务场景，可以直接用 Jedis，甚至可以简单封装 Jedis，实现 master-slave 的读写分离方案。如果想直接使用读写分离，想集成 spring session 等这些高级特性，也可以采用 redisson。</p>
<p>Redis client 在使用中，需要根据业务及运维的需要，进行相关改进。在 client 访问异常时，可以增加重试策略，在访问某个 slave 异常时，需要重试其他 slave 节点。需要增加对 Redis 主从切换、slave 扩展的支持，比如采用守护线程定期扫描 master、slave 域名，发现 IP 变更，及时切换连接。对于多个 slave 的访问，还需要增加负载均衡策略。最后，Redis client 还可以与配置中心、Redis 集群管理平台整合，从而实时感知及协调 Redis 服务的访问。</p>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="http://image.leonote.cn/20210714222113.png" alt=""></p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-Redis进阶(上)</title>
    <url>/2021/07/02/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Redis%E8%BF%9B%E9%98%B6(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="Redis进阶-上"><a href="#Redis进阶-上" class="headerlink" title="Redis进阶(上)"></a>Redis进阶(上)</h1><blockquote>
<p>Redis 系统架构中各个处理模块是干什么的？</p>
</blockquote>
<h2 id="Redis-系统架构"><a href="#Redis-系统架构" class="headerlink" title="Redis 系统架构"></a>Redis 系统架构</h2><p>Redis 组件的系统架构如图所示，主要包括<strong>事件处理</strong>、<strong>数据存储及管理</strong>、用于系统扩展的<strong>主从复制/集群管理</strong>，以及为插件化功能扩展的 <strong>Module System 模块</strong>。</p>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p><img src="http://image.leonote.cn/20210714215407.png" alt=""></p>
<p>Redis 中的事件处理模块，采用的是作者自己开发的 ae 事件驱动模型，可以进行高效的网络 IO 读写、命令执行，以及时间事件处理。</p>
<p>其中，网络 IO 读写处理采用的是 IO 多路复用技术，通过对 evport、epoll、kqueue、select 等进行封装，同时监听多个 socket，并根据 socket 目前执行的任务，来为 socket 关联不同的事件处理器。</p>
<p>当监听端口对应的 socket 收到连接请求后，就会创建一个 client 结构，通过 client 结构来对连接状态进行管理。在请求进入时，将请求命令读取缓冲并进行解析，并存入到 client 的参数列表。</p>
<p>然后根据请求命令找到对应的 redisCommand，最后根据命令协议，对请求参数进一步的解析、校验并执行。Redis 中时间事件比较简单，目前主要是执行 serverCron，来做一些统计更新、过期 key 清理、AOF 及 RDB 持久化等辅助操作。</p>
<h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>Redis 的内存数据都存在 redisDB 中。Redis 支持多 DB，每个 DB 都对应一个 redisDB 结构。Redis 的 8 种数据类型，每种数据类型都采用一种或多种内部数据结构进行存储。同时这些内部数据结构及数据相关的辅助信息，都以 kye/value 的格式存在 redisDB 中的各个 dict 字典中。</p>
<p>数据在写入 redisDB 后，这些执行的写指令还会及时追加到 AOF 中，追加的方式是先实时写入AOF 缓冲，然后按策略刷缓冲数据到文件。由于 AOF 记录每个写操作，所以一个 key 的大量中间状态也会呈现在 AOF 中，导致 AOF 冗余信息过多，因此 Redis 还设计了一个 RDB 快照操作，可以通过定期将内存里所有的数据快照落地到 RDB 文件，来以最简洁的方式记录 Redis 的所有内存数据。</p>
<p>Redis 进行数据读写的核心处理线程是单线程模型，为了保持整个系统的高性能，必须避免任何 kennel 导致阻塞的操作。为此，Redis 增加了 BIO 线程，来处理容易导致阻塞的文件 close、fsync 等操作，确保系统处理的性能和稳定性。</p>
<p>在 server 端，存储内存永远是昂贵且短缺的，Redis 中，过期的 key 需要及时清理，不活跃的 key 在内存不足时也可能需要进行淘汰。为此，Redis 设计了 8 种淘汰策略，借助新引入的 eviction pool，进行高效的 key 淘汰和内存回收。</p>
<h3 id="功能扩展"><a href="#功能扩展" class="headerlink" title="功能扩展"></a>功能扩展</h3><p>Redis 在 4.0 版本之后引入了 Module System 模块，可以方便使用者，在不修改核心功能的同时，进行插件化功能开发。使用者可以将新的 feature 封装成动态链接库，Redis 可以在启动时加载，也可以在运行过程中随时按需加载和启用。</p>
<p>在扩展模块中，开发者可以通过 RedisModule_init 初始化新模块，用 RedisModule_CreateCommand 扩展各种新模块指令，以可插拔的方式为 Redis 引入新的数据结构和访问命令。</p>
<h3 id="系统扩展"><a href="#系统扩展" class="headerlink" title="系统扩展"></a>系统扩展</h3><p>Redis 作者在架构设计中对系统的扩展也倾注了大量关注。在主从复制功能中，psyn 在不断的优化，不仅在 slave 闪断重连后可以进行增量复制，而且在 slave 通过主从切换成为 master 后，其他 slave 仍然可以与新晋升的 master 进行增量复制，另外，其他一些场景，如 slave 重启后，也可以进行增量复制，大大提升了主从复制的可用性。使用者可以更方便的使用主从复制，进行业务数据的读写分离，大幅提升 Redis 系统的稳定读写能力。</p>
<p>通过主从复制可以较好的解决 Redis 的单机读写问题，但所有写操作都集中在 master 服务器，很容易达到 Redis 的写上限，同时 Redis 的主从节点都保存了业务的所有数据，随着业务发展，很容易出现内存不够用的问题。</p>
<p>为此，Redis 分区无法避免。虽然业界大多采用在 client 和 proxy 端分区，但 Redis 自己也早早推出了 cluster 功能，并不断进行优化。Redis cluster 预先设定了 16384 个 slot 槽，在 Redis 集群启动时，通过手动或自动将这些 slot 分配到不同服务节点上。在进行 key 读写定位时，首先对 key 做 hash，并将 hash 值对 16383 ，做 按位与运算，确认 slot，然后确认服务节点，最后再对 对应的 Redis 节点，进行常规读写。如果 client 发送到错误的 Redis 分片，Redis 会发送重定向回复。如果业务数据大量增加，Redis 集群可以通过数据迁移，来进行在线扩容。</p>
<blockquote>
<p>Redis 如何处理文件事件和时间事件？</p>
</blockquote>
<h2 id="Redis-事件驱动模型"><a href="#Redis-事件驱动模型" class="headerlink" title="Redis 事件驱动模型"></a>Redis 事件驱动模型</h2><h3 id="事件驱动模型"><a href="#事件驱动模型" class="headerlink" title="事件驱动模型"></a>事件驱动模型</h3><p>Redis 是一个事件驱动程序，但和 Memcached 不同的是，Redis 并没有采用 libevent 或 libev 这些开源库，而是直接开发了一个新的事件循环组件。Redis 作者给出的理由是，尽量减少外部依赖，而自己开发的事件模型也足够简洁、轻便、高效，也更易控制。Redis 的事件驱动模型机制封装在 aeEventLoop 等相关的结构体中，网络连接、命令读取执行回复，数据的持久化、淘汰回收 key 等，几乎所有的核心操作都通过 ae 事件模型进行处理。</p>
<p><img src="http://image.leonote.cn/20210714215614.png" alt=""></p>
<p>Redis 的事件驱动模型处理 2 类事件：</p>
<ul>
<li><p>文件事件，如连接建立、接受请求命令、发送响应等；</p>
</li>
<li><p>时间事件，如 Redis 中定期要执行的统计、key 淘汰、缓冲数据写出、rehash等。</p>
</li>
</ul>
<h3 id="文件事件处理"><a href="#文件事件处理" class="headerlink" title="文件事件处理"></a>文件事件处理</h3><p><img src="http://image.leonote.cn/20210714215631.png" alt=""></p>
<p>Redis 的文件事件采用典型的 Reactor 模式进行处理。Redis 文件事件处理机制分为 4 部分：</p>
<ul>
<li><p>连接 socket</p>
</li>
<li><p>IO 多路复用程序</p>
</li>
<li><p>文件事件分派器</p>
</li>
<li><p>事件处理器</p>
</li>
</ul>
<p>文件事件是对连接 socket 操作的一个抽象。当端口监听 socket 准备 accept 新连接，或者连接 socket 准备好读取请求、写入响应、关闭时，就会产生一个文件事件。IO 多路复用程序负责同时监听多个 socket，当这些 socket 产生文件事件时，就会触发事件通知，文件分派器就会感知并获取到这些事件。</p>
<p>虽然多个文件事件可能会并发出现，但 IO 多路复用程序总会将所有产生事件的 socket 放入一个队列中，通过这个队列，有序的把这些文件事件通知给文件分派器。</p>
<h3 id="IO-多路复用"><a href="#IO-多路复用" class="headerlink" title="IO 多路复用"></a>IO 多路复用</h3><p>Redis 封装了 4 种多路复用程序，每种封装实现都提供了相同的 API 实现。编译时，会按照性能和系统平台，选择最佳的 IO 多路复用函数作为底层实现，选择顺序是，首先尝试选择 Solaries 中的 evport，如果没有，就尝试选择 Linux 中的 epoll，否则就选择大多 UNIX 系统都支持的 kqueue，这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符。</p>
<p>如果当前编译环境没有上述函数，就会选择 select 作为底层实现方案。select 方案的性能较差，事件发生时，会扫描全部监听的描述符，事件复杂度是 O(n)，并且只能同时服务有限个文件描述符，32 位机默认是 1024 个，64 位机默认是 2048 个，所以一般情况下，并不会选择 select 作为线上运行方案。Redis 的这 4 种实现，分别在 ae_evport、ae_epoll、ae_kqueue 和 ae_select 这 4 个代码文件中。</p>
<h3 id="文件事件收集及派发器"><a href="#文件事件收集及派发器" class="headerlink" title="文件事件收集及派发器"></a>文件事件收集及派发器</h3><p>Redis 中的文件事件分派器是 aeProcessEvents 函数。它会首先计算最大可以等待的时间，然后利用 aeApiPoll 等待文件事件的发生。如果在等待时间内，一旦 IO 多路复用程序产生了事件通知，则会立即轮询所有已产生的文件事件，并将文件事件放入 aeEventLoop 中的 aeFiredEvents 结构数组中。每个 fired event 会记录 socket 及 Redis 读写事件类型。</p>
<p>这里会涉及将多路复用中的事件类型，转换为 Redis 的 ae 事件驱动模型中的事件类型。以采用 Linux 中的 epoll 为例，会将 epoll 中的 EPOLLIN 转为 AE_READABLE 类型，将 epoll 中的 EPOLLOUT、EPOLLERR 和 EPOLLHUP 转为 AE_WRITABLE 事件。</p>
<p>aeProcessEvents 在获取到触发的事件后，会根据事件类型，将文件事件 dispatch 派发给对应事件处理函数。如果同一个 socket，同时有读事件和写事件，Redis 派发器会首先派发处理读事件，然后再派发处理写事件。</p>
<h3 id="文件事件处理函数分类"><a href="#文件事件处理函数分类" class="headerlink" title="文件事件处理函数分类"></a>文件事件处理函数分类</h3><p>Redis 中文件事件函数的注册和处理主要分为 3 种。</p>
<ul>
<li><p>连接处理函数 acceptTcpHandler</p>
<p>Redis 在启动时，在 initServer 中对监听的 socket 注册读事件，事件处理器为 acceptTcpHandler，该函数在有新连接进入时，会被派发器派发读任务。在处理该读任务时，会 accept 新连接，获取调用方的 IP 及端口，并对新连接创建一个 client 结构。如果同时有大量连接同时进入，Redis 一次最多处理 1000 个连接请求。</p>
</li>
<li><p>readQueryFromClient 请求处理函数</p>
<p>连接函数在创建 client 时，会对新连接 socket 注册一个读事件，该读事件的事件处理器就是 readQueryFromClient。在连接 socket 有请求命令到达时，IO 多路复用程序会获取并触发文件事件，然后这个读事件被派发器派发给本请求的处理函数。readQueryFromClient 会从连接 socket 读取数据，存入 client 的 query 缓冲，然后进行解析命令，按照 Redis 当前支持的 2 种请求格式，及 inline 内联格式和 multibulk 字符块数组格式进行尝试解析。解析完毕后，client 会根据请求命令从命令表中获取到对应的 redisCommand，如果对应 cmd 存在。则开始校验请求的参数，以及当前 server 的内存、磁盘及其他状态，完成校验后，然后真正开始执行 redisCommand 的处理函数，进行具体命令的执行，最后将执行结果作为响应写入 client 的写缓冲中。</p>
</li>
<li><p>命令回复处理器 sendReplyToClient</p>
<p>当 redis需要发送响应给client时，Redis 事件循环中会对client的连接socket注册写事件，这个写事件的处理函数就是sendReplyToClient。通过注册写事件，将 client 的socket与 AE_WRITABLE 进行间接关联。当 Client fd 可进行写操作时，就会触发写事件，该函数就会将写缓冲中的数据发送给调用方。</p>
</li>
</ul>
<p><img src="http://image.leonote.cn/20210714215711.png" alt=""></p>
<p>Redis 中的时间事件是指需要在特定时间执行的事件。多个 Redis 中的时间事件构成 aeEventLoop 中的一个链表，供 Redis 在 ae 事件循环中轮询执行。</p>
<p>Redis 当前的主要时间事件处理函数有 2 个：</p>
<ul>
<li><p>serverCron</p>
</li>
<li><p>moduleTimerHandler</p>
</li>
</ul>
<p>Redis 中的时间事件分为 2 类：</p>
<ul>
<li><p>单次时间，即执行完毕后，该时间事件就结束了。</p>
</li>
<li><p>周期性事件，在事件执行完毕后，会继续设置下一次执行的事件，从而在时间到达后继续执行，并不断重复。</p>
</li>
</ul>
<p>时间事件主要有 5 个属性组成。</p>
<ul>
<li><p>事件 ID：Redis 为时间事件创建全局唯一 ID，该 ID 按从小到大的顺序进行递增。</p>
</li>
<li><p>执行时间 when_sec 和 when_ms：精确到毫秒，记录该事件的到达可执行时间。</p>
</li>
<li><p>时间事件处理器 timeProc：在时间事件到达时，Redis 会调用相应的 timeProc 处理事件。</p>
</li>
<li><p>关联数据 clientData：在调用 timeProc 时，需要使用该关联数据作为参数。</p>
</li>
<li><p>链表指针 prev 和 next：它用来将时间事件维护为双向链表，便于插入及查找所要执行的时间事件。</p>
</li>
</ul>
<p>时间事件的处理是在事件循环中的 aeProcessEvents 中进行。执行过程是：</p>
<ol>
<li><p>首先遍历所有的时间事件。</p>
</li>
<li><p>比较事件的时间和当前时间，找出可执行的时间事件。</p>
</li>
<li><p>然后执行时间事件的 timeProc 函数。</p>
</li>
<li><p>执行完毕后，对于周期性时间，设置时间新的执行时间；对于单次性时间，设置事件的 ID为 -1，后续在事件循环中，下一次执行 aeProcessEvents 的时候从链表中删除。</p>
</li>
</ol>
<blockquote>
<p>Redis读取请求数据后，如何进行协议解析和处理?</p>
</blockquote>
<h2 id="Redis-协议解析及处理"><a href="#Redis-协议解析及处理" class="headerlink" title="Redis 协议解析及处理"></a>Redis 协议解析及处理</h2><h3 id="协议解析"><a href="#协议解析" class="headerlink" title="协议解析"></a>协议解析</h3><p>请求命令进入，触发 IO 读事件后。client 会从连接文件描述符读取请求，并存入 client 的 query buffer 中。client 的读缓冲默认是 16KB，读取命令时，如果发现请求超过 1GB，则直接报异常，关闭连接。</p>
<p><img src="http://image.leonote.cn/20210714215807.png" alt=""></p>
<p>client 读取完请求命令后，则根据 query buff 进行协议解析。协议解析时，首先查看协议的首字符。如果是 *，则解析为字符块数组类型，即 MULTIBULK。否则请求解析为 INLINE 类型。</p>
<p>INLINE 类型是以 CRLF 结尾的单行字符串，协议命令及参数以空格分隔。解析过程参考之前课程里分析的对应协议格式。协议解析完毕后，将请求参数个数存入 client 的 argc 中，将请求的具体参数存入 client 的 argv 中。</p>
<h3 id="协议执行"><a href="#协议执行" class="headerlink" title="协议执行"></a>协议执行</h3><p>请求命令解析完毕，则进入到协议执行部分。协议执行中，对于 quit 指令，直接返回 OK，设置 flag 为回复后关闭连接。</p>
<p><img src="http://image.leonote.cn/20210714215817.png" alt=""></p>
<p>对于非 quit 指令，以 client 中 argv[0] 作为命令，从 server 中的命令表中找到对应的 redisCommand。如果没有找到 redisCommand，则返回未知 cmd 异常。如果找到 cmd，则开始执行 redisCommand 中的 proc 函数，进行具体命令的执行。在命令执行完毕后，将响应写入 client 的写缓冲。并按配置和部署，将写指令分发给 aof 和 slaves。同时更新相关的统计数值。</p>
<blockquote>
<p>怎么认识和应用Redis内部数据结构?</p>
</blockquote>
<h2 id="Redis-内部数据结构"><a href="#Redis-内部数据结构" class="headerlink" title="Redis 内部数据结构"></a>Redis 内部数据结构</h2><h3 id="RdeisDb"><a href="#RdeisDb" class="headerlink" title="RdeisDb"></a>RdeisDb</h3><p><img src="http://image.leonote.cn/20210714220054.png" alt=""><br>Redis 中所有数据都保存在 DB 中，一个 Redis 默认最多支持 16 个 DB。Redis 中的每个 DB 都对应一个 redisDb 结构，即每个 Redis 实例，默认有 16 个 redisDb。用户访问时，默认使用的是 0 号 DB，可以通过 select $dbID 在不同 DB 之间切换。</p>
<p><img src="http://image.leonote.cn/20210714220141.png" alt=""></p>
<p>redisDb 主要包括 2 个核心 dict 字典、3 个非核心 dict 字典、dbID 和其他辅助属性。2 个核心 dict 包括一个 dict 主字典和一个 expires 过期字典。主 dict 字典用来存储当前 DB 中的所有数据，它将 key 和各种数据类型的 value 关联起来，该 dict 也称 key space。过期字典用来存储过期时间 key，存的是 key 与过期时间的映射。日常的数据存储和访问基本都会访问到 redisDb 中的这两个 dict。</p>
<p>3 个非核心 dict 包括一个字段名叫 blocking_keys 的阻塞 dict，一个字段名叫 ready_keys 的解除阻塞 dict，还有一个是字段名叫 watched_keys 的 watch 监控 dict。</p>
<p>在执行 Redis 中 list 的阻塞命令 blpop、brpop 或者 brpoplpush 时，如果对应的 list 列表为空，Redis 就会将对应的 client 设为阻塞状态，同时将该 client 添加到 DB 中 blocking_keys 这个阻塞 dict。所以该 dict 存储的是处于阻塞状态的 key 及 client 列表。</p>
<p>当有其他调用方在向某个 key 对应的 list 中增加元素时，Redis 会检测是否有 client 阻塞在这个 key 上，即检查 blocking_keys 中是否包含这个 key，如果有则会将这个 key 加入 read_keys 这个 dict 中。同时也会将这个 key 保存到 server 中的一个名叫 read_keys 的列表中。这样可以高效、不重复的插入及轮询。</p>
<p>当 client 使用 watch 指令来监控 key 时，这个 key 和 client 就会被保存到 watched_keys 这个 dict 中。redisDb 中可以保存所有的数据类型，而 Redis 中所有数据类型都是存放在一个叫 redisObject 的结构中。</p>
<h3 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h3><p><img src="http://image.leonote.cn/20210714220207.png" alt=""><br>redisObject 由 5 个字段组成。</p>
<ul>
<li>type：即 Redis 对象的数据类型，目前支持 7 种 type 类型，分别为<ul>
<li>OBJ_STRING</li>
<li>OBJ_LIST</li>
<li>OBJ_SET</li>
<li>OBJ_ZSET</li>
<li>OBJ_HASH</li>
<li>OBJ_MODULE</li>
<li>OBJ_STREAM</li>
</ul>
</li>
<li>encoding：Redis 对象的内部编码方式，即内部数据结构类型，目前支持 10 种编码方式包括<ul>
<li>OBJ_ENCODING_RAW</li>
<li>OBJ_ENCODING_INT</li>
<li>OBJ_ENCODING_HT</li>
<li>OBJ_ENCODING_ZIPLIST 等。</li>
<li>LRU：存储的是淘汰数据用的 LRU 时间或 LFU 频率及时间的数据。</li>
<li>refcount：记录 Redis 对象的引用计数，用来表示对象被共享的次数，共享使用时加 1，不再使用时减 1，当计数为 0 时表明该对象没有被使用，就会被释放，回收内存。</li>
<li>ptr：它指向对象的内部数据结构。比如一个代表 string 的对象，它的 ptr 可能指向一个 sds 或者一个 long 型整数。</li>
</ul>
</li>
</ul>
<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><p>Redis 中的数据实际是存在 DB 中的 2 个核心 dict 字典中的。实际上 dict 也是 Redis 的一种使用广泛的内部数据结构。</p>
<p><img src="http://image.leonote.cn/20210714220247.png" alt=""><br>Redis 中的 dict，类似于 Memcached 中 hashtable。都可以用于 key 或元素的快速插入、更新和定位。dict 字典中，有一个长度为 2 的哈希表数组，日常访问用 0 号哈希表，如果 0 号哈希表元素过多，则分配一个 2 倍 0 号哈希表大小的空间给 1 号哈希表，然后进行逐步迁移，rehashidx 这个字段就是专门用来做标志迁移位置的。在哈希表操作中，采用单向链表来解决 hash 冲突问题。dict 中还有一个重要字段是 type，它用于保存 hash 函数及 key/value 赋值、比较函数。</p>
<p>dictht 中的 table 是一个 hash 表数组，每个桶指向一个 dictEntry 结构。dictht 采用 dictEntry 的单向链表来解决 hash 冲突问题。</p>
<p><img src="http://image.leonote.cn/20210714220320.png" alt=""></p>
<p>dictht 是以 dictEntry 来存 key-value 映射的。其中 key 是 sds 字符串，value 为存储各种数据类型的 redisObject 结构。</p>
<p>dict 可以被 redisDb 用来存储数据 key-value 及命令操作的辅助信息。还可以用来作为一些 Redis 数据类型的内部数据结构。dict 可以作为 set 集合的内部数据结构。在哈希的元素数超过 512 个，或者哈希中 value 大于 64 字节，dict 还被用作为哈希类型的内部数据结构。</p>
<h3 id="sds"><a href="#sds" class="headerlink" title="sds"></a>sds</h3><p>字符串是 Redis 中最常见的数据类型，其底层实现是简单动态字符串即 sds。简单动态字符串本质是一个 char*，内部通过 sdshdr 进行管理。sdshdr 有 4 个字段。len 为字符串实际长度，alloc 当前字节数组总共分配的内存大小。flags 记录当前字节数组的属性；buf 是存储字符串真正的值及末尾一个 \0。</p>
<p><img src="http://image.leonote.cn/20210714220351.png" alt=""></p>
<p>sds 的存储 buf 可以动态扩展或收缩，字符串长度不用遍历，可直接获得，修改和访问都很方便。由于 sds 中字符串存在 buf 数组中，长度由 len 定义，而不像传统字符串遇 0 停止，所以 sds 是二进制安全的，可以存放任何二进制的数据。</p>
<p><img src="http://image.leonote.cn/20210714220415.png" alt=""><br>简单动态字符串 sds 的获取字符串长度很方便，通过 len 可以直接得到，而传统字符串需要对字符串进行遍历，时间复杂度为 O(n)。</p>
<p>sds 相比传统字符串多了一个 sdshdr，对于大量很短的字符串，这个 sdshdr 还是一个不小的开销。在 3.2 版本后，sds 会根据字符串实际的长度，选择不同的数据结构，以更好的提升内存效率。当前 sdshdr 结构分为 5 种子类型，分别为 sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64。其中 sdshdr5 只有 flags 和 buf 字段，其他几种类型的 len 和 alloc 采用从 uint8_t 到 uint64_t 的不同类型，以节省内存空间。</p>
<p>sds 可以作为字符串的内部数据结构，同时 sds 也是 hyperloglog、bitmap 类型的内部数据结构。</p>
<h3 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h3><p>为了节约内存，并减少内存碎片，Redis 设计了 ziplist 压缩列表内部数据结构。压缩列表是一块连续的内存空间，可以连续存储多个元素，没有冗余空间，是一种连续内存数据块组成的顺序型内存结构。</p>
<p><img src="http://image.leonote.cn/20210714220445.png" alt=""></p>
<p>ziplist 的结构如图所示，主要包括 5 个部分。</p>
<ol>
<li><p>zlbytes 是压缩列表所占用的总内存字节数。</p>
</li>
<li><p>Zltail 尾节点到起始位置的字节数。</p>
</li>
<li><p>Zllen 总共包含的节点/内存块数。</p>
</li>
<li><p>Entry 是 ziplist 保存的各个数据节点，这些数据点长度随意。</p>
</li>
<li><p>Zlend 是一个魔数 255，用来标记压缩列表的结束。</p>
</li>
</ol>
<p>如图所示，一个包含 4 个元素的 ziplist，总占用字节是 100bytes，该 ziplist 的起始元素的指针是 p，zltail 是 80，则第 4 个元素的指针是 P+80。</p>
<p><img src="http://image.leonote.cn/20210714220505.png" alt=""></p>
<p>压缩列表 ziplist 的存储节点 entry 的结构如图，主要有 6 个字段。</p>
<ul>
<li><p>prevRawLen 是前置节点的长度；</p>
</li>
<li><p>preRawLenSize 编码 preRawLen 需要的字节数；</p>
</li>
<li><p>len 当前节点的长度；</p>
</li>
<li><p>lensize 编码 len 所需要的字节数；</p>
</li>
<li><p>encoding  当前节点所用的编码类型；</p>
</li>
<li><p>entryData 当前节点数据。</p>
</li>
</ul>
<p><img src="http://image.leonote.cn/20210714220530.png" alt=""></p>
<p>由于 ziplist 是连续紧凑存储，没有冗余空间，所以插入新的元素需要 realloc 扩展内存，所以如果 ziplist 占用空间太大，realloc 重新分配内存和拷贝的开销就会很大，所以 ziplist 不适合存储过多元素，也不适合存储过大的字符串。</p>
<p>因此只有在元素数和 value 数都不大的时候，ziplist 才作为 hash 和 zset 的内部数据结构。其中 hash 使用 ziplist 作为内部数据结构的限制时，元素数默认不超过 512 个，value 值默认不超过 64 字节。可以通过修改配置来调整 hash_max_ziplist_entries 、hash_max_ziplist_value 这两个阀值的大小。</p>
<p>zset 有序集合，使用 ziplist 作为内部数据结构的限制元素数默认不超过 128 个，value 值默认不超过 64 字节。可以通过修改配置来调整 zset_max_ziplist_entries 和 zset_max_ziplist_value 这两个阀值的大小。</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>Redis 在 3.2 版本之后引入 quicklist，用以替换 linkedlist。因为 linkedlist 每个节点有前后指针，要占用 16 字节，而且每个节点独立分配内存，很容易加剧内存的碎片化。而 ziplist 由于紧凑型存储，增加元素需要 realloc，删除元素需要内存拷贝，天然不适合元素太多、value 太大的存储。</p>
<p><img src="http://image.leonote.cn/20210714220546.png" alt=""></p>
<p>而 quicklist 快速列表应运而生，它是一个基于 ziplist 的双向链表。将数据分段存储到 ziplist，然后将这些 ziplist 用双向指针连接。快速列表的结构如图所示。</p>
<ul>
<li><p>head、tail 是两个指向第一个和最后一个 ziplist 节点的指针。</p>
</li>
<li><p>count 是 quicklist 中所有的元素个数。</p>
</li>
<li><p>len 是 ziplist 节点的个数。</p>
</li>
<li><p>compress 是 LZF 算法的压缩深度。</p>
</li>
</ul>
<p>快速列表中，管理 ziplist 的是 quicklistNode 结构。quicklistNode 主要包含一个 prev/next 双向指针，以及一个 ziplist 节点。单个 ziplist 节点可以存放多个元素。</p>
<p>快速列表从头尾读写数据很快，时间复杂度为 O(1)。也支持从中间任意位置插入或读写元素，但速度较慢，时间复杂度为 O(n)。快速列表当前主要作为 list 列表的内部数据结构。</p>
<h3 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h3><p>跳跃表 zskiplist 是一种有序数据结构，它通过在每个节点维持多个指向其他节点的指针，从而可以加速访问。跳跃表支持平均 O(logN) 和最差 O(n) 复杂度的节点查找。在大部分场景，跳跃表的效率和平衡树接近，但跳跃表的实现比平衡树要简单，所以不少程序都用跳跃表来替换平衡树。</p>
<p><img src="http://image.leonote.cn/20210714220609.png" alt=""></p>
<p>如果 sorted set 类型的元素数比较多或者元素比较大，Redis 就会选择跳跃表来作为 sorted set有序集合的内部数据结构。</p>
<p>跳跃表主要由 zskipList 和节点 zskiplistNode 构成。zskiplist 结构如图，header 指向跳跃表的表头节点。tail 指向跳跃表的表尾节点。length 表示跳跃表的长度，它是跳跃表中不包含表头节点的节点数量。level 是目前跳跃表内，除表头节点外的所有节点中，层数最大的那个节点的层数。</p>
<p>跳跃表的节点 zskiplistNode 的结构如图所示。ele 是节点对应的 sds 值，在 zset 有序集合中就是集合中的 field 元素。score 是节点的分数，通过 score，跳跃表中的节点自小到大依次排列。backward 是指向当前节点的前一个节点的指针。level 是节点中的层，每个节点一般有多个层。每个 level 层都带有两个属性，一个是 forwad 前进指针，它用于指向表尾方向的节点；另外一个是 span 跨度，它是指 forward 指向的节点到当前节点的距离。</p>
<p><img src="http://image.leonote.cn/20210714220627.png" alt=""></p>
<p>如图所示是一个跳跃表，它有 3 个节点。对应的元素值分别是 S1、S2 和 S3，分数值依次为 1.0、3.0 和 5.0。其中 S3 节点的 level 最大是 5，跳跃表的 level 是 5。header 指向表头节点，tail 指向表尾节点。在查到元素时，累加路径上的跨度即得到元素位置。在跳跃表中，元素必须是唯一的，但 score 可以相同。相同 score 的不同元素，按照字典序进行排序。</p>
<p>在 sorted set 数据类型中，如果元素数较多或元素长度较大，则使用跳跃表作为内部数据结构。默认元素数超过 128 或者最大元素的长度超过 64，此时有序集合就采用 zskiplist 进行存储。由于 geo 也采用有序集合类型来存储地理位置名称和位置 hash 值，所以在超过相同阀值后，也采用跳跃表进行存储。</p>
<p><img src="http://image.leonote.cn/20210714220637.png" alt=""></p>
<blockquote>
<p> 8 种数据类型，具体都是采用哪种内部数据结构来存储的：</p>
<p>​    首先，对于 string 字符串，Redis 主要采用 sds 来进行存储。而对于 list 列表，Redis 采用 quicklist 进行存储。对于 set 集合类型，Redis 采用 dict 来进行存储。对于 sorted set 有序集合类型，如果元素数小于 128 且元素长度小于 64，则使用 ziplist 存储，否则使用 zskiplist 存储。对于哈希类型，如果元素数小于 512，并且元素长度小于 64，则用 ziplist 存储，否则使用 dict 字典存储。对于 hyperloglog，采用 sds 简单动态字符串存储。对于 geo，如果位置数小于 128，则使用 ziplist 存储，否则使用 zskiplist 存储。最后对于 bitmap，采用 sds 简单动态字符串存储。</p>
<p>​    除了这些主要的内部数据结构，还有在特殊场景下也会采用一些其他内部结构存储，比如，如果操作的字符串都是整数，同时指令是 incr、decr 等，会对字符串采用 long 型整数存储</p>
</blockquote>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-Redis进阶(下)</title>
    <url>/2021/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Redis%E8%BF%9B%E9%98%B6(%E4%B8%8B)/</url>
    <content><![CDATA[<h1 id="Redis进阶-下"><a href="#Redis进阶-下" class="headerlink" title="Redis进阶(下)"></a>Redis进阶(下)</h1><h2 id="Redis是如何淘汰key的？"><a href="#Redis是如何淘汰key的？" class="headerlink" title="Redis是如何淘汰key的？"></a>Redis是如何淘汰key的？</h2><h3 id="淘汰原理"><a href="#淘汰原理" class="headerlink" title="淘汰原理"></a>淘汰原理</h3><p>系统线上运行中，内存总是昂贵且有限的，在数据总量远大于 Redis 可用的内存总量时，为了最大限度的提升访问性能，Redis 中只能存放最新最热的有效数据。</p>
<p>当 key 过期后，或者 Redis 实际占用的内存超过阀值后，Redis 就会对 key 进行淘汰，删除过期的或者不活跃的 key，回收其内存，供新的 key 使用。Redis 的内存阀值是通过 maxmemory 设置的，而超过内存阀值后的淘汰策略，是通过 maxmemory-policy 设置的。Redis 会在 2 种场景下对 key 进行淘汰，第一种是在<strong>定期执行 serverCron 时</strong>，检查淘汰 key；第二种是在<strong>执行命令时</strong>，检查淘汰 key。</p>
<p>第一种场景，Redis 定期执行 serverCron 时，会对 DB 进行检测，清理过期 key。清理流程如下。首先轮询每个 DB，检查其 expire dict，即带过期时间的过期 key 字典，从所有带过期时间的 key 中，随机选取 20 个样本 key，检查这些 key 是否过期，如果过期则清理删除。如果 20 个样本中，超过 5 个 key 都过期，即过期比例大于 25%，就继续从该 DB 的 expire dict 过期字典中，再随机取样 20 个 key 进行过期清理，持续循环，直到选择的 20 个样本 key 中，过期的 key 数小于等于 5，当前这个 DB 则清理完毕，然后继续轮询下一个 DB。</p>
<p>在执行 serverCron 时，如果在某个 DB 中，过期 dict 的填充率低于 1%，则放弃对该 DB 的取样检查，因为效率太低。如果 DB 的过期 dict 中，过期 key 太多，一直持续循环回收，会占用大量主线程时间，所以 Redis 还设置了一个过期时间。这个过期时间根据 serverCron 的执行频率来计算，5.0 版本及之前采用慢循环过期策略，默认是 25ms，如果回收超过 25ms 则停止，6.0 非稳定版本采用快循环过期策略，过期时间为 1ms。</p>
<p>第二种场景，Redis 在执行命令请求时。会检查当前内存占用是否超过 maxmemory 的数值，如果超过，则按照设置的淘汰策略，进行删除淘汰 key 操作。</p>
<h3 id="淘汰方式"><a href="#淘汰方式" class="headerlink" title="淘汰方式"></a>淘汰方式</h3><p>Redis 中 key 的淘汰方式有两种，分别是<strong>同步删除淘汰</strong>和<strong>异步删除淘汰</strong>。在 serverCron 定期清理过期 key 时，如果设置了延迟过期配置 lazyfree-lazy-expire，会检查 key 对应的 value 是否为多元素的复合类型，即是否是 list 列表、set 集合、zset 有序集合和 hash 中的一种，并且 value 的元素数大于 64，则在将 key 从 DB 中 expire dict 过期字典和主 dict 中删除后，value 存放到 BIO 任务队列，由 BIO 延迟删除线程异步回收；否则，直接从 DB 的 expire dict 和主 dict 中删除，并回收 key、value 所占用的空间。在执行命令时，如果设置了 lazyfree-lazy-eviction，在淘汰 key 时，也采用前面类似的检测方法，对于元素数大于 64 的 4 种复合类型，使用 BIO 线程异步删除，否则采用同步直接删除。</p>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p><img src="http://image.leonote.cn/20210714220858.png" alt=""></p>
<p>Redis 提供了 8 种淘汰策略对 key 进行管理，而且还引入基于样本的 eviction pool，来提升剔除的准确性，确保在保持最大性能的前提下，剔除最不活跃的 key。eviction pool 主要对 LRU、LFU，以及过期 dict ttl  内存管理策略生效。处理流程为，当 Redis 内存占用超过阀值后，按策略从主 dict 或者带过期时间的 expire dict 中随机选择 N 个 key，N 默认是 5，计算每个 key 的 idle 值，按 idle 值从小到大的顺序插入 evictionPool 中，然后选择 idle 最大的那个 key，进行淘汰。</p>
<p><img src="http://image.leonote.cn/20210714220907.png" alt=""></p>
<p>选择淘汰策略时，可以通过配置 Redis 的 maxmemory 设置最大内存，并通 maxmemory_policy 设置超过最大内存后的处理策略。如果 maxmemory 设为 0，则表明对内存使用没有任何限制，可以持续存放数据，适合作为存储，来存放数据量较小的业务。如果数据量较大，就需要估算热数据容量，设置一个适当的值，将 Redis 作为一个缓存而非存储来使用。</p>
<p>Redis 提供了 8 种 maxmemory_policy 淘汰策略来应对内存超过阀值的情况。</p>
<ol>
<li><p>第一种淘汰策略是 noeviction，它是 Redis 的默认策略。在内存超过阀值后，Redis 不做任何清理工作，然后对所有写操作返回错误，但对读请求正常处理。noeviction 适合数据量不大的业务场景，将关键数据存入 Redis 中，将 Redis 当作 DB 来使用。</p>
</li>
<li><p>第二种淘汰策略是 volatile-lru，它对带过期时间的 key 采用最近最少访问算法来淘汰。使用这种策略，Redis 会从 redisDb 的 expire dict 过期字典中，首先随机选择 N 个 key，计算 key 的空闲时间，然后插入 evictionPool 中，最后选择空闲时间最久的 key 进行淘汰。这种策略适合的业务场景是，需要淘汰的key带有过期时间，且有冷热区分，从而可以淘汰最久没有访问的key。</p>
</li>
<li><p>第三种策略是 volatile-lfu，它对带过期时间的 key 采用最近最不经常使用的算法来淘汰。使用这种策略时，Redis 会从 redisDb 中的 expire dict 过期字典中，首先随机选择 N 个 key，然后根据其 value 的 lru 值，计算 key 在一段时间内的使用频率相对值。对于 lfu，要选择使用频率最小的 key，为了沿用 evictionPool 的 idle 概念，Redis 在计算 lfu 的 Idle 时，采用 255 减去使用频率相对值，从而确保 Idle 最大的 key 是使用次数最小的 key，计算 N 个 key 的 Idle 值后，插入 evictionPool，最后选择 Idle 最大，即使用频率最小的 key，进行淘汰。这种策略也适合大多数 key 带过期时间且有冷热区分的业务场景。</p>
</li>
<li><p>第四种策略是 volatile-ttl，它是对带过期时间的 key 中选择最早要过期的 key 进行淘汰。使用这种策略时，Redis 也会从 redisDb 的 expire dict 过期字典中，首先随机选择 N 个 key，然后用最大无符号 long 值减去 key 的过期时间来作为 Idle 值，计算 N 个 key 的 Idle 值后，插入evictionPool，最后选择 Idle 最大，即最快就要过期的 key，进行淘汰。这种策略适合，需要淘汰的key带过期时间，且有按时间冷热区分的业务场景。   </p>
</li>
<li><p>第五种策略是 volatile-random，它是对带过期时间的 key 中随机选择 key 进行淘汰。使用这种策略时，Redis 从 redisDb 的 expire dict 过期字典中，随机选择一个 key，然后进行淘汰。如果需要淘汰的key有过期时间，没有明显热点，主要被随机访问，那就适合选择这种淘汰策略。</p>
</li>
<li><p>第六种策略是 allkey-lru，它是对所有 key，而非仅仅带过期时间的 key，采用最近最久没有使用的算法来淘汰。这种策略与 volatile-lru 类似，都是从随机选择的 key 中，选择最长时间没有被访问的 key 进行淘汰。区别在于，volatile-lru 是从 redisDb 中的 expire dict 过期字典中选择 key，而 allkey-lru 是从所有的 key 中选择 key。这种策略适合，需要对所有 key 进行淘汰，且数据有冷热读写区分的业务场景。</p>
<p><img src="http://image.leonote.cn/20210714220936.png" alt=""></p>
</li>
<li><p>第七种策略是 allkeys-lfu，它也是针对所有 key 采用最近最不经常使用的算法来淘汰。这种策略与 volatile-lfu 类似，都是在随机选择的 key 中，选择访问频率最小的 key 进行淘汰。区别在于，volatile-flu从expire dict 过期字典中选择 key，而 allkeys-lfu 是从主 dict 中选择 key。这种策略适合的场景是，需要从所有的 key 中进行淘汰，但数据有冷热区分，且越热的数据访问频率越高。</p>
</li>
<li><p>最后一种策略是 allkeys-random，它是针对所有 key 进行随机算法进行淘汰。它也是从主 dict 中随机选择 key，然后进行删除回收。如果需要从所有的 key 中进行淘汰，并且 key 的访问没有明显热点，被随机访问，即可采用这种策略。</p>
</li>
</ol>
<h2 id="Redis崩溃后，如何进行数据恢复的？"><a href="#Redis崩溃后，如何进行数据恢复的？" class="headerlink" title="Redis崩溃后，如何进行数据恢复的？"></a>Redis崩溃后，如何进行数据恢复的？</h2><p><img src="http://image.leonote.cn/20210714220958.png" alt=""><br>Redis 持久化是一个将内存数据转储到磁盘的过程。Redis 目前支持 RDB、AOF，以及混合存储三种模式。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 的 RDB 持久化是以快照的方式将内存数据存储到磁盘。在需要进行 RDB 持久化时，Redis 会将内存中的所有数据以二进制的格式落地，每条数据存储的内容包括过期时间、数据类型、key，以及 value。当 Redis 重启时，如果 appendonly 关闭，则会读取 RDB 持久化生成的二进制文件进行数据恢复。</p>
<p>触发构建 RDB 的场景主要有以下四种。</p>
<ol>
<li><p>第一种场景是通过 save 或 bgsave 命令进行主动 RDB 快照构建。它是由调用方调用 save 或 bgsave 指令进行触发的。</p>
</li>
<li><p>第二种场景是利用配置 save m n 来进行自动快照生成。它是指在 m 秒中，如果插入或变更 n 个 key，则自动触发 bgsave。这个配置可以设置多个配置行，以便组合使用。由于峰值期间，Redis 的压力大，变更的 key 也比较多，如果再进行构建 RDB 的操作，会进一步增加机器负担，对调用方请求会有一定的影响，所以线上使用时需要谨慎。</p>
</li>
<li><p>第三种场景是主从复制，如果从库需要进行全量复制，此时主库也会进行 bgsave 生成一个 RDB 快照。</p>
</li>
<li><p>第四种场景是在运维执行 flushall 清空所有数据，或执行 shutdown 关闭服务时，也会触发 Redis 自动构建 RDB 快照。</p>
<p><img src="http://image.leonote.cn/20210714221041.png" alt=""></p>
</li>
</ol>
<p>save 是在主进程中进行 RDB 持久化的，持久化期间 Redis 处于阻塞状态，不处理任何客户请求，所以一般使用较少。而 bgsave 是 fork 一个子进程，然后在子进程中构建 RDB 快照，构建快照的过程不直接影响用户的访问，但仍然会增加机器负载。线上 Redis 快照备份，一般会选择凌晨低峰时段，通过 bgsave 主动触发进行备份。</p>
<p>RDB 快照文件主要由 3 部分组成。</p>
<ol>
<li><p>第一部分是 RDB 头部，主要包括 RDB 的版本，以及 Redis 版本、创建日期、占用内存等辅助信息。</p>
</li>
<li><p>第二部分是各个 RedisDB 的数据。存储每个 RedisDB 时，会首先记录当前 RedisDB 的DBID，然后记录主 dict 和 expire dict 的记录数量，最后再轮询存储每条数据记录。存储数据记录时，如果数据有过期时间，首先记录过期时间。如果 Redis 的 maxmemory_policy 过期策略采用 LRU 或者 LFU，还会将 key 对应的 LRU、LFU 值进行落地，最后记录数据的类型、key，以及 value。</p>
</li>
<li><p>第三部部分是 RDB 的尾部。RDB 尾部，首先存储 Redis 中的 Lua 脚本等辅助信息。然后存储 EOF 标记，即值为 255 的字符。最后存 RDB 的 cksum。</p>
</li>
</ol>
<p>至此，RDB 就落地完毕。</p>
<p>RDB 采用二进制方式存储内存数据，文件小，且启动时恢复速度快。但构建 RDB 时，一个快照文件只能存储，构建时刻的内存数据，无法记录之后的数据变更。构建 RDB 的过程，即便在子进程中进行，但仍然属于 CPU 密集型的操作，而且每次落地全量数据，耗时也比较长，不能随时进行，特别是不能在高峰期进行。由于 RDB 采用二进制存储，可读性差，而且由于格式固定，不同版本之间可能存在兼容性问题。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p><img src="http://image.leonote.cn/20210714221054.png" alt=""></p>
<p>Redis 的 AOF 持久化是以命令追加的方式进行数据落地的。通过打开 appendonly 配置，Redis 将每一个写指令追加到磁盘 AOF 文件，从而及时记录内存数据的最新状态。这样即便 Redis 被 crash 或异常关闭后，再次启动，也可以通过加载 AOF，来恢复最新的全量数据，基本不会丢失数据。</p>
<p>AOF 文件中存储的协议是写指令的 multibulk 格式，这是 Redis 的标准协议格式，所以不同的 Redis 版本均可解析并处理，兼容性很好。</p>
<p>但是，由于 Redis 会记录所有写指令操作到 AOF，大量的中间状态数据，甚至被删除的过期数据，都会存在 AOF 中，冗余度很大，而且每条指令还需通过加载和执行来进行数据恢复，耗时会比较大。</p>
<p>AOF 数据的落地流程如下。Redis 在处理完写指令后，首先将写指令写入 AOF 缓冲，然后通过 server_cron 定期将 AOF 缓冲写入文件缓冲。最后按照配置策略进行 fsync，将文件缓冲的数据真正同步写入磁盘。</p>
<p><img src="http://image.leonote.cn/20210714221116.png" alt=""></p>
<p>Redis 通过 appendfsync 来设置三种不同的同步文件缓冲策略。</p>
<ol>
<li><p>第一种配置策略是 no，即 Redis 不主动使用 fsync 进行文件数据同步落地，而是由操作系统的 write 函数去确认同步时间，在 Linux 系统中大概每 30 秒会进行一次同步，如果 Redis 发生 crash，就会造成大量的数据丢失。</p>
</li>
<li><p>第二种配置策略是 always，即每次将 AOF 缓冲写入文件，都会调用 fsync 强制将内核数据写入文件，安全性最高，但性能上会比较低效，而且由于频繁的 IO 读写，磁盘的寿命会大大降低。</p>
</li>
<li><p>第三种配置策略是 everysec。即每秒通过 BIO 线程进行一次 fsync。这种策略在安全性、性能，以及磁盘寿命之间做较好的权衡，可以较好的满足线上业务需要。</p>
<p><img src="http://image.leonote.cn/20210714221142.png" alt=""></p>
</li>
</ol>
<p>随着时间的推移，AOF 持续记录所有的写指令，AOF 会越来越大，而且会充斥大量的中间数据、过期数据，为了减少无效数据，提升恢复时间，可以定期对 AOF 进行 rewrite 操作。</p>
<p>AOF 的 rewrite 操作可以通过运维执行 bgrewiretaof 命令来进行，也可以通过配置重写策略进行，由 Redis 自动触发进行。当对 AOF 进行 rewrite 时，首先会 fork 一个子进程。子进程轮询所有 RedisDB 快照，将所有内存数据转为 cmd，并写入临时文件。在子进程 rewriteaof 时，主进程可以继续执行用户请求，执行完毕后将写指令写入旧的 AOF 文件和 rewrite 缓冲。子进程将 RedisDB 中数据落地完毕后，通知主进程。主进程从而将 AOF rewite 缓冲数据写入 AOF 临时文件，然后用新的 AOF 文件替换旧的 AOF 文件，最后通过 BIO 线程异步关闭旧的 AOF 文件。至此，AOF 的 rewrite 过程就全部完成了。</p>
<p><img src="http://image.leonote.cn/20210714221154.png" alt=""></p>
<p>AOF 重写的过程，是一个轮询全部 RedisDB 快照，逐一落地的过程。每个 DB，首先通过 select  $db 来记录待落的 DBID。然后通过命令记录每个 key/value。对于数据类型为 SDS 的value，可以直接落地。但如果 value 是聚合类型，则会将所有元素设为批量添加指令，进行落地。</p>
<p>对于 list 列表类型，通过 RPUSH 指令落地所有列表元素。对于 set 集合，会用 SADD 落地所有集合元素。对于 Zset 有序集合，会用 Zadd 落地所有元素，而对于 Hash 会用 Hmset 落地所有哈希元素。如果数据带过期时间，还会通过 pexpireat 来记录数据的过期时间。</p>
<p>AOF 持久化的优势是可以记录全部的最新内存数据，最多也就是 1-2 秒的数据丢失。同时 AOF 通过 Redis 协议来追加记录数据，兼容性高，而且可以持续轻量级的保存最新数据。最后因为是直接通过 Redis 协议存储，可读性也比较好。</p>
<p>AOF 持久化的不足是随着时间的增加，冗余数据增多，文件会持续变大，而且数据恢复需要读取所有命令并执行，恢复速度相对较慢。</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p><img src="http://image.leonote.cn/20210714221221.png" alt=""></p>
<p>Redis 在 4.0 版本之后，引入了混合持久化方式，而且在 5.0 版本后默认开启。前面讲到 RDB 加载速度快，但构建慢，缺少最新数据。AOF 持续追加最新写记录，可以包含所有数据，但冗余大，加载速度慢。混合模式一体化使用 RDB 和 AOF，综合 RDB 和 AOF 的好处。即可包含全量数据，加载速度也比较快。可以使用 aof-use-rdb-preamble 配置来明确打开混合持久化模式。</p>
<p>混合持久化也是通过 bgrewriteaof 来实现的。当启用混合存储后，进行 bgrewriteaof 时，主进程首先依然是 fork 一个子进程，子进程首先将内存数据以 RDB 的二进制格式写入 AOF 临时文件中。然后，再将落地期间缓冲的新增写指令，以命令的方式追加到临时文件。然后再通知主进程落地完毕。主进程将临时文件修改为 AOF 文件，并关闭旧的  AOF 文件。这样主体数据以 RDB 格式存储，新增指令以命令方式追加的混合存储方式进行持久化。后续执行的任务，以正常的命令方式追加到新的 AOF 文件即可。</p>
<p>混合持久化综合了 RDB 和 AOF 的优缺点，优势是包含全量数据，加载速度快。不足是头部的 RDB 格式兼容性和可读性较差。</p>
<h2 id="Redis是如何处理容易超时的系统调用的？"><a href="#Redis是如何处理容易超时的系统调用的？" class="headerlink" title="Redis是如何处理容易超时的系统调用的？"></a>Redis是如何处理容易超时的系统调用的？</h2><h3 id="BIO-线程简介"><a href="#BIO-线程简介" class="headerlink" title="BIO 线程简介"></a>BIO 线程简介</h3><p>Redis 在运行过程中，不可避免的会产生一些运行慢的、容易引发阻塞的任务，如将内核中的文件缓冲同步到磁盘中、关闭文件，都会引发短时阻塞，还有一些大 key，如一些元素数高达万级或更多的聚合类元素，在删除时，由于所有元素需要逐一释放回收，整个过程耗时也会比较长。而 Redis 的核心处理线程是单进程单线程模型，所有命令的接受与处理、数据淘汰等都在主线程中进行，这些任务处理速度非常快。如果核心单线程还要处理那些慢任务，在处理期间，势必会阻塞用户的正常请求，导致服务卡顿。为此，Redis 引入了 BIO 后台线程，专门处理那些慢任务，从而保证和提升主线程的处理能力。</p>
<p><img src="http://image.leonote.cn/20210714221248.png" alt=""></p>
<p>Redis 的 BIO 线程采用生产者-消费者模型。主线程是生产者，生产各种慢任务，然后存放到任务队列中。BIO 线程是消费者，从队列获取任务并进行处理。如果生产者生产任务过快，队列可用于缓冲这些任务，避免负荷过载或数据丢失。如果消费者处理速度很快，处理完毕后就可以安静的等待，不增加额外的性能开销。再次，有新任务时，主线程通过条件变量来通知 BIO 线程，这样 BIO 线程就可以再次执行任务。</p>
<h3 id="BIO-处理任务"><a href="#BIO-处理任务" class="headerlink" title="BIO 处理任务"></a>BIO 处理任务</h3><p>Redis 启动时，会创建三个任务队列，并对应构建 3 个 BIO 线程，三个 BIO 线程与 3 个任务队列之间一一对应。BIO 线程分别处理如下 3 种任务。</p>
<p>close 关闭文件任务。rewriteaof 完成后，主线程需要关闭旧的 AOF 文件，就向 close 队列插入一个旧 AOF 文件的关闭任务。由 close 线程来处理。</p>
<p>fysnc 任务。Redis 将 AOF 数据缓冲写入文件内核缓冲后，需要定期将系统内核缓冲数据写入磁盘，此时可以向 fsync 队列写入一个同步文件缓冲的任务，由 fsync 线程来处理。</p>
<p>lazyfree 任务。Redis 在需要淘汰元素数大于 64 的聚合类数据类型时，如列表、集合、哈希等，就往延迟清理队列中写入待回收的对象，由 lazyfree 线程后续进行异步回收。</p>
<h3 id="BIO-处理流程"><a href="#BIO-处理流程" class="headerlink" title="BIO 处理流程"></a>BIO 处理流程</h3><p>BIO 线程的整个处理流程如图所示。当主线程有慢任务需要异步处理时。就会向对应的任务队列提交任务。提交任务时，首先申请内存空间，构建 BIO 任务。然后对队列锁进行加锁，在队列尾部追加新的 BIO 任务，最后尝试唤醒正在等待任务的 BIO 线程。</p>
<p><img src="http://image.leonote.cn/20210714221308.png" alt=""></p>
<p>BIO 线程启动时或持续处理完所有任务，发现任务队列为空后，就会阻塞，并等待新任务的到来。当主线程有新任务后，主线程会提交任务，并唤醒 BIO 线程。BIO 线程随后开始轮询获取新任务，并进行处理。当处理完所有 BIO 任务后，则再次进入阻塞，等待下一轮唤醒。</p>
<h2 id="如何大幅成倍提升Redis处理性能？"><a href="#如何大幅成倍提升Redis处理性能？" class="headerlink" title="如何大幅成倍提升Redis处理性能？"></a>如何大幅成倍提升Redis处理性能？</h2><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>Redis 自问世以来，广受好评，应用广泛。但相比， Memcached 单实例压测 TPS 可以高达百万，线上可以稳定跑 20<del>40 万而言，Redis 的单实例压测 TPS 不过 10</del>12 万，线上一般最高也就 2~4 万，仍相差一个数量级。</p>
<p>Redis 慢的主要原因是单进程单线程模型。虽然一些重量级操作也进行了分拆，如 RDB 的构建在子进程中进行，文件关闭、文件缓冲同步，以及大 key 清理都放在 BIO 线程异步处理，但还远远不够。线上 Redis 处理用户请求时，十万级的 client 挂在一个 Redis 实例上，所有的事件处理、读请求、命令解析、命令执行，以及最后的响应回复，都由主线程完成，纵然是 Redis 各种极端优化，巧妇难为无米之炊，一个线程的处理能力始终是有上限的。当前服务器 CPU 大多是 16 核到 32 核以上，Redis 日常运行主要只使用 1 个核心，其他 CPU 核就没有被很好的利用起来，Redis 的处理性能也就无法有效地提升。而 Memcached 则可以按照服务器的 CPU 核心数，配置数十个线程，这些线程并发进行 IO 读写、任务处理，处理性能可以提高一个数量级以上。</p>
<h3 id="IO-线程"><a href="#IO-线程" class="headerlink" title="IO 线程"></a>IO 线程</h3><p>面对性能提升困境，虽然 Redis 作者不以为然，认为可以通过多部署几个 Redis 实例来达到类似多线程的效果。但多实例部署则带来了运维复杂的问题，而且单机多实例部署，会相互影响，进一步增大运维的复杂度。为此，社区一直有种声音，希望 Redis 能开发多线程版本。</p>
<p>因此，Redis 在 6.0 版本引入多线程模型。Redis 的多线程模型，分为主线程和 IO 线程。</p>
<p>因为处理命令请求的几个耗时点，分别是请求读取、协议解析、协议执行，以及响应回复等。所以 Redis 引入 IO 多线程，并发地进行请求命令的读取、解析，以及响应的回复。而其他的所有任务，如事件触发、命令执行、IO 任务分发，以及其他各种核心操作，仍然在主线程中进行，也就说这些任务仍然由单线程处理。这样可以在最大程度不改变原处理流程的情况下，引入多线程。</p>
<h3 id="命令处理流程"><a href="#命令处理流程" class="headerlink" title="命令处理流程"></a>命令处理流程</h3><p>Redis 6.0 的多线程处理流程如图所示。主线程负责监听端口，注册连接读事件。当有新连接进入时，主线程 accept 新连接，创建 client，并为新连接注册请求读事件。</p>
<p><img src="http://image.leonote.cn/20210714221342.png" alt=""></p>
<p>当请求命令进入时，在主线程触发读事件，主线程此时并不进行网络 IO 的读取，而将该连接所在的 client 加入待读取队列中。Redis 的 Ae 事件模型在循环中，发现待读取队列不为空，则将所有待读取请求的 client 依次分派给 IO 线程，并自旋检查等待，等待 IO 线程读取所有的网络数据。所谓自旋检查等待，也就是指主线程持续死循环，并在循环中检查 IO 线程是否读完，不做其他任何任务。只有发现 IO 线程读完所有网络数据，才停止循环，继续后续的任务处理。</p>
<p>一般可以配置多个 IO 线程，比如配置 4~8 个，这些 IO 线程发现待读取队列中有任务时，则开始并发处理。每个 IO 线程从对应列表获取一个任务，从里面的 client 连接中读取请求数据，并进行命令解析。当 IO 线程完成所有的请求读取，并完成解析后，待读取任务数变为 0。主线程就停止循环检测，开始依次执行 IO 线程已经解析的所有命令，每执行完毕一个命令，就将响应写入 client 写缓冲，这些 client 就变为待回复 client，这些待回复 client 被加入待回复列表。然后主线程将这些待回复 client，轮询分配给多个 IO 线程。然后再次自旋检测等待。</p>
<p>然后 IO 线程再次开始并发执行，将不同 client 的响应缓冲写给 client。当所有响应全部处理完后，待回复的任务数变为 0，主线程结束自旋检测，继续处理后续的任务，以及新的读请求。</p>
<p>Redis 6.0 版本中新引入的多线程模型，主要是指可配置多个 IO 线程，这些线程专门负责请求读取、解析，以及响应的回复。通过 IO 多线程，Redis 的性能可以提升 1 倍以上。</p>
<h3 id="多线程方案优劣"><a href="#多线程方案优劣" class="headerlink" title="多线程方案优劣"></a>多线程方案优劣</h3><p>虽然多线程方案能提升1倍以上的性能，但整个方案仍然比较粗糙。首先所有命令的执行仍然在主线程中进行，存在性能瓶颈。然后所有的事件触发也是在主线程中进行，也依然无法有效使用多核心。而且，IO 读写为批处理读写，即所有 IO 线程先一起读完所有请求，待主线程解析处理完毕后，所有 IO 线程再一起回复所有响应，不同请求需要相互等待，效率不高。最后在 IO 批处理读写时，主线程自旋检测等待，效率更是低下，即便任务很少，也很容易把 CPU 打满。整个多线程方案比较粗糙，所以性能提升也很有限，也就 1~2 倍多一点而已。要想更大幅提升处理性能，命令的执行、事件的触发等都需要分拆到不同线程中进行，而且多线程处理模型也需要优化，各个线程自行进行 IO 读写和执行，互不干扰、等待与竞争，才能真正高效地利用服务器多核心，达到性能数量级的提升。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-分布式Memcached实战</title>
    <url>/2021/06/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E5%88%86%E5%B8%83%E5%BC%8FMemcached%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="分布式Memcached实战"><a href="#分布式Memcached实战" class="headerlink" title="分布式Memcached实战"></a>分布式Memcached实战</h1><h2 id="大数据时代，MC如何应对新的常见问题"><a href="#大数据时代，MC如何应对新的常见问题" class="headerlink" title="大数据时代，MC如何应对新的常见问题"></a>大数据时代，MC如何应对新的常见问题</h2><h3 id="大数据时代-Memcached-经典问题"><a href="#大数据时代-Memcached-经典问题" class="headerlink" title="大数据时代 Memcached 经典问题"></a>大数据时代 Memcached 经典问题</h3><p>随着互联网的快速发展和普及，人类进入了大数据时代。在大数据时代，移动设备全面融入了人们的工作和生活，各种数据以前所未有的速度被生产、挖掘和消费。移动互联网系统也不断演进和发展，存储、计算和分析这些海量数据，以满足用户的需要。在大数据时代，大中型互联网系统具有如下特点。</p>
<ol>
<li><p>首先，系统存储的数据量巨大，比如微博系统，每日有数亿条记录，历史数据达百亿甚至千亿条记录。</p>
</li>
<li><p>其次，用户多，访问量巨大，每日峰值流量高达百万级QPS。</p>
</li>
<li><p>要存储百千亿级的海量数据，同时满足大量用户的高并发访问，互联网系统需要部署较多的服务实例，不少大中型互联网系统需要部署万级，甚至十万级的服务实例。</p>
</li>
<li><p>再次，由于大数据时代，社会信息获取扁平化，热点事件、突发事件很容易瞬间引爆，引来大量场外用户集中关注，从而形成流量洪峰。</p>
</li>
<li><p>最后，任何硬件资源都有发生故障的概率，而且存在 4 年故障效应，即服务资源在使用 4 年后，出现故障的概率会陡增；由于大中型互联网系统的部署，需要使用大量的服务器、路由器和交换机，同时部署在多个地区的不同 IDC，很多服务资源的使用时间远超 4 年，局部出现硬件故障、网络访问异常就比较常见了。 </p>
</li>
</ol>
<p>由于互联网系统会大量使用 Memcached 作为缓存，而在使用 Memcached 的过程中，同样也会受到前面所说的系统特点的影响，从而产生特有的经典问题。</p>
<h4 id="容量问题"><a href="#容量问题" class="headerlink" title="容量问题"></a>容量问题</h4><p>第一个问题是容量问题。Memcached 在使用中，除了存储数据占用内存外，连接的读写缓冲、哈希表分配、辅助线程处理、进程运行等都会占用内存空间，而且操作系统本身也会占用不少内存，为了确保 Mc 的稳定运行，Mc 的内存设置，一般设为物理内存的 80%。另外，设置的内存，也不完全是存储有效数据，因为每个 Item 数据存储在 chunk 时，会有部分字节浪费，另外 key 在过期、失效后，不是立即删除，而是采用延迟淘汰、异步 LRU 队尾扫描的方式清理，这些暂时没有淘汰的、过期失效的 key ，也会占用不少的存储空间。当前大数据时代，互联网系统中的很多核心业务，需要缓存的热数据在 300~500GB 以上，远远超过单机物理内存的容量。</p>
<h4 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h4><p>第二个问题是性能瓶颈问题。出于系统稳定性考虑，线上 Mc 的访问，最大 QPS 要在 10~20w 以下，超过则可能会出现慢查的问题。而对中大型互联网系统，核心业务的缓存请求高达百万级 QPS，仅仅靠简单部署单个物理机、单个资源池很难达到线上的业务要求。</p>
<h4 id="连接瓶颈"><a href="#连接瓶颈" class="headerlink" title="连接瓶颈"></a>连接瓶颈</h4><p>第三个问题是连接瓶颈的问题。出于稳定性考虑，线上 Mc 的连接数要控制在 10w 以下。以避免连接数过多，导致连接占用大量内存，从而出现命中率下降、甚至慢查超时的问题。对于大中型系统，线上实例高达万级、甚至十万级，单个实例的最小、最大连接数，一般设置在 5~60 个之间。业务实例的连接数远超过单个机器的稳定支撑范围。</p>
<h4 id="硬件资源局部故障"><a href="#硬件资源局部故障" class="headerlink" title="硬件资源局部故障"></a>硬件资源局部故障</h4><p>第四个问题是硬件资源局部故障，导致的缓存体系的可用性问题。由于任何硬件资源，都有一定故障概率，而且在使用 4 年后，故障率陡增。对于数以万计的硬件设备，随时都有可能出现机器故障，从而导致 Mc 节点访问性能下降、宕机，海量访问穿透到 DB，引发 DB 过载，最终导致整个系统无法访问，引发雪崩现象。</p>
<h4 id="流量洪峰下快速扩展"><a href="#流量洪峰下快速扩展" class="headerlink" title="流量洪峰下快速扩展"></a>流量洪峰下快速扩展</h4><p>第五个问题是在流量洪峰的场景下，如何快速扩展的问题。大数据时代，由于信息扩散的扁平化，突发事件、重大活动发生时，海量用户同时蜂拥而至，短时间引发巨大流量。整个系统的访问量相比日常峰值增大 70% 以上，同时出现大量的极热 key 的访问，这些极热 key 所在的 Mc 节点，访问量相比日常高峰，增大 2~3 倍以上，很容易出现 CPU 飙升、带宽打满、机器负荷严重过载的现象。</p>
<h3 id="Memchcaed-经典问题及应对方案"><a href="#Memchcaed-经典问题及应对方案" class="headerlink" title="Memchcaed 经典问题及应对方案"></a>Memchcaed 经典问题及应对方案</h3><p>为了解决大中型互联网系统在使用 Mc 时的这些问题。可以使用下面的解决方案。</p>
<h4 id="Memcached-分拆缓存池"><a href="#Memcached-分拆缓存池" class="headerlink" title="Memcached 分拆缓存池"></a>Memcached 分拆缓存池</h4><p>首先对系统内的核心业务数据进行分拆，让访问量大的数据，使用独立的缓存池。同时每个缓存池 4~8 个节点，这样就可以支撑足够大的容量，还避免单个缓存节点压力过大。对于缓存池的分布策略，可以采用<strong>一致性哈希分布</strong>和<strong>哈希取模分布</strong>。</p>
<p>一致性哈希分布算法中，首先计算 Mc 服务节点的哈希值，然后将其持续分散配置在圆中，这样每个缓存节点，实际包括大量大小各异的 N 个 hash 点。如下图所示，在数据存储或请求时，对 key 采用相同的 hash 算法，并映射到前面的那个圆中，从映射位置顺时针查找，找到的第一个 Mc 节点，就是目标存取节点。</p>
<p><img src="http://image.leonote.cn/20210617195100.png" alt=""></p>
<p>而哈希取模分布算法，则比较简单，对 key 做 hash 后，对 Mc 节点数取模，即可找到待存取的目标 Mc 节点。</p>
<p>系统运行过程中，Mc 节点故障不可避免，有时候甚至短期内出现多次故障。在 Mc 节点故障下线后，如果采用一致性 hash 分布，可以方便得通过 rehash 策略，将该 Mc 节点的 hash 点、访问量，均匀分散到其他 Mc 节点。如果采用取模分布，则会直接导致 1/N 的访问 miss，N 是 Mc 资源池的节点数。</p>
<p>因此，对于单层 Mc 缓存架构，一致性 hash 分布配合 rehash 策略，是一个更佳的方案。通过将业务数据分拆到独立 Mc 资源池，同时在每个资源池采用合适的分布算法，可以很好的解决 Mc 使用中容量问题、性能瓶颈问题，以及连接瓶颈问题。</p>
<h4 id="Master-Slave-两级架构"><a href="#Master-Slave-两级架构" class="headerlink" title="Master-Slave 两级架构"></a>Master-Slave 两级架构</h4><p>在系统的访问量比较大，比如峰值 QPS 达到 20w 以上时，如果缓存节点故障，即便采用一致性 hash，也会在一段时间内给 DB 造成足够大的压力，导致大量慢查询和访问超时的问题。另外，如果某些缓存服务器短期多次故障，反复上下线，多次 rehash 还会产生脏数据。对此，可以采用 Master-Slave 的两级架构方案。</p>
<p>在这种架构方案下，将业务正常访问的 Memcached 缓存池作为 master，然后在 master 之后，再加一个slave 资源池作 master 的热备份。slave 资源池也用 6<del>8 个节点，内存设置只用 master 的 1/2</del>1/3 即可。因为 slave 的应用，主要是考虑在 master 访问 miss 或异常时，Mc 缓存池整体的命中率不会过度下降，所以并不需要设置太大内存。</p>
<p>日常访问，对于读操作，直接访问 master，如果访问 miss，再访问 slave。如果 slave 命中，就将读取到的 key 回写到 master。对于写操作，set、touch 等覆盖类指令，直接更新master 和 slave；而 cas、append 等，以 master 为准，master 在 cas、add 成功后，再将 key 直接 set 到 slave，以保持 master、slave 的数据一致性。</p>
<p>如下图，在 master 部分节点异常后，由 slave 层来承接。任何一层，部分节点的异常，不会影响整体缓存的命中率、请求耗时等 SLA 指标。同时分布方式采用哈希取模方案，mc 节点异常不rehash，直接穿透，方案简洁，还可以避免一致性 hash 在 rehash 后产生的脏数据问题。</p>
<p><img src="http://image.leonote.cn/20210617195139.png" alt=""></p>
<p>Master-Slave 架构，在访问量比较大的场景下，可以很好得解决局部设备故障的问题。在部分节点异常或访问 miss 时，多消耗 1ms 左右的时间，访问 slave 资源，实现以时间换系统整体可用性的目的。</p>
<h4 id="M-S-L1-架构"><a href="#M-S-L1-架构" class="headerlink" title="M-S-L1 架构"></a>M-S-L1 架构</h4><p>20世纪初，意大利统计学家帕累托提出来一个观点：在任何特定群体中，重要的因子通常只占少数，而不重要的因子则占多数，因此只要能控制具有重要性的少数因子，即能控制全局。这个理论经过多年演化，就成为当前大家所熟悉的 80/20 定律。80/20 定律在互联网系统中也广泛存在，如 80% 的用户访问会集中在系统 20% 的功能上，80% 的请求会集中在 20% 的数据上。因此，互联网系统的数据，有明显的冷热区分，而且这个冷热程度往往比 80/20 更大，比如微博、微信最近一天的数据，被访问的特别频繁，而一周前的数据就很少被访问了。而且最近几天的热数据中，部分 feed 信息会被大量传播和交互，比其他 大部分数据的访问量要高很多倍，形成明显的头部请求。</p>
<p><strong>头部请求</strong>，会导致日常大量访问，被集中在其中一小部分 key 上。同时，在突发新闻、重大事件发生时，请求量短期增加 50~70% 以上，而这些请求，又集中在突发事件的关联 key 上，造就大量的热 key 的出现。热 key 具有随机性，如果集中在某少数几个节点，就会导致这些节点的压力陡增数倍，负荷严重过载，进而引发大量查询变慢超时的问题。</p>
<p>为了应对日常峰值的热数据访问，特别是在应对突发事件时，洪峰流量带来的极热数据访问，可以通过增加 L1 层来解决。如下图所示，L1 层包含 2<del>6 组 L1 资源池，每个 L1 资源池，用 4</del>6 个节点，但内存容量只要 Master 的 1/10 左右即可。</p>
<p><img src="http://image.leonote.cn/20210617195214.png" alt=""></p>
<p>如图，读请求时，首先随机选择一个 L1 进行读取，如果 miss 则访问 master，如果 master 也 miss，最后访问 slave。中途，只要任何一层命中，则对上一层资源池进行回写。</p>
<p>写请求时，同 Master-Slave 架构类似，对于 set 覆盖类指令，直接 set 三层所有的资源池。对于 add/cas/append 等操作，以 master 为准，master 操作成功后，将最后的 key/value set 到 L1 和 slave 层所有资源池。</p>
<p>由于 L1 的内存只有 master 的 1/10，且 L1 优先被读取，所以 L1 中 Memcached 只会保留最热的 key，因为 key 一旦稍微变冷，就会排到 COLD LRU 队尾，并最终被剔除。虽然 L1 的内存小，但由于 L1 里，永远只保存了系统访问量最大最热的数据，根据统计L1 可以满足整个系统的 60~80% 以上的请求数据。这也与 80/20 原则相符合。</p>
<p>master 存放全量的热数据，用于满足 L1 读取 miss 或异常后的访问流量。slave 用来存放绝大部分的热数据，而且与 master 存在一定的差异，用来满足 L1、master 读取 miss 或异常的访问流量。</p>
<p>这里面有个可以进一步优化的地方，即为确保 master、slave 的热度，让 master、slave 也尽可能只保留最热的那部分数据，可以在读取 L1 时，保留适当的概率，直接读取 master 或slave，让最热的 key 被访问到，从而不会被 master、slave 剔除。此时，访问路径需要稍做调整，即如果首先访问了 master，如果 miss，接下来只访问 slave。而如果首先访问了 slave，如果 miss，接下来只访问 master。</p>
<p>通过 Master-Slave-L1 架构，在流量洪峰到来之际，可以用很少的资源，快速部署多组L1资源池，然后加入 L1 层中，从而让整个系统的抗峰能力达到 N 倍的提升。从而以最简洁的办法，快速应对流量洪峰，把极热 key 分散到 N 组 L1 中，每个 L1 资源池只用负责 1/N 的请求。除了抗峰，另外，还可以轻松应对局部故障，避免雪崩的发生。</p>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="http://image.leonote.cn/20210617195300.png" alt=""></p>
<h2 id="如何深入理解、应用及扩展-Twemproxy"><a href="#如何深入理解、应用及扩展-Twemproxy" class="headerlink" title="如何深入理解、应用及扩展 Twemproxy"></a>如何深入理解、应用及扩展 Twemproxy</h2><h3 id="Twemproxy-架构及应用"><a href="#Twemproxy-架构及应用" class="headerlink" title="Twemproxy 架构及应用"></a>Twemproxy 架构及应用</h3><p>Twemproxy 是 Twitter 的一个开源架构，它是一个分片资源访问的代理组件。如下图所示，它可以封装资源池的分布及 hash 规则，解决后端部分节点异常后的探测和重连问题，让 client 访问尽可能简单，同时资源变更时，只要在 Twemproxy 变更即可，不用更新数以万计的 client，让资源变更更轻量。最后，Twemproxy 跟后端通过单个长连接访问，可以大大减少后端资源的连接压力。</p>
<h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p>接下来分析基于 Twemproxy 的应用系统架构，以及 Twemproxy 组件的内部架构。</p>
<p>如下图所示， 在应用系统中，Twemproxy 是一个介于 client 端和资源端的中间层。它的后端，支持Memcached 资源池和 Redis 资源池的分片访问。Twemproxy 支持取模分布和一致性 hash 分布，还支持随机分布，不过使用场景较少。 </p>
<p><img src="http://image.leonote.cn/20210617200127.png" alt=""></p>
<p>应用前端在请求缓存数据时，直接访问 Twemproxy 的对应端口，然后 Twemproxy 解析命令得到 key，通过 hash 计算后，按照分布策略，将 key 路由到后端资源的分片。在后端资源响应后，再将响应结果返回给对应的 client。</p>
<p>在系统运行中，Twemproxy 会自动维护后端资源服务的状态。如果后端资源服务异常，会自动进行剔除，并定期探测，在后端资源恢复后，再对缓存节点恢复正常使用。</p>
<h4 id="组件架构"><a href="#组件架构" class="headerlink" title="组件架构"></a>组件架构</h4><p>Twemproxy 是基于 epoll 事件驱动模型开发的，架构如下图所示。它是一个单进程、单线程组件。核心进程处理所有的事件，包括网络 IO，协议解析，消息路由等。Twemproxy 可以监听多个端口，每个端口接受并处理一个业务的缓存请求。Twemproxy 支持 Redis、Memcached 协议，支持一致性 hash 分布、取模分布、随机分布三种分布方案。Twemproxy 通过 YAML 文件进行配置，简单清晰，且便于人肉读写。</p>
<p><img src="http://image.leonote.cn/20210617200328.png" alt=""></p>
<p>Twemproxy 与后端资源通过单个长连接访问，在收到业务大量并发请求后，会通过 pipeline 的方式，将多个请求批量发到后端。在后端资源持续访问异常时，Twemproxy 会将其从正常列表中剔除，并不断探测，待其恢复后再进行请求的路由分发。</p>
<p>Twemproxy 运行中，会持续产生海量请求及响应的消息流，于是开发者精心设计了内存管理机制，尽可能的减少内存分配和复制，最大限度的提升系统性能。Twemproxy 内部，请求和响应都是一个消息，而这个消息结构体，以及消息存放数据的缓冲都是重复使用的，避免反复分配和回收的开销，提升消息处理的性能。为了解决短连接的问题，Twemproxy 的连接也是复用的，这样在面对 PHP client 等短连接访问时，也可以反复使用之前分配的 connection，提升连接性能。</p>
<p>另外，Twemproxy 对消息还采用了 zero copy（即零拷贝）方案。对于请求消息，只在client 接受时读取一次，后续的解析、处理、转发都不进行拷贝，全部共享最初的那个消息缓冲。对于后端的响应也采用类似方案，只在接受后端响应时，读取到消息缓冲，后续的解析、处理及回复 client 都不进行拷贝。通过共享消息体及消息缓冲，虽然 Twemproxy 是单进程/单线程处理，仍然可以达到 6~8w 以上的 QPS。</p>
<h3 id="Twemproxy-请求及响应"><a href="#Twemproxy-请求及响应" class="headerlink" title="Twemproxy 请求及响应"></a>Twemproxy 请求及响应</h3><p>接下来看一下 Twemproxy 是如何进行请求路由及响应的。</p>
<p>Twemproxy 监听端口，当有 client 连接进来时，则 accept 新连接，并构建初始化一个 client_conn。当建连完毕，client 发送数据到来时，client_conn 收到网络读事件，则从网卡读取数据，并记入请求消息的缓冲中。读取完毕，则开始按照配置的协议进行解析，解析成功后，就将请求 msg 放入到 client_conn 的 out 队列中。接下来，就对解析的命令 key 进行 hash 计算，并根据分布算法，找到对应 server 分片的连接，即一个 server_conn 结构体，如下图。</p>
<p><img src="http://image.leonote.cn/20210617200745.png" alt=""></p>
<p>如果 server_conn的 in 队列为空，首先对 server_conn 触发一个写事件。然后将 req msg 存入到 server_conn 的 in 队列。Server_conn 在处理写事件时，会对 in 队列中的 req msg 进行聚合，按照 pipeline 的方式批量发送到后端资源。待发送完毕后，将该条请求 msg 从 server_conn 的 in 队列删除，并插入到 out 队列中。</p>
<p>后端资源服务完成请求后，会将响应发送给 Twemproxy。当响应到 Twemproxy 后，对应的 server_conn 会收到 epoll 读事件，则开始读取响应 msg。响应读取并解析后，会首先将server_conn 中，out 队列的第一个 req msg 删除，并将这个 req msg 和最新收到的 rsp msg 进行配对。在 req 和 rsp 匹配后，触发 client_conn 的写事件，如下图。</p>
<p><img src="http://image.leonote.cn/20210617200824.png" alt=""></p>
<p>然后 client_conn 在处理 epoll 写事件时，则按照请求顺序，批量将响应发送给 client 端。发送完毕后，将 req msg 从 client 的 out 队列删除。最后，再回收消息缓冲，以及消息结构体，供后续请求处理的时候复用。至此一个请求的处理彻底完成。</p>
<h3 id="Twemproxy-安装和使用"><a href="#Twemproxy-安装和使用" class="headerlink" title="Twemproxy 安装和使用"></a>Twemproxy 安装和使用</h3><p>Twemproxy 的安装和使用比较简单。首先通过 Git，将 Twemproxy 从 GitHub clone 到目标服务器，然后进入 Twemproxy 路径，首先执行 $ autoreconf -fvi，然后执行 ./configure ，最后执行 make（当然，也可以再执行 make install），这样就完成了 Temproxy 的编译和安装。然后就可以通过 src/nutcracker -c /xxx/conf/nutcracker.yml 来启动 Twemproxy 了。</p>
<p>Twemproxy 代理后端资源访问，这些后端资源的部署信息及访问策略都是在 YAML 文件中配置。所以接下来，我们简单看一下 Twemproxy 的配置。如图所示，这个配置中代理了 2 个业务数据的缓存访问。一个是 alpha，另一个是 beta。在每个业务的配置详情里。首先是 listen 配置项，用于设置监听该业务的端口。然后是 hash 算法和分布算法。Auto_eject_hosts 用于设置在后端 server 异常时，是否将这个异常 server 剔除，然后进行 rehash，默认不剔除。Redis配置项用于指示后端资源类型，是 Redis 还是 Memcached。最后一个配置项 servers，用于设置资源池列表。</p>
<p>以 Memcached 访问为例，将业务的 Memcached 资源部署好之后，然后将 Mc 资源列表、访问方式等设到 YAML 文件的配置项，然后启动 Twemproxy，业务端就可以通过访问 Twemproxy ，来获取后端资源的数据了。后续，Mc 资源有任何变更，业务都不用做任何改变，运维直接修改 Twemproxy 的配置即可。</p>
<p>Twemproxy 在实际线的使用中，还是存在不少问题的。首先，它是单进程/单线程模型，一个 event_base 要处理所有的事件，这些事件包括 client 请求的读入，转发请求给后端 server，从 server 接受响应，以及将响应发送给 client。单个 Twemproxy 实例，压测最大可以到 8w 左右的 QPS，出于线上稳定性考虑，QPS 最多支撑到 3<del>4w。而 Memcached 的线上 QPS，一般可以达到 10</del>20w，一个 Mc 实例前面要挂 3~5 个 Twemproxy 实例。实例数太多，就会引发诸如管理复杂、成本过高等一系列问题。</p>
<p>其次，基于性能及预防单点故障的考虑，Twemproxy 需要进行多实例部署，而且还需要根据业务访问量的变化，进行新实例的加入或冗余实例的下线。多个 Twemproxy 实例同时被访问，如果 client 访问策略不当，就会出现有些 Twemproxy 压力过大，而有些却很空闲，造成访问不均的问题。</p>
<p>再次，后端资源在 Twemproxy 的 YAML 文件集中配置，资源变更的维护，比直接在所有业务 client 端维护，有了很大的简化。但在多个 Twemproxy 修改配置，让这些配置同时生效，也是一个复杂的工作。</p>
<p>最后，Twemproxy 也无法支持 Mc 多副本、多层次架构的访问策略，无法支持 Redis 的Master-Slave 架构的读写分离访问。</p>
<p>为此，你可以对 Twemproxy 进行扩展，以更好得满足业务及运维的需要。</p>
<h3 id="Twemproxy-扩展"><a href="#Twemproxy-扩展" class="headerlink" title="Twemproxy 扩展"></a>Twemproxy 扩展</h3><h4 id="多进程改造"><a href="#多进程改造" class="headerlink" title="多进程改造"></a>多进程改造</h4><p>性能首当其冲。首先可以对 Twemproxy 的单进程/单线程动刀，改为并行处理模型。并行方案可以用多线程方案，也可以采用多进程方案。由于 Twemproxy 只是一个消息路由中间件，不需要额外共享数据，采用多进程方案会更简洁，更适合。</p>
<p>多进程改造中，可以分别构建一个 master 进程和多个 worker 进程来进行任务处理，如下图所示。每个进程维护自己独立的 epoll 事件驱动。其中 master 进程，主要用于监听端口，accept 新连接，并将连接调度给 worker 进程。</p>
<p><img src="http://image.leonote.cn/20210617200958.png" alt=""><br>而 worker 进程，基于自己独立的 event_base，管理从 master 调度给自己的所有 client 连接。在 client 发送网络请求到达时，进行命令读取、解析，并在进程内的 IO 队列流转，最后将请求打包，pipeline 给后端的 server。</p>
<p>在 server 处理完毕请求，发回响应时。对应 worker 进程，会读取并解析响应，然后批量回复给 client。</p>
<p>通过多进程改造，Twemproxy 的 QPS 可以从 8w 提升到 40w+。业务访问时，需要部署的Twemproxy 的实例数会大幅减少，运维会更加简洁。</p>
<h4 id="增加负载均衡"><a href="#增加负载均衡" class="headerlink" title="增加负载均衡"></a>增加负载均衡</h4><p>对于多个 Twemproxy 访问，如何进行负载均衡的问题。一般有三种方案。</p>
<p>第一种方案，是在 Twemproxy 和业务访问端之间，再增加一组 LVS，作为负载均衡层，通过 LVS 负载均衡层，你可以方便得增加或减少 Twemproxy 实例，由 LVS 负责负载均衡和请求分发，如下图。</p>
<p><img src="http://image.leonote.cn/20210617201100.png" alt=""><br>第二种方案，是将 Twemproxy 的 IP 列表加入 DNS。业务 client 通过域名来访问 Twemproxy，每次建连时，DNS 随机返回一个 IP，让连接尽可能均衡。</p>
<p>第三种方案，是业务 client 自定义均衡策略。业务 client 从配置中心或 DNS 获取所有的Twemproxy 的 IP 列表，然后对这些 Twemproxy 进行均衡访问，从而达到负载均衡。</p>
<p>方案一，可以通过成熟的 LVS 方案，高效稳定的支持负载均衡策略，但多了一层，成本和运维的复杂度会有所增加。方案二，只能做到连接均衡，访问请求是否均衡，无法保障。方案三，成本最低，性能也比前面 2 个方案更高效。推荐使用方案三，微博内部也是采用第三种方案。</p>
<h4 id="增加配置中心"><a href="#增加配置中心" class="headerlink" title="增加配置中心"></a>增加配置中心</h4><p>对于 Twemproxy 配置的维护，可以通过增加一个配置中心服务来解决。将 YAML 配置文件中的所有配置信息，包括后端资源的部署信息、访问信息，以配置的方式存储到配置中心，如下图。</p>
<p><img src="http://image.leonote.cn/20210617201128.png" alt=""></p>
<p>Twemproxy 启动时，首先到配置中心订阅并拉取配置，然后解析并正常启动。Twemproxy 将自己的 IP 和监听端口信息，也注册到配置中心。业务 client 从配置中心，获取Twemproxy 的部署信息，然后进行均衡访问。</p>
<p>在后端资源变更时，直接更新配置中心的配置。配置中心会通知所有 Twemproxy 实例，收到事件通知，Twemproxy 即可拉取最新配置，并调整后端资源的访问，实现在线变更。整个过程自动完成，更加高效和可靠。</p>
<h4 id="支持-M-S-L1-多层访问"><a href="#支持-M-S-L1-多层访问" class="headerlink" title="支持 M-S-L1 多层访问"></a>支持 M-S-L1 多层访问</h4><p>前面提到，为了应对突发洪水流量，避免硬件局部故障的影响，对 Mc 访问采用了Master-Slave-L1 架构。可以将该缓存架构体系的访问策略，封装到 Twemproxy 内部。实现方案也比较简单。首先在 servers 配置中，增加 Master、Slave、L1 三层，如下图。</p>
<p><img src="http://image.leonote.cn/20210617201225.png" alt=""></p>
<p>Twemproxy 启动时，每个 worker 进程预连所有的 Mc 后端，当收到 client 请求时，根据解析出来的指令，分别采用不同访问策略即可。</p>
<ul>
<li><p>对于 get 请求，首先随机选择一个 L1 来访问，如果 miss，继续访问 Master 和 Slave。中间在任何一层命中，则回写。</p>
</li>
<li><p>对于 gets 请求，需要以 master 为准，从 master 读取。如果 master 获取失败，则从 slave获取，获取后回种到 master，然后再次从 master 获取，确保得到 cas unique id 来自 master。</p>
</li>
<li><p>对于 add/cas 等请求，首先请求 master，成功后，再将 key/value 通过 set 指令，写到 slave 和所有 L1。</p>
</li>
<li><p>对于 set 请求，最简单，直接 set 所有资源池即可。</p>
</li>
<li><p>对于 stats 指令的响应，由 Twemproxy 自己统计，或者到后端 Mc 获取后聚合获得。</p>
</li>
</ul>
<h4 id="Redis-主从访问"><a href="#Redis-主从访问" class="headerlink" title="Redis 主从访问"></a>Redis 主从访问</h4><p>Redis 支持主从复制，为了支持更大并发访问量，同时减少主库的压力，一般会部署多个从库，写操作直接请求 Redis 主库，读操作随机选择一个 Redis 从库。这个逻辑同样可以封装在Twemproxy 中。如下图所示，Redis 的主从配置信息，可以用域名的方式，也可以用 IP 端口的方式记录在配置中心，由 Twemproxy 订阅并实时更新，从而在 Redis 增减 slave、主从切换时，及时对后端进行访问变更。</p>
<p><img src="http://image.leonote.cn/20210617201322.png" alt=""></p>
<h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><p><img src="http://image.leonote.cn/20210617201351.png" alt=""></p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存的原理、引入与设计</title>
    <url>/2020/10/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%BC%95%E5%85%A5%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="缓存的原理、引入与设计"><a href="#缓存的原理、引入与设计" class="headerlink" title="缓存的原理、引入与设计"></a>缓存的原理、引入与设计</h1><h2 id="业务数据访问性能太低怎么办"><a href="#业务数据访问性能太低怎么办" class="headerlink" title="业务数据访问性能太低怎么办"></a>业务数据访问性能太低怎么办</h2><ol>
<li>缓存的基本思想</li>
<li>缓存的优点</li>
<li>缓存的代价</li>
</ol>
<h3 id="缓存的定义"><a href="#缓存的定义" class="headerlink" title="缓存的定义"></a>缓存的定义</h3><ul>
<li><p>缓存最初的含义，是指用于加速 CPU 数据交换的 RAM，即随机存取存储器，通常这种存储器使用更昂贵但快速的静态 RAM（SRAM）技术，用以对 DRAM 进行加速。这是一个狭义缓存的定义。</p>
</li>
<li><p>而广义缓存的定义则更宽泛，任何可以用于数据高速交换的存储介质都是缓存，可以是硬件也可以是软件。</p>
</li>
</ul>
<p><img src="http://image.leonote.cn//20201014195605.png" alt=""></p>
<blockquote>
<p>缓存存在的意义就是通过开辟一个新的数据交换缓冲区，来解决原始数据获取代价太大的问题，让数据得到更快的访问。目前讲的缓存主要是指广义缓存，特别是互联网产品大量使用的各种缓存组件和技术。</p>
</blockquote>
<h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><h4 id="缓存的基本思想"><a href="#缓存的基本思想" class="headerlink" title="缓存的基本思想"></a>缓存的基本思想</h4><p><img src="http://image.leonote.cn//20201014195847.png" alt=""></p>
<p>缓存构建的基本思想是利用时间局限性原理，通过空间换时间来达到加速数据获取的目的，同时由于缓存空间的成本较高，在实际设计架构中还要考虑<strong>访问延迟</strong>和<strong>成本</strong>的权衡问题。这里面有 3 个关键点。</p>
<ol>
<li><p>时间局限性原理，即被获取过一次的数据在未来会被多次引用，比如一条微博被一个人感兴趣并阅读后，它大概率还会被更多人阅读，当然如果变成热门微博后，会被数以百万/千万计算的更多用户查看。</p>
</li>
<li><p>以空间换时间，因为原始数据获取太慢，所以我们开辟一块高速独立空间，提供高效访问，来达到数据获取加速的目的。</p>
</li>
<li><p>性能成本 Tradeoff，构建系统时希望系统的访问性能越高越好，访问延迟越低小越好。但维持相同数据规模的存储及访问，性能越高延迟越小，成本也会越高，所以在系统架构设计时，你需要在系统性能和开发运行成本之间做取舍。比如左边这张图，相同成本的容量，SSD 硬盘容量会比内存大 10～30 倍以上，但读写延迟却高 50～100 倍。</p>
</li>
</ol>
<h4 id="缓存的优势"><a href="#缓存的优势" class="headerlink" title="缓存的优势"></a>缓存的优势</h4><p>缓存的优势主要有以下几点：</p>
<ul>
<li><p>提升访问性能</p>
</li>
<li><p>降低网络拥堵</p>
</li>
<li><p>减轻服务负载</p>
</li>
<li><p>增强可扩展性</p>
</li>
</ul>
<p>缓存存储原始数据，可以<strong>大幅提升访问性能</strong>。不过在实际业务场景中，缓存中存储的往往是需要频繁访问的中间数据甚至最终结果，这些数据相比 DB 中的原始数据小很多，这样就可以<strong>减少网络流量，降低网络拥堵</strong>，同时由于减少了解析和计算，调用方和存储服务的<strong>负载也可以大幅降低</strong>。缓存的读写性能很高，预热快，在数据访问存在性能瓶颈或遇到突发流量，系统读写压力大增时，<strong>可以快速部署</strong>上线，同时在流量稳定后，也可以随时下线，从而使系统的<strong>可扩展性大大增强</strong>。</p>
<h4 id="缓存的代价"><a href="#缓存的代价" class="headerlink" title="缓存的代价"></a>缓存的代价</h4><p>然而不幸的是，任何事情都有两面性，缓存也不例外，我们在享受缓存带来一系列好处的同时，也注定需要付出一定的代价。</p>
<ul>
<li><p>首先，服务系统中引入缓存，会<strong>增加系统的复杂度</strong>。</p>
</li>
<li><p>其次，由于缓存相比原始 DB 存储的<strong>成本更高</strong>，所以系统部署及运行的费用也会更高。</p>
</li>
<li><p>最后，由于一份数据同时存在缓存和 DB 中，甚至缓存内部也会有多个数据副本，多份数据就会<strong>存在一致性问题</strong>，同时缓存体系本身也会存在<strong>可用性问题和分区的问题</strong>。这就需要我们加强对缓存原理、缓存组件以及优秀缓存体系实践的理解，从系统架构之初就对缓存进行良好设计，降低缓存引入的副作用，让缓存体系成为服务系统高效稳定运行的强力基石。</p>
</li>
</ul>
<blockquote>
<p>一般来讲，服务系统的全量原始数据存储在 DB 中（如 MySQL、HBase 等），所有数据的读写都可以通过 DB 操作来获取。但 DB 读写性能低、延迟高，如 MySQL 单实例的读写 QPS 通常只有千级别（3000～6000），读写平均耗时 10～100ms 级别，如果一个用户请求需要查 20 个不同的数据来聚合，仅仅 DB 请求就需要数百毫秒甚至数秒。而 cache 的读写性能正好可以弥补 DB 的不足，比如 Memcached 的读写 QPS 可以达到 10～100万 级别，读写平均耗时在 1ms 以下，结合并发访问技术，单个请求即便查上百条数据，也可以轻松应对。</p>
<p>但 cache 容量小，只能存储部分访问频繁的热数据，同时，同一份数据可能同时存在 cache 和 DB，如果处理不当，就会出现数据不一致的问题。所以服务系统在处理业务请求时，需要对 cache 的读写方式进行适当设计，既要保证数据高效返回，又要尽量避免数据不一致等各种问题。</p>
</blockquote>
<h2 id="如何根据业务来选择缓存模式和组件"><a href="#如何根据业务来选择缓存模式和组件" class="headerlink" title="如何根据业务来选择缓存模式和组件"></a>如何根据业务来选择缓存模式和组件</h2><ol>
<li>缓存的读写模式</li>
<li>缓存的分类</li>
</ol>
<h3 id="缓存读写模式"><a href="#缓存读写模式" class="headerlink" title="缓存读写模式"></a>缓存读写模式</h3><p>如下图，业务系统读写缓存有 3 种模式：</p>
<ul>
<li><p>Cache Aside（旁路缓存）</p>
</li>
<li><p>Read/Write Through（读写穿透）</p>
</li>
<li><p>Write Behind Caching（异步缓存写入）</p>
</li>
</ul>
<p><img src="http://image.leonote.cn//20201014201011.png" alt=""></p>
<h4 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h4><p><img src="http://image.leonote.cn//20201014201115.png" alt=""></p>
<p>如上图所示，Cache Aside 模式中，业务应用方</p>
<ul>
<li>对于写，是更新 DB 后，直接将 key 从 cache 中删除，由 DB 驱动缓存数据的更新</li>
<li>对于读，是先读 cache，如果 cache miss，则读 DB，同时将数据回写到 cache</li>
</ul>
<p>这种模式的特点是，业务端处理所有数据访问细节，同时利用 Lazy 计算的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率。</p>
<p>如果没有专门的存储服务，同时是对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务，这些情况都比较适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式，这些缓存数据需要通过多个原始数据进行计算后设置。在部分数据变更后，直接删除缓存。同时，使用一个 Trigger 组件，实时读取 DB 的变更日志，然后重新计算并更新缓存。如果读缓存的时候，Trigger 还没写入 cache，则由调用方自行到 DB 加载计算并写入 cache。</p>
<blockquote>
<p>感觉直接用<code>@Cacheable</code>和<code>@CachePut</code>注解就基本达到这个效果</p>
</blockquote>
<h4 id="Read-Write-Through"><a href="#Read-Write-Through" class="headerlink" title="Read/Write Through"></a>Read/Write Through</h4><p><img src="http://image.leonote.cn//20201014202424.png" alt=""></p>
<p>如上图，对于 Cache Aside 模式，业务应用需要同时维护 cache 和 DB 两个数据存储方，过于繁琐，于是就有了 Read/Write Through 模式。</p>
<p>在这种模式下，业务应用只关注一个存储服务即可，业务方的读写 cache 和 DB 的操作，都由存储服务代理。存储服务收到业务应用的写请求时，会首先查 cache，如果数据在 cache 中不存在，则只更新 DB，如果数据在 cache 中存在，则先更新 cache，然后更新 DB。而存储服务收到读请求时，如果命中 cache 直接返回，否则先从 DB 加载，回种到 cache 后返回响应。<strong>( cache 为准)</strong></p>
<p>这种模式的特点是，存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，<strong>系统的隔离性更佳</strong>。另外，进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，<strong>内存效率更高</strong>。</p>
<p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p>
<h4 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h4><p><img src="http://image.leonote.cn//20201014203613.png" alt=""></p>
<p>Write Behind Caching 模式与 Read/Write Through 模式类似，也由数据存储服务来管理 cache 和 DB 的读写。不同点是，数据更新时，Read/write Through 是同步更新 cache 和 DB，而 <strong>Write Behind Caching 则是只更新缓存，不直接更新 DB</strong>，而是改为<strong><em>异步批量</em></strong>的方式来更新 DB。该模式的特点是，<em>数据存储的写性能最高，非常适合一些变更特别频繁的业务</em>，特别是可以合并写请求的业务，比如对一些计数业务，一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即<em>数据的一致性变差，甚至在一些极端场景下可能会丢失数据</em>。比如系统 Crash、机器宕机时，如果有数据还没保存到 DB，则会存在丢失的风险。</p>
<blockquote>
<p>📌这种读写模式适合变更频率特别高，但对一致性要求不太高的业务，这样写操作可以异步批量写入 DB，减小 DB 压力。</p>
</blockquote>
<p>三种模式各有优劣，不存在最佳模式。</p>
<p>实际上，我们也不可能设计出一个最佳的完美模式出来，如同前面讲到的空间换时间、访问延迟换低成本一样，高性能和强一致性从来都是有冲突的，系统设计从来就是取舍，随处需要 trade-off。</p>
<blockquote>
<p>重要的是思想：即如何根据业务场景，更好的做 trade-off，从而设计出更好的服务系统。</p>
</blockquote>
<h3 id="缓存分类及常用缓存介绍"><a href="#缓存分类及常用缓存介绍" class="headerlink" title="缓存分类及常用缓存介绍"></a>缓存分类及常用缓存介绍</h3><h4 id="按宿主层次分类"><a href="#按宿主层次分类" class="headerlink" title="按宿主层次分类"></a>按宿主层次分类</h4><p>分为本地 Cache、进程间 Cache 和远程 Cache。</p>
<ul>
<li><p>本地 Cache：是指业务进程内的缓存，这类缓存由于在业务系统进程内，所以读写性能超高且无任何网络开销，但不足是会随着业务系统重启而丢失。</p>
</li>
<li><p>进程间 Cache：是本机独立运行的缓存，这类缓存读写性能较高，不会随着业务系统重启丢数据，并且可以大幅减少网络开销，但不足是业务系统和缓存都在相同宿主机，运维复杂，且存在资源竞争。( cache 和 project 都在同一个 Linux 部署 )</p>
</li>
<li><p>远程 Cache：是指跨机器部署的缓存，这类缓存因为独立设备部署，容量大且易扩展，在互联网企业使用最广泛。不过远程缓存需要跨机访问，在高读写压力下，带宽容易成为瓶颈。</p>
</li>
</ul>
<p>本地 Cache 的缓存组件有 Ehcache、Guava Cache 等，开发者自己也可以用 Map、Set 等轻松构建一个自己专用的本地 Cache。</p>
<p>进程间 Cache 和远程 Cache 的缓存组件相同，只是部署位置的差异罢了，这类缓存组件有 Memcached、Redis、Pika 等。</p>
<h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><p>分为内存型缓存和持久化型缓存。</p>
<ul>
<li><p>内存型缓存将数据存储在内存，读写性能很高，但缓存系统重启或 Crash 后，内存数据会丢失。</p>
</li>
<li><p>持久化型缓存将数据存储到 SSD/Fusion-IO 硬盘中，相同成本下，这种缓存的容量会比内存型缓存大 1 个数量级以上，而且数据会持久化落地，重启不丢失，但读写性能相对低 1～2 个数量级。Memcached 是典型的内存型缓存，而 Pika 以及其他基于 RocksDB 开发的缓存组件等则属于持久化型缓存。</p>
</li>
</ul>
<h2 id="设计缓存架构时需要考量哪些因素"><a href="#设计缓存架构时需要考量哪些因素" class="headerlink" title="设计缓存架构时需要考量哪些因素"></a>设计缓存架构时需要考量哪些因素</h2><h3 id="缓存的引入及架构设计"><a href="#缓存的引入及架构设计" class="headerlink" title="缓存的引入及架构设计"></a>缓存的引入及架构设计</h3><h4 id="缓存组件选择"><a href="#缓存组件选择" class="headerlink" title="缓存组件选择"></a>缓存组件选择</h4><p>在设计架构缓存时，首先要选定缓存组件，比如要用 Local-Cache，还是 Redis、Memcached、Pika 等开源缓存组件，如果业务缓存需求比较特殊，还要考虑是直接定制开发一个新的缓存组件，还是对开源缓存进行二次开发，来满足业务需要。</p>
<h4 id="缓存数据结构设计"><a href="#缓存数据结构设计" class="headerlink" title="缓存数据结构设计"></a>缓存数据结构设计</h4><p>确定好缓存组件后，还要根据业务访问的特点，进行缓存数据结构的设计。</p>
<p>对于直接简单 KV 读写的业务，你可以将这些业务数据封装为 String、Json、Protocol Buffer 等格式，序列化成字节序列，然后直接写入缓存中。读取时，先从缓存组件获取到数据的字节序列，再进行反序列化操作即可。对于只需要存取部分字段或需要在缓存端进行计算的业务，可以把数据设计为 Hash、Set、List、Geo 等结构，存储到支持复杂集合数据类型的缓存中，如 Redis、Pika 等。</p>
<h4 id="缓存分布设计"><a href="#缓存分布设计" class="headerlink" title="缓存分布设计"></a>缓存分布设计</h4><p>确定了缓存组件，设计好了缓存数据结构，接下来就要设计缓存的分布。可以从 3 个维度来进行缓存分布设计。</p>
<ul>
<li><p>首先，要选择分布式算法，是采用<strong>取模</strong>还是<strong>一致性 Hash</strong> 进行分布。取模分布的方案简单，每个 key 只会存在确定的缓存节点，一致性 Hash 分布的方案相对复杂，一个 key 对应的缓存节点不确定。但一致性 Hash 分布，可以在部分缓存节点异常时，将失效节点的数据访问均衡分散到其他正常存活的节点，从而更好地保证了缓存系统的稳定性。</p>
</li>
<li><p>其次，分布读写访问如何进行实施，是由缓存 Client 直接进行 <strong>Hash 分布定位读写</strong>，还是通过 <strong>Proxy 代理来进行读写</strong>路由？Client 直接读写，读写性能最佳，但需要 Client 感知分布策略。在缓存部署发生在线变化时，也需要及时通知所有缓存 Client，避免读写异常，另外，Client 实现也较复杂。而通过 Proxy 路由，Client 只需直接访问 Proxy，分布逻辑及部署变更都由 Proxy 来处理，对业务应用开发最友好，但业务访问多一跳，访问性能会有一定的损失。</p>
</li>
<li><p>最后，缓存系统运行过程中，如果待缓存的数据量增长过快，会导致大量缓存数据被剔除，缓存命中率会下降，数据访问性能会随之降低，这样就需要将数据从缓存节点进行动态拆分，把部分数据水平迁移到其他缓存节点。这个迁移过程需要考虑，是由 Proxy 进行迁移还是缓存 Server 自身进行迁移，甚至根本就不支持迁移。对于 Memcached，一般不支持迁移，对 Redis，社区版本是依靠缓存 Server 进行迁移，而对 Codis 则是通过 Admin、Proxy 配合后端缓存组件进行迁移。</p>
</li>
</ul>
<h4 id="缓存架构部署及运维管理"><a href="#缓存架构部署及运维管理" class="headerlink" title="缓存架构部署及运维管理"></a>缓存架构部署及运维管理</h4><p>设计完毕缓存的分布策略后，接下来就要考虑缓存的架构部署及运维管理了。架构部署主要考虑如何对缓存进行分池、分层、分 IDC，以及是否需要进行异构处理。</p>
<ol>
<li><p>核心的、高并发访问的不同数据，需要分别分拆到独立的缓存池中，进行分别访问，避免相互影响；访问量较小、非核心的业务数据，则可以混存。</p>
</li>
<li><p>对海量数据、访问超过 10～100万 级的业务数据，要考虑分层访问，并且要分摊访问量，避免缓存过载。</p>
</li>
<li><p>如果业务系统需要多 IDC 部署甚至异地多活，则需要对缓存体系也进行多 IDC 部署，要考虑如何跨 IDC 对缓存数据进行更新，可以采用直接跨 IDC 读写，也可以采用 DataBus 配合队列机进行不同 IDC 的消息同步，然后由消息处理机进行缓存更新，还可以由各个 IDC 的 DB Trigger 进行缓存更新。</p>
</li>
<li><p>某些极端场景下，还需要把多种缓存组件进行组合使用，通过缓存异构达到最佳读写性能。</p>
</li>
<li><p>站在系统层面，要想更好得管理缓存，还要考虑缓存的服务化，考虑缓存体系如何更好得进行集群管理、监控运维等。</p>
</li>
</ol>
<h3 id="缓存设计架构的常见考量点"><a href="#缓存设计架构的常见考量点" class="headerlink" title="缓存设计架构的常见考量点"></a>缓存设计架构的常见考量点</h3><p>在缓存设计架构的过程中，有一些非常重要的考量点，如下图所示，只有分析清楚了这些考量点，才能设计架构出更佳的缓存体系。   </p>
<p><img src="http://image.leonote.cn//20201014211812.png" alt=""></p>
<h4 id="读写方式"><a href="#读写方式" class="headerlink" title="读写方式"></a>读写方式</h4><p>首先是 value 的读写方式。是全部整体读写，还是只部分读写及变更？是否需要内部计算？比如，用户粉丝数，很多普通用户的粉丝有几千到几万，而大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表肯定不能采用整体读写的方式，只能部分获取。另外在判断某用户是否关注了另外一个用户时，也不需要拉取该用户的全部关注列表，直接在关注列表上进行检查判断，然后返回 True/False 或 0/1 的方式更为高效。</p>
<h4 id="KV-size"><a href="#KV-size" class="headerlink" title="KV size"></a>KV size</h4><p>然后是不同业务数据缓存 KV 的 size。如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。但是，不同缓存数据的 KV size 如果差异过大，也不能缓存在一起，避免缓存效率的低下和相互影响。</p>
<h4 id="key-的数量"><a href="#key-的数量" class="headerlink" title="key 的数量"></a>key 的数量</h4><p>key 的数量也是一个重要考虑因素。如果 key 数量不大，可以在缓存中存下全量数据，把缓存当 DB 存储来用，如果缓存读取 miss，则表明数据不存在，根本不需要再去 DB 查询。如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p>
<h4 id="读写峰值"><a href="#读写峰值" class="headerlink" title="读写峰值"></a>读写峰值</h4><p>另外，对缓存数据的读写峰值，如果小于 10万 级别，简单分拆到独立 Cache 池即可。而一旦数据的读写峰值超过 10万 甚至到达 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。微博业务中，大多数核心业务的 Memcached 访问都采用的这种处理方式。</p>
<h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><p>缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache，常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p>
<h4 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h4><ul>
<li><p>可以设置较短的过期时间，让冷 key 自动过期；</p>
</li>
<li><p>也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 <code>key:key_20190801</code>。</p>
</li>
</ul>
<h4 id="平均缓存穿透加载时间"><a href="#平均缓存穿透加载时间" class="headerlink" title="平均缓存穿透加载时间"></a>平均缓存穿透加载时间</h4><p>平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p>
<h4 id="缓存可运维性"><a href="#缓存可运维性" class="headerlink" title="缓存可运维性"></a>缓存可运维性</h4><p>对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p>
<h4 id="缓存安全性"><a href="#缓存安全性" class="headerlink" title="缓存安全性"></a>缓存安全性</h4><p>对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时对于一些关键性指令，需要增加访问权限，避免被攻击或误操作时，导致重大后果。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存访问相关的经典问题</title>
    <url>/2021/02/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="缓存访问相关的经典问题"><a href="#缓存访问相关的经典问题" class="headerlink" title="缓存访问相关的经典问题"></a>缓存访问相关的经典问题</h1><p>实际上，在缓存系统的设计架构中，还有很多坑，很多的明枪暗箭，如果设计不当会导致很多严重的后果。</p>
<p>设计不当：</p>
<ul>
<li>轻则请求变慢、性能降低</li>
<li>重则会数据不一致、系统可用性降低，甚至会导致缓存雪崩，整个系统无法对外提供服务</li>
</ul>
<p>缓存七大经典问题，如图所示：</p>
<p> <img src="http://image.leonote.cn//20210206170529.jpg" alt=""></p>
<h2 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h2><p><strong>问题描述</strong></p>
<p>缓存第一个经典问题是缓存失效。</p>
<p>服务系统查数据，首先会查缓存，如果缓存数据不存在，就进一步查 DB，最后查到数据后回种到缓存并返回。缓存的性能比 DB 高 50<del>100 倍以上，所以我们希望数据查询尽可能命中缓存，这样系统负荷最小，性能最佳。缓存里的数据存储基本上都是以 key 为索引进行存储和获取的。业务访问时，如果大量的 key 同时过期，很多缓存数据访问都会 miss，进而穿透到 DB，DB 的压力就会明显上升，由于 DB 的性能较差，只在缓存的 1%</del>2% 以下，这样请求的<strong>慢查率</strong>会明显上升。这就是缓存失效的问题。</p>
<p><strong>原因分析</strong></p>
<p>导致缓存失效，特别是很多 key 一起失效的原因，跟我们日常写<strong>缓存的过期时间</strong>息息相关。</p>
<p>在写缓存时，我们一般会根据业务的访问特点，给<strong>每种业务数据预置一个过期时间</strong>，在写缓存时把这个过期时间带上，让缓存数据在这个固定的过期时间后被淘汰。一般情况下，因为缓存数据是逐步写入的，所以也是逐步过期被淘汰的。但在某些场景，一大批数据会被系统主动或被动从 DB 批量加载，然后写入缓存。这些数据写入缓存时，由于使用相同的过期时间，在经历这个过期时间之后，这批数据就会一起到期，从而被缓存淘汰。此时，对这批数据的所有请求，都会出现缓存失效，从而都穿透到 DB，DB 由于查询量太大，就很容易压力大增，请求变慢。</p>
<p><strong>业务场景</strong></p>
<p>很多业务场景，稍不注意，就出现大量的缓存失效，进而导致系统 DB 压力大、请求变慢的情况。比如同一批火车票、飞机票，当可以售卖时，系统会一次性加载到缓存，如果缓存写入时，过期时间按照预先设置的过期值，那过期时间到期后，系统就会因缓存失效出现变慢的问题。类似的业务场景还有很多，比如微博业务，会有后台离线系统，持续计算热门微博，每当计算结束，会将这批热门微博批量写入对应的缓存。还比如，很多业务，在部署新 IDC 或新业务上线时，会进行<strong>缓存预热</strong>，也会一次性加载大批热数据。</p>
<p><strong>解决方案</strong></p>
<p>对于批量 key 缓存失效的问题，原因既然是预置的固定过期时间，那解决方案也从这里入手。设计缓存的过期时间时，使用公式：<code>过期时间=base 时间+随机时间</code>。即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210206172610.jpg" alt=""></p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><strong>问题描述</strong></p>
<p>第二个经典问题是缓存穿透。</p>
<p>缓存穿透是一个很有意思的问题。因为缓存穿透发生的概率很低，所以一般很难被发现。但是，一旦你发现了，而且量还不小，你可能立即就会经历一个忙碌的夜晚。因为对于正常访问，访问的数据即便不在缓存，也可以通过 DB 加载回种到缓存。而缓存穿透，则意味着<strong>有特殊访客在查询一个不存在的 key，导致每次查询都会穿透到 DB，如果这个特殊访客再控制一批肉鸡机器，持续访问你系统里不存在的 key，就会对 DB 产生很大的压力，从而影响正常服务。</strong></p>
<p><strong>原因分析</strong></p>
<p>缓存穿透存在的原因，就是因为我们在系统设计时，更多考虑的是<strong>正常访问路径</strong>，对<strong>特殊访问路径</strong>、<strong>异常访问路径</strong>考虑相对欠缺。</p>
<p>缓存访问设计的正常路径，是先访问 cache，cache miss 后查 DB，DB 查询到结果后，回种缓存返回。这对于正常的 key 访问是没有问题的，但是如果用户访问的是一个不存在的 key，查 DB 返回空（即一个 NULL），那就不会把这个空写回cache。那以后不管查询多少次这个不存在的 key，都会 cache miss，都会查询 DB。整个系统就会退化成一个“前端+DB“的系统，由于 DB 的吞吐只在 cache 的 1%~2% 以下，如果有特殊访客，大量访问这些不存在的 key，就会导致系统的性能严重退化，影响正常用户的访问。</p>
<p><strong>业务场景</strong></p>
<p>缓存穿透的业务场景很多，比如通过不存在的 UID 访问用户，通过不存在的车次 ID 查看购票信息。用户输入错误，偶尔几个这种请求问题不大，但如果是大量这种请求，就会对系统影响非常大。</p>
<p><strong>解决方案</strong></p>
<p>那么如何解决这种问题呢？如下图所示。</p>
<p>第一种方案就是，查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值。</p>
<p>第二种方案是，构建一个 <code>BloomFilter</code> 缓存过滤器，记录全量数据，这样访问数据时，可以直接通过 <code>BloomFilter</code> 判断这个 key 是否存在，如果不存在直接返回即可，根本无需查缓存和 DB。</p>
<p><img src="http://image.leonote.cn//20210206173352.jpg" alt=""></p>
<p>不过这两种方案在设计时仍然有一些要注意的坑。</p>
<p>对于方案一，如果特殊访客持续访问大量的不存在的 key，这些 key 即便只存一个简单的默认值，也会占用大量的缓存空间，导致正常 key 的命中率下降。所以进一步的改进措施是，<strong>对这些不存在的 key 只存较短的时间，让它们尽快过期</strong>；或者<strong>将这些不存在的 key 存在一个独立的公共缓存</strong>，从缓存查找时，先查正常的缓存组件，如果 miss，则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存。</p>
<p>对于方案二，<code>BloomFilter</code> 要缓存全量的 key，这就要求<strong>全量的 key 数量不大，10亿 条数据以内最佳</strong>，因为 10亿 条数据大概要占用 1.2GB 的内存。也可以用 <code>BloomFilter</code> 缓存非法 key，每次发现一个 key 是不存在的非法 key，就记录到 BloomFilter 中，这种记录方案，会导致 <code>BloomFilter</code> 存储的 key 持续高速增长，为了避免记录 key 太多而导致误判率增大，需要定期清零处理。</p>
<p><strong>BloomFilter</strong></p>
<p><code>BloomFilter</code> 是一个非常有意思的数据结构，不仅仅可以挡住非法 key 攻击，还可以低成本、高性能地对海量数据进行判断，比如一个系统有数亿用户和百亿级新闻 feed，就可以用 <code>BloomFilter</code> 来判断某个用户是否阅读某条新闻 feed。下面来对 <code>BloomFilter</code> 数据结构做一个分析，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210206174015.jpg" alt=""></p>
<p><code>BloomFilter</code> 的目的是检测一个元素是否存在于一个集合内。它的原理，是用 bit 数据组来表示一个集合，对一个 key 进行多次不同的 Hash 检测，如果所有 Hash 对应的 bit 位都是 1，则表明 key 非常大概率存在，<strong>平均单记录占用 1.2 字节即可达到 99%</strong>，只要有一次 Hash 对应的 bit 位是 0，就说明这个 key 肯定不存在于这个集合内。</p>
<p><code>BloomFilter</code> 的算法是，首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0，加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。检测 key 时，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。</p>
<p><code>BloomFilter</code> 的优势是，全内存操作，性能很高。另外空间效率非常高，要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1/10，即平均单条记录占用 1.8 字节，误判率可以达到 1/1000；平均单条记录占用 2.4 字节，误判率可以到 1/10000，以此类推。这里的误判率是指，<code>BloomFilter</code> 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 <code>BloomFilter</code> 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>问题描述</strong></p>
<p>第三个经典问题是缓存雪崩。</p>
<p>系统运行过程中，缓存雪崩是一个非常严重的问题。缓存雪崩是指部分缓存节点不可用，导致整个缓存体系甚至甚至服务系统不可用的情况。</p>
<p>缓存雪崩按照缓存是否 rehash（即是否漂移）分两种情况：</p>
<ul>
<li><p>缓存不支持 rehash 导致的系统雪崩不可用</p>
</li>
<li><p>缓存支持 rehash 导致的缓存雪崩不可用</p>
</li>
</ul>
<p><strong>原因分析</strong></p>
<p>在上述两种情况中，缓存不进行 rehash 时产生的雪崩，一般是由于较多缓存节点不可用，请求穿透导致 DB 也过载不可用，最终整个系统雪崩不可用的。而缓存支持 rehash 时产生的雪崩，则大多跟流量洪峰有关，流量洪峰到达，引发部分缓存节点过载 Crash，然后因 rehash 扩散到其他缓存节点，最终整个缓存体系异常。</p>
<p>第一种情况比较容易理解，缓存节点不支持 rehash，较多缓存节点不可用时，大量 Cache 访问会失败，根据缓存读写模型，这些请求会进一步访问 DB，而且 DB 可承载的访问量要远比缓存小的多，请求量过大，就很容易造成 DB 过载，大量慢查询，最终阻塞甚至 Crash，从而导致服务异常。</p>
<p>第二种情况是怎么回事呢？这是因为缓存分布设计时，很多同学会选择一致性 Hash 分布方式，同时在部分节点异常时，采用 rehash 策略，即把异常节点请求平均分散到其他缓存节点。在一般情况下，一致性 Hash 分布+rehash 策略可以很好得运行，但在较大的流量洪峰到临之时，如果大流量 key 比较集中，正好在某 1～2 个缓存节点，很容易将这些缓存节点的内存、网卡过载，缓存节点异常 Crash，然后这些异常节点下线，这些大流量 key 请求又被 rehash 到其他缓存节点，进而导致其他缓存节点也被过载 Crash，缓存异常持续扩散，最终导致整个缓存体系异常，无法对外提供服务。</p>
<p><strong>业务场景</strong></p>
<p>缓存雪崩的业务场景并不少见，微博、Twitter 等系统在运行的最初若干年都遇到过很多次。比如，微博最初很多业务缓存采用一致性 Hash+rehash 策略，在突发洪水流量来临时，部分缓存节点过载 Crash 甚至宕机，然后这些异常节点的请求转到其他缓存节点，又导致其他缓存节点过载异常，最终整个缓存池过载。另外，机架断电，导致业务缓存多个节点宕机，大量请求直接打到 DB，也导致 DB 过载而阻塞，整个系统异常。最后缓存机器复电后，DB 重启，数据逐步加热后，系统才逐步恢复正常。</p>
<p><strong>解决方案</strong></p>
<p>预防缓存雪崩，这里给出 3 个解决方案。</p>
<ul>
<li>方案一，对业务 DB 的访问增加读写开关，当发现 DB 请求变慢、阻塞，<strong>慢请求</strong>超过阀值时，就会关闭读开关，部分或所有读 DB 的请求进行 failfast 立即返回，待 DB 恢复后再打开读开关，如下图所示：</li>
</ul>
<p><img src="http://image.leonote.cn//20210206180631.jpg" alt=""></p>
<ul>
<li>方案二，对缓存增加多个副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机架，从而确保在任何情况下，缓存系统都会正常对外提供服务。</li>
</ul>
<ul>
<li>方案三，对缓存体系进行实时监控，当请求访问的<strong>慢速比</strong>超过阀值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通过各种自动故障转移策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。</li>
</ul>
<p>实际上，微博平台系统，这三种方案都采用了，通过三管齐下，规避缓存雪崩的发生。</p>
<h2 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h2><p><strong>问题描述</strong></p>
<p>七大缓存经典问题的第四个问题是数据不一致。</p>
<p>同一份数据，可能会同时存在 DB 和缓存之中。那就有可能发生，DB 和缓存的数据不一致。如果缓存有多个副本，多个缓存副本里的数据也可能会发生不一致现象。</p>
<p><strong>原因分析</strong></p>
<p>不一致的问题大多跟缓存更新异常有关。比如更新 DB 后，写缓存失败，从而导致缓存中存的是老数据。另外，如果系统采用一致性 Hash 分布，同时采用 rehash 自动漂移策略，在节点多次上下线之后，也会产生脏数据。缓存有多个副本时，更新某个副本失败，也会导致这个副本的数据是老数据。</p>
<p><strong>业务场景</strong></p>
<p>导致数据不一致的场景也不少。如下图所示，在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p>
<p><img src="http://image.leonote.cn//20210206191204.jpg" alt=""></p>
<p><strong>解决方案</strong></p>
<p>要尽量保证数据的一致性。这里也给出了 3 个方案，可以根据实际情况进行选择。</p>
<ul>
<li><p>第一个方案，cache 更新失败后，可以进行重试，如果重试失败，则将失败的 key 写入队列机服务，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性。</p>
</li>
<li><p>第二个方案，缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</p>
</li>
<li><p>第三个方案，不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</p>
</li>
</ul>
<h2 id="数据并发竞争"><a href="#数据并发竞争" class="headerlink" title="数据并发竞争"></a>数据并发竞争</h2><p><strong>问题描述</strong></p>
<p>第五个经典问题是数据并发竞争。</p>
<p>互联网系统，线上流量较大，缓存访问中很容易出现数据并发竞争的现象。数据并发竞争，是指在高并发访问场景，一旦缓存访问没有找到数据，大量请求就会并发查询 DB，导致 DB 压力大增的现象。</p>
<p>数据并发竞争，主要是由于多个进程/线程中，有<strong>大量并发请求获取相同的数据</strong>，而这个数据 key 因为正好过期、被剔除等各种原因在缓存中不存在，这些进程/线程之间没有任何协调，然后一起并发查询 DB，请求那个相同的 key，最终导致 DB 压力大增，如下图。</p>
<p><img src="http://image.leonote.cn//20210206191523.jpg" alt=""></p>
<p><strong>业务场景</strong></p>
<p>数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成该车次信息、该条微博存在并发竞争读取的问题。</p>
<p><strong>解决方案</strong></p>
<p>要解决并发竞争，有 2 种方案。</p>
<ul>
<li><p>方案一是使用<strong>全局锁</strong>。如下图所示，即当缓存请求 miss 后，先尝试加全局锁，只有加全局锁成功的线程，才可以到 DB 去加载数据。其他进程/线程在读取缓存数据 miss 时，如果发现这个 key 有全局锁，就进行等待，待之前的线程将数据从 DB 回种到缓存后，再从缓存获取。</p>
<p><img src="http://image.leonote.cn//20210206191657.jpg" alt=""></p>
</li>
<li><p>方案二是，对缓存数据保持多个备份，即便其中一个备份中的数据过期或被剔除了，还可以访问其他备份，从而减少数据并发竞争的情况，如下图。</p>
<p><img src="http://image.leonote.cn//20210206191829.jpg" alt=""></p>
</li>
</ul>
<h2 id="Hot-key"><a href="#Hot-key" class="headerlink" title="Hot key"></a>Hot key</h2><p><strong>问题描述</strong></p>
<p>第六个经典问题是 Hot key。</p>
<p>对于大多数互联网系统，数据是分冷热的。比如最近的新闻、新发表的微博被访问的频率最高，而比较久远的之前的新闻、微博被访问的频率就会小很多。而在突发事件发生时，大量用户同时去访问这个突发热点信息，访问这个 Hot key，这个突发热点信息所在的缓存节点就很容易出现过载和卡顿现象，甚至会被 Crash。</p>
<p><strong>原因分析</strong></p>
<p>Hot key 引发缓存系统异常，主要是因为突发热门事件发生时，超大量的请求访问热点事件对应的 key，比如微博中数十万、数百万的用户同时去吃一个新瓜。数十万的访问请求同一个 key，流量集中打在一个缓存节点机器，这个缓存机器很容易被打到物理网卡、带宽、CPU 的极限，从而导致缓存访问变慢、卡顿。</p>
<p><strong>业务场景</strong></p>
<p>引发 Hot key 的业务场景很多，比如明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p>
<p><strong>解决方案</strong></p>
<p>要解决这种极热 key 的问题，首先要找出这些 Hot key 来。对于重要节假日、线上促销活动、集中推送这些<strong>提前已知的事情，可以提前评估出可能的热 key 来</strong>。而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析，及时发现新发布的热点 key</strong>。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以<strong>通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key</strong>。</p>
<p>找到热 key 后，就有很多解决办法了。首先可以将这些热 key 进行分散处理，比如一个热 key 名字叫 hotkey，可以被分散为 hotkey#1、hotkey#2、hotkey#3，……hotkey#n，这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210206193555.jpg" alt=""></p>
<p>其次，也可以 key 的名字不变，对缓存提前进行多副本+多级结合的缓存架构设计。</p>
<p>再次，如果热 key 较多，还可以通过监控体系对缓存的 SLA 实时监控，通过快速扩容来减少热 key 的冲击。</p>
<p>最后，业务端还可以使用本地缓存，将这些热 key 记录在本地缓存，来减少对远程缓存的冲击。</p>
<h2 id="Big-key"><a href="#Big-key" class="headerlink" title="Big key"></a>Big key</h2><p><strong>问题描述</strong></p>
<p>最后一个经典问题是 Big key，也就是大 Key 的问题。大 key，是指在缓存访问时，<strong>部分 Key 的 Value 过大，读写、加载易超时的现象</strong>。</p>
<p><strong>原因分析</strong></p>
<p>造成这些大 key 慢查询的原因很多。如果这些大 key 占总体数据的比例很小，存 Mc，对应的 slab 较少，导致很容易被频繁剔除，DB 反复加载，从而导致查询较慢。如果业务中这种大 key 很多，而这种 key 被大量访问，缓存组件的网卡、带宽很容易被打满，也会导致较多的大 key 慢查询。另外，如果大 key 缓存的字段较多，每个字段的变更都会引发对这个缓存数据的变更，同时这些 key 也会被频繁地读取，读写相互影响，也会导致慢查现象。最后，大 key 一旦被缓存淘汰，DB 加载可能需要花费很多时间，这也会导致大 key 查询慢的问题。</p>
<p><strong>业务场景</strong></p>
<p>大 key 的业务场景也比较常见。比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key，如下图。</p>
<p><img src="http://image.leonote.cn//20210206194147.jpg" alt=""></p>
<p><strong>解决方案</strong></p>
<p>对于大 key，给出 3 种解决方案。</p>
<ul>
<li>第一种方案，如果数据存在 Mc 中，可以设计一个缓存阀值，当 value 的长度超过阀值，则对内容启用压缩，让 KV 尽量保持小的 size，其次评估大 key 所占的比例，在 Mc 启动之初，就立即预写足够数据的大 key，让 Mc 预先分配足够多的 trunk size 较大的 slab。确保后面系统运行时，大 key 有足够的空间来进行缓存。       </li>
</ul>
<p>  <img src="http://image.leonote.cn//20210206194550.jpg" alt=""></p>
<ul>
<li><p>第二种方案，如果数据存在 Redis 中，比如业务数据存 set 格式，大 key 对应的 set 结构有几千几万个元素，这种写入 Redis 时会消耗很长的时间，导致 Redis 卡顿。此时，可以扩展新的数据结构，同时让 client 在这些大 key 写缓存之前，进行序列化构建，然后通过 restore 一次性写入，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210206194719.jpg" alt=""></p>
</li>
<li><p>第三种方案时，如下图所示，将大 key 分拆为多个 key，尽量减少大 key 的存在。同时由于大 key 一旦穿透到 DB，加载耗时很大，所以可以对这些大 key 进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰 key 时，同等条件下，尽量不淘汰这些大 key。</p>
<p><img src="http://image.leonote.cn//20210206194824.jpg" alt=""></p>
</li>
</ul>
<blockquote>
<p>对于互联网系统，由于实际业务场景复杂，数据量、访问量巨大，需要提前规避缓存使用中的各种坑。可以通过提前熟悉 Cache 的经典问题，提前构建防御措施， 避免大量 key 同时失效，避免不存在 key 访问的穿透，减少大 key、热 key 的缓存失效，对热 key 进行分流。可以采取一系列措施，让访问尽量命中缓存，同时保持数据的一致性。另外，还可以结合业务模型，提前规划 cache 系统的 SLA，如 QPS、响应分布、平均耗时等，实施监控，以方便运维及时应对。在遇到部分节点异常，或者遇到突发流量、极端事件时，也能通过分池分层策略、key 分拆等策略，避免故障发生。</p>
</blockquote>
<p>最终，你能在各种复杂场景下，面对高并发、海量访问，面对突发事件和洪峰流量，面对各种网络或机器硬件故障，都能保持服务的高性能和高可用。</p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>同源策略</title>
    <url>/2020/05/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<blockquote>
<p>【转载】</p>
<p>作者：laixiangran</p>
<p>链接：<a href="https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad">https://juejin.im/post/5ba1d4fe6fb9a05ce873d4ad</a></p>
</blockquote>
<h2 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="headerlink" title="什么是浏览器同源策略"></a>什么是浏览器同源策略</h2><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p>
<p>所谓同源是指：域名、协议、端口相同。</p>
<p>下表是相对于 <code>http://www.laixiangran.cn/home/index.html</code> 的同源检测结果：</p>
<table>
<thead>
<tr>
<th align="center">URL</th>
<th align="center">结果</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="http://www.laixiangran.cn/home/index.html">http://www.laixiangran.cn/home/index.html</a></td>
<td align="center">成功</td>
<td align="center">域名、协议、端口均不同</td>
</tr>
<tr>
<td align="center"><a href="https://www.laixiangran.cn/home/index.html">https://www.laixiangran.cn/home/index.html</a></td>
<td align="center">失败</td>
<td align="center">协议不同</td>
</tr>
<tr>
<td align="center"><a href="http://www.laixiangran.cn:8080/home/index.html">http://www.laixiangran.cn:8080/home/index.html</a></td>
<td align="center">失败</td>
<td align="center">端口不同</td>
</tr>
<tr>
<td align="center"><a href="http://www.laixiangran.cn/other/index.html">http://www.laixiangran.cn/other/index.html</a></td>
<td align="center">失败</td>
<td align="center">域名不同</td>
</tr>
</tbody></table>
<p>另外，同源策略又分为以下两种：</p>
<ol>
<li>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li>
<li>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li>
</ol>
<h2 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h2><p>因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。</p>
<p>如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：</p>
<p><strong>如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：</strong></p>
<ol>
<li>做一个假网站，里面用 iframe 嵌套一个银行网站 <code>http://mybank.com</code>。</li>
<li>把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>
<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到 <code>http://mybank.com</code> 的 dom 节点，就可以拿到用户的账户密码了。</li>
</ol>
<p><strong>如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</strong></p>
<ol>
<li>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code> 向用户的 cookie 中添加用户标识。</li>
<li>用户浏览了恶意页面 <code>http://evil.com</code>，执行了页面中的恶意 AJAX 请求代码。</li>
<li><code>http://evil.com</code> 向 <code>http://mybank.com</code> 发起 AJAX HTTP 请求，请求会默认把 <code>http://mybank.com</code> 对应 cookie 也同时发送过去。</li>
<li>银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。</li>
<li>而且由于 Ajax 在后台执行，用户无法感知这一过程。</li>
</ol>
<p>因此，有了浏览器同源策略，我们才能更安全的上网。</p>
<h2 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h2><p>从上面我们了解到了浏览器同源策略的作用，也正是有了跨域限制，才使我们能安全的上网。但是在实际中，有时候我们需要突破这样的限制，因此下面将介绍几种跨域的解决方法。</p>
<h3 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h3><p>CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于<strong>简单请求</strong>。</p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol>
<li>HTTP的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ol>
<li>在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：<code>Origin: http://www.laixiangran.cn</code></li>
<li>如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：<code>Access-Control-Allow-Origin：http://www.laixiangran.cn</code></li>
<li>没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。</li>
<li>如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 <code>Access-Control-Allow-Credentials: true</code>。</li>
</ol>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</p>
<ul>
<li>Origin：与简单的请求相同。</li>
<li>Access-Control-Request-Method: 请求自身使用的方法。</li>
<li>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</li>
</ul>
<p>例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Origin</span>: <span class="string">http://www.laixiangran.cn</span></span><br><span class="line"><span class="meta">Access-Control-Request-Method</span>: <span class="string">POST</span></span><br><span class="line"><span class="meta">Access-Control-Request-Headers</span>: <span class="string">NCZ</span></span><br></pre></td></tr></table></figure>

<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。</li>
<li>Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。</li>
<li>Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。</li>
<li>Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。</li>
</ul>
<p>例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">Access-Control-Allow-Origin</span>: <span class="string">http://www.laixiangran.cn</span></span><br><span class="line"><span class="meta">Access-Control-Allow-Methods</span>: <span class="string">GET, POST</span></span><br><span class="line"><span class="meta">Access-Control-Allow-Headers</span>: <span class="string">NCZ</span></span><br><span class="line"><span class="meta">Access-Control-Max-Age</span>: <span class="string">1728000</span></span><br></pre></td></tr></table></figure>

<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p>由于 <code>script</code> 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</p>
<p>直接通过下面的例子来说明 JSONP 实现跨域的流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.gerElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.src = <span class="string">&#x27;http://www.laixiangran.cn/json?callback=handleResponse&#x27;</span>;</span><br><span class="line">body.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，</span></span><br><span class="line"><span class="comment">// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器</span></span><br><span class="line"><span class="comment">// 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</span></span><br></pre></td></tr></table></figure>

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</li>
</ul>
<h3 id="图像-Ping-跨域"><a href="#图像-Ping-跨域" class="headerlink" title="图像 Ping 跨域"></a>图像 Ping 跨域</h3><p>由于 <code>img</code> 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。</p>
<p>直接通过下面的例子来说明图像 Ping 实现跨域的流程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本</span></span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求数据通过查询字符串形式发送</span></span><br><span class="line">img.src = <span class="string">&#x27;http://www.laixiangran.cn/test?name=laixiangran&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
<h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所有域的资源再返回给客户端。</p>
<p>服务器代理是万能的。</p>
<h3 id="document-domain-跨域"><a href="#document-domain-跨域" class="headerlink" title="document.domain 跨域"></a>document.domain 跨域</h3><p>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。</p>
<p>比如，有一个页面，它的地址是 <code>http://www.laixiangran.cn/a.html</code>，在这个页面里面有一个 iframe，它的 src 是 <code>http://laixiangran.cn/b.html</code>。很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。</p>
<p>这个时候，document.domain 就可以派上用场了，我们只要把 <code>http://www.laixiangran.cn/a.html</code> 和 <code>http://laixiangran.cn/b.html</code> 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.laixiangran.cn</code> 中某个文档的 document.domain 可以设成 <code>a.b.laixiangran.cn</code>、<code>b.laixiangran.cn</code> 、<code>laixiangran.cn</code> 中的任意一个，但是不可以设成 <code>c.a.b.laixiangran.cn</code> ，因为这是当前域的子域，也不可以设成 <code>baidu.com</code>，因为主域已经不相同了。</p>
<p>例如，在页面 <code>http://www.laixiangran.cn/a.html</code> 中设置document.domain：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;laixiangran.cn&#x27;</span>; <span class="comment">// 设置成主域</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIframe&#x27;</span>).contentWindow);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在页面 <code>http://laixiangran.cn/b.html</code> 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 <code>laixiangran.cn</code>，但是还是必须显式地设置 document.domain 的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;laixiangran.cn&#x27;</span>; <span class="comment">// document.domain 设置成与主页面相同</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，<code>http://www.laixiangran.cn/a.html</code> 就可以通过 js 访问到 <code>http://laixiangran.cn/b.html</code> 中的各种属性和对象了。</p>
<h3 id="window-name-跨域"><a href="#window-name-跨域" class="headerlink" title="window.name 跨域"></a><a href="http://window.name">window.name</a> 跨域</h3><p>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限，<code>window.name</code> 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<p>通过下面的例子介绍如何通过 <a href="http://window.name">window.name</a> 来跨域获取数据的。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIframe&#x27;</span>);</span></span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 重置 iframe 的 onload 事件程序，</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 此时经过后面代码重置 src 之后，</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// http://www.laixiangran.cn/a.html 页面与该 iframe 在同一个源了，可以相互访问了</span></span></span><br><span class="line"><span class="javascript">        iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> data = iframe.contentWindow.name; <span class="comment">// 4. 获取 iframe 里的 window.name</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data); <span class="comment">// hello world!</span></span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line"><span class="javascript">        <span class="comment">// 3. 重置一个与 http://www.laixiangran.cn/a.html 页面同源的页面</span></span></span><br><span class="line"><span class="javascript">        iframe.src = <span class="string">&#x27;http://www.laixiangran.cn/c.html&#x27;</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1. 给当前的 window.name 设置一个 http://www.laixiangran.cn/a.html 页面想要得到的数据值 </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">&quot;hello world!&quot;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="location-hash-跨域"><a href="#location-hash-跨域" class="headerlink" title="location.hash 跨域"></a>location.hash 跨域</h3><p>location.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3. 获取通过 http://laixiangran.cn/b.html 页面设置 hash 值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">window</span>.location.hash;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1. 设置父页面的 hash 值</span></span></span><br><span class="line"><span class="javascript">    parent.location.hash = <span class="string">&quot;world&quot;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="postMessage-跨域"><a href="#postMessage-跨域" class="headerlink" title="postMessage 跨域"></a>postMessage 跨域</h3><p>window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。</p>
<p>调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。</p>
<p>需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://laixiangran.cn/b.html&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myIframe&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;test()&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象，</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myIframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> win = iframe.contentWindow;</span></span><br><span class="line"><span class="javascript">        win.postMessage(<span class="string">&#x27;我是来自 http://www.laixiangran.cn/a.html 页面的消息&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 注册 message 事件用来接收消息</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        e = e || event; <span class="comment">// 获取事件对象</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data); <span class="comment">// 通过 data 属性得到发送来的消息</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>同源策略</category>
      </categories>
      <tags>
        <tag>同源策略</tag>
        <tag>浏览器</tag>
        <tag>CORF</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-Memcached进阶</title>
    <url>/2021/02/08/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-Memcached%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="Memcached进阶"><a href="#Memcached进阶" class="headerlink" title="Memcached进阶"></a>Memcached进阶</h1><h2 id="Memcached-是怎么定位key的"><a href="#Memcached-是怎么定位key的" class="headerlink" title="Memcached 是怎么定位key的"></a>Memcached 是怎么定位key的</h2><h3 id="key-定位"><a href="#key-定位" class="headerlink" title="key 定位"></a>key 定位</h3><p><strong>哈希表</strong></p>
<p>Mc 将数据存储在 Item 中，然后这些 Item 会被 slabclass 的 4 个 LRU 管理。这些 LRU 都是通过双向链表实现数据记录的。双向链表在进行增加、删除、修改位置时都非常高效，但其获取定位 key 的性能非常低下，只能通过链表遍历来实现。因此，Mc 还通过 Hashtable，也就是哈希表，来记录管理这些 Item，通过对 key 进行哈希计算，从而快速定位和读取这些 key/value 所在的 Item，如下图所示。</p>
<p><img src="http://image.leonote.cn//20210220163845.jpg" alt=""></p>
<p>哈希表也称散列表，可以通过把 key 映射到哈希表中的一个位置来快速访问记录，定位 key 的时间复杂度只有 O(1)。Mc 的哈希表实际是一个一维指针数组，数组的每个位置称作一个 bucket，即一个桶。性能考虑的需要，Mc 的哈希表的长度设置为 2 的 N 次方。Mc 启动时，默认会构建一个拥有 6.4万 个桶的哈希表，随着新 key 的不断插入，哈希表中的元素超过阀值后，会对哈希表进行扩容，最大可以构建 2 的 32 次方个桶的哈希表，也就是说 Mc 哈希表经过多次扩容后，最多只能有不超过 43亿 个桶。</p>
<p><strong>哈希表设计</strong></p>
<p>对于哈希表设计，有 2 个关键点，一个是哈希算法，一个是哈希冲突解决方案。Mc 使用的哈希算法有 2 种，分别是 Murmur3 Hash 和 Jenkins Hash。Mc 当前版本，默认使用 Murmur3 Hash 算法。不同的 key 通过 Hash 计算，被定位到了相同的桶，这就是哈希冲突。Mc 是通过对每个桶启用一个单向链表，来解决哈希冲突问题的。</p>
<p><strong>定位 key</strong></p>
<p>Memcached 定位 key 时，首先根据 key 采用 Murmur3 或者 Jenkins 算法进行哈希计算，得到一个 32 位的无符号整型输出，存储到变量 hv 中。因为哈希表一般没有 2^32 那么大，所以需要将 key 的哈希值映射到哈希表的范围内。Mc 采用最简单的取模算法作为映射函数，即采用 hv%hashsize 进行计算。由于普通的取模运算比较耗时，所以 Mc 将哈希表的长度设置为 2 的 n 次方，采用位运算进行优化，即采用 hv&amp;hashmask 来计算。hashmask 即 2 的 n 次方 减 1。</p>
<p>定位到 key 所在的桶的位置后，如果是插入一个新数据，则将数据 Item 采用头部插入法插入桶的单向链表中。如果是查找，则轮询对应哈希桶中的那个单向链表，依次比对 key 字符串，key 相同则找到数据 Item。</p>
<p><img src="http://image.leonote.cn//20210220164215.jpg" alt=""></p>
<p>如果哈希表桶中元素太多，这个链表轮询耗时会比较长，所以在哈希表中元素达到桶数的 1.5 倍之后，Mc 会对哈希表进行 2 倍扩容。由于哈希表最多只有 43 亿左右个桶，所以性能考虑，单个 Mc 节点最多存储 65亿 个 key/value。如果要存更多 key，则需要修改 Mc 源码，将最大哈希，即 HASHPOWER_MAX， 进行调大设置。</p>
<p><strong>哈希表扩容</strong></p>
<p>当 Mc 的哈希表中，Item 数量大于 1.5 倍的哈希桶数量后，Mc 就对哈希表进行扩容处理。如下图所示，Mc 的哈希扩容是通过哈希维护线程进行处理的。准备开始扩容时，哈希维护线程会首先将所有 IO 工作线程和辅助线程进行暂停，其中辅助线程包括 LRU 维护线程、slab 维护线程、LRU 爬虫线程。待这些线程暂停后，哈希维护线程会将当前的主哈希表设为旧哈希表，然后将新的主哈希表扩容之前的 2 倍容量。然后，工作线程及辅助线程继续工作，同时哈希维护线程开始逐步将 Item 元素从旧哈希表迁移到主哈希表。</p>
<p><img src="http://image.leonote.cn//20210220171554.jpg" alt=""></p>
<p>Mc 在启动时，会根据设置的工作线程数，来构建 一个 Item 锁哈希表，线程越多，构建的锁哈希表越大，对于 4 个线程，锁哈希表有 4096 个桶，对于 10 个线程，锁哈希表会有 8192 个桶，Item 锁哈希表最多有 32k 个桶，1k 是 1024，即最多即 32768 个桶。Mc 的锁哈希表中，每个桶对应一个 Item 锁，所以 Mc 最多只有 32768 个 Item 锁。</p>
<p>Mc 哈希表在读取、变更以及扩容迁移过程中，先将 key hash 定位到 Item 锁哈希表的锁桶，然后对 Item 锁进行加锁，然后再进行实际操作。实际上，除了在哈希表，在其他任何时候，只要涉及到在对 Item 的操作，都会根据 Item 中的 key，进行 Item 哈希锁桶加锁，以避免 Item 被同时读写而产生脏数据。Mc 默认有 4096 个锁桶，所以对 key 加锁时，冲突的概率较小，而且 Mc 全部是内存操作，操作速度很快，即便申请时锁被占用，也会很快被释放。</p>
<p>Mc 哈希表在扩容时，哈希表维护线程，每次按 桶链表纬度 迁移，即一次迁移一个桶里单向链表的所有 Item 元素。在扩容过程中，如果要查找或插入 key，会参照迁移位置选择哈希表。如果 key 对应的哈希桶在迁移位置之前，则到新的主哈希表进行查询或插入，否则到旧哈希表进行查询和插入。待全部扩容迁移完毕，所有的处理就会全部在新的主哈希表进行。</p>
<h2 id="Memcached-如何淘汰冷key和失效key"><a href="#Memcached-如何淘汰冷key和失效key" class="headerlink" title="Memcached 如何淘汰冷key和失效key"></a>Memcached 如何淘汰冷key和失效key</h2><h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>Mc 作为缓存组件，意味着 Mc 中只能存储访问最频繁的热数据，一旦存入数据超过内存限制，就需要对 Mc 中的冷 key 进行淘汰工作。Mc 中的 key 基本都会有过期时间，在 key 过期后，出于性能考虑，Mc 并不会立即删除过期的 key，而是由维护线程逐步清理，同时，只有这个失效的 key 被访问时，才会进行删除，从而回收存储空间。所以 Mc 对 key 生命周期的管理，即 Mc 对 key 的淘汰，包括失效和删除回收两个纬度，知识结构如下图所示。</p>
<p><img src="http://image.leonote.cn//20210220210918.jpg" alt=""></p>
<p>key 的失效，包括 key 在 expire 时间之后的过期，以及用户在 flush_all 之后对所有 key 的过期 2 种方式。</p>
<p>而 Mc 对 key/value 的删除回收，则有 3 种方式。</p>
<ol>
<li><p>第一种是获取时的惰性删除，即 key 在失效后，不立即删除淘汰，而在获取时，检测 key 的状态，如果失效，才进行真正的删除并回收存储空间。</p>
</li>
<li><p>第二种方式是在需要对 Item 进行内存分配申请时，如果内存已全部用完，且该 Item 对应的slabclass 没有空闲的 chunk 可用，申请失败，则会对 LRU 队尾进行同步扫描，回收过期失效的 key，如果没有失效的 key，则会强制删除一个 key。</p>
</li>
<li><p>第三种方式是 LRU 维护线程，不定期扫描 4 个 LRU 队列，对过期 key/value 进行异步淘汰。</p>
</li>
</ol>
<p><strong>flush_all</strong></p>
<p>Mc 中，key 失效除了常规的到达过期时间之外，还有一种用 flush_all 的方式进行全部过期。如果缓存数据写入异常，出现大量脏数据，而又没有简单的办法快速找出所有的脏数据，可以用 flush_all 立即让所有数据失效，通过 key 重新从 DB 加载的方式来保证数据的正确性。flush_all 可以让 Mc 节点的所有 key 立即失效，不过，在某些场景下，需要让多个 Mc 节点的数据在某个时间同时失效，这时就可以用 flush_all 的延迟失效指令了。该指令通过 flush_all 指令后面加一个 expiretime 参数，可以让多个 Mc 在某个时间同时失效所有的 key。</p>
<p>flush_all 后面没有任何参数，等价于 flush_all 0，即立即失效所有的 key。当 Mc 收到 flush_all 指令后，如果是延迟失效，会将全局 setting 中的 oldest_live 设为指定 N 秒后的时间戳，即 N 秒后失效；如果是立即失效，则将全局 setting 中的 oldest_cas 设为当前最大的全局 cas 值。设置完这个全局变量值后，立即返回。因此，在 Mc 通过 flush_all 失效所有 key 时，实际不做任何 key 的删除操作，这些 key ，后续会通过用户请求同步删除，或 LRU 维护线程的异步删除，来完成真正的删除动作。</p>
<p><strong>惰性删除</strong></p>
<p>Mc 中，过期失效 key 的惰性主动删除，是指在 touch、get、gets 等指令处理时，首先需要查询 key，找到 key 所在的 Item，然后校验 key 是否过期，是否被 flush，如果过期或被 flush，则直接进行真正的删除回收操作。</p>
<p>对于校验 key 过期很容易，直接判断过期时间即可。对于检查 key 是否被 flush，处理逻辑是首先检查 key 的最近访问时间是否小于全局设置中的 oldest_live，如果小于则说明 key 被 flush 了；否则，再检查 key 的 cas 唯一 id 值，如果小于全局设置中的 oldest_cas，说明也被 flush 了。</p>
<p><strong>内存分配失败，LRU 同步淘汰</strong></p>
<p>Mc 在插入或变更 key 时，首先会在适合的 slabclass 为新的 key/value 分配一个空闲的 Item 空间，如果分配失败，会同步对该 slabclass 的 COLD LRU 进行队尾元素淘汰，如果淘汰回收成功，则 slabclass 会多一个空闲的 Item，这个 Item 就可以被前面那个 key 来使用。如果 COLD LRU 队列没有 Item 数据，则淘汰失败，此时会对 HOT LRU 进行队尾轮询，如果 key 过期失效则进行淘汰回收，否则进行迁移。</p>
<p><strong>LRU 维护线程，异步淘汰</strong></p>
<p>在 key 进行读取、插入或变更时，同步进行 key 淘汰回收，并不是一种高效的办法，因为淘汰回收操作相比请求处理，也是一个重量级操作，会导致 Mc 性能大幅下降。因此 Mc 额外增加了一个 LRU 维护线程，对过期失效 key 进行回收，在不增加请求负担的情况下，尽快回收失效 key 锁占用的空间。</p>
<p>前面讲到，Mc 有 64 个 slabclass，其中 1<del>63 号 slabclass 用于存取 Item 数据。实际上，为了管理过期失效数据，1</del>63 号 slabclass 还分别对应了 4 个 LRU，分布是 TEMP、HOT、WARM、COLD LRU。所以这就总共有 63*4 = 252 个 LRU。LRU 维护线程，会按策略间断 sleep，待 sleep 结束，就开始对 4 个 LRU 进行队尾清理工作。</p>
<p>Mc 在新写入 key 时，如果 key 的过期时间小于 61s，就会直接插入到 TEMP LRU 中，如下图所示。TEMP LRU 没有长度限制，可以一直插入，同时因为过期时间短，TEMP LRU 不进行队列内部的搬运和队列间的迁移，确保处理性能最佳。LRU 维护线程在 sleep 完毕后，首先会对 TEMP LRU 队尾进行 500 次轮询，然后在每次轮询时，会进行 5 次小循环。小循环时，首先检查 key是否过期失效，如果失效则进行回收淘汰，然后继续小循环；如果遇到一个没失效的 key，则回收该 key 并退出 TEMP LRU 的清理工作。如果 TEMP LRU 队尾 key 全部失效，维护线程一次可以回收 500*5 共 2500 个失效的 key。</p>
<p><img src="http://image.leonote.cn//20210220211300.jpg" alt=""></p>
<p>如下图，MC 在新写入 key 时，如果 key 的过期时间超过 61s，就会直接插入到 HOT LRU。HOT LRU 会有内存限制，每个 HOT LRU 所占内存不得超过所在 slabclass 总实际使用内存的 20%。LRU 维护线程在执行日常维护工作时，首先对 TEMP LRU 进行清理，接下来就会对 HOT LRU 进行维护。HOT LRU 的维护，也是首先轮询 500 次，每次轮询进行 5 次小循环，小循环时，首先检查 key 是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的 key。如果这个 key 的状态是 ACTIVE，则迁移到 WARM LRU。对于非 ACTIVE 状态的 key，如果 HOT LRU 内存占用超过限制，则迁移到 COLD LRU，否则进行纾困性清理掉该 key，注意这种纾困性清理操作一般不会发生，一旦发生时，虽然会清理掉该 key，但操作函数此时也认定本次操作回收和清理 keys 数仍然为 0。</p>
<p><img src="http://image.leonote.cn//20210220211338.jpg" alt=""></p>
<p>如下图，如果 HOT LRU 中回收和迁移的 keys 数为 0，LRU 维护线程会对 WARM LRU 进行轮询。WARM LRU 也有内存限制，每个 WARM LRU 所占内存不得超过所在 slabclass 总实际使用内存的 40%。WARM LRU 的维护，也是首先轮询 500 次，每次轮询进行 5 次小循环，小循环时，首先检查 key 是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的 key。如果这个 key 的状态是 ACTIVE，则内部搬运到 LRU 队列头部。对于非 ACTIVE 状态的 key，如果 WARM LRU 内存占用超过限制，则迁移到 COLD LRU，否则进行纾困性清理掉该 key。注意这种纾困性清理操作一般不会发生，一旦发生时，虽然会清理掉该 key，但操作函数此时也认定本次操作回收和清理 keys 数仍然为 0。</p>
<p><img src="http://image.leonote.cn//20210220211420.jpg" alt=""></p>
<p>LRU 维护线程最后会对 COLD LRU 进行维护，如下图。与 TEMP LRU 相同，COLD LRU 也没有长度限制，可以持续存放数据。COLD LRU 的维护，也是首先轮询 500 次，每次轮询进行 5 次小循环，小循环时，首先检查 key 是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的 key。如果这个 key 的状态是 ACTIVE，则会迁移到 WARM LRU 队列头部，否则不处理直接返回。</p>
<p><img src="http://image.leonote.cn//20210220211501.jpg" alt=""></p>
<p>LRU 维护线程处理时，TEMP LRU 是在独立循环中进行，其他三个 LRU 在另外一个循环中进行，如果 HOT、WARM、COLD LRU 清理或移动的 keys 数为 0，则那个 500 次的大循环就立即停止。</p>
<h2 id="为何-Memcached-能长期维持高性能读写"><a href="#为何-Memcached-能长期维持高性能读写" class="headerlink" title="为何 Memcached 能长期维持高性能读写"></a>为何 Memcached 能长期维持高性能读写</h2><h3 id="内存管理-slab-机制"><a href="#内存管理-slab-机制" class="headerlink" title="内存管理 slab 机制"></a>内存管理 slab 机制</h3><p><strong>slabclass</strong></p>
<p>Mc 的 slab 机制是通过 slabclass 来进行运作的，如下图所示。Mc 在启动时，会构建长度为 64 的 slabclass 数组，其中 0 号 slabclass 用于 slab 的重新分配，1~63 号 slabclass 存储数据 Item。存储数据的每个 slabclass，都会记录本 slabclass 的 chunk size，同时不同 slabclass 的 chunk size 会按递增因子增加，最后一个 slabclass（即 63 号 slabclass）的 chunk size 会直接设为最大的 chunk size，默认是 0.5MB。每个 slabclass 在没有空闲的 chunk 时，Mc 就会为其分配一个默认大小为 1MB 的 slab，同时按照本 slabclass 的 chunk size 进行拆分，这些分拆出来的 chunk 会按 Item 结构体进行初始化，然后记录到 slabclass 的 freelist 链表中。当有 key/value 要存储在本 slabclass 时，就从 freelist 分配一个 Item，供其使用。同时，如果 Item 过期了，或被 flush_all 失效了，或在内存不够时被强项剔除了，也会在适当时刻，重新被回收到 freelist，以供后续分配使用。</p>
<p><img src="http://image.leonote.cn//20210220212913.jpg" alt=""></p>
<p><strong>存储 slab 分配</strong></p>
<p>如下图所示，Mc 的存储空间分配是以 slab 为单位的，每个 slab 的默认大小时 1MB。因此在存数据时，Mc 的内存最小分配单位是 1MB，分配了这个 1MB 的 slab 后，才会进一步按所在 slabclass 的chunk size 进行细分，分拆出的相同 size 的 chunk。这个 chunk 用来存放 Item 数据，Item 数据包括 Item 结构体字段，以及 key/value。</p>
<p>一般来讲，Item 结构体及 key/value 不会填满 chunk，会存在少量字节的浪费，但这个浪费的字节很少，基本可以忽略。Mc 中，slab 一旦分配，就不会再被回收，但会根据运行状况，重新在不同 slabclass 之间进行分配。</p>
<p><img src="http://image.leonote.cn//20210220213031.jpg" alt=""></p>
<p>当一个 slabclass 没有空闲 chunk，而新数据插入时，就会对其尝试增加一个新的 slab。slabclass 增加新 slab 时，首先会从 0 号全局 slabclass 中复用一个之前分配的 slab，如果 0 号 slabclass 没有 slab，则会尝试从内存堆空间直接分配一个 slab。如果 0 号全局 slabclass 没有空闲 slab，而且 Mc 内存分配已经达到 Mc 设定的上限值，就说明此时没有可重新分配的 slab，分配新 slab 失败，直接返回。</p>
<p>当然，虽然 slabclass 分配 slab 失败，但并不意味着 Item分配会失败，前面已经讲到，可以通过同步 LRU 淘汰，回收之前分配出去的 Item，供新的存储请求使用。</p>
<p><strong>Item</strong></p>
<p>Mc 中，slabclass 中的 chunk 会首先用 Item 结构体进行初始化，然后存到 freelist 链表中，待需要分配给数据存储时，再从 freelist 中取出，存入 key/value，以及各种辅助属性，然后再存到 LRU 链表及 Hashtable 中，如下图所示。Item 结构体，首先有两个 prev、next 指针，在分配给待存储数据之前，这两个指针用来串联 freelist 链表，在分配之后，则用来串联所在的 LRU 链表。接下来是一个 h_next 指针，用来在分配之后串联哈希表的桶单向链表。Item 结构体还存储了过期时间、所属 slabclass id，key 长度、cas 唯一 id 值等，最后在 Item 结构体尾部，存储了 key、flag、value 长度，以及 value block 数据。在 value 之后的 chunk 空间，就被浪费掉了。Item 在空闲期间，即初始分配时以及被回收后，都被 freelist 管理。在存储期间，被哈希表、LRU 管理。</p>
<p><img src="http://image.leonote.cn//20210220213232.jpg" alt=""></p>
<p><strong>存储 Item 分配</strong></p>
<p>Mc 采用 slab 机制管理分配内存，采用 Item 结构存储 key/value，因此对存储 key/value 的内存分配，就转换为对 Item 的分配。分配 Item 空间时，会进行 10 次大循环，直到分配到 Item  空间才会提前返回。如果循环了 10 次，还没有分配到 Item 空间，则存储失败，返回一个 SERVER_ERROR 响应。</p>
<p>在分配过程中，首先，如果 slabclass 的 freelist 有空间，则直接分配。否则，尝试分配一个新的 slab，新 slab 依次尝试从全局 slab 池（即 0 号 slabclass）中复用一个空闲 slab，如果全局 slab 池没有 slab，则尝试从内存直接分配。分配新 slab 成功后，会按照 slabclass 记录的 chunk size 对 slab 进行分拆，并将分拆出来的 chunk 按 Item 结构初始化后记录到 freelist。如果全局 slab 池为空，且 Mc 内存分配已经达到设定的上限，则走新增 slab 的路径失败，转而进行 5 次小循环，尝试从 COLD LRU 回收过期 key，如果没有过期则直接强制剔除队尾的一个正常 key。如果该 slabclass 的 COLD LRU 没有 Item，则对其 HOT LRU 进行处理，对 HOT 链表队尾 Item 进行回收或者迁移，以方便在下次循环中找到一个可用的 Item 空间。</p>
<p><strong>数据存储机理</strong></p>
<p>如下图所示，当需要存储 key/value 数据时，首先根据 key/value size，以及 Item 结构体的 size，计算出存储这个 key/value 需要的字节数，然后根据这个字节数选择一个能存储的 chunk size 最小的 slabclass。再从这个 slabclass 的 freelist 分配一个空闲的 chunk 给这个 key/value 使用。如果 freelist 为空，首先尝试为该 slabclass 新分配一个 slab，如果 slab 分配成功，则将 slab 按 size 分拆出一些 chunk，通过 Item 结构初始化后填充到 freelist。如果 slab 分配失败，则通过 LRU 淘汰失效的 Item 或强行剔除一个正常的 Item，然后这些 Item 也会填充到 freelist。当 freelist 有 Item 时，即可分配给 key/value。这个过程会重试 10 次，直到分配到 Item 位置。一般情况下，Item 分配总会成功，极小概率情况下也会分配失败，如果分配失败，则会回复一个 SERVER_ERROR 响应，通知 client 存储失败。分配到一个空闲的 Item 后，就会往这个 Item 空间写入过期时间、flag、slabclass id、key，以及 value 等。对于 set 指令，如果这个 key 还有一个旧值，在存入新 value 之前，还会先将这个旧值删除掉。</p>
<p><img src="http://image.leonote.cn//20210220214440.jpg" alt=""></p>
<p>当对 key/value 分配 Item 成功，并写入数据后，接下来就会将这个 Item 存入哈希表。因为Mc 哈希表存在迁移的情况，所以对于正常场景，直接存入主哈希表。在哈希表迁移期间，需要根据迁移位置，选择存入主哈希表还是旧哈希表。存入哈希表之后，这个 key 就可以快速定位了。然后这个 Item 还会被存入 LRU，Mc 会根据这个 key 的过期时间进行判断，如果过期时间小于 61s，则存入 TEMP LRU，否则存入 HOT LRU。</p>
<p>至此，这个 key/value 就被正确地存入 Mc 了，数据内容写入 slabclass 中某个 slab 的 chunk 位置，该 chunk 用 Item 结构填充，这个 Item 会被同时记录到 Hashtable 和 LRU，如下图所示。通过 Hashtable 可以快速定位查到这个 key，而 LRU 则用于 Item 生命周期的日常维护。</p>
<p><img src="http://image.leonote.cn//20210220215002.jpg" alt=""></p>
<p>Mc 对 Item 生命周期的日常维护，包括异步维护和同步维护。异步维护是通过 LRU 维护线程来进行的，整个过程不影响 client 的正常请求，在 LRU 维护线程内，对过期、失效 key 进行回收，并对 4 个 LRU 进行链表内搬运和链表间迁移。这是 Item 生命周期管理的主要形式。同步维护，由工作线程在处理请求命令时进行。工作线程在处理 delete 指令时，会直接将 key/value 进行删除。在存储新 key/value 时，如果分配失败，会进行失效的 key 回收，或者强行剔除正常的 Item。这些 Item 被回收后，会进入到 slabclass 的 freelist 进行重复使用。</p>
<h2 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h2><p><strong>异常错误响应</strong></p>
<p>Mc 在处理所有 client 端指令时，如果遇到错误，就会返回 3 种错误信息中的一种。</p>
<ul>
<li><p>第一种错误是协议错误，一个”ERROR\r\n”的字符串。表明 client 发送了一个非法命令。</p>
</li>
<li><p>第二种错误是 client 错误，格式为”CLIENT_ERROR &lt;error-描述信息&gt;\r\n”。这个错误信息表明 ，client 发送的协议命令格式有误，比如少了字段、多了非法字段等。</p>
</li>
<li><p>第三种错误是”SERVER_ERROR &lt;error-描述信息&gt;\r\n”。这个错误信息表明 Mc server 端，在处理命令时出现的错误。比如在给 key/value 分配 Item 空间失败后，会返回”SERVER_ERROR out of memory storing object” 错误信息。</p>
</li>
</ul>
<p><strong>存储协议命令</strong></p>
<p>Mc 的存储协议命令不多，只有 6 个。</p>
<p>Mc 存储指令分 2 行。第一行是报文首部，第二行是 value 的 data block 块。这两部分用 \r\n 来进行分割和收尾。</p>
<p>存储类指令的报文首行分 2 种格式，其中一种是在 cmd 存储指令，后面跟 key、flags、expiretime、value 字节数，以及一个可选的 noreply。</p>
<p>其中 flags 是用户自己设计的一个特殊含义数字，Mc 对 flag 只存储，而不进行任何额外解析处理，expiretime 是 key 的过期时间，value 字节数是 value block 块的字节长度，而带上 noreply 是指 Mc 处理完后静默处理，不返回任何响应给 client。</p>
<p>这种 cmd 指令包括我们最常用的 set 指令，另外还包括 add、replace、append、reppend ，总共 5 个指令：</p>
<ul>
<li><p>Set 命令用于存储一个 key/value；</p>
</li>
<li><p>Add 命令是在当 key 不存在时，才存储这个 key/value；</p>
</li>
<li><p>Replace 命令，是当 key 存在时，才存储这个 key/value；</p>
</li>
<li><p>Append 命令，是当 key 存在时，追加 data 到 value 的尾部；</p>
</li>
<li><p>Prepend 命令，是当 key 存在时，将 data 加到 value 的头部。</p>
</li>
</ul>
<p>另外一种存储协议指令，主要格式和字段与前一种基本相同，只是多了一个 cas unique id，这种格式只有 cas 指令使用。cas 指令是指只有当这个 key 存在，且从本 client 获取以来，没有其他任何人修改过时，才进行修改。cas 的英文含义是 compare and set，即比较成功后设置的意思。</p>
<p><strong>存储命令响应</strong></p>
<p>Mc 在响应存储协议时，如果遇到错误，就返回前面说的3种错误信息中的一种。否则就会返回如下 4 种正常的响应，”STORED\r\n”、”EXISTS\r\n”、”NOT_STORED\r\n”、”NOT_FOUND\r\n“。</p>
<p>其中，stored 表明存储修改成功。NOT_STORED 表明数据没有存储成功，但并不是遇到错误或异常。这个响应一般表明 add 或 replace 等指令，前置条件不满足时，比如 add，这个 key 已经存在 Mc，就会 add 新 key 失败。replace 时， key 不存在，也无法 replace 成功。EXISTS 表明待 cas 的key 已经被修改过了，而 NOT_FOUND 是指待 cas 的 key 在 Mc 中不存在。</p>
<p>Mc 对存储命令的请求及响应协议，可以参考下面的思维导图来有一个完整的印象。</p>
<p><img src="http://image.leonote.cn//20210220215930.jpg" alt=""></p>
<p><strong>获取命令</strong></p>
<p>Mc 的获取协议，只有 get、gets 两种指令，如下图所示。格式为 get/gets 后，跟随若干个 key，然后 \r\n 结束请求命令。get 指令只获取 key 的 flag 及 value，gets 会额外多获取一个 cas unique id值。gets 主要是为 cas 指令服务的。</p>
<p>获取命令的响应，就是 value 字串，后面跟上 key、flag、value 字节数，以及 value 的 data block 块。最后跟一个 END\r\n 表明所有存在的 key/value 已经返回，如果没有返回的 key，则表明这个 key 在 Mc 中不存在。</p>
<p><img src="http://image.leonote.cn//20210220220006.jpg" alt=""></p>
<p><strong>其他指令</strong></p>
<p>Mc 的其他协议指令包括 delete、incr、decr、touch、gat、gats、slabs、lru、stats 这 9 种指令。</p>
<p>其中 delete 用于删除一个 key。</p>
<p>incr/decr 用于对一个无符号长整型数字进行加或减。</p>
<p>touch、gat、gats 是 Mc 后来增加的指令，都可以用来修改 key 的过期时间。不同点是 touch 只修改 key 的过期时间，不获取 key对应的value。</p>
<p>而 gat、gats 指令，不仅会修改 key 的过期时间，还会获取 key 对应的 flag 和 value 数据。gats 同 gets，还会额外获取 cas 唯一 id 值。</p>
<p>Slabs reassign 用于在 Mc 内存达到设定上限后，将 slab 重新在不同的 slabclass 之间分配。这样可以规避 Mc 启动后自动分配而产生随机性，使特殊 size 的数据也得到较好的命中率。Slabs automove 是一个开关指令，当打开时，就允许 Mc 后台线程自行决定何时将 slab 在slabclass 之间重新分配。</p>
<p>lru 指令用于 Mc LRU 的设置和调优。比如 LRU tune 用于设置 HOT、WARM LRU 的内存占比。LRU mode 用来设置 Mc 只使用 COLD LRU，还是使用新版的 4 个 LRU 的新策略。LRU TEMP_TTL 用来设置 Mc 的 TEMP LRU 的TTL值，默认是 61s，小于这个 TMEP_TTL 的 key会被插入到 TEMP LRU。</p>
<p>Stats 用于获取 Mc 的各种统计数据。Stats 后面可以跟 statistics、slabs、size 等参数，来进一步获取更多不同的详细统计。</p>
<p><strong>Client 使用</strong></p>
<p>Mc 在互联网企业应用广泛，热门语言基本都有 Mc client 的实现。以 Java 语言为例，互联网业界广泛使用的有 Memcached-Java-Client、SpyMemcached、Xmemcached 等。</p>
<p>Memcached-Java-Client 推出时间早，10 年前就被广泛使用，这个 client 性能一般，但足够稳定，很多互联网企业至今仍在使用。不过这个 client 几年前就停止了更新。</p>
<p>SpyMemcached 出现的比较晚，性能较好，但高并发访问场景，稳定性欠缺。近几年变更很少，基本停止了更新。</p>
<p>Xmemcached 性能较好，综合表现最佳。而且社区活跃度高，近些年也一直在持续更新中。Java 新项目启动，推荐使用 Xmemcached。 </p>
<p>在使用 Mc client 时，有一些通用性的调优及改进方案。比如，如果读写的 key/value 较大，需要设置更大的缓冲 buf，以提高性能。在一些业务场景中，需要启用 TCP_NODELAY，避免 40ms 的延迟问题。同时，如果存取的 key/value size 较大，可以设置一个压缩阀值，超过阀值，就对value 进行压缩算法，减少读写及存储的空间。</p>
<p>为了避免缓存雪崩，并更好地应对极热 key 及洪水流量的问题，还可以对 Mc client 进行封装，加入多副本、多层级策略，使 Mc 缓存系统在任何场景下，都可做到高可用、高性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>知识点结构图如下所示。</p>
<p><img src="http://image.leonote.cn//20210220220242.jpg" alt=""></p>
<p>Mc 协议的思维导图</p>
<p><img src="http://image.leonote.cn//20210220220319.jpg" alt=""></p>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript</title>
    <url>/2020/11/09/ECMAScript/</url>
    <content><![CDATA[<h1 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h1><blockquote>
<p>ES 全称 ECMAScript，ECMAScript 是 ECMA 制定的标准化脚本语言</p>
</blockquote>
<h2 id="ES6新特性（2015）"><a href="#ES6新特性（2015）" class="headerlink" title="ES6新特性（2015）"></a>ES6新特性（2015）</h2><p>ES6中的特性比较多。 列举几个常用的：</p>
<ul>
<li>类</li>
<li>模块化</li>
<li>箭头函数</li>
<li>函数参数默认值</li>
<li>模板字符串</li>
<li>解构赋值</li>
<li>延展操作符</li>
<li>对象属性简写</li>
<li>Promise</li>
<li>Let 与 Const</li>
</ul>
<h3 id="类（class）"><a href="#类（class）" class="headerlink" title="类（class）"></a>类（class）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 构造函数，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数.</span></span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name, color</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name;</span><br><span class="line">     <span class="built_in">this</span>.color = color;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// toString 是原型对象上的属性</span></span><br><span class="line">   <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;name:&#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;,color:&#x27;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;white&#x27;</span>); <span class="comment">//实例化 Animal</span></span><br><span class="line">animal.toString();</span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(animal.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="title">constructor</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 子类必须要在constructor中指定 super 函数，否则在新建实例的时候会报错.</span></span><br><span class="line">   <span class="comment">// 如果没有置顶consructor, 默认带super函数的constructor将会被添加</span></span><br><span class="line">   <span class="built_in">super</span>(<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">   <span class="built_in">this</span>.action = action;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">super</span>.toString());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;catch&#x27;</span>)</span><br><span class="line">cat.toString();</span><br><span class="line"><span class="comment">// 实例cat 是 Cat 和 Animal 的实例，和 Es5 完全一致。</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="模块化-Module"><a href="#模块化-Module" class="headerlink" title="模块化(Module)"></a>模块化(Module)</h3><p>ES5 不支持原生的模块化，在 ES6 中模块作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成。每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过 import 来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。</p>
<h4 id="导出-export"><a href="#导出-export" class="headerlink" title="导出(export)"></a>导出(export)</h4><p>ES6 允许在一个模块中使用 export 来导出多个变量或函数。</p>
<h5 id="导出变量"><a href="#导出变量" class="headerlink" title="导出变量"></a>导出变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&#x27;Rainbow&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ES6不仅支持变量的导出，也支持常量的导出。 </p>
<p><code>export const sqrt = Math.sqrt // 导出常量</code></p>
</blockquote>
<p>ES6 将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"> <span class="keyword">var</span> name = <span class="string">&#x27;Rainbow&#x27;</span>;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="string">&#x27;24&#x27;</span>;</span><br><span class="line"> <span class="keyword">export</span> &#123;name, age&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// myModule.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">myModule</span>(<span class="params">someArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someArg;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="导入-import"><a href="#导入-import" class="headerlink" title="导入(import)"></a>导入(import)</h4><p>定义好模块的输出以后就可以在另外一个模块通过 import 引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myModule&#125; <span class="keyword">from</span> <span class="string">&#x27;myModule&#x27;</span> <span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name,age&#125; <span class="keyword">from</span> <span class="string">&#x27;test&#x27;</span> <span class="comment">// test.js</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一条 import 语句可以同时导入默认函数和其它变量。<code>import defaultMethod, &#123; otherMethod &#125; from &#39;xxx.js&#39;</code></p>
</blockquote>
<h3 id="箭头（Arrow）函数"><a href="#箭头（Arrow）函数" class="headerlink" title="箭头（Arrow）函数"></a>箭头（Arrow）函数</h3><p><code>=&gt;</code>不只是关键字 function 的简写，它还带来了其它好处。箭头函数与包围它的代码共享同一个<code>this</code>，能帮你很好的解决 <code>this</code> 的指向问题。有经验的 JavaScript 开发者都熟悉诸如<code>var self = this</code>或<code>var that = this</code>这种引用外围 <code>this</code> 的模式。但借助<code>=&gt;</code>，就不需要这种模式了。</p>
<h4 id="箭头函数的结构"><a href="#箭头函数的结构" class="headerlink" title="箭头函数的结构"></a>箭头函数的结构</h4><p>箭头函数的箭头<code>=&gt;</code>之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过 return 来返回值，否则返回的是 undefined）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数的例子</span></span><br><span class="line">()=&gt;<span class="number">1</span></span><br><span class="line">v=&gt;v+<span class="number">1</span></span><br><span class="line">(a,b)=&gt;a+b</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    alert(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>/e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不论是箭头函数还是 bind，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用。</p>
</blockquote>
<h4 id="卸载监听器时的陷阱"><a href="#卸载监听器时的陷阱" class="headerlink" title="卸载监听器时的陷阱"></a>卸载监听器时的陷阱</h4><p><strong>错误的做法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onAppPaused</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正确的做法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>._onAppPaused = <span class="built_in">this</span>.onAppPaused.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>._onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">onAppPaused</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除上述的做法外，还可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PauseMenu</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        AppStateIOS.removeEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="built_in">this</span>.onAppPaused);</span><br><span class="line">    &#125;</span><br><span class="line">    onAppPaused = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//把函数直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/default_parameters">函数参数默认值</a></h3><p>ES6支持在定义函数的时候为其设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height = <span class="number">50</span>, color = <span class="string">&#x27;red&#x27;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不使用默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">height, color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> height = height || <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">var</span> color = color || <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写一般没问题，但当<strong>参数的布尔值为 false</strong> 时，就会有问题了。</p>
<p>比如，我们这样调用foo函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo(<span class="number">0</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>因为 0 的布尔值为 false，这样 height 的取值将是50。同理 color 的取值为 ‘red’。</p>
<p>所以说，<strong>函数参数默认值</strong>不仅能是代码变得更加简洁而且能规避一些问题。</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>ES6 支持模板字符串，使得字符串的拼接更加的简洁、直观。</p>
<p>不使用模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Your name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>使用模板字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">`Your name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span></span><br></pre></td></tr></table></figure>

<p>在 ES6 中通过<code>$&#123;&#125;</code>就可以完成字符串的拼接，只需要将变量放在大括号之中。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a></h3><p>解构赋值语法是 JavaScript 的一种表达式，可以方便的从<strong>数组</strong>或者<strong>对象</strong>中<strong>快速提取值赋给定义的变量</strong>。</p>
<h4 id="获取数组中的值"><a href="#获取数组中的值" class="headerlink" title="获取数组中的值"></a>获取数组中的值</h4><p>从数组中获取值并赋值到变量中，变量的顺序与数组中对象顺序对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &quot;two&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// &quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你要忽略某些值，你可以按照下面的写法获取你想要的值</span></span><br><span class="line"><span class="keyword">var</span> [first, , , last] = foo;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(last); <span class="comment">// &quot;four&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//你也可以这样写</span></span><br><span class="line"><span class="keyword">var</span> a, b; <span class="comment">//先声明变量</span></span><br><span class="line"></span><br><span class="line">[a, b] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>如果没有从数组中的获取到值，你可以为变量设置一个默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b;</span><br><span class="line"></span><br><span class="line">[a=<span class="number">5</span>, b=<span class="number">7</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>通过解构赋值可以方便的交换两个变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="获取对象中的值"><a href="#获取对象中的值" class="headerlink" title="获取对象中的值"></a>获取对象中的值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">  name:<span class="string">&#x27;Ming&#x27;</span>,</span><br><span class="line">  age:<span class="string">&#x27;18&#x27;</span>,</span><br><span class="line">  city:<span class="string">&#x27;Shanghai&#x27;</span>  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name, age, city&#125; = student;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// &quot;Ming&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// &quot;18&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(city); <span class="comment">// &quot;Shanghai&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="延展操作符-Spread-operator"><a href="#延展操作符-Spread-operator" class="headerlink" title="延展操作符( Spread operator )"></a>延展操作符( Spread operator )</h3><p>延展操作符<code>...</code>可以在<strong>函数调用</strong>/<strong>数组构造</strong>时，将数组表达式或者 string 在语法层面展开；还可以在构造对象时，将对象表达式按 key-value 的方式展开。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><strong>函数调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure>

<p><strong>数组构造或字符串</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...iterableObj, <span class="string">&#x27;4&#x27;</span>, ...<span class="string">&#x27;hello&#x27;</span>, <span class="number">6</span>];</span><br></pre></td></tr></table></figure>

<p>构造对象时，进行<strong>克隆或者属性拷贝</strong>（ECMAScript 2018规范新增特性）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objClone = &#123; ...obj &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>在函数调用时使用延展操作符</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, numbers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延展操作符</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(...numbers));<span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>构造数组</strong></p>
<p>没有展开语法的时候，只能组合使用 push、splice、concat 等方法，来将已有数组元素变成新数组的一部分。有了展开语法，构造新数组会变得更简单、更优雅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> stuendts = [<span class="string">&#x27;Jine&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>]; </span><br><span class="line"><span class="keyword">const</span> persons = [<span class="string">&#x27;Tony&#x27;</span>, ...stuendts, <span class="string">&#x27;Aaron&#x27;</span>, <span class="string">&#x27;Anna&#x27;</span>];</span><br><span class="line">conslog.log(persions) <span class="comment">// [&quot;Tony&quot;, &quot;Jine&quot;, &quot;Tom&quot;, &quot;Aaron&quot;, &quot;Anna&quot;]</span></span><br></pre></td></tr></table></figure>

<p>和参数列表的展开类似，<code>...</code> 在构造字数组时，可以在任意位置多次使用。</p>
<p><strong>数组拷贝</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [...arr]; <span class="comment">// 等同于 arr.slice()</span></span><br><span class="line">arr2.push(<span class="number">4</span>); </span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">//[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>展开语法和 Object.assign() 行为一致, 执行的都是浅拷贝(只遍历一层)。</p>
<p><strong>连接多个数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2]; <span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.concat(arr2);</span><br></pre></td></tr></table></figure>

<p>在ECMAScript 2018中延展操作符增加了对<strong>对象</strong>的支持</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;baz&#x27;</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: &quot;bar&quot;, x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: &quot;baz&quot;, x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="在React中的应用"><a href="#在React中的应用" class="headerlink" title="在React中的应用"></a>在React中的应用</h4><p>通常我们在封装一个组件时，会对外公开一些 props 用于实现功能。大部分情况下在外部使用都应显示的传递 props 。但是当传递大量的props时，会非常繁琐，这时我们可以使用 <strong><code>...</code>(延展操作符，用于取出参数对象的所有可遍历属性)</strong> 来进行传递。</p>
<p>一般情况下我们应该这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;CustomComponent name =<span class="string">&#x27;Jine&#x27;</span> age =&#123;<span class="number">21</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>...</code> ，等同于上面的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123;</span><br><span class="line">	name: <span class="string">&#x27;Jine&#x27;</span>,</span><br><span class="line">	age: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;CustomComponent &#123;...params&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>配合解构赋值避免传入一些不需要的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> params = &#123;</span><br><span class="line">	name: <span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">	title: <span class="string">&#x27;456&#x27;</span>,</span><br><span class="line">	type: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; type, ...other &#125; = params;</span><br><span class="line"></span><br><span class="line">&lt;CustomComponent type=<span class="string">&#x27;normal&#x27;</span> number=&#123;<span class="number">2</span>&#125; &#123;...other&#125; /&gt;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">&lt;CustomComponent type=<span class="string">&#x27;normal&#x27;</span> number=&#123;<span class="number">2</span>&#125; name=<span class="string">&#x27;123&#x27;</span> title=<span class="string">&#x27;456&#x27;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="对象属性简写"><a href="#对象属性简写" class="headerlink" title="对象属性简写"></a>对象属性简写</h3><p>在ES6中允许我们在设置一个对象的属性的时候不指定属性名。</p>
<p><strong>不使用ES6</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;Ming&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>, city=<span class="string">&#x27;Shanghai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name:name,</span><br><span class="line">    age:age,</span><br><span class="line">    city:city</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(student); <span class="comment">//&#123;name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>对象中必须包含属性和值，显得非常冗余。</p>
<p><strong>使用ES6</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name=<span class="string">&#x27;Ming&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span>, city=<span class="string">&#x27;Shanghai&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    city</span><br><span class="line">&#125;;</span><br><span class="line">console.log(student); <span class="comment">//&#123;name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>对象中直接写变量，非常简洁。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">Promise</a></h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案callback更加的优雅。它最早由社区提出和实现的，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p><strong>不使用ES6</strong></p>
<p>嵌套两个 setTimeout 回调函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// 1秒后输出 &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hi&#x27;</span>); <span class="comment">// 2秒后输出 &quot;Hi&quot;</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p><strong>使用ES6</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> waitSecond = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">waitSecond</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 1秒后输出&quot;Hello&quot;</span></span><br><span class="line">      <span class="keyword">return</span> waitSecond;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>); <span class="comment">// 2秒后输出&quot;Hi&quot;</span></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>上面的的代码使用两个 then 来进行异步编程串行化，避免了回调地狱：</p>
<h3 id="支持-let-与-const"><a href="#支持-let-与-const" class="headerlink" title="支持 let 与 const"></a>支持 let 与 const</h3><p>在之前 JS 是没有块级作用域的，const 与 let 填补了这方便的空白，const 与 let 都是块级作用域。</p>
<p>使用 var 定义的变量为函数级作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure>

<p>使用 let 与 const 定义的变量为块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//-1 or Error“ReferenceError: a is not defined”</span></span><br></pre></td></tr></table></figure>

<h2 id="ES7新特性（2016）"><a href="#ES7新特性（2016）" class="headerlink" title="ES7新特性（2016）"></a>ES7新特性（2016）</h2><p>ES2016添加了两个小的特性来说明标准化过程：</p>
<ul>
<li>数组 includes() 方法，用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</li>
<li>a ** b 指数运算符，它与 Math.pow(a, b) 相同。</li>
</ul>
<h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h3><p><code>includes()</code> 函数用来判断一个数组是否包含一个指定的值，如果包含则返回 <code>true</code>，否则返回<code>false</code>。</p>
<p><code>includes</code> 函数与 <code>indexOf</code> 函数很相似，下面两个表达式是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.includes(x)</span><br><span class="line">arr.indexOf(x) &gt;= <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>在 ES7 之前的做法</p>
<p>使用<code>indexOf()</code>验证数组中是否存在某个元素，这时需要根据返回值是否为-1来判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;angular&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.indexOf(<span class="string">&#x27;react&#x27;</span>) !== -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;react存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ES7 的 includes()</p>
<p>使用 includes() 验证数组中是否存在某个元素，这样更加直观简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;angular&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arr.includes(<span class="string">&#x27;react&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;react存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指数操作符"><a href="#指数操作符" class="headerlink" title="指数操作符"></a>指数操作符</h3><p>在 ES7 中引入了指数运算符<code>**</code>，<code>**</code>具有与<code>Math.pow(..)</code>等效的计算结果。</p>
<p><strong>不使用指数操作符</strong></p>
<p>使用自定义的递归函数 calculateExponent 或者 Math.pow() 进行指数运算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateExponent</span>(<span class="params">base, exponent</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent === <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> base * calculateExponent(base, exponent - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calculateExponent(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure>

<p><strong>使用指数操作符</strong></p>
<p>使用指数运算符**，就像+、-等操作符一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>);<span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure>

<h2 id="ES8新特性（2017）"><a href="#ES8新特性（2017）" class="headerlink" title="ES8新特性（2017）"></a>ES8新特性（2017）</h2><ul>
<li>async/await</li>
<li><code>Object.values()</code></li>
<li><code>Object.entries()</code></li>
<li>String padding: <code>padStart()</code>和<code>padEnd()</code>，填充字符串达到当前长度</li>
<li>函数参数列表结尾允许逗号</li>
<li><code>Object.getOwnPropertyDescriptors()</code></li>
<li><code>ShareArrayBuffer</code>和<code>Atomics</code>对象，用于从共享内存位置读取和写入</li>
</ul>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p> ES6 提供的 Promise 方法和 ES7 提供的 Async/Await 语法糖可以更好解决多层回调问题</p>
<p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。</p>
<ul>
<li>async 表示这是一个 async 函数，即异步函数。</li>
<li>await 操作符用于等待一个 Promise 对象。它只能在异步函数 async function 中使用，Promise 返回结果后，再继续往下执行。</li>
<li>await 后面跟着的应该是一个 Promise 对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…）</li>
<li>await 等待的虽然是 Promise 对象，但不必写.then(..)，直接可以得到返回值。</li>
</ul>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values()</code>是一个与<code>Object.keys()</code>类似的新函数，但返回的是Object自身属性的所有值，不包括继承的值。</p>
<p>假设我们要遍历如下对象<code>obj</code>的所有值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不使用Object.values() :ES7</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vals=<span class="built_in">Object</span>.keys(obj).map(<span class="function"><span class="params">key</span>=&gt;</span>obj[key]);</span><br><span class="line"><span class="built_in">console</span>.log(vals);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Object.values() :ES8</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values=<span class="built_in">Object</span>.values(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(values);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出<code>Object.values()</code>为我们省去了遍历key，并根据这些key获取value的步骤。</p>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h3><p><code>Object.entries()</code>函数返回一个给定对象自身可枚举属性的键值对的数组。</p>
<p>接下来我们来遍历上文中的<code>obj</code>对象的所有属性的key和value：</p>
<blockquote>
<p>不使用Object.entries() :ES7</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;key:&#x27;</span>+key+<span class="string">&#x27; value:&#x27;</span>+obj[key]);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用Object.entries() :ES8</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj1))&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> value:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//key:a value:1</span></span><br><span class="line"><span class="comment">//key:b value:2</span></span><br><span class="line"><span class="comment">//key:c value:3</span></span><br></pre></td></tr></table></figure>

<h3 id="String-padding"><a href="#String-padding" class="headerlink" title="String padding"></a>String padding</h3><p>在 ES8 中 String 新增了两个实例函数<code>String.prototype.padStart</code>和<code>String.prototype.padEnd</code>，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。</p>
<blockquote>
<p>String.padStart(targetLength,[padString])</p>
</blockquote>
<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString(可选)：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">4</span>,<span class="string">&#x27;10&#x27;</span>)) <span class="comment">//10.0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padStart(<span class="number">20</span>)) <span class="comment">// 0.00</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>String.padEnd(targetLength,padString])</p>
</blockquote>
<ul>
<li>targetLength：当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li>
<li>padString(可选)：填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padEnd(<span class="number">4</span>,<span class="string">&#x27;0&#x27;</span>))  <span class="comment">//0.00    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;0.0&#x27;</span>.padEnd(<span class="number">10</span>,<span class="string">&#x27;0&#x27;</span>)) <span class="comment">// 0.00000000</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数列表结尾允许逗号"><a href="#函数参数列表结尾允许逗号" class="headerlink" title="函数参数列表结尾允许逗号"></a>函数参数列表结尾允许逗号</h3><p>主要作用是方便使用 git 进行多人协作开发时修改同一个函数减少不必要的行变更。</p>
<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p><code>Object.getOwnPropertyDescriptors()</code>函数用来获取一个对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<p>函数原型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br></pre></td></tr></table></figure>

<p>返回<code>obj</code>对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">	name: <span class="string">&#x27;Jine&#x27;</span>,</span><br><span class="line">	<span class="keyword">get</span> <span class="title">age</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;18&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj2)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   age: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//     get: function age()&#123;&#125;, //the getter function</span></span><br><span class="line"><span class="comment">//     set: undefined</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   name: &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true,</span></span><br><span class="line"><span class="comment">//     enumerable: true,</span></span><br><span class="line"><span class="comment">//		value:&quot;Jine&quot;,</span></span><br><span class="line"><span class="comment">//		writable:true</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="SharedArrayBuffer对象"><a href="#SharedArrayBuffer对象" class="headerlink" title="SharedArrayBuffer对象"></a>SharedArrayBuffer对象</h3><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>length 所创建的数组缓冲区的大小，以字节(byte)为单位。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;SharedArrayBuffer&#125;</span> </span>一个大小指定的新 SharedArrayBuffer 对象。其内容被初始化为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> SharedArrayBuffer(length)</span><br></pre></td></tr></table></figure>

<h3 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a>Atomics对象</h3><p>Atomics 对象提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作。</p>
<p>这些原子操作属于 Atomics 模块。与一般的全局对象不同，Atomics 不是构造函数，因此不能使用 new 操作符调用，也不能将其当作函数直接调用。Atomics 的所有属性和方法都是静态的（与 Math 对象一样）。</p>
<p>多个共享内存的线程能够同时读写同一位置上的数据。原子操作会确保正在读或写的数据的值是符合预期的，即下一个原子操作一定会在上一个原子操作结束后才会开始，其操作过程不会中断。</p>
<ul>
<li>Atomics.add()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.and()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.compareExchange()</li>
</ul>
<blockquote>
<p>如果数组中指定的元素与给定的值不等，则将其更新为新的值，并返回该元素原先的值。</p>
</blockquote>
<ul>
<li>Atomics.exchange()</li>
</ul>
<blockquote>
<p>将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p>
</blockquote>
<ul>
<li>Atomics.load()</li>
</ul>
<blockquote>
<p>返回数组中指定元素的值。</p>
</blockquote>
<ul>
<li>Atomics.or()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.store()</li>
</ul>
<blockquote>
<p>将数组中指定的元素设置为给定的值，并返回该值。</p>
</blockquote>
<ul>
<li>Atomics.sub()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p>
</blockquote>
<ul>
<li>Atomics.xor()</li>
</ul>
<blockquote>
<p>将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p>
</blockquote>
<p>wait() 和 wake() 方法采用的是 Linux 上的 futexes 模型（fast user-space mutex，快速用户空间互斥量），可以让进程一直等待直到某个特定的条件为真，主要用于实现阻塞。</p>
<ul>
<li>Atomics.wait()</li>
</ul>
<blockquote>
<p>检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p>
</blockquote>
<ul>
<li>Atomics.wake()</li>
</ul>
<blockquote>
<p>唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p>
</blockquote>
<ul>
<li>Atomics.isLockFree(size)</li>
</ul>
<blockquote>
<p>可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。–&gt;</p>
</blockquote>
<h2 id="ES9新特性（2018）"><a href="#ES9新特性（2018）" class="headerlink" title="ES9新特性（2018）"></a>ES9新特性（2018）</h2><ul>
<li>异步迭代</li>
<li>Promise.finally()</li>
<li>Rest/Spread 属性</li>
<li><a href="http://esnext.justjavac.com/proposal/regexp-named-groups.html">正则表达式命名捕获组</a>（Regular Expression Named Capture Groups）</li>
<li><a href="https://segmentfault.com/a/1190000006824133">正则表达式反向断言</a>（lookbehind）</li>
<li>正则表达式dotAll模式</li>
<li><a href="https://juejin.im/post/6844903622870827022#heading-1">正则表达式 Unicode 转义</a></li>
<li><a href="https://juejin.im/post/6844903622870827022#heading-1">非转义序列的模板字符串</a></li>
</ul>
<h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><p>在<code>async/await</code>的某些时刻，你可能尝试在同步循环中调用异步函数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不会正常运行，下面这段同样也不会：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> i =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> doSomething(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。</p>
<p>ES2018 引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了<code>next()</code>方法返回一个Promise。因此<code>await</code>可以和<code>for...of</code>循环一起使用，以串行的方式运行异步操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> array) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a>Promise.finally()</h3><p>一个 Promise 调用链要么成功到达最后一个<code>.then()</code>，要么失败触发<code>.catch()</code>。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。</p>
<p><code>.finally()</code>允许你指定最终的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doSomething1()</span><br><span class="line">  .then(doSomething2)</span><br><span class="line">  .then(doSomething3)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// finish here!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rest-Spread-属性"><a href="#Rest-Spread-属性" class="headerlink" title="Rest/Spread 属性"></a>Rest/Spread 属性</h3><p>ES2015 引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters">Rest参数</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">扩展运算符</a>。三个点（…）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">p1, p2, ...p3</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// p1 = 1</span></span><br><span class="line">  <span class="comment">// p2 = 2</span></span><br><span class="line">  <span class="comment">// p3 = [3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。例如<code>Math.max()</code>返回给定数字中的最大值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> values = [<span class="number">99</span>, <span class="number">100</span>, -<span class="number">1</span>, <span class="number">48</span>, <span class="number">16</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max(...values) ); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>ES2018 为对象解构提供了和数组一样的Rest参数（）和展开操作符，一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...x &#125; = myObject;</span><br><span class="line"><span class="comment">// a = 1</span></span><br><span class="line"><span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure>

<p>或者你可以使用它给函数传递参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">restParam(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restParam</span>(<span class="params">&#123; a, ...x &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// a = 1</span></span><br><span class="line">  <span class="comment">// x = &#123; b: 2, c: 3 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用。</p>
<p>扩展运算符可以在其他对象内使用，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj1, <span class="attr">z</span>: <span class="number">26</span> &#125;;</span><br><span class="line"><span class="comment">// obj2 is &#123; a: 1, b: 2, c: 3, z: 26 &#125;</span></span><br></pre></td></tr></table></figure>

<p>可以使用扩展运算符拷贝一个对象，像是这样<code>obj2 = &#123;...obj1&#125;</code>，但是 <strong>这只是一个对象的浅拷贝</strong>。另外，如果一个对象A的属性是对象B，那么在克隆后的对象 cloneB 中，该属性指向对象B。</p>
<h3 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h3><p>JavaScript 正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以<code>YYYY-MM-DD</code>的格式解析日期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/([0-9]&#123;4&#125;)-([0-9]&#123;2&#125;)-([0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year   = match[<span class="number">1</span>], <span class="comment">// 2018</span></span><br><span class="line">  month  = match[<span class="number">2</span>], <span class="comment">// 04</span></span><br><span class="line">  day    = match[<span class="number">3</span>]; <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。</p>
<p>ES2018 允许命名捕获组使用符号<code>?&lt;name&gt;</code>，在打开捕获括号<code>(</code>后立即命名，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  match  = reDate.exec(<span class="string">&#x27;2018-04-30&#x27;</span>),</span><br><span class="line">  year   = match.groups.year,  <span class="comment">// 2018</span></span><br><span class="line">  month  = match.groups.month, <span class="comment">// 04</span></span><br><span class="line">  day    = match.groups.day;   <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>任何匹配失败的命名组都将返回<code>undefined</code>。</p>
<p>命名捕获也可以使用在<code>replace()</code>方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reDate = <span class="regexp">/(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/</span>,</span><br><span class="line">  d      = <span class="string">&#x27;2018-04-30&#x27;</span>,</span><br><span class="line">  usDate = d.replace(reDate, <span class="string">&#x27;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="正则表达式反向断言"><a href="#正则表达式反向断言" class="headerlink" title="正则表达式反向断言"></a>正则表达式反向断言</h3><p>目前 JavaScript 在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookahead = <span class="regexp">/\D(?=\d+)/</span>,</span><br><span class="line">  match       = reLookahead.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// $</span></span><br></pre></td></tr></table></figure>

<p>ES2018 引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehind = <span class="regexp">/(?&lt;=\D)\d+/</span>,</span><br><span class="line">  match        = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// 123.89</span></span><br></pre></td></tr></table></figure>

<p>以上是 <strong>肯定反向断言</strong>，非数字<code>\D</code>必须存在。同样的，还存在 <strong>否定反向断言</strong>，表示一个值必须不存在，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">  reLookbehindNeg = <span class="regexp">/(?&lt;!\D)\d+/</span>,</span><br><span class="line">  match           = reLookbehind.exec(<span class="string">&#x27;$123.89&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( match[<span class="number">0</span>] ); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式dotAll模式"><a href="#正则表达式dotAll模式" class="headerlink" title="正则表达式dotAll模式"></a>正则表达式dotAll模式</h3><p>正则表达式中点<code>.</code>匹配除回车外的任何单字符，标记<code>s</code>改变这种行为，允许行终止符的出现，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/hello.world/.test(<span class="string">&#x27;hello\nworld&#x27;</span>);  <span class="comment">// false</span></span><br><span class="line">/hello.world/s.test(<span class="string">&#x27;hello\nworld&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h3><p>到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为<code>\p&#123;...&#125;</code>和<code>\P&#123;...&#125;</code>，在正则表达式中使用标记 <code>u</code> (unicode) 设置，在<code>\p</code>块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">reGreekSymbol.test(<span class="string">&#x27;π&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>此特性可以避免使用特定 Unicode 区间来进行内容类型判断，提升可读性和可维护性。</p>
<h3 id="非转义序列的模板字符串"><a href="#非转义序列的模板字符串" class="headerlink" title="非转义序列的模板字符串"></a>非转义序列的模板字符串</h3><p>之前，<code>\u</code>开始一个 unicode 转义，<code>\x</code>开始一个十六进制转义，<code>\</code>后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 <code>C:\uuu\xxx\111</code>。更多细节参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings">模板字符串</a>。</p>
<h2 id="ES10新特性（2019）"><a href="#ES10新特性（2019）" class="headerlink" title="ES10新特性（2019）"></a>ES10新特性（2019）</h2><ul>
<li>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</li>
<li>更加友好的 JSON.stringify</li>
<li>新增了Array的<code>flat()</code>方法和<code>flatMap()</code>方法</li>
<li>新增了String的<code>trimStart()</code>方法和<code>trimEnd()</code>方法</li>
<li><code>Object.fromEntries()</code></li>
<li><code>Symbol.prototype.description</code></li>
<li><code>String.prototype.matchAll</code></li>
<li><code>Function.prototype.toString()</code>现在返回精确字符，包括空格和注释</li>
<li>简化<code>try &#123;&#125; catch &#123;&#125;</code>,修改 <code>catch</code> 绑定</li>
<li>新的基本数据类型<code>BigInt</code></li>
<li>globalThis</li>
<li>import()</li>
<li>Legacy RegEx</li>
<li>私有的实例方法和访问器</li>
</ul>
<h3 id="行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与-JSON-匹配"><a href="#行分隔符（U-2028）和段分隔符（U-2029）符号现在允许在字符串文字中，与-JSON-匹配" class="headerlink" title="行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配"></a>行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与 JSON 匹配</h3><p>以前，这些符号在字符串文字中被视为行终止符，因此使用它们会导致 SyntaxError 异常。</p>
<h3 id="更加友好的-JSON-stringify"><a href="#更加友好的-JSON-stringify" class="headerlink" title="更加友好的 JSON.stringify"></a>更加友好的 JSON.stringify</h3><p>如果输入 Unicode 格式但是超出范围的字符，在原先 JSON.stringify 返回格式错误的Unicode 字符串。现在实现了一个改变 JSON.stringify 的<a href="https://github.com/tc39/proposal-well-formed-stringify">第3阶段提案</a>，因此它为其输出转义序列，使其成为有效Unicode（并以UTF-8表示）</p>
<h3 id="新增了-Array-的-flat-方法和-flatMap-方法"><a href="#新增了-Array-的-flat-方法和-flatMap-方法" class="headerlink" title="新增了 Array 的 flat() 方法和 flatMap() 方法"></a>新增了 Array 的 flat() 方法和 flatMap() 方法</h3><p><code>flat()</code> 和 <code>flatMap()</code>本质上就是是归纳（reduce） 与 合并（concat）的操作。</p>
<h4 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat()"></a>Array.prototype.flat()</h4><p><code>flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<ul>
<li><code>flat()</code>方法最基本的作用就是数组降维</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line">arr1.flat(); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr2.flat();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr3.flat(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Infinity 作为深度，展开任意深度的嵌套数组</span></span><br><span class="line">arr3.flat(<span class="literal">Infinity</span>); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>其次，还可以利用<code>flat()</code>方法的特性来去除数组的空项</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr4.flat();</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap()"></a>Array.prototype.flatMap()</h4><p><code>flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1 的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。 这里我们拿map方法与flatMap方法做一个比较。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]); </span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只会将 flatMap 中的函数返回的数组 “压平” 一层</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]);</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

<h3 id="新增了String的-trimStart-方法和-trimEnd-方法"><a href="#新增了String的-trimStart-方法和-trimEnd-方法" class="headerlink" title="新增了String的 trimStart() 方法和 trimEnd() 方法"></a>新增了String的 trimStart() 方法和 trimEnd() 方法</h3><p>新增的这两个方法很好理解，分别去除字符串首尾空白字符。</p>
<h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h3><p><code>Object.entries()</code>方法的作用是返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。</p>
<p><strong>而<code>Object.fromEntries()</code> 则是 <code>Object.entries()</code> 的反转。</strong></p>
<p><code>Object.fromEntries()</code> 函数传入一个键值对的列表，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类似数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。</p>
<ul>
<li>通过 Object.fromEntries， 可以将 Map 转化为 Object:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([ [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>] ]);</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(map);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过 Object.fromEntries， 可以将 Array 转化为 Object:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [ [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;a&#x27;</span>], [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], [<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] ];</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h3><p>通过工厂函数 Symbol() 创建符号时，您可以选择通过参数提供字符串作为描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">&#x27;The description&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>以前，访问描述的唯一方法是将符号转换为字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(<span class="built_in">String</span>(sym), <span class="string">&#x27;Symbol(The description)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>现在引入了getter Symbol.prototype.description 以直接访问描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">assert.equal(sym.description, <span class="string">&#x27;The description&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h3><p><code>matchAll()</code> 方法返回一个包含所有匹配正则表达式及分组捕获结果的迭代器。 在 matchAll 出现之前，通过在循环中调用 regexp.exec 来获取所有匹配项信息（ regexp 需使用 /g 标志：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((matches = regexp.exec(str)) !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Found <span class="subst">$&#123;matches[<span class="number">0</span>]&#125;</span>. Next starts at <span class="subst">$&#123;regexp.lastIndex&#125;</span>.`</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 9.&quot;</span></span><br><span class="line">  <span class="comment">// expected output: &quot;Found foo. Next starts at 19.&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用 matchAll ，就可以不必使用 while 循环加 exec 方式（且正则表达式需使用／g标志）。使用 matchAll 会得到一个迭代器的返回值，配合 for…of，array spread，or Array.from() 可以更方便实现功能：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> regexp = <span class="built_in">RegExp</span>(<span class="string">&#x27;foo*&#x27;</span>,<span class="string">&#x27;g&#x27;</span>); </span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;table football, foosball&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> matches) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot; ]</span></span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// matches iterator is exhausted after the for..of iteration</span></span><br><span class="line"><span class="comment">// Call matchAll again to create a new iterator</span></span><br><span class="line">matches = str.matchAll(regexp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(matches, <span class="function"><span class="params">m</span> =&gt;</span> m[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// Array [ &quot;foo&quot;, &quot;foo&quot; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="matchAll-可以更好的用于分组"><a href="#matchAll-可以更好的用于分组" class="headerlink" title="matchAll 可以更好的用于分组"></a>matchAll 可以更好的用于分组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;test1test2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str.match(regexp); </span><br><span class="line"><span class="comment">// Array [&#x27;test1&#x27;, &#x27;test2&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> array = [...str.matchAll(regexp)];</span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// [&#x27;test1&#x27;, &#x27;e&#x27;, &#x27;st1&#x27;, &#x27;1&#x27;, index: 0, input: &#x27;test1test2&#x27;, length: 4]</span></span><br><span class="line">array[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// [&#x27;test2&#x27;, &#x27;e&#x27;, &#x27;st2&#x27;, &#x27;2&#x27;, index: 5, input: &#x27;test1test2&#x27;, length: 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-prototype-toString-现在返回精确字符，包括空格和注释"><a href="#Function-prototype-toString-现在返回精确字符，包括空格和注释" class="headerlink" title="Function.prototype.toString() 现在返回精确字符，包括空格和注释"></a>Function.prototype.toString() 现在返回精确字符，包括空格和注释</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">comment</span> */ <span class="title">foo</span> /* <span class="title">another</span> <span class="title">comment</span> */(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前不会打印注释部分</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">// function foo()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2019 会把注释一同打印</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.toString()); <span class="comment">// function /* comment */ foo /* another comment */ ()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> bar <span class="comment">/* comment */</span> = <span class="comment">/* another comment */</span> <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar.toString()); <span class="comment">// () =&gt; &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-catch-绑定"><a href="#修改-catch-绑定" class="headerlink" title="修改 catch 绑定"></a>修改 catch 绑定</h3><p>在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10 提案使我们能够简单的把变量省略掉。</p>
<p>不算大的改动。</p>
<p>之前是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>现在是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;&#125; <span class="keyword">catch</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新的基本数据类型-BigInt"><a href="#新的基本数据类型-BigInt" class="headerlink" title="新的基本数据类型 BigInt"></a>新的基本数据类型 BigInt</h3><p>现在的基本数据类型（值类型）不止5种（ES6之后是六种），加上 BigInt 一共有七种基本数据类型，分别是： String、Number、Boolean、Null、Undefined、Symbol、BigInt</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ECMAScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa Hibernate加载过程与配置项</title>
    <url>/2020/11/20/SpringDataJpa%E7%9A%84Hibernate%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-Hibernate加载过程与配置项"><a href="#Spring-Data-Jpa-Hibernate加载过程与配置项" class="headerlink" title="Spring Data Jpa Hibernate加载过程与配置项"></a>Spring Data Jpa Hibernate加载过程与配置项</h1><h2 id="Hibernate-架构分析"><a href="#Hibernate-架构分析" class="headerlink" title="Hibernate 架构分析"></a>Hibernate 架构分析</h2><p>首先看一下 Hibernate 官方提供的架构图</p>
<p><img src="http://image.leonote.cn/20201120152718.png" alt=""></p>
<p>从架构图上可以知道 Hibernate 实现的 ORM 的接口有两种：</p>
<ul>
<li>Hibernate 自己的 API 接口</li>
<li>Java Persistence API 的接口</li>
</ul>
<p>Hibernate 比 Java Persistence API 早几年发展的，后来才有了 Java 的持久化协议，Hibernate 是 Spring Data JPA 持久化操作的核心。</p>
<p>再从类上面具体看一下，关键类的图如下所示：</p>
<p><img src="http://image.leonote.cn/20201120152958.png" alt=""></p>
<p>结合类的关系图来看，Session 接口和 SessionFactory 接口都是 Hibernate 的概念，而 EntityManger 和 EntityManagerFactory 都是 Java Persistence API 协议规定的接口。</p>
<p>不过 HibernateEntityManger 从 Hibernate 5.2 之后就开始不推荐使用了，而是建议直接使用 EntityManager 接口即可。那么我们看看 Hibernate 在 Spring BOOT 里面是如何被加载进去的。</p>
<h2 id="Hibernate-5-在-Spring-Boot-2-里面的加载过程"><a href="#Hibernate-5-在-Spring-Boot-2-里面的加载过程" class="headerlink" title="Hibernate 5 在 Spring Boot 2 里面的加载过程"></a>Hibernate 5 在 Spring Boot 2 里面的加载过程</h2><p>不同的 Spring Boot 版本，可能加载类的实现逻辑是不一样的，但是分析过程都是相同的。</p>
<p>先打开 spring.factories 文件，如下图所示，其中可以自动加载 Hibernate 的只有一个类，那就是 <code>HibernateJpaAutoConfiguration</code>。</p>
<p><img src="http://image.leonote.cn/20201120153722.png" alt=""></p>
<p><code>HibernateJpaAutoConfiguration</code> 就是 Spring Boot 加载 Hibernate 的主要入口，所以可以直接打开这个类看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; LocalContainerEntityManagerFactoryBean.class, EntityManager.class, SessionImplementor.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JpaProperties.class)</span><span class="comment">//JPAProperties的配置</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@Import(HibernateJpaConfiguration.class)</span> <span class="comment">//hibernate加载的关键类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateJpaAutoConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，第一个需要关注的就是 JpaProperties 类，因为通过这个类可以间接知道，application.properties 里面可以配置的 spring.jpa 的属性有哪些。</p>
<h3 id="JpaProperties-属性"><a href="#JpaProperties-属性" class="headerlink" title="JpaProperties 属性"></a>JpaProperties 属性</h3><p>打开 JpaProperties 类看一下，如下图所示。</p>
<p><img src="http://image.leonote.cn/20201120153919.png" alt=""></p>
<p>通过这个类，我们可以在 application.properties 里面得到如下配置项。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以配置JPA的实现者的原始属性的配置，如：这里用的JPA的实现者是hibernate</span></span><br><span class="line"><span class="comment"># 那么hibernate里面的一些属性设置就可以通过如下方式实现</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">none</span></span><br><span class="line"><span class="comment">#hibernate的persistence.xml文件有哪些，目前已经不推荐使用</span></span><br><span class="line"><span class="comment">#spring.jpa.mapping-resources=</span></span><br><span class="line"><span class="comment"># 指定数据源的类型，如果不指定，Spring Boot加载Datasource的时候会根据URL的协议自己判断</span></span><br><span class="line"><span class="comment"># 如：spring.datasource.url=jdbc:mysql://localhost:3306/test 上面可以明确知道是mysql数据源，所以这个可以不需要指定；</span></span><br><span class="line"><span class="comment"># 应用场景，当我们通过代理的方式，可能通过datasource.url没办法判断数据源类型的时候，可以通过如下方式指定，可选的值有：DB2,H2,HSQL,INFORMIX,MYSQL,ORACLE,POSTGRESQL,SQL_SERVER,SYBASE)</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"># 是否在启动阶段根据实体初始化数据库的schema，默认false，当我们用内存数据库做测试的时候可以打开，很有用</span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 和spring.jpa.database用法差不多，指定数据库的平台，默认会自己发现；一般不需要指定，database-platform指定的必须是org.hibernate.dialect.Dialect的子类，如mysql默认是用下面的platform</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>=<span class="string">org.hibernate.dialect.MySQLInnoDBDialect</span></span><br><span class="line"><span class="comment"># 是否在view层打开session，默认是true，其实大部分场景不需要打开，可以设置成false，</span></span><br><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 是否显示sql，当执行JPA的数据库操作的时候，默认是false，在本地开发的时候我们可以把这个打开，有助于分析sql是不是我们预期的</span></span><br><span class="line"><span class="comment"># 在生产环境的时候建议给这个设置成false，改由logging.level.org.hibernate.SQL=DEBUG代替，这样的话日志默认是基于logback输出的</span></span><br><span class="line"><span class="comment"># 而不是直接打印到控制台的，有利于增加traceId和线程ID等信息，便于分析</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>其中，spring.jpa.show-sql=true 输出的 sql 效果如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hibernate: insert into user_info (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>上面是单线程的 System.out.println 的效果，如果是在线上环境，多线程的情况下就不知道是哪个线程输出来的，而 <code>logging.level.org.hibernate.SQL=DEBUG</code> 输出的 sql 效果如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2020-11-08 16:54:22.275 DEBUG 6589 --- [nio-8087-exec-1] org.hibernate.SQL </span><br></pre></td></tr></table></figure>

<p>这样可以轻易知道线程 ID 和执行时间，甚至可以有 tranceID 和 spanID 进行日志跟踪，方便分析是哪个线程打印的。</p>
<h3 id="HibernateJpaConfiguration-分析"><a href="#HibernateJpaConfiguration-分析" class="headerlink" title="HibernateJpaConfiguration 分析"></a>HibernateJpaConfiguration 分析</h3><p>它是通过 HibernateJpaAutoConfiguration 里面的 <code>@Import(HibernateJpaConfiguration.class)</code> 导入进来加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HibernateProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HibernateJpaConfiguration</span> <span class="keyword">extends</span> <span class="title">JpaBaseConfiguration</span> </span>&#123;</span><br><span class="line">...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码可以得到 Hibernate 在 JPA 中配置的三个重要线索</p>
<p><strong>第一个线索：HibernateProperties 这个配置类对应的是 spring.jpa.hibernate 的配置</strong></p>
<p><code>@EnableConfigurationProperties(HibernateProperties.class)</code> 启用了 HibernateProperties 的配置类，如下图所示。</p>
<p><img src="http://image.leonote.cn/20201120155250.png" alt=""></p>
<p>其中可以看到 application.properties 的配置项，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># naming 的物理策略值有：org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy(默认)和org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.physical-strategy</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># ddl的生成策略，默认none；如果我们没有指定任何数据源的url，采用的是spring的集成数据源，也就是内存数据源H2的时候，默认值是create-drop;</span></span><br><span class="line"><span class="comment"># 所以当我们每次用H2的时候什么都没做，它就会自动帮我们创建表等，内存数据库和写测试用的时候，create-drop就非常方便了；不过，生产数据库一定要设置成none;</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 当 @Id 配置成 @GeneratedValue(strategy= GenerationType.AUTO) 的时候</span></span><br><span class="line"><span class="comment"># 是否采用 hibernate 的 Id-generator-mappings(即会默认帮我们创建一张表hibernate_sequence来存储和生成ID)，默认是true</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.use-new-id-generator-mappings</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>第二个线索：HibernateJpaConfiguration 的父类 JpaBaseConfiguration 也会优先加载，此类就是 Spring Boot 加载 JPA 的核心逻辑</strong></p>
<p>打开 JpaBaseConfiguration 类看一下源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(JpaProperties.class)</span></span><br><span class="line"><span class="comment">// DataSourceInitializedPublisher 用来进行数据源的初始化操作</span></span><br><span class="line"><span class="meta">@Import(DataSourceInitializedPublisher.Registrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaBaseConfiguration</span> <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">JpaBaseConfiguration</span><span class="params">(DataSource dataSource, JpaProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">      ObjectProvider&lt;JtaTransactionManager&gt; jtaTransactionManager)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">   <span class="keyword">this</span>.properties = properties;</span><br><span class="line">   <span class="comment">//jtaTransactionManager 赋值，正常情况下我们用不到，一般用来解决分布式事务的场景才会用到。</span></span><br><span class="line">   <span class="keyword">this</span>.jtaTransactionManager = jtaTransactionManager.getIfAvailable(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载 JPA 的实现方式</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JpaVendorAdapter <span class="title">jpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//createJpaVendorAdapter 是由子类 HibernateJpaConfiguration 实现的，创建JPA的实现类</span></span><br><span class="line">   AbstractJpaVendorAdapter adapter = createJpaVendorAdapter();</span><br><span class="line">   adapter.setShowSql(<span class="keyword">this</span>.properties.isShowSql());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.properties.getDatabase() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      adapter.setDatabase(<span class="keyword">this</span>.properties.getDatabase());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.properties.getDatabasePlatform() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   adapter.setDatabasePlatform(<span class="keyword">this</span>.properties.getDatabasePlatform());</span><br><span class="line">   &#125;</span><br><span class="line">   adapter.setGenerateDdl(<span class="keyword">this</span>.properties.isGenerateDdl());</span><br><span class="line">   <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Import(DataSourceInitializedPublisher.Registrar.class)</code> 是用来初始化数据的；从构造函数中也可以看到其是否有用到 <code>jtaTransactionManager</code>（这个是分布式事务才会用到）；而 createJpaVendorAdapter() 是在 HibernateJpaConfiguration 里面实现的，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HibernateJpaConfiguration</span> <span class="keyword">extends</span> <span class="title">JpaBaseConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里是hibernate和Jpa的结合，可以看到使用的HibernateJpaVendorAdapter作为JPA的实现者，可以打开HibernateJpaVendorAdapter里面设置一些断点，就会知道Spring boot是如何一步一步加载Hibernate的了；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AbstractJpaVendorAdapter <span class="title">createJpaVendorAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经知道了 HibernateJpaVendorAdapter 的加载逻辑，而 HibernateJpaVendorAdapter 里面实现了 Hibernate 的初始化逻辑</p>
<p><strong>第三个线索：spring.jpa.properties 配置项有哪些</strong></p>
<p>如果接着在 HibernateJpaConfiguration 类里面 debug 查看关键代码的话，可以找到如下代码：</p>
<p><img src="http://image.leonote.cn/20201120163348.png" alt=""></p>
<p>上图中的代码显示，JpaProperties 类里面的 properties 属性，也就是 spring.jpa.properties 的配置加载到了 vendorProperties 里面。而 properties 里面是 HashMap 结构，那么它都可以支持哪些配置呢？</p>
<p>打开 org.hibernate.cfg.AvailableSettings 可以看到 Hibernate 支持的配置项大概有 100 多个配置信息，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">String</span> <span class="string">JPA_PERSISTENCE_PROVIDER = &quot;javax.persistence.provider&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_TRANSACTION_TYPE = &quot;javax.persistence.transactionType&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_JTA_DATASOURCE = &quot;javax.persistence.jtaDataSource&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_NON_JTA_DATASOURCE = &quot;javax.persistence.nonJtaDataSource&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_JDBC_DRIVER = &quot;javax.persistence.jdbc.driver&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_JDBC_URL = &quot;javax.persistence.jdbc.url&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_JDBC_USER = &quot;javax.persistence.jdbc.user&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_JDBC_PASSWORD = &quot;javax.persistence.jdbc.password&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_SHARED_CACHE_MODE = &quot;javax.persistence.sharedCache.mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_SHARED_CACHE_RETRIEVE_MODE =&quot;javax.persistence.cache.retrieveMode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_SHARED_CACHE_STORE_MODE =&quot;javax.persistence.cache.storeMode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_VALIDATION_MODE = &quot;javax.persistence.validation.mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_VALIDATION_FACTORY = &quot;javax.persistence.validation.factory&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_PERSIST_VALIDATION_GROUP = &quot;javax.persistence.validation.group.pre-persist&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_UPDATE_VALIDATION_GROUP = &quot;javax.persistence.validation.group.pre-update&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_REMOVE_VALIDATION_GROUP = &quot;javax.persistence.validation.group.pre-remove&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_LOCK_SCOPE = &quot;javax.persistence.lock.scope&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_LOCK_TIMEOUT = &quot;javax.persistence.lock.timeout&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CDI_BEAN_MANAGER = &quot;javax.persistence.bean.manager&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CLASSLOADERS = &quot;hibernate.classLoaders&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">TC_CLASSLOADER = &quot;hibernate.classLoader.tccl_lookup_precedence&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">APP_CLASSLOADER = &quot;hibernate.classLoader.application&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">RESOURCES_CLASSLOADER = &quot;hibernate.classLoader.resources&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HIBERNATE_CLASSLOADER = &quot;hibernate.classLoader.hibernate&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ENVIRONMENT_CLASSLOADER = &quot;hibernate.classLoader.environment&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_METAMODEL_GENERATION = &quot;hibernate.ejb.metamodel.generation&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_METAMODEL_POPULATION = &quot;hibernate.ejb.metamodel.population&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">STATIC_METAMODEL_POPULATION = &quot;hibernate.jpa.static_metamodel.population&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CONNECTION_PROVIDER =&quot;hibernate.connection.provider_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DRIVER =&quot;hibernate.connection.driver_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">URL =&quot;hibernate.connection.url&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USER =&quot;hibernate.connection.username&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PASS =&quot;hibernate.connection.password&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ISOLATION =&quot;hibernate.connection.isolation&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">AUTOCOMMIT = &quot;hibernate.connection.autocommit&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">POOL_SIZE =&quot;hibernate.connection.pool_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DATASOURCE =&quot;hibernate.connection.datasource&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CONNECTION_PROVIDER_DISABLES_AUTOCOMMIT= &quot;hibernate.connection.provider_disables_autocommit&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CONNECTION_PREFIX = &quot;hibernate.connection&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JNDI_CLASS =&quot;hibernate.jndi.class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JNDI_URL =&quot;hibernate.jndi.url&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JNDI_PREFIX = &quot;hibernate.jndi&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DIALECT =&quot;hibernate.dialect&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DIALECT_RESOLVERS = &quot;hibernate.dialect_resolvers&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">STORAGE_ENGINE = &quot;hibernate.dialect.storage_engine&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SCHEMA_MANAGEMENT_TOOL = &quot;hibernate.schema_management_tool&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">TRANSACTION_COORDINATOR_STRATEGY = &quot;hibernate.transaction.coordinator_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JTA_PLATFORM = &quot;hibernate.transaction.jta.platform&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PREFER_USER_TRANSACTION = &quot;hibernate.jta.prefer_user_transaction&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JTA_PLATFORM_RESOLVER = &quot;hibernate.transaction.jta.platform_resolver&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JTA_CACHE_TM = &quot;hibernate.jta.cacheTransactionManager&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JTA_CACHE_UT = &quot;hibernate.jta.cacheUserTransaction&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JDBC_TYLE_PARAMS_ZERO_BASE = &quot;hibernate.query.sql.jdbc_style_params_base&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_CATALOG = &quot;hibernate.default_catalog&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_SCHEMA = &quot;hibernate.default_schema&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_CACHE_CONCURRENCY_STRATEGY = &quot;hibernate.cache.default_cache_concurrency_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_NEW_ID_GENERATOR_MAPPINGS = &quot;hibernate.id.new_generator_mappings&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">FORCE_DISCRIMINATOR_IN_SELECTS_BY_DEFAULT = &quot;hibernate.discriminator.force_in_select&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">IMPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS = &quot;hibernate.discriminator.implicit_for_joined&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">IGNORE_EXPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS = &quot;hibernate.discriminator.ignore_explicit_for_joined&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_NATIONALIZED_CHARACTER_DATA = &quot;hibernate.use_nationalized_character_data&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SCANNER_DEPRECATED = &quot;hibernate.ejb.resource_scanner&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SCANNER = &quot;hibernate.archive.scanner&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SCANNER_ARCHIVE_INTERPRETER = &quot;hibernate.archive.interpreter&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SCANNER_DISCOVERY = &quot;hibernate.archive.autodetection&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">IMPLICIT_NAMING_STRATEGY = &quot;hibernate.implicit_naming_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PHYSICAL_NAMING_STRATEGY = &quot;hibernate.physical_naming_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ARTIFACT_PROCESSING_ORDER = &quot;hibernate.mapping.precedence&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">KEYWORD_AUTO_QUOTING_ENABLED = &quot;hibernate.auto_quote_keyword&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">XML_MAPPING_ENABLED = &quot;hibernate.xml_mapping_enabled&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SESSION_FACTORY_NAME = &quot;hibernate.session_factory_name&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SESSION_FACTORY_NAME_IS_JNDI = &quot;hibernate.session_factory_name_is_jndi&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SHOW_SQL =&quot;hibernate.show_sql&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">FORMAT_SQL =&quot;hibernate.format_sql&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_SQL_COMMENTS =&quot;hibernate.use_sql_comments&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">MAX_FETCH_DEPTH = &quot;hibernate.max_fetch_depth&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_BATCH_FETCH_SIZE = &quot;hibernate.default_batch_fetch_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_STREAMS_FOR_BINARY = &quot;hibernate.jdbc.use_streams_for_binary&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_SCROLLABLE_RESULTSET = &quot;hibernate.jdbc.use_scrollable_resultset&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_GET_GENERATED_KEYS = &quot;hibernate.jdbc.use_get_generated_keys&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">STATEMENT_FETCH_SIZE = &quot;hibernate.jdbc.fetch_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">STATEMENT_BATCH_SIZE = &quot;hibernate.jdbc.batch_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">BATCH_STRATEGY = &quot;hibernate.jdbc.factory_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">BATCH_VERSIONED_DATA = &quot;hibernate.jdbc.batch_versioned_data&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JDBC_TIME_ZONE = &quot;hibernate.jdbc.time_zone&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">AUTO_CLOSE_SESSION = &quot;hibernate.transaction.auto_close_session&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">FLUSH_BEFORE_COMPLETION = &quot;hibernate.transaction.flush_before_completion&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ACQUIRE_CONNECTIONS = &quot;hibernate.connection.acquisition_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">RELEASE_CONNECTIONS = &quot;hibernate.connection.release_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CONNECTION_HANDLING = &quot;hibernate.connection.handling_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CURRENT_SESSION_CONTEXT_CLASS = &quot;hibernate.current_session_context_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_IDENTIFIER_ROLLBACK = &quot;hibernate.use_identifier_rollback&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_REFLECTION_OPTIMIZER = &quot;hibernate.bytecode.use_reflection_optimizer&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ENFORCE_LEGACY_PROXY_CLASSNAMES = &quot;hibernate.bytecode.enforce_legacy_proxy_classnames&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ALLOW_ENHANCEMENT_AS_PROXY = &quot;hibernate.bytecode.allow_enhancement_as_proxy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_TRANSLATOR = &quot;hibernate.query.factory_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_SUBSTITUTIONS = &quot;hibernate.query.substitutions&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_STARTUP_CHECKING = &quot;hibernate.query.startup_check&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CONVENTIONAL_JAVA_CONSTANTS = &quot;hibernate.query.conventional_java_constants&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SQL_EXCEPTION_CONVERTER = &quot;hibernate.jdbc.sql_exception_converter&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">WRAP_RESULT_SETS = &quot;hibernate.jdbc.wrap_result_sets&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">NATIVE_EXCEPTION_HANDLING_51_COMPLIANCE = &quot;hibernate.native_exception_handling_51_compliance&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ORDER_UPDATES = &quot;hibernate.order_updates&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ORDER_INSERTS = &quot;hibernate.order_inserts&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_CALLBACKS_ENABLED = &quot;hibernate.jpa_callbacks.enabled&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_NULL_ORDERING = &quot;hibernate.order_by.default_null_ordering&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">LOG_JDBC_WARNINGS =  &quot;hibernate.jdbc.log.warnings&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">BEAN_CONTAINER = &quot;hibernate.resource.beans.container&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_CONFIG_PREFIX = &quot;hibernate.c3p0&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_MAX_SIZE = &quot;hibernate.c3p0.max_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_MIN_SIZE = &quot;hibernate.c3p0.min_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_TIMEOUT = &quot;hibernate.c3p0.timeout&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_MAX_STATEMENTS = &quot;hibernate.c3p0.max_statements&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_ACQUIRE_INCREMENT = &quot;hibernate.c3p0.acquire_increment&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">C3P0_IDLE_TEST_PERIOD = &quot;hibernate.c3p0.idle_test_period&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_CONFIG_PREFIX = &quot;hibernate.proxool&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_PREFIX = PROXOOL_CONFIG_PREFIX;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_XML = &quot;hibernate.proxool.xml&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_PROPERTIES = &quot;hibernate.proxool.properties&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_EXISTING_POOL = &quot;hibernate.proxool.existing_pool&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROXOOL_POOL_ALIAS = &quot;hibernate.proxool.pool_alias&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CACHE_REGION_FACTORY = &quot;hibernate.cache.region.factory_class&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CACHE_KEYS_FACTORY = &quot;hibernate.cache.keys_factory&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CACHE_PROVIDER_CONFIG = &quot;hibernate.cache.provider_configuration_file_resource_path&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_SECOND_LEVEL_CACHE = &quot;hibernate.cache.use_second_level_cache&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_QUERY_CACHE = &quot;hibernate.cache.use_query_cache&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_CACHE_FACTORY = &quot;hibernate.cache.query_cache_factory&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CACHE_REGION_PREFIX = &quot;hibernate.cache.region_prefix&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_MINIMAL_PUTS = &quot;hibernate.cache.use_minimal_puts&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_STRUCTURED_CACHE = &quot;hibernate.cache.use_structured_entries&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">AUTO_EVICT_COLLECTION_CACHE = &quot;hibernate.cache.auto_evict_collection_cache&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_DIRECT_REFERENCE_CACHE_ENTRIES = &quot;hibernate.cache.use_reference_entries&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEFAULT_ENTITY_MODE = &quot;hibernate.default_entity_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">GLOBALLY_QUOTED_IDENTIFIERS = &quot;hibernate.globally_quoted_identifiers&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">GLOBALLY_QUOTED_IDENTIFIERS_SKIP_COLUMN_DEFINITIONS = &quot;hibernate.globally_quoted_identifiers_skip_column_definitions&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CHECK_NULLABILITY = &quot;hibernate.check_nullability&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">BYTECODE_PROVIDER = &quot;hibernate.bytecode.provider&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPAQL_STRICT_COMPLIANCE= &quot;hibernate.query.jpaql_strict_compliance&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PREFER_POOLED_VALUES_LO = &quot;hibernate.id.optimizer.pooled.prefer_lo&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PREFERRED_POOLED_OPTIMIZER = &quot;hibernate.id.optimizer.pooled.preferred&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_PLAN_CACHE_MAX_STRONG_REFERENCES = &quot;hibernate.query.plan_cache_max_strong_references&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_PLAN_CACHE_MAX_SOFT_REFERENCES = &quot;hibernate.query.plan_cache_max_soft_references&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_PLAN_CACHE_MAX_SIZE = &quot;hibernate.query.plan_cache_max_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE = &quot;hibernate.query.plan_parameter_metadata_max_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">NON_CONTEXTUAL_LOB_CREATION = &quot;hibernate.jdbc.lob.non_contextual_creation&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_AUTO = &quot;hibernate.hbm2ddl.auto&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DATABASE_ACTION = &quot;javax.persistence.schema-generation.database.action&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_SCRIPTS_ACTION = &quot;javax.persistence.schema-generation.scripts.action&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CONNECTION = &quot;javax.persistence.schema-generation-connection&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DB_NAME = &quot;javax.persistence.database-product-name&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DB_MAJOR_VERSION = &quot;javax.persistence.database-major-version&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DB_MINOR_VERSION = &quot;javax.persistence.database-minor-version&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CREATE_SOURCE = &quot;javax.persistence.schema-generation.create-source&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DROP_SOURCE = &quot;javax.persistence.schema-generation.drop-source&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CREATE_SCRIPT_SOURCE = &quot;javax.persistence.schema-generation.create-script-source&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DROP_SCRIPT_SOURCE = &quot;javax.persistence.schema-generation.drop-script-source&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_SCRIPTS_CREATE_TARGET = &quot;javax.persistence.schema-generation.scripts.create-target&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_SCRIPTS_DROP_TARGET = &quot;javax.persistence.schema-generation.scripts.drop-target&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_IMPORT_FILES = &quot;hibernate.hbm2ddl.import_files&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_LOAD_SCRIPT_SOURCE = &quot;javax.persistence.sql-load-script-source&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_IMPORT_FILES_SQL_EXTRACTOR = &quot;hibernate.hbm2ddl.import_files_sql_extractor&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CREATE_NAMESPACES = &quot;hibernate.hbm2ddl.create_namespaces&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DLL_CREATE_NAMESPACES = &quot;hibernate.hbm2dll.create_namespaces&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CREATE_SCHEMAS = &quot;javax.persistence.create-database-schemas&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DLL_CREATE_SCHEMAS = HBM2DDL_CREATE_SCHEMAS;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_FILTER_PROVIDER = &quot;hibernate.hbm2ddl.schema_filter_provider&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_JDBC_METADATA_EXTRACTOR_STRATEGY = &quot;hibernate.hbm2ddl.jdbc_metadata_extraction_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_DELIMITER = &quot;hibernate.hbm2ddl.delimiter&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_CHARSET_NAME = &quot;hibernate.hbm2ddl.charset_name&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HBM2DDL_HALT_ON_ERROR = &quot;hibernate.hbm2ddl.halt_on_error&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_ENABLED = &quot;hibernate.jmx.enabled&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_PLATFORM_SERVER = &quot;hibernate.jmx.usePlatformServer&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_AGENT_ID = &quot;hibernate.jmx.agentId&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_DOMAIN_NAME = &quot;hibernate.jmx.defaultDomain&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_SF_NAME = &quot;hibernate.jmx.sessionFactoryName&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JMX_DEFAULT_OBJ_NAME_DOMAIN = &quot;org.hibernate.core&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CUSTOM_ENTITY_DIRTINESS_STRATEGY = &quot;hibernate.entity_dirtiness_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_ENTITY_WHERE_CLAUSE_FOR_COLLECTIONS = &quot;hibernate.use_entity_where_clause_for_collections&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">MULTI_TENANT = &quot;hibernate.multiTenancy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">MULTI_TENANT_CONNECTION_PROVIDER = &quot;hibernate.multi_tenant_connection_provider&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">MULTI_TENANT_IDENTIFIER_RESOLVER = &quot;hibernate.tenant_identifier_resolver&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">INTERCEPTOR = &quot;hibernate.session_factory.interceptor&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SESSION_SCOPED_INTERCEPTOR = &quot;hibernate.session_factory.session_scoped_interceptor&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">STATEMENT_INSPECTOR = &quot;hibernate.session_factory.statement_inspector&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ENABLE_LAZY_LOAD_NO_TRANS = &quot;hibernate.enable_lazy_load_no_trans&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">HQL_BULK_ID_STRATEGY = &quot;hibernate.hql.bulk_id_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">BATCH_FETCH_STYLE = &quot;hibernate.batch_fetch_style&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DELAY_ENTITY_LOADER_CREATIONS = &quot;hibernate.loader.delay_entity_loader_creations&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JTA_TRACK_BY_THREAD = &quot;hibernate.jta.track_by_thread&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JACC_CONTEXT_ID = &quot;hibernate.jacc_context_id&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JACC_PREFIX = &quot;hibernate.jacc&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JACC_ENABLED = &quot;hibernate.jacc.enabled&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ENABLE_SYNONYMS = &quot;hibernate.synonyms&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">EXTRA_PHYSICAL_TABLE_TYPES = &quot;hibernate.hbm2ddl.extra_physical_table_types&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">DEPRECATED_EXTRA_PHYSICAL_TABLE_TYPES = &quot;hibernate.hbm2dll.extra_physical_table_types&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">UNIQUE_CONSTRAINT_SCHEMA_UPDATE_STRATEGY = &quot;hibernate.schema_update.unique_constraint_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">GENERATE_STATISTICS = &quot;hibernate.generate_statistics&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">LOG_SESSION_METRICS = &quot;hibernate.session.events.log&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">LOG_SLOW_QUERY = &quot;hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">AUTO_SESSION_EVENTS_LISTENER = &quot;hibernate.session.events.auto&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PROCEDURE_NULL_PARAM_PASSING = &quot;hibernate.proc.param_null_passing&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CREATE_EMPTY_COMPOSITES_ENABLED = &quot;hibernate.create_empty_composites.enabled&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ALLOW_JTA_TRANSACTION_ACCESS = &quot;hibernate.jta.allowTransactionAccess&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ALLOW_UPDATE_OUTSIDE_TRANSACTION = &quot;hibernate.allow_update_outside_transaction&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">COLLECTION_JOIN_SUBQUERY = &quot;hibernate.collection_join_subquery&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">ALLOW_REFRESH_DETACHED_ENTITY = &quot;hibernate.allow_refresh_detached_entity&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">MERGE_ENTITY_COPY_OBSERVER = &quot;hibernate.event.merge.entity_copy_observer&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">USE_LEGACY_LIMIT_HANDLERS = &quot;hibernate.legacy_limit_handler&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">VALIDATE_QUERY_PARAMETERS = &quot;hibernate.query.validate_parameters&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">CRITERIA_LITERAL_HANDLING_MODE = &quot;hibernate.criteria.literal_handling_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">PREFER_GENERATOR_NAME_AS_DEFAULT_SEQUENCE_NAME = &quot;hibernate.model.generator_name_as_sequence_name&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_TRANSACTION_COMPLIANCE = &quot;hibernate.jpa.compliance.transaction&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_QUERY_COMPLIANCE = &quot;hibernate.jpa.compliance.query&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_LIST_COMPLIANCE = &quot;hibernate.jpa.compliance.list&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_CLOSED_COMPLIANCE = &quot;hibernate.jpa.compliance.closed&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_PROXY_COMPLIANCE = &quot;hibernate.jpa.compliance.proxy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_CACHING_COMPLIANCE = &quot;hibernate.jpa.compliance.caching&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">JPA_ID_GENERATOR_GLOBAL_SCOPE_COMPLIANCE = &quot;hibernate.jpa.compliance.global_id_generators&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">TABLE_GENERATOR_STORE_LAST_USED = &quot;hibernate.id.generator.stored_last_used&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">FAIL_ON_PAGINATION_OVER_COLLECTION_FETCH = &quot;hibernate.query.fail_on_pagination_over_collection_fetch&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">IMMUTABLE_ENTITY_UPDATE_QUERY_HANDLING_MODE = &quot;hibernate.query.immutable_entity_update_query_handling_mode&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">IN_CLAUSE_PARAMETER_PADDING = &quot;hibernate.query.in_clause_parameter_padding&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">QUERY_STATISTICS_MAX_SIZE = &quot;hibernate.statistics.query_max_size&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">SEQUENCE_INCREMENT_SIZE_MISMATCH_STRATEGY = &quot;hibernate.id.sequence.increment_size_mismatch_strategy&quot;;</span></span><br><span class="line"><span class="attr">String</span> <span class="string">OMIT_JOIN_OF_SUPERCLASS_TABLES = &quot;hibernate.query.omit_join_of_superclass_tables&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="AvailableSettings-里面的配置项的用法"><a href="#AvailableSettings-里面的配置项的用法" class="headerlink" title="AvailableSettings 里面的配置项的用法"></a>AvailableSettings 里面的配置项的用法</h3><p>只需要将 AvailableSettings 变量的值放到 spring.jpa.properties 里面即可，如下这些是我们常用的。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##开启hibernate statistics的信息，如session、连接等日志：</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.generate_statistics</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 格式化 SQL</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.format_sql</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># 显示 SQL</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.show_sql</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># 添加 HQL 相关的注释信息</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.use_sql_comments</span>: <span class="string">true</span></span><br><span class="line"><span class="comment"># hbm2ddl的策略 validate, update, create, create-drop, none，建议配置成validate，</span></span><br><span class="line"><span class="comment"># 这样在我们启动项目的时候就知道生产数据库的表结构是否正确的了，而不用等到运行期间才发现问题。</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.hbm2ddl.auto</span>=<span class="string">validate</span></span><br><span class="line"><span class="comment"># 关联关系的时候取数据的深度，默认是3层，我们可以设置成2级，防止其他开发乱用，提高sql性能</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.max_fetch_depth</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 批量fetch大小默认 -1</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.default_batch_fetch_size</span>= <span class="string">100</span></span><br><span class="line"><span class="comment"># 事务完成之前是否进行flush操作，即同步到db里面去，默认是true</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.transaction.flush_before_completion</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 事务结束之后是否关闭session，默认false</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.transaction.auto_close_session</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 有的时候不只要批量查询，也会批量更新，默认batch size是15，可以根据实际情况自由调整，可以提高批量更新的效率；</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.jdbc.batch_size</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure>

<h3 id="自动加载过程类之间的关系图"><a href="#自动加载过程类之间的关系图" class="headerlink" title="自动加载过程类之间的关系图"></a>自动加载过程类之间的关系图</h3><p><img src="http://image.leonote.cn/20201120164350.png" alt=""></p>
<p>从上图中，可以看出以下几点内容。</p>
<ol>
<li><code>JpaBaseConfiguration</code> 是 Jpa 和 Hibernate 被加载的基石，里面通过 <code>BeanFactoryAware</code> 的接口的 bean 加载生命周期也实现了一些逻辑。</li>
<li><code>HibernateJpaConfiguration</code> 是 JpaBaseConfiguration 的子类，覆盖了一些父类里面的配置相关的特殊逻辑，并且里面引用了 <code>JpaPropeties</code> 和 <code>HibernateProperties</code> 的配置项。</li>
<li><code>HibernateJpaAutoConfiguration</code> 是 Spring Boot 自动加载 HibernateJpaConfiguration 的桥梁，起到了导入和加载 HibernateJpaConfiguration 的作用。</li>
<li><code>JpaRepositoriesAutoConfiguration</code> 和 <code>HibernateJpaAutoConfiguration</code>、<code>DataSourceAutoConfiguration</code> 分别加载 JpaRepositories 的逻辑和 Hibernate/JPA、数据源，都是被 spring.factories 自动装配进入到 Spring Boot 里面的，而三者之间有加载的先后顺序。</li>
<li>上图的 UML 还展示了几个 Configuration 类的加载顺序和依赖关系，顺序是从上到下进行加载的<ul>
<li>DataSourceAutoConfiguration 最先加载</li>
<li>HibernateJpaAutoConfiguration 第二顺序加载</li>
<li>JpaRepositoriesAutoConfiguration 最后加载</li>
</ul>
</li>
</ol>
<h2 id="Spring-Data-JPA-Repositories-Bootstrap-Mode"><a href="#Spring-Data-JPA-Repositories-Bootstrap-Mode" class="headerlink" title="Spring Data JPA Repositories Bootstrap Mode"></a>Spring Data JPA Repositories Bootstrap Mode</h2><p>了解完了 Hibernate 在 Spring Boot 里面的加载过程，那么来看下 JpaRepositoriesAutoConfiguration 的主要作用有哪些？</p>
<p>通过上面分享的整个加载过程可以发现：</p>
<ul>
<li>DataSourceAutoConfiguration 完成了数据源的加载</li>
<li>HibernateJpaAutoConfiguration 完成了 Hibernate 的加载过程</li>
<li>JpaRepositoriesAutoConfiguration 完成了各种 JpaRepositories 的加载过程，这是 Spring Data JPA 的主要实现逻辑，和 Hibernate、数据源没什么关系。</li>
</ul>
<p>可以通过 <code>JpaRepositoriesAutoConfiguration</code> 的源码发现其主要职责和实现方式，利用异步线程池初始化 repositories，关键源码如下：</p>
<p><img src="http://image.leonote.cn/20201120165726.png" alt=""></p>
<p>而其中加载 repositories 有三种方式，即 <code>spring.data.jpa.repositories.bootstrap-mode</code> 的三个值，分别为 <strong>deferred</strong>、 <strong>lazy</strong>、 <strong>default</strong></p>
<ul>
<li><strong>deferred</strong>：是默认值，表示在<strong>启动的时候会进行数据库字段的检查</strong>，而 repositories 相关的实例的初始化是 lazy 模式，也就是在第一次用到 repositories 实例的时候再进行初始化。这个<strong>比较适合用在测试环境和生产环境</strong>中，因为测试不可能覆盖所有场景，万一谁多加个字段或者少一个字段，这样在启动的阶段就可以及时发现问题，不能等进行到生产环境才暴露。</li>
<li><strong>lazy</strong>：<strong>表示启动阶段不会进行数据库字段的检查，也不会初始化 repositories 相关的实例</strong>，而是在第一次用到 repositories 实例的时候再进行初始化。这个<strong>比较适合用在开发的阶段，可以加快应用的启动速度</strong>。如果生产环境中，我们为了提高业务高峰期间水平来扩展应用的启动速度，也可以采用这种模式。</li>
<li><strong>default</strong>：默认加载方式，但从 Spring Boot 2.0 之后就不是默认值了，表示<strong>立即验证、立即初始化 repositories 实例</strong>，这种方式启动的速度最慢，但是最保险，<strong>运行期间的请求最快</strong>，因为避免了第一次请求初始化 repositories 实例的过程。</li>
</ul>
<p>我们通过在 application.properties 里面修改这一行代码，来测试一下 lazy 的加载方式。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.jpa.repositories.bootstrap-mode</span>=<span class="string">lazy</span></span><br></pre></td></tr></table></figure>

<p>然后启动项目，就会发现在 tomcat 容器加载完之后，没有用到 UserInfoRepository 之前，这个 UserInfoRepository 是不会进行初始化的。而当我们发一个请求用到了 UserInfoRepository，就进行了初始化。</p>
<p>通过日志也可以看到，启动的线程和初始化的线程是不一样的，而初始化的线程是 NIO 线程的名字，表示 request 的 http 线程池里面的线程，具体如下图所示。</p>
<p><img src="http://image.leonote.cn/20201120170349.png" alt=""></p>
<h2 id="Debug-时候，日志的配置"><a href="#Debug-时候，日志的配置" class="headerlink" title="Debug 时候，日志的配置"></a>Debug 时候，日志的配置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 日志级别的灵活运用</span></span><br><span class="line"><span class="comment">## hibernate相关</span></span><br><span class="line"><span class="comment"># 显示sql的执行日志，如果开了这个,show_sql就可以不用了</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.SQL</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"># hibernate id的生成日志</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.id</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"># hibernate所有的操作都是PreparedStatement，把sql的执行参数显示出来</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.type.descriptor.sql.BasicBinder</span>=<span class="string">TRACE</span></span><br><span class="line"><span class="comment"># sql执行完提取的返回值</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.type.descriptor.sql</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment"># 请求参数</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.type</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"># 缓存相关</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.cache</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"># 统计hibernate的执行状态</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.stat</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment"># 查看所有的缓存操作</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.event.internal</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.cache</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment"># hibernate 的监控指标日志</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.engine.internal.StatisticalLoggingSessionEventListener</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="comment">### 连接池的相关日志</span></span><br><span class="line"><span class="comment">## hikari连接池的状态日志，以及连接池是否完好 #连接池的日志效果：HikariCPPool - Pool stats (total=20, active=0, idle=20, waiting=0)</span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari</span>=<span class="string">TRACE</span></span><br><span class="line"><span class="comment">#开启 debug可以看到 AvailableSettings里面的默认配置的值都有哪些，会输出类似下面的日志格式</span></span><br><span class="line"><span class="comment"># org.hibernate.cfg.Settings               : Statistics: enabled</span></span><br><span class="line"><span class="comment"># org.hibernate.cfg.Settings               : Default batch fetch size: -1</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.cfg</span>=<span class="string">debug</span></span><br><span class="line"><span class="comment">#hikari数据的配置项日志</span></span><br><span class="line"><span class="meta">logging.level.com.zaxxer.hikari.HikariConfig</span>=<span class="string">TRACE</span></span><br><span class="line"><span class="comment">### 查看事务相关的日志，事务获取，释放日志</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm.jpa</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.transaction</span>=<span class="string">TRACE</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate.engine.transaction.internal.TransactionImpl</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="comment">### 分析connect 以及 orm和 data的处理过程更全的日志</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.data</span>=<span class="string">trace</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.orm</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<p>上面是在分析复杂问题和原理的时候常用的日志配置项目</p>
<blockquote>
<p>🎯技巧：</p>
<p>当我们分析一个问题的时候，如果不知道日志具体在哪个类里面，通过设置 logging.level.root=trace 的话，日志又非常多几乎没有办法看，那么我们可以缩小范围，不如说我们分析的是 hikari 包里面相关的问题。</p>
<p>我们可以把整个日志级别 logging.level.root=info 设置成 info，把其他所有的日志都关闭，并把 logging.level.com.zaxxer=trace 设置成最大的，保持日志不受干扰，然后观察日志再逐渐减少查看范围。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data Jpa 如何解决 N+1 SQL 问题</title>
    <url>/2021/01/12/SpringDataJpa%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3N+1SQL%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Spring-Data-Jpa-如何解决-N-1-SQL-问题"><a href="#Spring-Data-Jpa-如何解决-N-1-SQL-问题" class="headerlink" title="Spring Data Jpa 如何解决 N+1 SQL 问题"></a>Spring Data Jpa 如何解决 N+1 SQL 问题</h1><p>在 JPA 的使用过程中，N+1 SQL 是很常见的问题</p>
<h2 id="什么是-N-1-SQL-问题？"><a href="#什么是-N-1-SQL-问题？" class="headerlink" title="什么是 N+1 SQL 问题？"></a>什么是 N+1 SQL 问题？</h2><blockquote>
<p>想要解决一个问题，必须要知道它是什么、如何产生的，这样才能有方法、有逻辑地去解决它。</p>
</blockquote>
<p>下面通过一个例子来看一下什么是 N+1 的 SQL 问题。</p>
<p>假设一个 UserInfo 实体对象和 Address 是一对多的关系，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserInfo实体对象如下：</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addressList&quot;)</span><span class="comment">//exclude防止 toString打印日志的时候死循环</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="comment">// UserInfo实体对象的关联关系由Address对象里面的userInfo字段维护，默认是lazy加载模式</span></span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Address对象如下：</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="comment">//维护UserInfo和Address的外键关系</span></span><br><span class="line">   <span class="meta">@ManyToOne(fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="meta">@JsonBackReference</span> <span class="comment">//此注解防止JSON死循环</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，假设数据库里面有三条 UserInfo 的数据，ID 分别为 3、6、9，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210112134537.png" alt=""></p>
<p>其中，每个 UserInfo 分别有两条 Address 数据，也就是一共 6 条 Address 的数据，如下图所示：</p>
<p><img src="http://image.leonote.cn/20210112134946.png" alt=""></p>
<p>然后，请求通过 UserInfoRepository 查询所有的 UserInfo 信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userInfoRepository.findAll()</span><br></pre></td></tr></table></figure>

<p>现在，控制台将会得到四个 SQL，如下所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                    <span class="keyword">as</span> id1_1_,</span><br><span class="line">       userinfo0_.create_time           <span class="keyword">as</span> create_t2_1_,</span><br><span class="line">       userinfo0_.create_user_id        <span class="keyword">as</span> create_u3_1_,</span><br><span class="line">       userinfo0_.last_modified_time    <span class="keyword">as</span> last_mod4_1_,</span><br><span class="line">       userinfo0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_,</span><br><span class="line">       userinfo0_.version               <span class="keyword">as</span> version6_1_,</span><br><span class="line">       userinfo0_.ages                  <span class="keyword">as</span> ages7_1_,</span><br><span class="line">       userinfo0_.email_address         <span class="keyword">as</span> email_ad8_1_,</span><br><span class="line">       userinfo0_.last_name             <span class="keyword">as</span> last_nam9_1_,</span><br><span class="line">       userinfo0_.name                  <span class="keyword">as</span> name10_1_,</span><br><span class="line">       userinfo0_.telephone             <span class="keyword">as</span> telepho11_1_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_ org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ? org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ? org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>通过 SQL 可以看得出来，当取 UserInfo 的时候，有多少条 UserInfo 数据就会触发多少条查询 Address 的 SQL。</p>
<p>那么所谓的 N+1 的 SQL，此时 1 代表的是一条 SQL 查询 UserInfo 信息；N 条 SQL 查询 Address 的信息。想象一下，如果有 100 条 UserInfo 信息，可能会触发 100 条查询 Address 的 SQL，性能多差呀。这里使用的是 EAGER 模式，当使用 LAZY 的时候也是一样的道理，只是生成 N 条 SQL 的时机是不一样的。</p>
<p>上面演示了 @OneToMany 的情况，那么再看一下 @ManyToOne 的情况。利用 AddressRepository 查询所有的 Address 信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addressRepository.findAll();</span><br></pre></td></tr></table></figure>

<p>控制台会产生如下 SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> address0_.id                    <span class="keyword">as</span> id1_0_,</span><br><span class="line">       address0_.create_time           <span class="keyword">as</span> create_t2_0_,</span><br><span class="line">       address0_.create_user_id        <span class="keyword">as</span> create_u3_0_,</span><br><span class="line">       address0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_,</span><br><span class="line">       address0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_,</span><br><span class="line">       address0_.version               <span class="keyword">as</span> version6_0_,</span><br><span class="line">       address0_.city                  <span class="keyword">as</span> city7_0_,</span><br><span class="line">       address0_.user_info_id          <span class="keyword">as</span> user_inf8_0_</span><br><span class="line"><span class="keyword">from</span> address address0_ </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="operator">=</span> ? </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="operator">=</span> ? </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>这里通过 SQL 可以看得出来，当取 Address 的时候，Address 里面有多少个 user_info_id，就会触发多少条查询 UserInfo 的 SQL。</p>
<p>那么所谓的 N+1 的 SQL，此时 1 就代表一条 SQL 查询 Address 信息；N 条 SQL 查询 UserInfo 的信息。同样，想象一下，如果有 100 条 Address 信息，分别有不同的 user_info_id 可能会触发 100 条查询 UserInfo 的 SQL，性能依然很差。</p>
<p>这只是演示了 @OneToMany 和 @ManyToOne 的情况，@ManyToMany 和 @OneToOne 也是一样的道理，都是当我们查询主体信息时候，1 条 SQL 会衍生出来关联关系的 N 条 SQL。</p>
<p>现在认识了这个问题，下一步该思考，怎么解决才更合理呢？有没有什么办法可以减少 SQL 条数呢？</p>
<h2 id="减少-N-1-SQL-的条数"><a href="#减少-N-1-SQL-的条数" class="headerlink" title="减少 N+1 SQL 的条数"></a>减少 N+1 SQL 的条数</h2><p>最容易想到，就是有没有什么机制可以减少 N 对应的 SQL 条数呢？从原理分析会知道，不管是 LAZY 还是 EAGER 都是没有用的，因为这两个只是决定了 N 条 SQL 的触发时机，而不能减少 SQL 的条数。</p>
<h3 id="hibernate-default-batch-fetch-size-配置"><a href="#hibernate-default-batch-fetch-size-配置" class="headerlink" title="hibernate.default_batch_fetch_size 配置"></a>hibernate.default_batch_fetch_size 配置</h3><p>hibernate.default_batch_fetch_size 配置在 AvailableSettings.class 里面，指的是批量获取数据的大小，默认是 -1，表示默认没有匹配取数据。那么把这个值改成 20 看一下效果，只需要在 application.properties 里面增加如下配置即可。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更改批量取数据的大小为20</span></span><br><span class="line"><span class="meta">spring.jpa.properties.hibernate.default_batch_fetch_size</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure>

<p>在实体类不发生任何改变的前提下，再执行如下两个方法，分别看一下 SQL 的生成情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userInfoRepository.findAll();</span><br></pre></td></tr></table></figure>

<p>还是先查询所有的 UserInfo 信息，看一下 SQL 的执行情况，代码如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                    <span class="keyword">as</span> id1_1_,</span><br><span class="line">       userinfo0_.create_time           <span class="keyword">as</span> create_t2_1_,</span><br><span class="line">       userinfo0_.create_user_id        <span class="keyword">as</span> create_u3_1_,</span><br><span class="line">       userinfo0_.last_modified_time    <span class="keyword">as</span> last_mod4_1_,</span><br><span class="line">       userinfo0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_,</span><br><span class="line">       userinfo0_.version               <span class="keyword">as</span> version6_1_,</span><br><span class="line">       userinfo0_.ages                  <span class="keyword">as</span> ages7_1_,</span><br><span class="line">       userinfo0_.email_address         <span class="keyword">as</span> email_ad8_1_,</span><br><span class="line">       userinfo0_.last_name             <span class="keyword">as</span> last_nam9_1_,</span><br><span class="line">       userinfo0_.name                  <span class="keyword">as</span> name10_1_,</span><br><span class="line">       userinfo0_.telephone             <span class="keyword">as</span> telepho11_1_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_ org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_0_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_0_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_0_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_0_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_0_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_0_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="keyword">in</span> (?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>可以看到 SQL 直接减少到两条了，其中查询 Address 的地方查询条件变成了 in(?,?,?)。</p>
<p>想象一下，如果有 20 条 UserInfo 信息，那么产生的 SQL 也是两条，此时要比 20+1 条 SQL 性能高太多了。</p>
<p>接着再执行另一个方法，看一下 @ManyToOne 的情况，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addressRepository.findAll()</span><br></pre></td></tr></table></figure>

<p>关于执行的 SQL 情况如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-11</span><span class="number">-29</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">27.381</span> DEBUG <span class="number">30870</span> <span class="comment">--- [nio-8087-exec-5] org.hibernate.SQL                        : </span></span><br><span class="line"><span class="keyword">select</span> address0_.id                    <span class="keyword">as</span> id1_0_,</span><br><span class="line">       address0_.create_time           <span class="keyword">as</span> create_t2_0_,</span><br><span class="line">       address0_.create_user_id        <span class="keyword">as</span> create_u3_0_,</span><br><span class="line">       address0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_,</span><br><span class="line">       address0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_,</span><br><span class="line">       address0_.version               <span class="keyword">as</span> version6_0_,</span><br><span class="line">       address0_.city                  <span class="keyword">as</span> city7_0_,</span><br><span class="line">       address0_.user_info_id          <span class="keyword">as</span> user_inf8_0_</span><br><span class="line"><span class="keyword">from</span> address address0_</span><br><span class="line"><span class="number">2020</span><span class="number">-11</span><span class="number">-29</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">27.383</span> DEBUG <span class="number">30870</span> <span class="comment">--- [nio-8087-exec-5] org.hibernate.SQL                        : </span></span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="keyword">in</span> (?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，查询所有的 Address 信息也只产生了 2 条 SQL；而当我们查询 UserInfo 的时候，SQL 最后的查询条件也变成了 in (？，？，？)，同样的道理这样也会提升不少性能。</p>
<p>而 hibernate.default_batch_fetch_size 的经验参考值，<strong>可以设置成 20、30、50、100 等，太高了也没有意义</strong>。<strong><em>一个请求执行一次，产生的 SQL 数量为 3-5 条基本上都算合理情况</em></strong>，这样通过设置 default_batch_fetch_size 就可以很好地避免大部分业务场景下的 N+1 条 SQL 的性能问题了。</p>
<p>此时还需要注意一点就是，在实际工作中，一定要知道一次操作会产生多少 SQL，有没有预期之外的 SQL 参数，这是需要关注的重点，这种情况可以利用如下配置来开启打印 SQL，请看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 显示sql的执行日志，如果开了这个,show_sql就可以不用了，show_sql没有上下文，多线程情况下，分不清楚是谁打印的，所有我推荐如下配置项：</span><br><span class="line">logging.level.org.hibernate.SQL=debug</span><br></pre></td></tr></table></figure>

<p>但是这种配置也有个缺陷，就是只能全局配置，没办法针对不通过的实体管理关系配置不同的 Fetch Size 的值。</p>
<p>而与之类似的 Hibernate 里面也提供了一个注解 @BatchSize 可以解决此问题。</p>
<h3 id="BatchSize-注解"><a href="#BatchSize-注解" class="headerlink" title="@BatchSize 注解"></a>@BatchSize 注解</h3><p><code>@BatchSize</code> 注解是 Hibernate 提供的用来解决查询关联关系的批量处理大小，默认无，可以配置在实体上，也可以配置在关联关系上面。此注解里面只有一个属性 size，用来指定关联关系 LAZY 或者是 EAGER 一次性取数据的大小。</p>
<p>还是将上面的例子中的 UserInfo 实体做一下改造，在里面增加两次 @BatchSize 注解，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addressList&quot;)</span></span><br><span class="line"><span class="meta">@BatchSize(size = 2)</span><span class="comment">//实体类上加@BatchSize注解，用来设置当被关联关系的时候一次查询的大小，设置成2，方便演示Address关联UserInfo的时候的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="meta">@BatchSize(size = 20)</span><span class="comment">//关联关系的属性上加@BatchSize注解，用来设置当通过UserInfo加载Address的时候一次取数据的大小</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过改造 UserInfo 实体，可以直接演示 <code>@BatchSize</code> 应用在实体类和属性字段上的效果，所以 Address 实体可以不做任何改变，hibernate.default_batch_fetch_size 还改成默认值 -1，再分别执行一下两个 findAll 方法，看一下效果。</p>
<p>第一种：查询所有 UserInfo，代码如下面这行所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userInfoRepository.findAll()</span><br></pre></td></tr></table></figure>

<p>看一下控制台 SQL 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                    <span class="keyword">as</span> id1_1_,</span><br><span class="line">       userinfo0_.create_time           <span class="keyword">as</span> create_t2_1_,</span><br><span class="line">       userinfo0_.create_user_id        <span class="keyword">as</span> create_u3_1_,</span><br><span class="line">       userinfo0_.last_modified_time    <span class="keyword">as</span> last_mod4_1_,</span><br><span class="line">       userinfo0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_,</span><br><span class="line">       userinfo0_.version               <span class="keyword">as</span> version6_1_,</span><br><span class="line">       userinfo0_.ages                  <span class="keyword">as</span> ages7_1_,</span><br><span class="line">       userinfo0_.email_address         <span class="keyword">as</span> email_ad8_1_,</span><br><span class="line">       userinfo0_.last_name             <span class="keyword">as</span> last_nam9_1_,</span><br><span class="line">       userinfo0_.name                  <span class="keyword">as</span> name10_1_,</span><br><span class="line">       userinfo0_.telephone             <span class="keyword">as</span> telepho11_1_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_ org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_0_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_0_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_0_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_0_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_0_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_0_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="keyword">in</span> (?, ?, ?)</span><br></pre></td></tr></table></figure>

<p>和刚才设置 hibernate.default_batch_fetch_size=20 的效果一模一样，所以可以利用 <code>@BatchSize</code> 这个注解针对不同的关联关系，配置不同的大小，从而提升 N+1 SQL 的性能。</p>
<p>第二种：查询一下所有 Address，如下面这行代码所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addressRepository.findAll();</span><br></pre></td></tr></table></figure>

<p>控制台的 SQL 情况，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> address0_.id                    <span class="keyword">as</span> id1_0_,</span><br><span class="line">       address0_.create_time           <span class="keyword">as</span> create_t2_0_,</span><br><span class="line">       address0_.create_user_id        <span class="keyword">as</span> create_u3_0_,</span><br><span class="line">       address0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_,</span><br><span class="line">       address0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_,</span><br><span class="line">       address0_.version               <span class="keyword">as</span> version6_0_,</span><br><span class="line">       address0_.city                  <span class="keyword">as</span> city7_0_,</span><br><span class="line">       address0_.user_info_id          <span class="keyword">as</span> user_inf8_0_</span><br><span class="line"><span class="keyword">from</span> address address0_ </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="keyword">in</span> (?, ?) </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>这里可以看到，由于在 UserInfo 的实体上设置了 <code>@BatchSize(size = 2)</code>，表示所有关联关系到 UserInfo 的时候一次取两条数据，所以就会发现这次查询 Address 加载 UserInfo 的时候，产生了 3 条 SQL。</p>
<p>其中通过关联关系查询 UserInfo 产生了 2 条 SQL，由于我们 UserInfo 在数据库里面有三条数据，所以第一条 UserInfo 的 SQL 受 <code>@BatchSize(size = 2)</code> 控制，从而 in (?,?) 只支持了两个参数，同时也产生了第二条查 UserInfo 的 SQL。</p>
<p>从上面的例子中可以看到 @BatchSize 和 hibernate.default_batch_fetch_size 的效果是一样的，只不过一个是全局配置、一个是局部设置，这是可以减少 N+1 SQL 最直接、最方便的两种方式。</p>
<blockquote>
<p>注意事项：</p>
<p>@BatchSize 的使用具有局限性，不能作用于 @ManyToOne 和 @OneToOne 的关联关系上，那样代码是不起作用的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="meta">@ManyToOne(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="meta">@BatchSize(size = 30)</span> <span class="comment">//由于是@ManyToOne的关联关系所有没有作用</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> @BatchSize 只能作用在 @ManyToMany、@OneToMany、实体类这三个地方。</p>
</blockquote>
<p>此外，Hibernate 中还提供了一种 FetchMode 的策略，包含三种模式，分别为 FetchMode.SELECT、FetchMode.JOIN，以及 FetchMode.SUBSELECT。</p>
<h3 id="Hibernate-中-Fetch-数据的策略"><a href="#Hibernate-中-Fetch-数据的策略" class="headerlink" title="Hibernate 中 @Fetch 数据的策略"></a>Hibernate 中 @Fetch 数据的策略</h3><p>Hibernate 提供了一个 <code>@Fetch</code> 注解，用来改变获取数据的策略。代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fetch注解只能用在方法和字段上面</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Fetch &#123;</span><br><span class="line">   <span class="comment">//注解里面，只有一个属性获取数据的模式</span></span><br><span class="line">   <span class="function">FetchMode <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其中FetchMode的值有如下几种：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">FetchMode</span> </span>&#123;</span><br><span class="line">   <span class="comment">//默认模式，就是会有N+1 sql的问题；</span></span><br><span class="line">   SELECT,</span><br><span class="line">   <span class="comment">//通过join的模式，用一个sql把主体数据和关联关系数据一口气查出来</span></span><br><span class="line">   JOIN,</span><br><span class="line">   <span class="comment">//通过子查询的模式，查询关联关系的数据</span></span><br><span class="line">   SUBSELECT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，不要把这个注解和 JPA 协议里面的 FetchType.EAGER、FetchType.LAZY 搞混了，<strong>JPA 协议的关联关系中的 FetchType 解决的是取关联关系数据时机的问题</strong>，也就是说 EAGER 代表的是立即获得关联关系的数据，LAZY 是需要的时候再获得关联关系的数据。</p>
<p>这和 Hibernate 的 FetchMode 是两回事，<strong>FetchMode 解决的是获得数据策略的问题</strong>，也就是说，获得关联关系数据的策略有三种模式：SELECT（默认）、JOIN、SUBSELECT。</p>
<h4 id="FetchMode-SELECT"><a href="#FetchMode-SELECT" class="headerlink" title="FetchMode.SELECT"></a>FetchMode.SELECT</h4><p>更改一下 UserInfo 实体，将 <code>@Fetch(value = FetchMode.SELECT)</code> 作为获取数据的策略，使用 FetchType.EAGER 作为获取数据的时机，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addressList&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="meta">@Fetch(value = FetchMode.SELECT)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还是执行 <code>userInfoRepository.findAll();</code> 这个方法，看一下打印的 SQL 有哪些。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                    <span class="keyword">as</span> id1_1_,</span><br><span class="line">       userinfo0_.create_time           <span class="keyword">as</span> create_t2_1_,</span><br><span class="line">       userinfo0_.create_user_id        <span class="keyword">as</span> create_u3_1_,</span><br><span class="line">       userinfo0_.last_modified_time    <span class="keyword">as</span> last_mod4_1_,</span><br><span class="line">       userinfo0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_,</span><br><span class="line">       userinfo0_.version               <span class="keyword">as</span> version6_1_,</span><br><span class="line">       userinfo0_.ages                  <span class="keyword">as</span> ages7_1_,</span><br><span class="line">       userinfo0_.email_address         <span class="keyword">as</span> email_ad8_1_,</span><br><span class="line">       userinfo0_.last_name             <span class="keyword">as</span> last_nam9_1_,</span><br><span class="line">       userinfo0_.name                  <span class="keyword">as</span> name10_1_,</span><br><span class="line">       userinfo0_.telephone             <span class="keyword">as</span> telepho11_1_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_ </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ? </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ? </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>从上述 SQL 中可以看出，这依然是 N+1 的 SQL 问题，FetchMode.Select 是默认策略，加与不加是同样的效果，代表获取关系的时候新开一个 SQL 进行查询。</p>
<h4 id="FetchMode-JOIN"><a href="#FetchMode-JOIN" class="headerlink" title="FetchMode.JOIN"></a>FetchMode.JOIN</h4><p>FetchMode.JOIN 的意思是主表信息和关联关系通过一个 SQL JOIN 的方式查出来，看一下例子。</p>
<p>首先，将 UserInfo 里面的 FetchMode 改成 JOIN 模式，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="meta">@Fetch(value = FetchMode.JOIN)</span> <span class="comment">//唯一变化的地方采用JOIN模式</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，调用一下 <code>userInfoRepository.findAll();</code> 这个方法，发现依然是这三条 SQL，如下图所示。</p>
<p><img src="http://image.leonote.cn/20210112143025.png" alt="">这是因为 FetchMode.JOIN 只支持通过 ID 或者联合唯一键获取数据才有效，这正是 JOIN 策略模式的局限性所在。</p>
<p>那么再调用一下 <code>userInfoRepository.findById(id)</code>，看看控制台的 SQL 执行情况，代码如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_1_0_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_1_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_1_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_1_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_1_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_1_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_1_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_1_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_1_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_1_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_1_0_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_2_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_2_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_2_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_2_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_2_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_2_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_2_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_2_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br><span class="line"><span class="keyword">where</span> userinfo0_.id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p>这时会发现，当查询 UserInfo 的时候，它会通过 left outer join 把 Address 的信息也查询出来，虽然 SQL 上会有冗余信息，但是你会发现我们之前的 N+1 的 SQL 直接变成 1 条 SQL 了。</p>
<p>此时修改 UserInfo 里面的 @OneToMany，这个 <code>@Fetch(value = FetchMode.JOIN)</code> 同样适用于 @ManyToOne；然后再改一下 Address 实例，用 <code>@Fetch(value = FetchMode.JOIN)</code> 把 Address 里面的 UserInfo 关联关系改成 JOIN 模式；接着用 LAZY 获取数据的时机，会发现其对获取数据的策略没有任何影响。</p>
<p>这里只是给你演示获取数据时机的不同情况，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="meta">@ManyToOne(cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="meta">@JsonBackReference</span></span><br><span class="line">   <span class="meta">@Fetch(value = FetchMode.JOIN)</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的道理，JOIN 对列表性的查询是没有效果的，我们调用一下 <code>addressRepository.findById(id)</code>，产生的 SQL 如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        : </span><br><span class="line">select address0_.id                     as id1_0_0_,</span><br><span class="line">       address0_.create_time            as create_t2_0_0_,</span><br><span class="line">       address0_.create_user_id         as create_u3_0_0_,</span><br><span class="line">       address0_.last_modified_time     as last_mod4_0_0_,</span><br><span class="line">       address0_.last_modified_user_id  as last_mod5_0_0_,</span><br><span class="line">       address0_.version                as version6_0_0_,</span><br><span class="line">       address0_.city                   as city7_0_0_,</span><br><span class="line">       address0_.user_info_id           as user_inf8_0_0_,</span><br><span class="line">       userinfo1_.id                    as id1_1_1_,</span><br><span class="line">       userinfo1_.create_time           as create_t2_1_1_,</span><br><span class="line">       userinfo1_.create_user_id        as create_u3_1_1_,</span><br><span class="line">       userinfo1_.last_modified_time    as last_mod4_1_1_,</span><br><span class="line">       userinfo1_.last_modified_user_id as last_mod5_1_1_,</span><br><span class="line">       userinfo1_.version               as version6_1_1_,</span><br><span class="line">       userinfo1_.ages                  as ages7_1_1_,</span><br><span class="line">       userinfo1_.email_address         as email_ad8_1_1_,</span><br><span class="line">       userinfo1_.last_name             as last_nam9_1_1_,</span><br><span class="line">       userinfo1_.name                  as name10_1_1_,</span><br><span class="line">       userinfo1_.telephone             as telepho11_1_1_</span><br><span class="line">from address address0_</span><br><span class="line">         left outer join user_info userinfo1_ on address0_.user_info_id &#x3D; userinfo1_.id</span><br><span class="line">where address0_.id &#x3D; ?</span><br></pre></td></tr></table></figure>

<p>发现此时只会产生一个 SQL，即通过 from address left outer join user_info 一次性把所有信息都查出来，然后 Hibernate 再根据查询出来的结果组合到不同的实体里面。</p>
<p>也就是说 <strong><em>FetchMode.JOIN 对于关联关系的查询 LAZY 是不起作用的</em></strong>，因为 JOIN 的模式是通过一条 SQL 查出来所有信息，所以 <strong><em>FetchMode.JOIN 会忽略 FetchType</em></strong>。</p>
<h4 id="FetchMode-SUBSELECT"><a href="#FetchMode-SUBSELECT" class="headerlink" title="FetchMode.SUBSELECT"></a>FetchMode.SUBSELECT</h4><p>这种模式很简单，就是将关联关系通过子查询的形式查询出来，结合例子来理解一下。</p>
<p>首先，将 UserInfo 里面的关联关系改成 <code>@Fetch(value = FetchMode.SUBSELECT)</code>，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span> <span class="comment">//这里测试一下LAZY情况</span></span><br><span class="line">   <span class="meta">@Fetch(value = FetchMode.SUBSELECT)</span> <span class="comment">//唯一变化之处</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，像上面的做法一样，执行一下 <code>userInfoRepository.findAll()；</code>方法，看一下控制台的 SQL 情况，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                    <span class="keyword">as</span> id1_1_,</span><br><span class="line">       userinfo0_.create_time           <span class="keyword">as</span> create_t2_1_,</span><br><span class="line">       userinfo0_.create_user_id        <span class="keyword">as</span> create_u3_1_,</span><br><span class="line">       userinfo0_.last_modified_time    <span class="keyword">as</span> last_mod4_1_,</span><br><span class="line">       userinfo0_.last_modified_user_id <span class="keyword">as</span> last_mod5_1_,</span><br><span class="line">       userinfo0_.version               <span class="keyword">as</span> version6_1_,</span><br><span class="line">       userinfo0_.ages                  <span class="keyword">as</span> ages7_1_,</span><br><span class="line">       userinfo0_.email_address         <span class="keyword">as</span> email_ad8_1_,</span><br><span class="line">       userinfo0_.last_name             <span class="keyword">as</span> last_nam9_1_,</span><br><span class="line">       userinfo0_.name                  <span class="keyword">as</span> name10_1_,</span><br><span class="line">       userinfo0_.telephone             <span class="keyword">as</span> telepho11_1_</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_ </span><br><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       addresslis0_.id                    <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       addresslis0_.create_time           <span class="keyword">as</span> create_t2_0_0_,</span><br><span class="line">       addresslis0_.create_user_id        <span class="keyword">as</span> create_u3_0_0_,</span><br><span class="line">       addresslis0_.last_modified_time    <span class="keyword">as</span> last_mod4_0_0_,</span><br><span class="line">       addresslis0_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_0_,</span><br><span class="line">       addresslis0_.version               <span class="keyword">as</span> version6_0_0_,</span><br><span class="line">       addresslis0_.city                  <span class="keyword">as</span> city7_0_0_,</span><br><span class="line">       addresslis0_.user_info_id          <span class="keyword">as</span> user_inf8_0_0_</span><br><span class="line"><span class="keyword">from</span> address addresslis0_</span><br><span class="line"><span class="keyword">where</span> addresslis0_.user_info_id <span class="keyword">in</span> (<span class="keyword">select</span> userinfo0_.id <span class="keyword">from</span> user_info userinfo0_)</span><br></pre></td></tr></table></figure>

<p>这个时候会发现，查询 Address 信息是直接通过 addresslis0_.user_info_id in (select userinfo0_.id from user_info userinfo0_) 子查询的方式进行的，也就是说 N+1 SQL 变成了 1+1 的 SQL，这有点类似我们配置 @BatchSize 的效果。</p>
<p><strong>FetchMode.SUBSELECT 支持 ID 查询和各种条件查询</strong>，唯一的缺点是<strong>只能配置在 @OneToMany 和 @ManyToMany 的关联关系上</strong>，不能配置在 @ManyToOne 和 @OneToOne 的关联关系上，所以我们在 Address 里面关联 UserInfo 的时候就没有办法做实验了。</p>
<p>总之，<code>@Fetch</code> 的不同模型，都有各自的优缺点：</p>
<ul>
<li>FetchMode.SELECT 默认，和不配置的效果一样；</li>
<li>FetchMode.JOIN 只支持类似 findById(id) 的方法，只能根据 ID 查询才有效果；</li>
<li>FetchMode.SUBSELECT 虽然不限使用方式，但是只支持 **ToMany 的关联关系。</li>
</ul>
<p>所以在使用 <code>@Fetch</code> 的时候需要注意一下它的局限性，个人是比较推荐 <code>@BatchSize</code> 的方式。</p>
<p>那么除了上面的处理方式，也可以采用之前写 Mybatis 的思路来查询关联关系，下面来看一下该如何转变思路。</p>
<h3 id="转化解决问题的思路"><a href="#转化解决问题的思路" class="headerlink" title="转化解决问题的思路"></a>转化解决问题的思路</h3><p>这时需要在思想上进行转变，利用 JPA 的优势，摒弃它的缺陷。想想没有用 JPA 的时候是怎么做的？难道一定要用实体之间的关联关系吗？如果用的是 Mybatis，你在给前端返回关联关系数据的时候一般怎么写呢？</p>
<p>答案肯定是写成 1+1 SQL 的形式，也就是一条主 SQL、一条查关联关系的 SQL。还用 UserInfo 和 Address 实体来演示，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="meta">@Transient</span> <span class="comment">//在UserInfo实体中，不利用JPA来关联实体的关联关系了，而是把它设置成@Transisent，只维护java对象的关系，不维护DB之间的关联关系</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="keyword">private</span> String userId;</span><br><span class="line">   <span class="meta">@Transient</span> <span class="comment">//同样Address里面也可以不维护UserInfo的关联关系</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当查询所有 UserInfo 信息的时候，又想把每个 UserInfo 的 Address 信息都带上，应该怎么做呢？请看如下代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己实现一套 Batch fetch的逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">getAllUserWithAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//先查出来所有的UserInfo信息</span></span><br><span class="line">   List&lt;UserInfo&gt; userInfos = userInfoRepository.findAll();</span><br><span class="line">   <span class="comment">//再查出来上面userInfos里面的所有userId列表，再查询出来上面的查询结果所对应的所有Address信息</span></span><br><span class="line">   List&lt;Address&gt; addresses = addressRepository.findByUserIdIn(userInfos.stream().map(userInfo -&gt; userInfo.getId()).collect(Collectors.toList()));</span><br><span class="line">   <span class="comment">//我们自己再写一个转化逻辑，把各自user info的address信息放置到响应的UserInfo实例里面；</span></span><br><span class="line">   Map&lt;Long,List&lt;Address&gt;&gt; addressMaps = addresses</span><br><span class="line">         .stream()</span><br><span class="line">         .collect(Collectors.groupingBy(Address::getUserId));<span class="comment">//里面Map结构方便获取</span></span><br><span class="line">   <span class="keyword">return</span> userInfos.stream().map(userInfo -&gt; &#123;</span><br><span class="line">       userInfo.setAddressList(addressMaps.get(userInfo.getId()));</span><br><span class="line">       <span class="keyword">return</span> userInfo;</span><br><span class="line">   &#125;).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现，这要比原来的方式稍微复杂一点，但是如果做框架的话，上面有些逻辑可以抽到一个 Util 类里面去。</p>
<p>不过需要注意的是，实际工作中肯定不是 findAll()，而是会根据一些业务逻辑查询一个 UserInfo 的 List 信息，然后再根据查询出来的 userInfo 的 ID 列表去二次查询 Address 信息，这样最多只需要 2 个 SQL 就可完成实际业务逻辑。</p>
<p>那么反向思考，通过 Address 对象查询 UserInfo 也是一样的道理，可以先查询出 List<Address>，再查询出 List<Address>里面包含的所有 UserInfoId 列表，然后再去查询 UserInfo 信息，通过 Map 组装到 Address 里面。</p>
<blockquote>
<p>Tips：实体里面如果关联关系有非常多的请求，想维护关联关系是一件非常难的事情。我们可以利用 Mybatis 的思想、JPA 的快捷查询语法，来组装想要的任何关联关系的对象。这样的代码虽然比起原生的 JPA 语法较复杂，但是比起 Mybatis 还是要简单很多，理解起来也更容易，问题反倒会更少一点。</p>
</blockquote>
<h3 id="EntityGraph-使用详解"><a href="#EntityGraph-使用详解" class="headerlink" title="@EntityGraph 使用详解"></a>@EntityGraph 使用详解</h3><p>JPA 协议也提供了另外一种解题思路：利用 <code>@EntityGraph</code> 注解来解决</p>
<p>众所周知，实体与实体之间的关联关系错综复杂，就像一个大网图一样，网状分布交叉引用。而 JPA 协议在 2.1 版本之后企图用 Entity Graph 的方式，描绘出一个实体与实体之间的关联关系。</p>
<p>普通做法为，通过 @ManyToOne/@OneToMany/@ManyToMany/@OneToOne 这些关联关系注解表示它们之间的关系时，只能配置 EAGER 或者 LAZY，没办法根据不同的配置、不同的关联关系加载时机。</p>
<p>而 JPA 协议企图通过 <code>@NamedEntityGraph</code> 注解来描述实体之间的关联关系，当被 <code>@EntityGraph</code> 使用的时候进行 EAGER 加载，以减少 N+1 的 SQL，我们来看一下具体用法。</p>
<h4 id="NamedEntityGraph-和-EntityGraph-用法"><a href="#NamedEntityGraph-和-EntityGraph-用法" class="headerlink" title="@NamedEntityGraph 和 @EntityGraph 用法"></a>@NamedEntityGraph 和 @EntityGraph 用法</h4><p>还是直接通过一个例子来说明，请看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以被@NamedEntityGraphs注解重复使用，只能配置在类上面，用来声明不同的EntityGraph；</span></span><br><span class="line"><span class="meta">@Repeatable(NamedEntityGraphs.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NamedEntityGraph &#123;</span><br><span class="line">    <span class="comment">//指定一个名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//哪些关联关系属性可以被EntityGraph包含进去，默认一个没有。可以配置多个</span></span><br><span class="line">    NamedAttributeNode[] attributeNodes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否所有的关联关系属性自动包含在内，默认false;</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">includeAllAttributes</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置subgraphs，子实体图(可以理解为关联关系实体图，即如果算层级，可以配置第二层级)，可以被NamedAttributeNode引用</span></span><br><span class="line">    NamedSubgraph[] subgraphs() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//配置subclassSubgraphs的namedSubgraph有哪些。即如果算层级，可以配置第三层级</span></span><br><span class="line">    NamedSubgraph[] subclassSubgraphs() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，可以看到 <code>@NamedEntityGraphs</code> 能够配置多个 <code>@NamedEntityGraph</code>。接着往下看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能使用在实体类上面</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NamedEntityGraphs&#123;</span><br><span class="line">    NamedEntityGraph[] value();<span class="comment">//可以同时指定多个NamedEntityGraph</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，NamedSubgraph 用来指定关联关系的策略，也就关联关系有两层。</p>
<p>再看一下 <code>@NamedEntityGraph</code> 里面的 NamedAttributeNode 属性有哪些值，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来进行属性节点的描述</span></span><br><span class="line"><span class="meta">@Target(&#123;&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NamedAttributeNode &#123;</span><br><span class="line">    <span class="comment">//要包含的关联关系的属性的名字，必填</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//如果我们在@NamedEntityGraph里面配置了子关联关系，这个是配置subgraph的名字</span></span><br><span class="line">    <span class="function">String <span class="title">subgraph</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//当关联关系是被Map结构引用的时候，可以指定key的方式，一般很少用</span></span><br><span class="line">    <span class="function">String <span class="title">keySubgraph</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是对 <code>@NamedAttributeNode</code> 的介绍，再看一下 <code>@EntityGraph</code> 里面的 <code>@NamedSubgraph</code> 的结构，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NamedSubgraph &#123;</span><br><span class="line">    <span class="comment">//指定一个名字</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//子关联关系的类的class</span></span><br><span class="line">    <span class="function">Class <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    <span class="comment">//二层关联关系的要包含的关联关系的属性的名字</span></span><br><span class="line">    NamedAttributeNode[] attributeNodes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>@NamedEntityGraph</code> 的注解都是配置在实体本身上面的，而 <code>@EntityGraph</code> 是用在 ***Repository 接口里的方法中的。</p>
<p>了解一下 <code>@EntityGraph</code> 注解的语法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.METHOD, ElementType.ANNOTATION_TYPE &#125;)</span></span><br><span class="line"><span class="comment">//EntityGraph 作用在Repository的接口里面的方法上面</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EntityGraph &#123;</span><br><span class="line">   <span class="comment">//指@EntityGraph注解引用的@NamedEntityGraph里面定义的name，如果是空EntityGraph就不会起作用，如果为空相当于没有配置；</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//EntityGraph的类型，默认是EntityGraphType.FETCH类型</span></span><br><span class="line">   <span class="function">EntityGraphType <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> EntityGraphType.FETCH</span>;</span><br><span class="line">    <span class="comment">//可以指定attributePaths用来覆盖@NamedEntityGraph里面的attributeNodes的配置，默认配置是空，以@NamedEntityGraph里面的为准；</span></span><br><span class="line">   String[] attributePaths() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">   <span class="comment">//JPA 2.1支持的EntityGraphType对应的枚举值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EntityGraphType</span> </span>&#123;</span><br><span class="line">      <span class="comment">//LOAD模式，当被指定了这种模式、被@EntityGraph管理的attributes的时候，原来的FetchType的类型直接忽略变成Eager模式，而不被@EntityGraph管理的attributes还是保持默认的FetchType</span></span><br><span class="line">      LOAD(<span class="string">&quot;javax.persistence.loadgraph&quot;</span>),</span><br><span class="line">      <span class="comment">//FETCH模式，当被指定了这种模式、被@EntityGraph管理的attributes的时候，原来的FetchType的类型直接忽略变成Eager模式，而不被@EntityGraph管理的attributes将会变成Lazy模式，和LOAD的区别就是对不被@NamedEntityGraph配置的关联关系的属性的FetchType不一样；</span></span><br><span class="line">      FETCH(<span class="string">&quot;javax.persistence.fetchgraph&quot;</span>);</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">EntityGraphType</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EntityGraph-使用实例"><a href="#EntityGraph-使用实例" class="headerlink" title="@EntityGraph 使用实例"></a>@EntityGraph 使用实例</h4><p>通过改造 Address 和 UserInfo 实体，来分别测试一下 <code>@NamedEntityGraph</code> 和 <code>@EntityGraph</code> 的用法。</p>
<p>第一步：在实体里面配置 <code>@EntityGraph</code>，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;userInfo&quot;)</span></span><br><span class="line"><span class="comment">//这里直接使用@NamedEntityGraph，因为只需要配置一个@NamedEntityGraph，指定一个名字getAllUserInfo，指定被这个名字的实体试图关联的关联关系属性是userInfo</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;getAllUserInfo&quot;,attributeNodes = @NamedAttributeNode(value = &quot;userInfo&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String city;</span><br><span class="line">   <span class="meta">@JsonBackReference</span> <span class="comment">//防止JSON死循环</span></span><br><span class="line">   <span class="meta">@ManyToOne(cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span><span class="comment">//采用默认的lazy模式</span></span><br><span class="line">   <span class="keyword">private</span> UserInfo userInfo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Table</span></span><br><span class="line"><span class="meta">@ToString(exclude = &quot;addressList&quot;)</span></span><br><span class="line"><span class="comment">//UserInfo对应的关联关系，利用@NamedEntityGraphs配置了两个，一个是针对Address的关联关系，一个是name叫rooms的实体图包含了rooms属性；在UserInfo里面增加了两个关联关系；</span></span><br><span class="line"><span class="meta">@NamedEntityGraphs(value = &#123;@NamedEntityGraph(name = &quot;addressGraph&quot;,attributeNodes = @NamedAttributeNode(value = &quot;addressList&quot;)),@NamedEntityGraph(name = &quot;rooms&quot;,attributeNodes = @NamedAttributeNode(value = &quot;rooms&quot;))&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String telephone;</span><br><span class="line">   <span class="keyword">private</span> Integer ages;</span><br><span class="line">   <span class="comment">//默认LAZY模式</span></span><br><span class="line">   <span class="meta">@OneToMany(mappedBy = &quot;userInfo&quot;,cascade = CascadeType.PERSIST,fetch = FetchType.LAZY)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Address&gt; addressList;</span><br><span class="line">   <span class="comment">//默认EAGER模式</span></span><br><span class="line">   <span class="meta">@OneToMany(cascade = CascadeType.PERSIST,fetch = FetchType.EAGER)</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;Room&gt; rooms;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步：在我们需要的 *Repository 的方法上面直接使用 <code>@EntityGraph</code>，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为要用findAll()做测试，所以可以覆盖JpaRepository里面的findAll()方法，加上@EntityGraph注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInfoRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfo</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="comment">//指定EntityGraph引用的是，在UserInfo实例里面配置的name=addressGraph的NamedEntityGraph；</span></span><br><span class="line">   <span class="comment">// 这里采用的是LOAD的类型，也就是说被addressGraph配置的实体图属性address采用的fetch会变成 FetchType.EAGER模式，而没有被addressGraph实体图配置关联关系属性room还是采用默认的EAGER模式</span></span><br><span class="line"><span class="meta">@EntityGraph(value = &quot;addressGraph&quot;,type = EntityGraph.EntityGraphType.LOAD)</span></span><br><span class="line">   <span class="function">List&lt;UserInfo&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的道理，其对于 AddressRepository 也是适用的，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AddressRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Address</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line"><span class="meta">@Override</span> <span class="comment">//可以覆盖原始方法，添加上不同的@EntityGraph策略</span></span><br><span class="line"><span class="comment">//使用@EntityGraph查询所有Address的时候，指定name = &quot;getAllUserInfo&quot;的@NamedEntityGraph，采用默认的EntityGraphType.FETCH，如果Address里面有多个关联关系的时候，只有在name = &quot;getAllUserInfo&quot;的实体图配置的userInfo属性上采用Eager模式，其他关联关系属性没有指定，默认采用LAZY模式；</span></span><br><span class="line"><span class="meta">@EntityGraph(value = &quot;getAllUserInfo&quot;)</span></span><br><span class="line"><span class="function">List&lt;Address&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步：看一下上面的两个方法执行的 SQL。</p>
<p>再次执行 <code>userInfoRepository.findAll();</code> 这个方法的时候会发现，被配置 EntityGraph 的 Address 和 user_info 通过 left join 一条 SQL 就把所有的信息都查出来了，SQL 如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> userinfo0_.id                      <span class="keyword">as</span> id1_2_0_,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_1_,</span><br><span class="line">       userinfo0_.create_time             <span class="keyword">as</span> create_t2_2_0_,</span><br><span class="line">       userinfo0_.create_user_id          <span class="keyword">as</span> create_u3_2_0_,</span><br><span class="line">       userinfo0_.last_modified_time      <span class="keyword">as</span> last_mod4_2_0_,</span><br><span class="line">       userinfo0_.last_modified_user_id   <span class="keyword">as</span> last_mod5_2_0_,</span><br><span class="line">       userinfo0_.version                 <span class="keyword">as</span> version6_2_0_,</span><br><span class="line">       userinfo0_.ages                    <span class="keyword">as</span> ages7_2_0_,</span><br><span class="line">       userinfo0_.email_address           <span class="keyword">as</span> email_ad8_2_0_,</span><br><span class="line">       userinfo0_.last_name               <span class="keyword">as</span> last_nam9_2_0_,</span><br><span class="line">       userinfo0_.name                    <span class="keyword">as</span> name10_2_0_,</span><br><span class="line">       userinfo0_.telephone               <span class="keyword">as</span> telepho11_2_0_,</span><br><span class="line">       addresslis1_.create_time           <span class="keyword">as</span> create_t2_0_1_,</span><br><span class="line">       addresslis1_.create_user_id        <span class="keyword">as</span> create_u3_0_1_,</span><br><span class="line">       addresslis1_.last_modified_time    <span class="keyword">as</span> last_mod4_0_1_,</span><br><span class="line">       addresslis1_.last_modified_user_id <span class="keyword">as</span> last_mod5_0_1_,</span><br><span class="line">       addresslis1_.version               <span class="keyword">as</span> version6_0_1_,</span><br><span class="line">       addresslis1_.city                  <span class="keyword">as</span> city7_0_1_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_1_,</span><br><span class="line">       addresslis1_.user_info_id          <span class="keyword">as</span> user_inf8_0_0__,</span><br><span class="line">       addresslis1_.id                    <span class="keyword">as</span> id1_0_0__</span><br><span class="line"><span class="keyword">from</span> user_info userinfo0_</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> address addresslis1_ <span class="keyword">on</span> userinfo0_.id <span class="operator">=</span> addresslis1_.user_info_id</span><br></pre></td></tr></table></figure>

<p>而没有配置 rooms 这个关联关系的属性时，rooms 的查询还是会触发 N+1 的 SQL。</p>
<p>从中可以看到 <code>@EntityGraph</code> 的效果有点类似 Hibernate 里面提供的 FetchModel.JOIN 的模式，但不同的是 <code>@EntityGraph</code> 可以搭配任何的查询情况，只需要在查询方法上直接加 <code>@EntityGraph</code> 注解即可。</p>
<p>这种方法还有个优势就是 <code>@EntityGraph</code> 和 <code>@NamedEntityGraph</code> 是 JPA 协议规定的，这样可以对 Hibernate 无感。</p>
<p>那么再看一下 <code>@ManyToOne</code> 的模式是否同样奏效，访问 <code>addressRepository.findAll()</code> 这个方法看一下 SQL，如下所示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">org.hibernate.SQL                        :</span><br><span class="line"><span class="keyword">select</span> address0_.id                     <span class="keyword">as</span> id1_0_0_,</span><br><span class="line">       userinfo1_.id                    <span class="keyword">as</span> id1_2_1_,</span><br><span class="line">       address0_.create_time            <span class="keyword">as</span> create_t2_0_0_,</span><br><span class="line">       address0_.create_user_id         <span class="keyword">as</span> create_u3_0_0_,</span><br><span class="line">       address0_.last_modified_time     <span class="keyword">as</span> last_mod4_0_0_,</span><br><span class="line">       address0_.last_modified_user_id  <span class="keyword">as</span> last_mod5_0_0_,</span><br><span class="line">       address0_.version                <span class="keyword">as</span> version6_0_0_,</span><br><span class="line">       address0_.city                   <span class="keyword">as</span> city7_0_0_,</span><br><span class="line">       address0_.user_info_id           <span class="keyword">as</span> user_inf8_0_0_,</span><br><span class="line">       userinfo1_.create_time           <span class="keyword">as</span> create_t2_2_1_,</span><br><span class="line">       userinfo1_.create_user_id        <span class="keyword">as</span> create_u3_2_1_,</span><br><span class="line">       userinfo1_.last_modified_time    <span class="keyword">as</span> last_mod4_2_1_,</span><br><span class="line">       userinfo1_.last_modified_user_id <span class="keyword">as</span> last_mod5_2_1_,</span><br><span class="line">       userinfo1_.version               <span class="keyword">as</span> version6_2_1_,</span><br><span class="line">       userinfo1_.ages                  <span class="keyword">as</span> ages7_2_1_,</span><br><span class="line">       userinfo1_.email_address         <span class="keyword">as</span> email_ad8_2_1_,</span><br><span class="line">       userinfo1_.last_name             <span class="keyword">as</span> last_nam9_2_1_,</span><br><span class="line">       userinfo1_.name                  <span class="keyword">as</span> name10_2_1_,</span><br><span class="line">       userinfo1_.telephone             <span class="keyword">as</span> telepho11_2_1_</span><br><span class="line"><span class="keyword">from</span> address address0_</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> user_info userinfo1_ <span class="keyword">on</span> address0_.user_info_id <span class="operator">=</span> userinfo1_.id</span><br></pre></td></tr></table></figure>

<p>可以看到 address left join 的模式中，一个 SQL 把所有的 address 和 user_info 都查询出来了。</p>
<p>综上所述，<code>@EntityGraph</code> 可以用在任何 ***Repository 的查询方法上，针对不同的场景配置不同的关联关系策略，就可以减少 N+1 的 SQL，成为一条 SQL。</p>
]]></content>
      <categories>
        <category>Spring Data</category>
        <category>Spring Data Jpa</category>
      </categories>
      <tags>
        <tag>Spring Data Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot的properties</title>
    <url>/2019/09/30/Springboot%E7%9A%84properties/</url>
    <content><![CDATA[<h1 id="Springboot基本的配置"><a href="#Springboot基本的配置" class="headerlink" title="Springboot基本的配置"></a>Springboot基本的配置</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"><span class="comment"># COMMON SPRING BOOT PROPERTIES</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This sample file is provided as a guideline. Do NOT copy it in its</span></span><br><span class="line"><span class="comment"># entirety to your own application.               ^^^</span></span><br><span class="line"><span class="comment"># ===================================================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># CORE PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">false # Enable debug logs.</span></span><br><span class="line"><span class="attr">trace</span>=<span class="string">false # Enable trace logs.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGGING</span></span><br><span class="line"><span class="meta">logging.config</span>= <span class="string"># Location of the logging configuration file. For instance, `classpath:logback.xml` for Logback.</span></span><br><span class="line"><span class="meta">logging.exception-conversion-word</span>=<span class="string">%wEx # Conversion word used when logging exceptions.</span></span><br><span class="line"><span class="meta">logging.file</span>= <span class="string"># Log file name (for instance, `myapp.log`). Names can be an exact location or relative to the current directory.</span></span><br><span class="line"><span class="meta">logging.file.max-history</span>=<span class="string">0 # Maximum of archive log files to keep. Only supported with the default logback setup.</span></span><br><span class="line"><span class="meta">logging.file.max-size</span>=<span class="string">10MB # Maximum log file size. Only supported with the default logback setup.</span></span><br><span class="line"><span class="meta">logging.group.*</span>= <span class="string"># Log groups to quickly change multiple loggers at the same time. For instance, `logging.level.db=org.hibernate,org.springframework.jdbc`.</span></span><br><span class="line"><span class="meta">logging.level.*</span>= <span class="string"># Log levels severity mapping. For instance, `logging.level.org.springframework=DEBUG`.</span></span><br><span class="line"><span class="meta">logging.path</span>= <span class="string"># Location of the log file. For instance, `/var/log`.</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>= <span class="string"># Appender pattern for output to the console. Supported only with the default Logback setup.</span></span><br><span class="line"><span class="meta">logging.pattern.dateformat</span>=<span class="string">yyyy-MM-dd HH:mm:ss.SSS # Appender pattern for log date format. Supported only with the default Logback setup.</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>= <span class="string"># Appender pattern for output to a file. Supported only with the default Logback setup.</span></span><br><span class="line"><span class="meta">logging.pattern.level</span>=<span class="string">%5p # Appender pattern for log level. Supported only with the default Logback setup.</span></span><br><span class="line"><span class="meta">logging.register-shutdown-hook</span>=<span class="string">false # Register a shutdown hook for the logging system when it is initialized.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOP</span></span><br><span class="line"><span class="meta">spring.aop.auto</span>=<span class="string">true # Add @EnableAspectJAutoProxy.</span></span><br><span class="line"><span class="meta">spring.aop.proxy-target-class</span>=<span class="string">true # Whether subclass-based (CGLIB) proxies are to be created (true), as opposed to standard Java interface-based proxies (false).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IDENTITY (ContextIdApplicationContextInitializer)</span></span><br><span class="line"><span class="meta">spring.application.name</span>= <span class="string"># Application name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ADMIN (SpringApplicationAdminJmxAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.application.admin.enabled</span>=<span class="string">false # Whether to enable admin features for the application.</span></span><br><span class="line"><span class="meta">spring.application.admin.jmx-name</span>=<span class="string">org.springframework.boot:type=Admin,name=SpringApplication # JMX name of the application admin MBean.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUTO-CONFIGURATION</span></span><br><span class="line"><span class="meta">spring.autoconfigure.exclude</span>= <span class="string"># Auto-configuration classes to exclude.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BANNER</span></span><br><span class="line"><span class="meta">spring.banner.charset</span>=<span class="string">UTF-8 # Banner file encoding.</span></span><br><span class="line"><span class="meta">spring.banner.location</span>=<span class="string">classpath:banner.txt # Banner text resource location.</span></span><br><span class="line"><span class="meta">spring.banner.image.location</span>=<span class="string">classpath:banner.gif # Banner image file location (jpg or png can also be used).</span></span><br><span class="line"><span class="meta">spring.banner.image.width</span>=<span class="string">76 # Width of the banner image in chars.</span></span><br><span class="line"><span class="meta">spring.banner.image.height</span>= <span class="string"># Height of the banner image in chars (default based on image height).</span></span><br><span class="line"><span class="meta">spring.banner.image.margin</span>=<span class="string">2 # Left hand image margin in chars.</span></span><br><span class="line"><span class="meta">spring.banner.image.invert</span>=<span class="string">false # Whether images should be inverted for dark terminal themes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CORE</span></span><br><span class="line"><span class="meta">spring.beaninfo.ignore</span>=<span class="string">true # Whether to skip search of BeanInfo classes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CACHE (CacheProperties)</span></span><br><span class="line"><span class="meta">spring.cache.cache-names</span>= <span class="string"># Comma-separated list of cache names to create if supported by the underlying cache manager.</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>= <span class="string"># The spec to use to create caches. See CaffeineSpec for more details on the spec format.</span></span><br><span class="line"><span class="meta">spring.cache.couchbase.expiration</span>= <span class="string"># Entry expiration. By default the entries never expire. Note that this value is ultimately converted to seconds.</span></span><br><span class="line"><span class="meta">spring.cache.ehcache.config</span>= <span class="string"># The location of the configuration file to use to initialize EhCache.</span></span><br><span class="line"><span class="meta">spring.cache.infinispan.config</span>= <span class="string"># The location of the configuration file to use to initialize Infinispan.</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>= <span class="string"># The location of the configuration file to use to initialize the cache manager.</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>= <span class="string"># Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Needed only if more than one JSR-107 implementation is available on the classpath.</span></span><br><span class="line"><span class="meta">spring.cache.redis.cache-null-values</span>=<span class="string">true # Allow caching null values.</span></span><br><span class="line"><span class="meta">spring.cache.redis.key-prefix</span>= <span class="string"># Key prefix.</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>= <span class="string"># Entry expiration. By default the entries never expire.</span></span><br><span class="line"><span class="meta">spring.cache.redis.use-key-prefix</span>=<span class="string">true # Whether to use the key prefix when writing to Redis.</span></span><br><span class="line"><span class="meta">spring.cache.type</span>= <span class="string"># Cache type. By default, auto-detected according to the environment.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING CONFIG - using environment property only (ConfigFileApplicationListener)</span></span><br><span class="line"><span class="meta">spring.config.additional-location</span>= <span class="string"># Config file locations used in addition to the defaults.</span></span><br><span class="line"><span class="meta">spring.config.location</span>= <span class="string"># Config file locations that replace the defaults.</span></span><br><span class="line"><span class="meta">spring.config.name</span>=<span class="string">application # Config file name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HAZELCAST (HazelcastProperties)</span></span><br><span class="line"><span class="meta">spring.hazelcast.config</span>= <span class="string"># The location of the configuration file to use to initialize Hazelcast.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROJECT INFORMATION (ProjectInfoProperties)</span></span><br><span class="line"><span class="meta">spring.info.build.encoding</span>=<span class="string">UTF-8 # File encoding.</span></span><br><span class="line"><span class="meta">spring.info.build.location</span>=<span class="string">classpath:META-INF/build-info.properties # Location of the generated build-info.properties file.</span></span><br><span class="line"><span class="meta">spring.info.git.encoding</span>=<span class="string">UTF-8 # File encoding.</span></span><br><span class="line"><span class="meta">spring.info.git.location</span>=<span class="string">classpath:git.properties # Location of the generated git.properties file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMX</span></span><br><span class="line"><span class="meta">spring.jmx.default-domain</span>= <span class="string"># JMX domain name.</span></span><br><span class="line"><span class="meta">spring.jmx.enabled</span>=<span class="string">true # Expose management beans to the JMX domain.</span></span><br><span class="line"><span class="meta">spring.jmx.server</span>=<span class="string">mbeanServer # MBeanServer bean name.</span></span><br><span class="line"><span class="meta">spring.jmx.unique-names</span>=<span class="string">false # Whether unique runtime object names should be ensured.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Email (MailProperties)</span></span><br><span class="line"><span class="meta">spring.mail.default-encoding</span>=<span class="string">UTF-8 # Default MimeMessage encoding.</span></span><br><span class="line"><span class="meta">spring.mail.host</span>= <span class="string"># SMTP server host. For instance, `smtp.example.com`.</span></span><br><span class="line"><span class="meta">spring.mail.jndi-name</span>= <span class="string"># Session JNDI name. When set, takes precedence over other Session settings.</span></span><br><span class="line"><span class="meta">spring.mail.password</span>= <span class="string"># Login password of the SMTP server.</span></span><br><span class="line"><span class="meta">spring.mail.port</span>= <span class="string"># SMTP server port.</span></span><br><span class="line"><span class="meta">spring.mail.properties.*</span>= <span class="string"># Additional JavaMail Session properties.</span></span><br><span class="line"><span class="meta">spring.mail.protocol</span>=<span class="string">smtp # Protocol used by the SMTP server.</span></span><br><span class="line"><span class="meta">spring.mail.test-connection</span>=<span class="string">false # Whether to test that the mail server is available on startup.</span></span><br><span class="line"><span class="meta">spring.mail.username</span>= <span class="string"># Login user of the SMTP server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APPLICATION SETTINGS (SpringApplication)</span></span><br><span class="line"><span class="meta">spring.main.allow-bean-definition-overriding</span>=<span class="string">false # Whether bean definition overriding, by registering a definition with the same name as an existing definition, is allowed.</span></span><br><span class="line"><span class="meta">spring.main.banner-mode</span>=<span class="string">console # Mode used to display the banner when the application runs.</span></span><br><span class="line"><span class="meta">spring.main.sources</span>= <span class="string"># Sources (class names, package names, or XML resource locations) to include in the ApplicationContext.</span></span><br><span class="line"><span class="meta">spring.main.web-application-type</span>= <span class="string"># Flag to explicitly request a specific type of web application. If not set, auto-detected based on the classpath.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FILE ENCODING (FileEncodingApplicationListener)</span></span><br><span class="line"><span class="meta">spring.mandatory-file-encoding</span>= <span class="string"># Expected character encoding the application must use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INTERNATIONALIZATION (MessageSourceProperties)</span></span><br><span class="line"><span class="meta">spring.messages.always-use-message-format</span>=<span class="string">false # Whether to always apply the MessageFormat rules, parsing even messages without arguments.</span></span><br><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">messages # Comma-separated list of basenames (essentially a fully-qualified classpath location), each following the ResourceBundle convention with relaxed support for slash based locations.</span></span><br><span class="line"><span class="meta">spring.messages.cache-duration</span>= <span class="string"># Loaded resource bundle files cache duration. When not set, bundles are cached forever. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.messages.encoding</span>=<span class="string">UTF-8 # Message bundles encoding.</span></span><br><span class="line"><span class="meta">spring.messages.fallback-to-system-locale</span>=<span class="string">true # Whether to fall back to the system Locale if no files for a specific Locale have been found.</span></span><br><span class="line"><span class="meta">spring.messages.use-code-as-default-message</span>=<span class="string">false # Whether to use the message code as the default message instead of throwing a &quot;NoSuchMessageException&quot;. Recommended during development only.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT</span></span><br><span class="line"><span class="meta">spring.output.ansi.enabled</span>=<span class="string">detect # Configures the ANSI output.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PID FILE (ApplicationPidFileWriter)</span></span><br><span class="line"><span class="meta">spring.pid.fail-on-write-error</span>= <span class="string"># Fails if ApplicationPidFileWriter is used but it cannot write the PID file.</span></span><br><span class="line"><span class="meta">spring.pid.file</span>= <span class="string"># Location of the PID file to write (if ApplicationPidFileWriter is used).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROFILES</span></span><br><span class="line"><span class="meta">spring.profiles.active</span>= <span class="string"># Comma-separated list of active profiles. Can be overridden by a command line switch.</span></span><br><span class="line"><span class="meta">spring.profiles.include</span>= <span class="string"># Unconditionally activate the specified comma-separated list of profiles (or list of profiles if using YAML).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># QUARTZ SCHEDULER (QuartzProperties)</span></span><br><span class="line"><span class="meta">spring.quartz.auto-startup</span>=<span class="string">true # Whether to automatically start the scheduler after initialization.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.comment-prefix</span>=<span class="string">-- # Prefix for single-line comments in SQL initialization scripts.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.quartz.jdbc.schema</span>=<span class="string">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">memory # Quartz job store type.</span></span><br><span class="line"><span class="meta">spring.quartz.overwrite-existing-jobs</span>=<span class="string">false # Whether configured jobs should overwrite existing job definitions.</span></span><br><span class="line"><span class="meta">spring.quartz.properties.*</span>= <span class="string"># Additional Quartz Scheduler properties.</span></span><br><span class="line"><span class="meta">spring.quartz.scheduler-name</span>=<span class="string">quartzScheduler # Name of the scheduler.</span></span><br><span class="line"><span class="meta">spring.quartz.startup-delay</span>=<span class="string">0s # Delay after which the scheduler is started once initialization completes.</span></span><br><span class="line"><span class="meta">spring.quartz.wait-for-jobs-to-complete-on-shutdown</span>=<span class="string">false # Whether to wait for running jobs to complete on shutdown.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REACTOR (ReactorCoreProperties)</span></span><br><span class="line"><span class="meta">spring.reactor.stacktrace-mode.enabled</span>=<span class="string">false # Whether Reactor should collect stacktrace information at runtime.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SENDGRID (SendGridAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.sendgrid.api-key</span>= <span class="string"># SendGrid API key.</span></span><br><span class="line"><span class="meta">spring.sendgrid.proxy.host</span>= <span class="string"># SendGrid proxy host.</span></span><br><span class="line"><span class="meta">spring.sendgrid.proxy.port</span>= <span class="string"># SendGrid proxy port.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TASK EXECUTION  (TaskExecutionProperties)</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.allow-core-thread-timeout</span>=<span class="string">true # Whether core threads are allowed to time out. This enables dynamic growing and shrinking of the pool.</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.core-size</span>=<span class="string">8 # Core number of threads.</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">60s # Time limit for which threads may remain idle before being terminated.</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.max-size</span>= <span class="string"># Maximum allowed number of threads. If tasks are filling up the queue, the pool can expand up to that size to accommodate the load. Ignored if the queue is unbounded.</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>= <span class="string"># Queue capacity. An unbounded capacity does not increase the pool and therefore ignores the &quot;max-size&quot; property.</span></span><br><span class="line"><span class="meta">spring.task.execution.thread-name-prefix</span>=<span class="string">task- # Prefix to use for the names of newly created threads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TASK SCHEDULING  (TaskSchedulingProperties)</span></span><br><span class="line"><span class="meta">spring.task.scheduling.pool.size</span>=<span class="string">1 # Maximum allowed number of threads.</span></span><br><span class="line"><span class="meta">spring.task.scheduling.thread-name-prefix</span>=<span class="string">scheduling- # Prefix to use for the names of newly created threads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># WEB PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span></span><br><span class="line"><span class="meta">server.address</span>= <span class="string"># Network address to which the server should bind.</span></span><br><span class="line"><span class="meta">server.compression.enabled</span>=<span class="string">false # Whether response compression is enabled.</span></span><br><span class="line"><span class="meta">server.compression.excluded-user-agents</span>= <span class="string"># Comma-separated list of user agents for which responses should not be compressed.</span></span><br><span class="line"><span class="meta">server.compression.mime-types</span>=<span class="string">text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json,application/xml # Comma-separated list of MIME types that should be compressed.</span></span><br><span class="line"><span class="meta">server.compression.min-response-size</span>=<span class="string">2KB # Minimum &quot;Content-Length&quot; value that is required for compression to be performed.</span></span><br><span class="line"><span class="meta">server.connection-timeout</span>= <span class="string"># Time that connectors wait for another HTTP request before closing the connection. When not set, the connector&#x27;s container-specific default is used. Use a value of -1 to indicate no (that is, an infinite) timeout.</span></span><br><span class="line"><span class="meta">server.error.include-exception</span>=<span class="string">false # Include the &quot;exception&quot; attribute.</span></span><br><span class="line"><span class="meta">server.error.include-stacktrace</span>=<span class="string">never # When to include a &quot;stacktrace&quot; attribute.</span></span><br><span class="line"><span class="meta">server.error.path</span>=<span class="string">/error # Path of the error controller.</span></span><br><span class="line"><span class="meta">server.error.whitelabel.enabled</span>=<span class="string">true # Whether to enable the default error page displayed in browsers in case of a server error.</span></span><br><span class="line"><span class="meta">server.http2.enabled</span>=<span class="string">false # Whether to enable HTTP/2 support, if the current environment supports it.</span></span><br><span class="line"><span class="meta">server.jetty.acceptors</span>=<span class="string">-1 # Number of acceptor threads to use. When the value is -1, the default, the number of acceptors is derived from the operating environment.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.append</span>=<span class="string">false # Append to log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.date-format</span>=<span class="string">dd/MMM/yyyy:HH:mm:ss Z # Timestamp format of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.enabled</span>=<span class="string">false # Enable access log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.extended-format</span>=<span class="string">false # Enable extended NCSA format.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.file-date-format</span>= <span class="string"># Date format to place in log file name.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.filename</span>= <span class="string"># Log filename. If not specified, logs redirect to &quot;System.err&quot;.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.locale</span>= <span class="string"># Locale of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-cookies</span>=<span class="string">false # Enable logging of the request cookies.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-latency</span>=<span class="string">false # Enable logging of request processing time.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.log-server</span>=<span class="string">false # Enable logging of the request hostname.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.retention-period</span>=<span class="string">31 # Number of days before rotated log files are deleted.</span></span><br><span class="line"><span class="meta">server.jetty.accesslog.time-zone</span>=<span class="string">GMT # Timezone of the request log.</span></span><br><span class="line"><span class="meta">server.jetty.max-http-post-size</span>=<span class="string">200000B # Maximum size of the HTTP post or put content.</span></span><br><span class="line"><span class="meta">server.jetty.selectors</span>=<span class="string">-1 # Number of selector threads to use. When the value is -1, the default, the number of selectors is derived from the operating environment.</span></span><br><span class="line"><span class="meta">server.max-http-header-size</span>=<span class="string">8KB # Maximum size of the HTTP message header.</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080 # Server HTTP port.</span></span><br><span class="line"><span class="meta">server.server-header</span>= <span class="string"># Value to use for the Server response header (if empty, no header is sent).</span></span><br><span class="line"><span class="meta">server.use-forward-headers</span>= <span class="string"># Whether X-Forwarded-* headers should be applied to the HttpRequest.</span></span><br><span class="line"><span class="meta">server.servlet.context-parameters.*</span>= <span class="string"># Servlet context init parameters.</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>= <span class="string"># Context path of the application.</span></span><br><span class="line"><span class="meta">server.servlet.application-display-name</span>=<span class="string">application # Display name of the application.</span></span><br><span class="line"><span class="meta">server.servlet.jsp.class-name</span>=<span class="string">org.apache.jasper.servlet.JspServlet # Class name of the servlet to use for JSPs.</span></span><br><span class="line"><span class="meta">server.servlet.jsp.init-parameters.*</span>= <span class="string"># Init parameters used to configure the JSP servlet.</span></span><br><span class="line"><span class="meta">server.servlet.jsp.registered</span>=<span class="string">true # Whether the JSP servlet is registered.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.comment</span>= <span class="string"># Comment for the session cookie.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.domain</span>= <span class="string"># Domain for the session cookie.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.http-only</span>= <span class="string"># Whether to use &quot;HttpOnly&quot; cookies for session cookies.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.max-age</span>= <span class="string"># Maximum age of the session cookie. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.name</span>= <span class="string"># Session cookie name.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.path</span>= <span class="string"># Path of the session cookie.</span></span><br><span class="line"><span class="meta">server.servlet.session.cookie.secure</span>= <span class="string"># Whether to always mark the session cookie as secure.</span></span><br><span class="line"><span class="meta">server.servlet.session.persistent</span>=<span class="string">false # Whether to persist session data between restarts.</span></span><br><span class="line"><span class="meta">server.servlet.session.store-dir</span>= <span class="string"># Directory used to store session data.</span></span><br><span class="line"><span class="meta">server.servlet.session.timeout</span>=<span class="string">30m # Session timeout. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">server.servlet.session.tracking-modes</span>= <span class="string"># Session tracking modes.</span></span><br><span class="line"><span class="meta">server.ssl.ciphers</span>= <span class="string"># Supported SSL ciphers.</span></span><br><span class="line"><span class="meta">server.ssl.client-auth</span>= <span class="string"># Client authentication mode.</span></span><br><span class="line"><span class="meta">server.ssl.enabled</span>=<span class="string">true # Whether to enable SSL support.</span></span><br><span class="line"><span class="meta">server.ssl.enabled-protocols</span>= <span class="string"># Enabled SSL protocols.</span></span><br><span class="line"><span class="meta">server.ssl.key-alias</span>= <span class="string"># Alias that identifies the key in the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-password</span>= <span class="string"># Password used to access the key in the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate (typically a jks file).</span></span><br><span class="line"><span class="meta">server.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store-provider</span>= <span class="string"># Provider for the key store.</span></span><br><span class="line"><span class="meta">server.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">server.ssl.protocol</span>=<span class="string">TLS # SSL protocol to use.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-provider</span>= <span class="string"># Provider for the trust store.</span></span><br><span class="line"><span class="meta">server.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">server.tomcat.accept-count</span>=<span class="string">100 # Maximum queue length for incoming connection requests when all possible request processing threads are in use.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.buffered</span>=<span class="string">true # Whether to buffer output such that it is flushed only periodically.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.directory</span>=<span class="string">logs # Directory in which log files are created. Can be absolute or relative to the Tomcat base dir.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.enabled</span>=<span class="string">false # Enable access log.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.file-date-format</span>=<span class="string">.yyyy-MM-dd # Date format to place in the log file name.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.pattern</span>=<span class="string">common # Format pattern for access logs.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.prefix</span>=<span class="string">access_log # Log file name prefix.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.rename-on-rotate</span>=<span class="string">false # Whether to defer inclusion of the date stamp in the file name until rotate time.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.request-attributes-enabled</span>=<span class="string">false # Set request attributes for the IP address, Hostname, protocol, and port used for the request.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.rotate</span>=<span class="string">true # Whether to enable access log rotation.</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.suffix</span>=<span class="string">.log # Log file name suffix.</span></span><br><span class="line"><span class="meta">server.tomcat.additional-tld-skip-patterns</span>= <span class="string"># Comma-separated list of additional patterns that match jars to ignore for TLD scanning.</span></span><br><span class="line"><span class="meta">server.tomcat.background-processor-delay</span>=<span class="string">10s # Delay between the invocation of backgroundProcess methods. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">server.tomcat.basedir</span>= <span class="string"># Tomcat base directory. If not specified, a temporary directory is used.</span></span><br><span class="line"><span class="meta">server.tomcat.internal-proxies</span>=<span class="string">10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|\\</span></span><br><span class="line">		<span class="attr">172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\</span></span><br><span class="line">		<span class="attr">0</span>:<span class="string">0:0:0:0:0:0:1\\</span></span><br><span class="line">		::1 # Regular expression that matches proxies that are to be trusted.</span><br><span class="line"><span class="meta">server.tomcat.max-connections</span>=<span class="string">10000 # Maximum number of connections that the server accepts and processes at any given time.</span></span><br><span class="line"><span class="meta">server.tomcat.max-http-post-size</span>=<span class="string">2MB # Maximum size of the HTTP post content.</span></span><br><span class="line"><span class="meta">server.tomcat.max-swallow-size</span>=<span class="string">2MB # Maximum amount of request body to swallow.</span></span><br><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">200 # Maximum amount of worker threads.</span></span><br><span class="line"><span class="meta">server.tomcat.min-spare-threads</span>=<span class="string">10 # Minimum amount of worker threads.</span></span><br><span class="line"><span class="meta">server.tomcat.port-header</span>=<span class="string">X-Forwarded-Port # Name of the HTTP header used to override the original port value.</span></span><br><span class="line"><span class="meta">server.tomcat.protocol-header</span>= <span class="string"># Header that holds the incoming protocol, usually named &quot;X-Forwarded-Proto&quot;.</span></span><br><span class="line"><span class="meta">server.tomcat.protocol-header-https-value</span>=<span class="string">https # Value of the protocol header indicating whether the incoming request uses SSL.</span></span><br><span class="line"><span class="meta">server.tomcat.redirect-context-root</span>=<span class="string">true # Whether requests to the context root should be redirected by appending a / to the path.</span></span><br><span class="line"><span class="meta">server.tomcat.remote-ip-header</span>= <span class="string"># Name of the HTTP header from which the remote IP is extracted. For instance, `X-FORWARDED-FOR`.</span></span><br><span class="line"><span class="meta">server.tomcat.resource.allow-caching</span>=<span class="string">true # Whether static resource caching is permitted for this web application.</span></span><br><span class="line"><span class="meta">server.tomcat.resource.cache-ttl</span>= <span class="string"># Time-to-live of the static resource cache.</span></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8 # Character encoding to use to decode the URI.</span></span><br><span class="line"><span class="meta">server.tomcat.use-relative-redirects</span>= <span class="string"># Whether HTTP 1.1 and later location headers generated by a call to sendRedirect will use relative or absolute redirects.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.dir</span>= <span class="string"># Undertow access log directory.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.enabled</span>=<span class="string">false # Whether to enable the access log.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.pattern</span>=<span class="string">common # Format pattern for access logs.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.prefix</span>=<span class="string">access_log. # Log file name prefix.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.rotate</span>=<span class="string">true # Whether to enable access log rotation.</span></span><br><span class="line"><span class="meta">server.undertow.accesslog.suffix</span>=<span class="string">log # Log file name suffix.</span></span><br><span class="line"><span class="meta">server.undertow.buffer-size</span>= <span class="string"># Size of each buffer.</span></span><br><span class="line"><span class="meta">server.undertow.direct-buffers</span>= <span class="string"># Whether to allocate buffers outside the Java heap. The default is derived from the maximum amount of memory that is available to the JVM.</span></span><br><span class="line"><span class="meta">server.undertow.eager-filter-init</span>=<span class="string">true # Whether servlet filters should be initialized on startup.</span></span><br><span class="line"><span class="meta">server.undertow.io-threads</span>= <span class="string"># Number of I/O threads to create for the worker. The default is derived from the number of available processors.</span></span><br><span class="line"><span class="meta">server.undertow.max-http-post-size</span>=<span class="string">-1B # Maximum size of the HTTP post content. When the value is -1, the default, the size is unlimited.</span></span><br><span class="line"><span class="meta">server.undertow.worker-threads</span>= <span class="string"># Number of worker threads. The default is 8 times the number of I/O threads.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FREEMARKER (FreeMarkerProperties)</span></span><br><span class="line"><span class="meta">spring.freemarker.allow-request-override</span>=<span class="string">false # Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.freemarker.allow-session-override</span>=<span class="string">false # Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.freemarker.cache</span>=<span class="string">false # Whether to enable template caching.</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">UTF-8 # Template encoding.</span></span><br><span class="line"><span class="meta">spring.freemarker.check-template-location</span>=<span class="string">true # Whether to check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.freemarker.content-type</span>=<span class="string">text/html # Content-Type value.</span></span><br><span class="line"><span class="meta">spring.freemarker.enabled</span>=<span class="string">true # Whether to enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-request-attributes</span>=<span class="string">false # Whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-session-attributes</span>=<span class="string">false # Whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-spring-macro-helpers</span>=<span class="string">true # Whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.freemarker.prefer-file-system-access</span>=<span class="string">true # Whether to prefer file system access for template loading. File system access enables hot detection of template changes.</span></span><br><span class="line"><span class="meta">spring.freemarker.prefix</span>= <span class="string"># Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.freemarker.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.freemarker.settings.*</span>= <span class="string"># Well-known FreeMarker keys which are passed to FreeMarker&#x27;s Configuration.</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.ftl # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/ # Comma-separated list of template paths.</span></span><br><span class="line"><span class="meta">spring.freemarker.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GROOVY TEMPLATES (GroovyTemplateProperties)</span></span><br><span class="line"><span class="meta">spring.groovy.template.allow-request-override</span>=<span class="string">false # Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.groovy.template.allow-session-override</span>=<span class="string">false # Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.groovy.template.cache</span>=<span class="string">false # Whether to enable template caching.</span></span><br><span class="line"><span class="meta">spring.groovy.template.charset</span>=<span class="string">UTF-8 # Template encoding.</span></span><br><span class="line"><span class="meta">spring.groovy.template.check-template-location</span>=<span class="string">true # Whether to check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.groovy.template.configuration.*</span>= <span class="string"># See GroovyMarkupConfigurer</span></span><br><span class="line"><span class="meta">spring.groovy.template.content-type</span>=<span class="string">text/html # Content-Type value.</span></span><br><span class="line"><span class="meta">spring.groovy.template.enabled</span>=<span class="string">true # Whether to enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-request-attributes</span>=<span class="string">false # Whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-session-attributes</span>=<span class="string">false # Whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.groovy.template.expose-spring-macro-helpers</span>=<span class="string">true # Whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.groovy.template.prefix</span>= <span class="string"># Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.groovy.template.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.groovy.template.resource-loader-path</span>=<span class="string">classpath:/templates/ # Template path.</span></span><br><span class="line"><span class="meta">spring.groovy.template.suffix</span>=<span class="string">.tpl # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.groovy.template.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING HATEOAS (HateoasProperties)</span></span><br><span class="line"><span class="meta">spring.hateoas.use-hal-as-default-json-media-type</span>=<span class="string">true # Whether application/hal+json responses should be sent to requests that accept application/json.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP (HttpProperties)</span></span><br><span class="line"><span class="meta">spring.http.converters.preferred-json-mapper</span>= <span class="string"># Preferred JSON mapper to use for HTTP message conversion. By default, auto-detected according to the environment.</span></span><br><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">UTF-8 # Charset of HTTP requests and responses. Added to the &quot;Content-Type&quot; header if not set explicitly.</span></span><br><span class="line"><span class="meta">spring.http.encoding.enabled</span>=<span class="string">true # Whether to enable http encoding support.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force</span>= <span class="string"># Whether to force the encoding to the configured charset on HTTP requests and responses.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force-request</span>= <span class="string"># Whether to force the encoding to the configured charset on HTTP requests. Defaults to true when &quot;force&quot; has not been specified.</span></span><br><span class="line"><span class="meta">spring.http.encoding.force-response</span>= <span class="string"># Whether to force the encoding to the configured charset on HTTP responses.</span></span><br><span class="line"><span class="meta">spring.http.encoding.mapping</span>= <span class="string"># Locale in which to encode mapping.</span></span><br><span class="line"><span class="meta">spring.http.log-request-details</span>=<span class="string">false # Whether logging of (potentially sensitive) request details at DEBUG and TRACE level is allowed.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MULTIPART (MultipartProperties)</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.enabled</span>=<span class="string">true # Whether to enable support of multipart uploads.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.file-size-threshold</span>=<span class="string">0B # Threshold after which files are written to disk.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.location</span>= <span class="string"># Intermediate location of uploaded files.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">1MB # Max file size.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">10MB # Max request size.</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.resolve-lazily</span>=<span class="string">false # Whether to resolve the multipart request lazily at the time of file or parameter access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JACKSON (JacksonProperties)</span></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>= <span class="string"># Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span></span><br><span class="line"><span class="meta">spring.jackson.default-property-inclusion</span>= <span class="string"># Controls the inclusion of properties during serialization. Configured with one of the values in Jackson&#x27;s JsonInclude.Include enumeration.</span></span><br><span class="line"><span class="meta">spring.jackson.deserialization.*</span>= <span class="string"># Jackson on/off features that affect the way Java objects are deserialized.</span></span><br><span class="line"><span class="meta">spring.jackson.generator.*</span>= <span class="string"># Jackson on/off features for generators.</span></span><br><span class="line"><span class="meta">spring.jackson.joda-date-time-format</span>= <span class="string"># Joda date time format string. If not configured, &quot;date-format&quot; is used as a fallback if it is configured with a format string.</span></span><br><span class="line"><span class="meta">spring.jackson.locale</span>= <span class="string"># Locale used for formatting.</span></span><br><span class="line"><span class="meta">spring.jackson.mapper.*</span>= <span class="string"># Jackson general purpose on/off features.</span></span><br><span class="line"><span class="meta">spring.jackson.parser.*</span>= <span class="string"># Jackson on/off features for parsers.</span></span><br><span class="line"><span class="meta">spring.jackson.property-naming-strategy</span>= <span class="string"># One of the constants on Jackson&#x27;s PropertyNamingStrategy. Can also be a fully-qualified class name of a PropertyNamingStrategy subclass.</span></span><br><span class="line"><span class="meta">spring.jackson.serialization.*</span>= <span class="string"># Jackson on/off features that affect the way Java objects are serialized.</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>= <span class="string">#  Time zone used when formatting dates. For instance, &quot;America/Los_Angeles&quot; or &quot;GMT+10&quot;.</span></span><br><span class="line"><span class="meta">spring.jackson.visibility.*</span>= <span class="string"># Jackson visibility thresholds that can be used to limit which methods (and fields) are auto-detected.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GSON (GsonProperties)</span></span><br><span class="line"><span class="meta">spring.gson.date-format</span>= <span class="string"># Format to use when serializing Date objects.</span></span><br><span class="line"><span class="meta">spring.gson.disable-html-escaping</span>= <span class="string"># Whether to disable the escaping of HTML characters such as &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, etc.</span></span><br><span class="line"><span class="meta">spring.gson.disable-inner-class-serialization</span>= <span class="string"># Whether to exclude inner classes during serialization.</span></span><br><span class="line"><span class="meta">spring.gson.enable-complex-map-key-serialization</span>= <span class="string"># Whether to enable serialization of complex map keys (i.e. non-primitives).</span></span><br><span class="line"><span class="meta">spring.gson.exclude-fields-without-expose-annotation</span>= <span class="string"># Whether to exclude all fields from consideration for serialization or deserialization that do not have the &quot;Expose&quot; annotation.</span></span><br><span class="line"><span class="meta">spring.gson.field-naming-policy</span>= <span class="string"># Naming policy that should be applied to an object&#x27;s field during serialization and deserialization.</span></span><br><span class="line"><span class="meta">spring.gson.generate-non-executable-json</span>= <span class="string"># Whether to generate non executable JSON by prefixing the output with some special text.</span></span><br><span class="line"><span class="meta">spring.gson.lenient</span>= <span class="string"># Whether to be lenient about parsing JSON that doesn&#x27;t conform to RFC 4627.</span></span><br><span class="line"><span class="meta">spring.gson.long-serialization-policy</span>= <span class="string"># Serialization policy for Long and long types.</span></span><br><span class="line"><span class="meta">spring.gson.pretty-printing</span>= <span class="string"># Whether to output serialized JSON that fits in a page for pretty printing.</span></span><br><span class="line"><span class="meta">spring.gson.serialize-nulls</span>= <span class="string"># Whether to serialize null fields.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JERSEY (JerseyProperties)</span></span><br><span class="line"><span class="meta">spring.jersey.application-path</span>= <span class="string"># Path that serves as the base URI for the application. If specified, overrides the value of &quot;@ApplicationPath&quot;.</span></span><br><span class="line"><span class="meta">spring.jersey.filter.order</span>=<span class="string">0 # Jersey filter chain order.</span></span><br><span class="line"><span class="meta">spring.jersey.init.*</span>= <span class="string"># Init parameters to pass to Jersey through the servlet or filter.</span></span><br><span class="line"><span class="meta">spring.jersey.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the Jersey servlet.</span></span><br><span class="line"><span class="meta">spring.jersey.type</span>=<span class="string">servlet # Jersey integration type.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING LDAP (LdapProperties)</span></span><br><span class="line"><span class="meta">spring.ldap.anonymous-read-only</span>=<span class="string">false # Whether read-only operations should use an anonymous environment.</span></span><br><span class="line"><span class="meta">spring.ldap.base</span>= <span class="string"># Base suffix from which all operations should originate.</span></span><br><span class="line"><span class="meta">spring.ldap.base-environment.*</span>= <span class="string"># LDAP specification settings.</span></span><br><span class="line"><span class="meta">spring.ldap.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line"><span class="meta">spring.ldap.urls</span>= <span class="string"># LDAP URLs of the server.</span></span><br><span class="line"><span class="meta">spring.ldap.username</span>= <span class="string"># Login username of the server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED LDAP (EmbeddedLdapProperties)</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.base-dn</span>= <span class="string"># List of base DNs.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.credential.username</span>= <span class="string"># Embedded LDAP username.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.credential.password</span>= <span class="string"># Embedded LDAP password.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.ldif</span>=<span class="string">classpath:schema.ldif # Schema (LDIF) script resource reference.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.port</span>=<span class="string">0 # Embedded LDAP port.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.validation.enabled</span>=<span class="string">true # Whether to enable LDAP schema validation.</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.validation.schema</span>= <span class="string"># Path to the custom schema.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MUSTACHE TEMPLATES (MustacheAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.mustache.allow-request-override</span>=<span class="string">false # Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.mustache.allow-session-override</span>=<span class="string">false # Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</span></span><br><span class="line"><span class="meta">spring.mustache.cache</span>=<span class="string">false # Whether to enable template caching.</span></span><br><span class="line"><span class="meta">spring.mustache.charset</span>=<span class="string">UTF-8 # Template encoding.</span></span><br><span class="line"><span class="meta">spring.mustache.check-template-location</span>=<span class="string">true # Whether to check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.mustache.content-type</span>=<span class="string">text/html # Content-Type value.</span></span><br><span class="line"><span class="meta">spring.mustache.enabled</span>=<span class="string">true # Whether to enable MVC view resolution for this technology.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-request-attributes</span>=<span class="string">false # Whether all request attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-session-attributes</span>=<span class="string">false # Whether all HttpSession attributes should be added to the model prior to merging with the template.</span></span><br><span class="line"><span class="meta">spring.mustache.expose-spring-macro-helpers</span>=<span class="string">true # Whether to expose a RequestContext for use by Spring&#x27;s macro library, under the name &quot;springMacroRequestContext&quot;.</span></span><br><span class="line"><span class="meta">spring.mustache.prefix</span>=<span class="string">classpath:/templates/ # Prefix to apply to template names.</span></span><br><span class="line"><span class="meta">spring.mustache.request-context-attribute</span>= <span class="string"># Name of the RequestContext attribute for all views.</span></span><br><span class="line"><span class="meta">spring.mustache.suffix</span>=<span class="string">.mustache # Suffix to apply to template names.</span></span><br><span class="line"><span class="meta">spring.mustache.view-names</span>= <span class="string"># White list of view names that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING MVC (WebMvcProperties)</span></span><br><span class="line"><span class="meta">spring.mvc.async.request-timeout</span>= <span class="string"># Amount of time before asynchronous request handling times out.</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">false # Whether a request parameter (&quot;format&quot; by default) should be used to determine the requested media type.</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-path-extension</span>=<span class="string">false # Whether the path extension in the URL path should be used to determine the requested media type.</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.media-types.*</span>= <span class="string"># Map file extensions to media types for content negotiation. For instance, yml to text/yaml.</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.parameter-name</span>= <span class="string"># Query parameter name to use when &quot;favor-parameter&quot; is enabled.</span></span><br><span class="line"><span class="meta">spring.mvc.date-format</span>= <span class="string"># Date format to use. For instance, `dd/MM/yyyy`.</span></span><br><span class="line"><span class="meta">spring.mvc.dispatch-trace-request</span>=<span class="string">false # Whether to dispatch TRACE requests to the FrameworkServlet doService method.</span></span><br><span class="line"><span class="meta">spring.mvc.dispatch-options-request</span>=<span class="string">true # Whether to dispatch OPTIONS requests to the FrameworkServlet doService method.</span></span><br><span class="line"><span class="meta">spring.mvc.favicon.enabled</span>=<span class="string">true # Whether to enable resolution of favicon.ico.</span></span><br><span class="line"><span class="meta">spring.mvc.formcontent.filter.enabled</span>=<span class="string">true # Whether to enable Spring&#x27;s FormContentFilter.</span></span><br><span class="line"><span class="meta">spring.mvc.hiddenmethod.filter.enabled</span>=<span class="string">true # Whether to enable Spring&#x27;s HiddenHttpMethodFilter.</span></span><br><span class="line"><span class="meta">spring.mvc.ignore-default-model-on-redirect</span>=<span class="string">true # Whether the content of the &quot;default&quot; model should be ignored during redirect scenarios.</span></span><br><span class="line"><span class="meta">spring.mvc.locale</span>= <span class="string"># Locale to use. By default, this locale is overridden by the &quot;Accept-Language&quot; header.</span></span><br><span class="line"><span class="meta">spring.mvc.locale-resolver</span>=<span class="string">accept-header # Define how the locale should be resolved.</span></span><br><span class="line"><span class="meta">spring.mvc.log-resolved-exception</span>=<span class="string">false # Whether to enable warn logging of exceptions resolved by a &quot;HandlerExceptionResolver&quot;, except for &quot;DefaultHandlerExceptionResolver&quot;.</span></span><br><span class="line"><span class="meta">spring.mvc.message-codes-resolver-format</span>= <span class="string"># Formatting strategy for message codes. For instance, `PREFIX_ERROR_CODE`.</span></span><br><span class="line"><span class="meta">spring.mvc.pathmatch.use-registered-suffix-pattern</span>=<span class="string">false # Whether suffix pattern matching should work only against extensions registered with &quot;spring.mvc.contentnegotiation.media-types.*&quot;.</span></span><br><span class="line"><span class="meta">spring.mvc.pathmatch.use-suffix-pattern</span>=<span class="string">false # Whether to use suffix pattern match (&quot;.*&quot;) when matching patterns to requests.</span></span><br><span class="line"><span class="meta">spring.mvc.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the dispatcher servlet.</span></span><br><span class="line"><span class="meta">spring.mvc.servlet.path</span>=<span class="string">/ # Path of the dispatcher servlet.</span></span><br><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/** # Path pattern used for static resources.</span></span><br><span class="line"><span class="meta">spring.mvc.throw-exception-if-no-handler-found</span>=<span class="string">false # Whether a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.</span></span><br><span class="line"><span class="meta">spring.mvc.view.prefix</span>= <span class="string"># Spring MVC view prefix.</span></span><br><span class="line"><span class="meta">spring.mvc.view.suffix</span>= <span class="string"># Spring MVC view suffix.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING RESOURCES HANDLING (ResourceProperties)</span></span><br><span class="line"><span class="meta">spring.resources.add-mappings</span>=<span class="string">true # Whether to enable default resource handling.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.cache-private</span>= <span class="string"># Indicate that the response message is intended for a single user and must not be stored by a shared cache.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.cache-public</span>= <span class="string"># Indicate that any cache may store the response.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.max-age</span>= <span class="string"># Maximum time the response should be cached, in seconds if no duration suffix is not specified.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.must-revalidate</span>= <span class="string"># Indicate that once it has become stale, a cache must not use the response without re-validating it with the server.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.no-cache</span>= <span class="string"># Indicate that the cached response can be reused only if re-validated with the server.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.no-store</span>= <span class="string"># Indicate to not cache the response in any case.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.no-transform</span>= <span class="string"># Indicate intermediaries (caches and others) that they should not transform the response content.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.proxy-revalidate</span>= <span class="string"># Same meaning as the &quot;must-revalidate&quot; directive, except that it does not apply to private caches.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.s-max-age</span>= <span class="string"># Maximum time the response should be cached by shared caches, in seconds if no duration suffix is not specified.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.stale-if-error</span>= <span class="string"># Maximum time the response may be used when errors are encountered, in seconds if no duration suffix is not specified.</span></span><br><span class="line"><span class="meta">spring.resources.cache.cachecontrol.stale-while-revalidate</span>= <span class="string"># Maximum time the response can be served after it becomes stale, in seconds if no duration suffix is not specified.</span></span><br><span class="line"><span class="meta">spring.resources.cache.period</span>= <span class="string"># Cache period for the resources served by the resource handler. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.resources.chain.cache</span>=<span class="string">true # Whether to enable caching in the Resource chain.</span></span><br><span class="line"><span class="meta">spring.resources.chain.compressed</span>=<span class="string">false # Whether to enable resolution of already compressed resources (gzip, brotli).</span></span><br><span class="line"><span class="meta">spring.resources.chain.enabled</span>= <span class="string"># Whether to enable the Spring Resource Handling chain. By default, disabled unless at least one strategy has been enabled.</span></span><br><span class="line"><span class="meta">spring.resources.chain.html-application-cache</span>=<span class="string">false # Whether to enable HTML5 application cache manifest rewriting.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.enabled</span>=<span class="string">false # Whether to enable the content Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.paths</span>=<span class="string">/** # Comma-separated list of patterns to apply to the content Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.enabled</span>=<span class="string">false # Whether to enable the fixed Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.paths</span>=<span class="string">/** # Comma-separated list of patterns to apply to the fixed Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.version</span>= <span class="string"># Version string to use for the fixed Version Strategy.</span></span><br><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/ # Locations of static resources.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION (SessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.store-type</span>= <span class="string"># Session store type.</span></span><br><span class="line"><span class="meta">spring.session.timeout</span>= <span class="string"># Session timeout. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.session.servlet.filter-order</span>=<span class="string">-2147483598 # Session repository filter order.</span></span><br><span class="line"><span class="meta">spring.session.servlet.filter-dispatcher-types</span>=<span class="string">async,error,request # Session repository filter dispatcher types.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION HAZELCAST (HazelcastSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.hazelcast.flush-mode</span>=<span class="string">on-save # Sessions flush mode.</span></span><br><span class="line"><span class="meta">spring.session.hazelcast.map-name</span>=<span class="string">spring:session:sessions # Name of the map used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION JDBC (JdbcSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.jdbc.cleanup-cron</span>=<span class="string">0 * * * * * # Cron expression for expired session cleanup job.</span></span><br><span class="line"><span class="meta">spring.session.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.session.jdbc.schema</span>=<span class="string">classpath:org/springframework/session/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.session.jdbc.table-name</span>=<span class="string">SPRING_SESSION # Name of the database table used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION MONGODB (MongoSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.mongodb.collection-name</span>=<span class="string">sessions # Collection name used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING SESSION REDIS (RedisSessionProperties)</span></span><br><span class="line"><span class="meta">spring.session.redis.cleanup-cron</span>=<span class="string">0 * * * * * # Cron expression for expired session cleanup job.</span></span><br><span class="line"><span class="meta">spring.session.redis.flush-mode</span>=<span class="string">on-save # Sessions flush mode.</span></span><br><span class="line"><span class="meta">spring.session.redis.namespace</span>=<span class="string">spring:session # Namespace for keys used to store sessions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THYMELEAF (ThymeleafAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">true # Whether to enable template caching.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template</span>=<span class="string">true # Whether to check that the template exists before rendering it.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.check-template-location</span>=<span class="string">true # Whether to check that the templates location exists.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.enabled</span>=<span class="string">true # Whether to enable Thymeleaf view resolution for Web frameworks.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.enable-spring-el-compiler</span>=<span class="string">false # Enable the SpringEL compiler in SpringEL expressions.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span>=<span class="string">UTF-8 # Template files encoding.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.excluded-view-names</span>= <span class="string"># Comma-separated list of view names (patterns allowed) that should be excluded from resolution.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.mode</span>=<span class="string">HTML # Template mode to be applied to templates. See also Thymeleaf&#x27;s TemplateMode enum.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.prefix</span>=<span class="string">classpath:/templates/ # Prefix that gets prepended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.chunked-mode-view-names</span>= <span class="string"># Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.full-mode-view-names</span>= <span class="string"># Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.max-chunk-size</span>=<span class="string">0B # Maximum size of data buffers used for writing to the response.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.reactive.media-types</span>= <span class="string"># Media types supported by the view technology.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.render-hidden-markers-before-checkboxes</span>=<span class="string">false # Whether hidden form inputs acting as markers for checkboxes should be rendered before the checkbox element itself.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.servlet.content-type</span>=<span class="string">text/html # Content-Type value written to HTTP responses.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.servlet.produce-partial-output-while-processing</span>=<span class="string">true # Whether Thymeleaf should start writing partial output as soon as possible or buffer until template processing is finished.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.suffix</span>=<span class="string">.html # Suffix that gets appended to view names when building a URL.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.template-resolver-order</span>= <span class="string"># Order of the template resolver in the chain.</span></span><br><span class="line"><span class="meta">spring.thymeleaf.view-names</span>= <span class="string"># Comma-separated list of view names (patterns allowed) that can be resolved.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING WEBFLUX (WebFluxProperties)</span></span><br><span class="line"><span class="meta">spring.webflux.date-format</span>= <span class="string"># Date format to use. For instance, `dd/MM/yyyy`.</span></span><br><span class="line"><span class="meta">spring.webflux.hiddenmethod.filter.enabled</span>=<span class="string">true # Whether to enable Spring&#x27;s HiddenHttpMethodFilter.</span></span><br><span class="line"><span class="meta">spring.webflux.static-path-pattern</span>=<span class="string">/** # Path pattern used for static resources.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING WEB SERVICES (WebServicesProperties)</span></span><br><span class="line"><span class="meta">spring.webservices.path</span>=<span class="string">/services # Path that serves as the base URI for the services.</span></span><br><span class="line"><span class="meta">spring.webservices.servlet.init</span>= <span class="string"># Servlet init parameters to pass to Spring Web Services.</span></span><br><span class="line"><span class="meta">spring.webservices.servlet.load-on-startup</span>=<span class="string">-1 # Load on startup priority of the Spring Web Services servlet.</span></span><br><span class="line"><span class="meta">spring.webservices.wsdl-locations</span>= <span class="string"># Comma-separated list of locations of WSDLs and accompanying XSDs to be exposed as beans.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># SECURITY PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># SECURITY (SecurityProperties)</span></span><br><span class="line"><span class="meta">spring.security.filter.order</span>=<span class="string">-100 # Security filter chain order.</span></span><br><span class="line"><span class="meta">spring.security.filter.dispatcher-types</span>=<span class="string">async,error,request # Security filter chain dispatcher types.</span></span><br><span class="line"><span class="meta">spring.security.user.name</span>=<span class="string">user # Default user name.</span></span><br><span class="line"><span class="meta">spring.security.user.password</span>= <span class="string"># Password for the default user name.</span></span><br><span class="line"><span class="meta">spring.security.user.roles</span>= <span class="string"># Granted roles for the default user name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY OAUTH2 CLIENT (OAuth2ClientProperties)</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.*</span>= <span class="string"># OAuth provider details.</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.*</span>= <span class="string"># OAuth client registrations.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SECURITY OAUTH2 RESOURCE SERVER (OAuth2ResourceServerProperties)</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.jwk-set-uri</span>= <span class="string"># JSON Web Key URI to use to verify the JWT token.</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.issuer-uri</span>= <span class="string"># URI that an OpenID Connect Provider asserts as its Issuer Identifier.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># DATA PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FLYWAY (FlywayProperties)</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-description</span>=<span class="string">&lt;&lt; Flyway Baseline &gt;&gt; # Description to tag an existing schema with when applying a baseline.</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-on-migrate</span>=<span class="string">false # Whether to automatically call baseline when migrating a non-empty schema.</span></span><br><span class="line"><span class="meta">spring.flyway.baseline-version</span>=<span class="string">1 # Version to tag an existing schema with when executing baseline.</span></span><br><span class="line"><span class="meta">spring.flyway.check-location</span>=<span class="string">true # Whether to check that migration scripts location exists.</span></span><br><span class="line"><span class="meta">spring.flyway.clean-disabled</span>=<span class="string">false # Whether to disable cleaning of the database.</span></span><br><span class="line"><span class="meta">spring.flyway.clean-on-validation-error</span>=<span class="string">false # Whether to automatically call clean when a validation error occurs.</span></span><br><span class="line"><span class="meta">spring.flyway.connect-retries</span>=<span class="string">0 # Maximum number of retries when attempting to connect to the database.</span></span><br><span class="line"><span class="meta">spring.flyway.enabled</span>=<span class="string">true # Whether to enable flyway.</span></span><br><span class="line"><span class="meta">spring.flyway.encoding</span>=<span class="string">UTF-8 # Encoding of SQL migrations.</span></span><br><span class="line"><span class="meta">spring.flyway.group</span>=<span class="string">false # Whether to group all pending migrations together in the same transaction when applying them.</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-future-migrations</span>=<span class="string">true # Whether to ignore future migrations when reading the schema history table.</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-ignored-migrations</span>=<span class="string">false # Whether to ignore ignored migrations when reading the schema history table.</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-missing-migrations</span>=<span class="string">false # Whether to ignore missing migrations when reading the schema history table.</span></span><br><span class="line"><span class="meta">spring.flyway.ignore-pending-migrations</span>=<span class="string">false # Whether to ignore pending migrations when reading the schema history table.</span></span><br><span class="line"><span class="meta">spring.flyway.init-sqls</span>= <span class="string"># SQL statements to execute to initialize a connection immediately after obtaining it.</span></span><br><span class="line"><span class="meta">spring.flyway.installed-by</span>= <span class="string"># Username recorded in the schema history table as having applied the migration.</span></span><br><span class="line"><span class="meta">spring.flyway.locations</span>=<span class="string">classpath:db/migration # Locations of migrations scripts. Can contain the special &quot;&#123;vendor&#125;&quot; placeholder to use vendor-specific locations.</span></span><br><span class="line"><span class="meta">spring.flyway.mixed</span>=<span class="string">false # Whether to allow mixing transactional and non-transactional statements within the same migration.</span></span><br><span class="line"><span class="meta">spring.flyway.out-of-order</span>=<span class="string">false # Whether to allow migrations to be run out of order.</span></span><br><span class="line"><span class="meta">spring.flyway.password</span>= <span class="string"># Login password of the database to migrate.</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-prefix</span>=<span class="string">$&#123; # Prefix of placeholders in migration scripts.</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-replacement</span>=<span class="string">true # Perform placeholder replacement in migration scripts.</span></span><br><span class="line"><span class="meta">spring.flyway.placeholder-suffix</span>=<span class="string">&#125; # Suffix of placeholders in migration scripts.</span></span><br><span class="line"><span class="meta">spring.flyway.placeholders</span>= <span class="string"># Placeholders and their replacements to apply to sql migration scripts.</span></span><br><span class="line"><span class="meta">spring.flyway.repeatable-sql-migration-prefix</span>=<span class="string">R # File name prefix for repeatable SQL migrations.</span></span><br><span class="line"><span class="meta">spring.flyway.schemas</span>= <span class="string"># Scheme names managed by Flyway (case-sensitive).</span></span><br><span class="line"><span class="meta">spring.flyway.skip-default-callbacks</span>=<span class="string">false # Whether to skip default callbacks. If true, only custom callbacks are used.</span></span><br><span class="line"><span class="meta">spring.flyway.skip-default-resolvers</span>=<span class="string">false # Whether to skip default resolvers. If true, only custom resolvers are used.</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-prefix</span>=<span class="string">V # File name prefix for SQL migrations.</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-separator</span>=<span class="string">__ # File name separator for SQL migrations.</span></span><br><span class="line"><span class="meta">spring.flyway.sql-migration-suffixes</span>=<span class="string">.sql # File name suffix for SQL migrations.</span></span><br><span class="line"><span class="meta">spring.flyway.table</span>=<span class="string">flyway_schema_history # Name of the schema schema history table that will be used by Flyway.</span></span><br><span class="line"><span class="meta">spring.flyway.target</span>= <span class="string"># Target version up to which migrations should be considered.</span></span><br><span class="line"><span class="meta">spring.flyway.url</span>= <span class="string"># JDBC url of the database to migrate. If not set, the primary configured data source is used.</span></span><br><span class="line"><span class="meta">spring.flyway.user</span>= <span class="string"># Login user of the database to migrate.</span></span><br><span class="line"><span class="meta">spring.flyway.validate-on-migrate</span>=<span class="string">true # Whether to automatically call validate when performing a migration.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LIQUIBASE (LiquibaseProperties)</span></span><br><span class="line"><span class="meta">spring.liquibase.change-log</span>=<span class="string">classpath:/db/changelog/db.changelog-master.yaml # Change log configuration path.</span></span><br><span class="line"><span class="meta">spring.liquibase.contexts</span>= <span class="string"># Comma-separated list of runtime contexts to use.</span></span><br><span class="line"><span class="meta">spring.liquibase.database-change-log-lock-table</span>=<span class="string">DATABASECHANGELOGLOCK # Name of table to use for tracking concurrent Liquibase usage.</span></span><br><span class="line"><span class="meta">spring.liquibase.database-change-log-table</span>=<span class="string">DATABASECHANGELOG # Name of table to use for tracking change history.</span></span><br><span class="line"><span class="meta">spring.liquibase.default-schema</span>= <span class="string"># Default database schema.</span></span><br><span class="line"><span class="meta">spring.liquibase.drop-first</span>=<span class="string">false # Whether to first drop the database schema.</span></span><br><span class="line"><span class="meta">spring.liquibase.enabled</span>=<span class="string">true # Whether to enable Liquibase support.</span></span><br><span class="line"><span class="meta">spring.liquibase.labels</span>= <span class="string"># Comma-separated list of runtime labels to use.</span></span><br><span class="line"><span class="meta">spring.liquibase.liquibase-schema</span>= <span class="string"># Schema to use for Liquibase objects.</span></span><br><span class="line"><span class="meta">spring.liquibase.liquibase-tablespace</span>= <span class="string"># Tablespace to use for Liquibase objects.</span></span><br><span class="line"><span class="meta">spring.liquibase.parameters.*</span>= <span class="string"># Change log parameters.</span></span><br><span class="line"><span class="meta">spring.liquibase.password</span>= <span class="string"># Login password of the database to migrate.</span></span><br><span class="line"><span class="meta">spring.liquibase.rollback-file</span>= <span class="string"># File to which rollback SQL is written when an update is performed.</span></span><br><span class="line"><span class="meta">spring.liquibase.test-rollback-on-update</span>=<span class="string">false # Whether rollback should be tested before update is performed.</span></span><br><span class="line"><span class="meta">spring.liquibase.url</span>= <span class="string"># JDBC URL of the database to migrate. If not set, the primary configured data source is used.</span></span><br><span class="line"><span class="meta">spring.liquibase.user</span>= <span class="string"># Login user of the database to migrate.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># COUCHBASE (CouchbaseProperties)</span></span><br><span class="line"><span class="meta">spring.couchbase.bootstrap-hosts</span>= <span class="string"># Couchbase nodes (host or IP address) to bootstrap from.</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.name</span>=<span class="string">default # Name of the bucket to connect to.</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.password</span>=  <span class="string"># Password of the bucket.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.key-value</span>=<span class="string">1 # Number of sockets per node against the key/value service.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.queryservice.min-endpoints</span>=<span class="string">1 # Minimum number of sockets per node.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.queryservice.max-endpoints</span>=<span class="string">1 # Maximum number of sockets per node.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.viewservice.min-endpoints</span>=<span class="string">1 # Minimum number of sockets per node.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.endpoints.viewservice.max-endpoints</span>=<span class="string">1 # Maximum number of sockets per node.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.enabled</span>= <span class="string"># Whether to enable SSL support. Enabled automatically if a &quot;keyStore&quot; is provided unless specified otherwise.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store</span>= <span class="string"># Path to the JVM key store that holds the certificates.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.connect</span>=<span class="string">5000ms # Bucket connections timeouts.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.key-value</span>=<span class="string">2500ms # Blocking operations performed on a specific key timeout.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.query</span>=<span class="string">7500ms # N1QL query operations timeout.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.socket-connect</span>=<span class="string">1000ms # Socket connect connections timeout.</span></span><br><span class="line"><span class="meta">spring.couchbase.env.timeouts.view</span>=<span class="string">7500ms # Regular and geospatial view operations timeout.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DAO (PersistenceExceptionTranslationAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.dao.exceptiontranslation.enabled</span>=<span class="string">true # Whether to enable the PersistenceExceptionTranslationPostProcessor.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CASSANDRA (CassandraProperties)</span></span><br><span class="line"><span class="meta">spring.data.cassandra.cluster-name</span>= <span class="string"># Name of the Cassandra cluster.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.compression</span>=<span class="string">none # Compression supported by the Cassandra binary protocol.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.connect-timeout</span>= <span class="string"># Socket option: connection time out.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.consistency-level</span>= <span class="string"># Queries consistency level.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">localhost # Cluster node addresses.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.fetch-size</span>= <span class="string"># Queries default fetch size.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.jmx-enabled</span>=<span class="string">false # Whether to enable JMX reporting.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>= <span class="string"># Keyspace name to use.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.port</span>= <span class="string"># Port of the Cassandra server.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.heartbeat-interval</span>=<span class="string">30s # Heartbeat interval after which a message is sent on an idle connection to make sure it&#x27;s still alive. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.idle-timeout</span>=<span class="string">120s # Idle timeout before an idle connection is removed. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.max-queue-size</span>=<span class="string">256 # Maximum number of requests that get queued if no connection is available.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.pool.pool-timeout</span>=<span class="string">5000ms # Pool timeout when trying to acquire a connection from a host&#x27;s pool.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.read-timeout</span>= <span class="string"># Socket option: read time out.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.repositories.type</span>=<span class="string">auto # Type of Cassandra repositories to enable.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.serial-consistency-level</span>= <span class="string"># Queries serial consistency level.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.schema-action</span>=<span class="string">none # Schema action to take at startup.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.ssl</span>=<span class="string">false # Enable SSL support.</span></span><br><span class="line"><span class="meta">spring.data.cassandra.username</span>= <span class="string"># Login user of the server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA COUCHBASE (CouchbaseDataProperties)</span></span><br><span class="line"><span class="meta">spring.data.couchbase.auto-index</span>=<span class="string">false # Automatically create views and indexes.</span></span><br><span class="line"><span class="meta">spring.data.couchbase.consistency</span>=<span class="string">read-your-own-writes # Consistency to apply by default on generated queries.</span></span><br><span class="line"><span class="meta">spring.data.couchbase.repositories.type</span>=<span class="string">auto # Type of Couchbase repositories to enable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ELASTICSEARCH (ElasticsearchProperties)</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-name</span>=<span class="string">elasticsearch # Elasticsearch cluster name.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.cluster-nodes</span>= <span class="string"># Comma-separated list of cluster node addresses.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.properties.*</span>= <span class="string"># Additional properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.data.elasticsearch.repositories.enabled</span>=<span class="string">true # Whether to enable Elasticsearch repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA JDBC</span></span><br><span class="line"><span class="meta">spring.data.jdbc.repositories.enabled</span>=<span class="string">true # Whether to enable JDBC repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA LDAP</span></span><br><span class="line"><span class="meta">spring.data.ldap.repositories.enabled</span>=<span class="string">true # Whether to enable LDAP repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MONGODB (MongoProperties)</span></span><br><span class="line"><span class="meta">spring.data.mongodb.authentication-database</span>= <span class="string"># Authentication database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.database</span>= <span class="string"># Database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.field-naming-strategy</span>= <span class="string"># Fully qualified name of the FieldNamingStrategy to use.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.grid-fs-database</span>= <span class="string"># GridFS database name.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.host</span>= <span class="string"># Mongo server host. Cannot be set with URI.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.password</span>= <span class="string"># Login password of the mongo server. Cannot be set with URI.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.port</span>= <span class="string"># Mongo server port. Cannot be set with URI.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.repositories.type</span>=<span class="string">auto # Type of Mongo repositories to enable.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://localhost/test # Mongo database URI. Cannot be set with host, port and credentials.</span></span><br><span class="line"><span class="meta">spring.data.mongodb.username</span>= <span class="string"># Login user of the mongo server. Cannot be set with URI.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA REDIS</span></span><br><span class="line"><span class="meta">spring.data.redis.repositories.enabled</span>=<span class="string">true # Whether to enable Redis repositories.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NEO4J (Neo4jProperties)</span></span><br><span class="line"><span class="meta">spring.data.neo4j.auto-index</span>=<span class="string">none # Auto index mode.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.embedded.enabled</span>=<span class="string">true # Whether to enable embedded mode if the embedded driver is available.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.open-in-view</span>=<span class="string">true # Register OpenSessionInViewInterceptor. Binds a Neo4j Session to the thread for the entire processing of the request.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.password</span>= <span class="string"># Login password of the server.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.repositories.enabled</span>=<span class="string">true # Whether to enable Neo4j repositories.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.uri</span>= <span class="string"># URI used by the driver. Auto-detected by default.</span></span><br><span class="line"><span class="meta">spring.data.neo4j.username</span>= <span class="string"># Login user of the server.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA REST (RepositoryRestProperties)</span></span><br><span class="line"><span class="meta">spring.data.rest.base-path</span>= <span class="string"># Base path to be used by Spring Data REST to expose repository resources.</span></span><br><span class="line"><span class="meta">spring.data.rest.default-media-type</span>= <span class="string"># Content type to use as a default when none is specified.</span></span><br><span class="line"><span class="meta">spring.data.rest.default-page-size</span>= <span class="string"># Default size of pages.</span></span><br><span class="line"><span class="meta">spring.data.rest.detection-strategy</span>=<span class="string">default # Strategy to use to determine which repositories get exposed.</span></span><br><span class="line"><span class="meta">spring.data.rest.enable-enum-translation</span>= <span class="string"># Whether to enable enum value translation through the Spring Data REST default resource bundle.</span></span><br><span class="line"><span class="meta">spring.data.rest.limit-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates how many results to return at once.</span></span><br><span class="line"><span class="meta">spring.data.rest.max-page-size</span>= <span class="string"># Maximum size of pages.</span></span><br><span class="line"><span class="meta">spring.data.rest.page-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates what page to return.</span></span><br><span class="line"><span class="meta">spring.data.rest.return-body-on-create</span>= <span class="string"># Whether to return a response body after creating an entity.</span></span><br><span class="line"><span class="meta">spring.data.rest.return-body-on-update</span>= <span class="string"># Whether to return a response body after updating an entity.</span></span><br><span class="line"><span class="meta">spring.data.rest.sort-param-name</span>= <span class="string"># Name of the URL query string parameter that indicates what direction to sort results.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SOLR (SolrProperties)</span></span><br><span class="line"><span class="meta">spring.data.solr.host</span>=<span class="string">http://127.0.0.1:8983/solr # Solr host. Ignored if &quot;zk-host&quot; is set.</span></span><br><span class="line"><span class="meta">spring.data.solr.repositories.enabled</span>=<span class="string">true # Whether to enable Solr repositories.</span></span><br><span class="line"><span class="meta">spring.data.solr.zk-host</span>= <span class="string"># ZooKeeper host address in the form HOST:PORT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATA WEB (SpringDataWebProperties)</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.default-page-size</span>=<span class="string">20 # Default page size.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.max-page-size</span>=<span class="string">2000 # Maximum page size to be accepted.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.one-indexed-parameters</span>=<span class="string">false # Whether to expose and assume 1-based page number indexes.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.page-parameter</span>=<span class="string">page # Page index parameter name.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.prefix</span>= <span class="string"># General prefix to be prepended to the page number and page size parameters.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.qualifier-delimiter</span>=<span class="string">_ # Delimiter to be used between the qualifier and the actual page number and size properties.</span></span><br><span class="line"><span class="meta">spring.data.web.pageable.size-parameter</span>=<span class="string">size # Page size parameter name.</span></span><br><span class="line"><span class="meta">spring.data.web.sort.sort-parameter</span>=<span class="string">sort # Sort parameter name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span></span><br><span class="line"><span class="meta">spring.datasource.continue-on-error</span>=<span class="string">false # Whether to stop if an error occurs while initializing the database.</span></span><br><span class="line"><span class="meta">spring.datasource.data</span>= <span class="string"># Data (DML) script resource references.</span></span><br><span class="line"><span class="meta">spring.datasource.data-username</span>= <span class="string"># Username of the database to execute DML scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.data-password</span>= <span class="string"># Password of the database to execute DML scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.dbcp2.*</span>= <span class="string"># Commons DBCP2 specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>= <span class="string"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span></span><br><span class="line"><span class="meta">spring.datasource.generate-unique-name</span>=<span class="string">false # Whether to generate a random datasource name.</span></span><br><span class="line"><span class="meta">spring.datasource.hikari.*</span>= <span class="string"># Hikari specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.initialization-mode</span>=<span class="string">embedded # Initialize the datasource with available DDL and DML scripts.</span></span><br><span class="line"><span class="meta">spring.datasource.jmx-enabled</span>=<span class="string">false # Whether to enable JMX support (if provided by the underlying pool).</span></span><br><span class="line"><span class="meta">spring.datasource.jndi-name</span>= <span class="string"># JNDI location of the datasource. Class, url, username &amp; password are ignored when set.</span></span><br><span class="line"><span class="meta">spring.datasource.name</span>= <span class="string"># Name of the datasource. Default to &quot;testdb&quot; when using an embedded database.</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>= <span class="string"># Login password of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">all # Platform to use in the DDL or DML scripts (such as schema-$&#123;platform&#125;.sql or data-$&#123;platform&#125;.sql).</span></span><br><span class="line"><span class="meta">spring.datasource.schema</span>= <span class="string"># Schema (DDL) script resource references.</span></span><br><span class="line"><span class="meta">spring.datasource.schema-username</span>= <span class="string"># Username of the database to execute DDL scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.schema-password</span>= <span class="string"># Password of the database to execute DDL scripts (if different).</span></span><br><span class="line"><span class="meta">spring.datasource.separator</span>=<span class="string">; # Statement separator in SQL initialization scripts.</span></span><br><span class="line"><span class="meta">spring.datasource.sql-script-encoding</span>= <span class="string"># SQL scripts encoding.</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.*</span>= <span class="string"># Tomcat datasource specific settings</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>= <span class="string"># Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>= <span class="string"># JDBC URL of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>= <span class="string"># Login username of the database.</span></span><br><span class="line"><span class="meta">spring.datasource.xa.data-source-class-name</span>= <span class="string"># XA datasource fully qualified name.</span></span><br><span class="line"><span class="meta">spring.datasource.xa.properties</span>= <span class="string"># Properties to pass to the XA data source.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JEST (Elasticsearch HTTP client) (JestProperties)</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.connection-timeout</span>=<span class="string">3s # Connection timeout.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.multi-threaded</span>=<span class="string">true # Whether to enable connection requests from multiple execution threads.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.password</span>= <span class="string"># Login password.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.host</span>= <span class="string"># Proxy host the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.proxy.port</span>= <span class="string"># Proxy port the HTTP client should use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.read-timeout</span>=<span class="string">3s # Read timeout.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.uris</span>=<span class="string">http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.username</span>= <span class="string"># Login username.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Elasticsearch REST clients (RestClientProperties)</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.password</span>= <span class="string"># Credentials password.</span></span><br><span class="line">   <span class="meta">spring.elasticsearch.rest.uris</span>=<span class="string">http://localhost:9200 # Comma-separated list of the Elasticsearch instances to use.</span></span><br><span class="line">   <span class="meta">spring.elasticsearch.rest.username</span>= <span class="string"># Credentials username.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># H2 Web Console (H2ConsoleProperties)</span></span><br><span class="line"><span class="meta">spring.h2.console.enabled</span>=<span class="string">false # Whether to enable the console.</span></span><br><span class="line"><span class="meta">spring.h2.console.path</span>=<span class="string">/h2-console # Path at which the console is available.</span></span><br><span class="line"><span class="meta">spring.h2.console.settings.trace</span>=<span class="string">false # Whether to enable trace output.</span></span><br><span class="line"><span class="meta">spring.h2.console.settings.web-allow-others</span>=<span class="string">false # Whether to enable remote access.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># InfluxDB (InfluxDbProperties)</span></span><br><span class="line"><span class="meta">spring.influx.password</span>= <span class="string"># Login password.</span></span><br><span class="line"><span class="meta">spring.influx.url</span>= <span class="string"># URL of the InfluxDB instance to which to connect.</span></span><br><span class="line"><span class="meta">spring.influx.user</span>= <span class="string"># Login user.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JOOQ (JooqProperties)</span></span><br><span class="line"><span class="meta">spring.jooq.sql-dialect</span>= <span class="string"># SQL dialect to use. Auto-detected by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JDBC (JdbcProperties)</span></span><br><span class="line"><span class="meta">spring.jdbc.template.fetch-size</span>=<span class="string">-1 # Number of rows that should be fetched from the database when more rows are needed.</span></span><br><span class="line"><span class="meta">spring.jdbc.template.max-rows</span>=<span class="string">-1 # Maximum number of rows.</span></span><br><span class="line"><span class="meta">spring.jdbc.template.query-timeout</span>= <span class="string"># Query timeout. Default is to use the JDBC driver&#x27;s default configuration. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JPA (JpaBaseConfiguration, HibernateJpaAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.data.jpa.repositories.bootstrap-mode</span>=<span class="string">default # Bootstrap mode for JPA repositories.</span></span><br><span class="line"><span class="meta">spring.data.jpa.repositories.enabled</span>=<span class="string">true # Whether to enable JPA repositories.</span></span><br><span class="line"><span class="meta">spring.jpa.database</span>= <span class="string"># Target database to operate on, auto-detected by default. Can be alternatively set using the &quot;databasePlatform&quot; property.</span></span><br><span class="line"><span class="meta">spring.jpa.database-platform</span>= <span class="string"># Name of the target database to operate on, auto-detected by default. Can be alternatively set using the &quot;Database&quot; enum.</span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">false # Whether to initialize the schema on startup.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>= <span class="string"># DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Defaults to &quot;create-drop&quot; when using an embedded database and no schema manager was detected. Otherwise, defaults to &quot;none&quot;.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.implicit-strategy</span>= <span class="string"># Fully qualified name of the implicit naming strategy.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming.physical-strategy</span>= <span class="string"># Fully qualified name of the physical naming strategy.</span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.use-new-id-generator-mappings</span>= <span class="string"># Whether to use Hibernate&#x27;s newer IdentifierGenerator for AUTO, TABLE and SEQUENCE.</span></span><br><span class="line"><span class="meta">spring.jpa.mapping-resources</span>= <span class="string"># Mapping resources (equivalent to &quot;mapping-file&quot; entries in persistence.xml).</span></span><br><span class="line"><span class="meta">spring.jpa.open-in-view</span>=<span class="string">true # Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the thread for the entire processing of the request.</span></span><br><span class="line"><span class="meta">spring.jpa.properties.*</span>= <span class="string"># Additional native properties to set on the JPA provider.</span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">false # Whether to enable logging of SQL statements.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JTA (JtaAutoConfiguration)</span></span><br><span class="line"><span class="meta">spring.jta.enabled</span>=<span class="string">true # Whether to enable JTA support.</span></span><br><span class="line"><span class="meta">spring.jta.log-dir</span>= <span class="string"># Transaction logs directory.</span></span><br><span class="line"><span class="meta">spring.jta.transaction-manager-id</span>= <span class="string"># Transaction manager unique identifier.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ATOMIKOS (AtomikosProperties)</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.borrow-connection-timeout</span>=<span class="string">30 # Timeout, in seconds, for borrowing connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.ignore-session-transacted-flag</span>=<span class="string">true # Whether to ignore the transacted flag when creating session.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.local-transaction-mode</span>=<span class="string">false # Whether local transactions are desired.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.maintenance-interval</span>=<span class="string">60 # Time, in seconds, between runs of the pool&#x27;s maintenance thread.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-idle-time</span>=<span class="string">60 # Time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-lifetime</span>=<span class="string">0 # Time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.max-pool-size</span>=<span class="string">1 # Maximum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.min-pool-size</span>=<span class="string">1 # Minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.reap-timeout</span>=<span class="string">0 # Reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.unique-resource-name</span>=<span class="string">jmsConnectionFactory # Unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.xa-connection-factory-class-name</span>= <span class="string"># Vendor-specific implementation of XAConnectionFactory.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.connectionfactory.xa-properties</span>= <span class="string"># Vendor-specific XA properties.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.borrow-connection-timeout</span>=<span class="string">30 # Timeout, in seconds, for borrowing connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.concurrent-connection-validation</span>=<span class="string">true # Whether to use concurrent connection validation.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.default-isolation-level</span>= <span class="string"># Default isolation level of connections provided by the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.login-timeout</span>=<span class="string">0 # Timeout, in seconds, for establishing a database connection.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.maintenance-interval</span>=<span class="string">60 # Time, in seconds, between runs of the pool&#x27;s maintenance thread.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-idle-time</span>=<span class="string">60 # Time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-lifetime</span>=<span class="string">0 # Time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.max-pool-size</span>=<span class="string">1 # Maximum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.min-pool-size</span>=<span class="string">1 # Minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.reap-timeout</span>=<span class="string">0 # Reap timeout, in seconds, for borrowed connections. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.test-query</span>= <span class="string"># SQL query or statement used to validate a connection before returning it.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.unique-resource-name</span>=<span class="string">dataSource # Unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.xa-data-source-class-name</span>= <span class="string"># Vendor-specific implementation of XAConnectionFactory.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.datasource.xa-properties</span>= <span class="string"># Vendor-specific XA properties.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.allow-sub-transactions</span>=<span class="string">true # Specify whether sub-transactions are allowed.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.checkpoint-interval</span>=<span class="string">500 # Interval between checkpoints, expressed as the number of log writes between two checkpoints.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.default-jta-timeout</span>=<span class="string">10000ms # Default timeout for JTA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.default-max-wait-time-on-shutdown</span>=<span class="string">9223372036854775807 # How long should normal shutdown (no-force) wait for transactions to complete.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.enable-logging</span>=<span class="string">true # Whether to enable disk logging.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.force-shutdown-on-vm-exit</span>=<span class="string">false # Whether a VM shutdown should trigger forced shutdown of the transaction core.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.log-base-dir</span>= <span class="string"># Directory in which the log files should be stored.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.log-base-name</span>=<span class="string">tmlog # Transactions log file base name.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.max-actives</span>=<span class="string">50 # Maximum number of active transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.max-timeout</span>=<span class="string">300000ms # Maximum timeout that can be allowed for transactions.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.delay</span>=<span class="string">10000ms # Delay between two recovery scans.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.forget-orphaned-log-entries-delay</span>=<span class="string">86400000ms # Delay after which recovery can cleanup pending (&#x27;orphaned&#x27;) log entries.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.max-retries</span>=<span class="string">5 # Number of retry attempts to commit the transaction before throwing an exception.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.recovery.retry-interval</span>=<span class="string">10000ms # Delay between retry attempts.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.serial-jta-transactions</span>=<span class="string">true # Whether sub-transactions should be joined when possible.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.service</span>= <span class="string"># Transaction manager implementation that should be started.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.threaded-two-phase-commit</span>=<span class="string">false # Whether to use different (and concurrent) threads for two-phase commit on the participating resources.</span></span><br><span class="line"><span class="meta">spring.jta.atomikos.properties.transaction-manager-unique-name</span>= <span class="string"># The transaction manager&#x27;s unique name.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BITRONIX</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquire-increment</span>=<span class="string">1 # Number of connections to create when growing the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquisition-interval</span>=<span class="string">1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.acquisition-timeout</span>=<span class="string">30 # Timeout, in seconds, for acquiring connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.allow-local-transactions</span>=<span class="string">false # Whether the transaction manager should allow mixing XA and non-XA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.apply-transaction-timeout</span>=<span class="string">false # Whether the transaction timeout should be set on the XAResource when it is enlisted.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.automatic-enlisting-enabled</span>=<span class="string">true # Whether resources should be enlisted and delisted automatically.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.cache-producers-consumers</span>=<span class="string">true # Whether producers and consumers should be cached.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.class-name</span>= <span class="string"># Underlying implementation class name of the XA resource.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.defer-connection-release</span>=<span class="string">true # Whether the provider can run many transactions on the same connection and supports transaction interleaving.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.disabled</span>=<span class="string">false # Whether this resource is disabled, meaning it&#x27;s temporarily forbidden to acquire a connection from its pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.driver-properties</span>= <span class="string"># Properties that should be set on the underlying implementation.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.ignore-recovery-failures</span>=<span class="string">false # Whether recovery failures should be ignored.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.max-idle-time</span>=<span class="string">60 # Time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.max-pool-size</span>=<span class="string">0 # Maximum size of the pool. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.min-pool-size</span>=<span class="string">0 # Minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.password</span>= <span class="string"># Password to use to connect to the JMS provider.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.share-transaction-connections</span>=<span class="string">false #  Whether connections in the ACCESSIBLE state can be shared within the context of a transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.test-connections</span>=<span class="string">false # Whether connections should be tested when acquired from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.two-pc-ordering-position</span>=<span class="string">1 # Position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, always last is Integer.MAX_VALUE).</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.unique-name</span>=<span class="string">jmsConnectionFactory # Unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.use-tm-join</span>=<span class="string">true # Whether TMJOIN should be used when starting XAResources.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.connectionfactory.user</span>= <span class="string"># User to use to connect to the JMS provider.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquire-increment</span>=<span class="string">1 # Number of connections to create when growing the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquisition-interval</span>=<span class="string">1 # Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.acquisition-timeout</span>=<span class="string">30 # Timeout, in seconds, for acquiring connections from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.allow-local-transactions</span>=<span class="string">false # Whether the transaction manager should allow mixing XA and non-XA transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.apply-transaction-timeout</span>=<span class="string">false # Whether the transaction timeout should be set on the XAResource when it is enlisted.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.automatic-enlisting-enabled</span>=<span class="string">true # Whether resources should be enlisted and delisted automatically.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.class-name</span>= <span class="string"># Underlying implementation class name of the XA resource.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.cursor-holdability</span>= <span class="string"># Default cursor holdability for connections.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.defer-connection-release</span>=<span class="string">true # Whether the database can run many transactions on the same connection and supports transaction interleaving.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.disabled</span>=<span class="string">false # Whether this resource is disabled, meaning it&#x27;s temporarily forbidden to acquire a connection from its pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.driver-properties</span>= <span class="string"># Properties that should be set on the underlying implementation.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.enable-jdbc4-connection-test</span>=<span class="string">false # Whether Connection.isValid() is called when acquiring a connection from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.ignore-recovery-failures</span>=<span class="string">false # Whether recovery failures should be ignored.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.isolation-level</span>= <span class="string"># Default isolation level for connections.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.local-auto-commit</span>= <span class="string"># Default auto-commit mode for local transactions.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.login-timeout</span>= <span class="string"># Timeout, in seconds, for establishing a database connection.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.max-idle-time</span>=<span class="string">60 # Time, in seconds, after which connections are cleaned up from the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.max-pool-size</span>=<span class="string">0 # Maximum size of the pool. 0 denotes no limit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.min-pool-size</span>=<span class="string">0 # Minimum size of the pool.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.prepared-statement-cache-size</span>=<span class="string">0 # Target size of the prepared statement cache. 0 disables the cache.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.share-transaction-connections</span>=<span class="string">false #  Whether connections in the ACCESSIBLE state can be shared within the context of a transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.test-query</span>= <span class="string"># SQL query or statement used to validate a connection before returning it.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.two-pc-ordering-position</span>=<span class="string">1 # Position that this resource should take during two-phase commit (always first is Integer.MIN_VALUE, and always last is Integer.MAX_VALUE).</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.unique-name</span>=<span class="string">dataSource # Unique name used to identify the resource during recovery.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.datasource.use-tm-join</span>=<span class="string">true # Whether TMJOIN should be used when starting XAResources.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.allow-multiple-lrc</span>=<span class="string">false # Whether to allow multiple LRC resources to be enlisted into the same transaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.asynchronous2-pc</span>=<span class="string">false # Whether to enable asynchronously execution of two phase commit.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.background-recovery-interval-seconds</span>=<span class="string">60 # Interval in seconds at which to run the recovery process in the background.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.current-node-only-recovery</span>=<span class="string">true # Whether to recover only the current node.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.debug-zero-resource-transaction</span>=<span class="string">false # Whether to log the creation and commit call stacks of transactions executed without a single enlisted resource.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.default-transaction-timeout</span>=<span class="string">60 # Default transaction timeout, in seconds.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.disable-jmx</span>=<span class="string">false # Whether to enable JMX support.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.exception-analyzer</span>= <span class="string"># Set the fully qualified name of the exception analyzer implementation to use.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.filter-log-status</span>=<span class="string">false # Whether to enable filtering of logs so that only mandatory logs are written.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.force-batching-enabled</span>=<span class="string">true #  Whether disk forces are batched.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.forced-write-enabled</span>=<span class="string">true # Whether logs are forced to disk.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.graceful-shutdown-interval</span>=<span class="string">60 # Maximum amount of seconds the TM waits for transactions to get done before aborting them at shutdown time.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.jndi-transaction-synchronization-registry-name</span>= <span class="string"># JNDI name of the TransactionSynchronizationRegistry.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.jndi-user-transaction-name</span>= <span class="string"># JNDI name of the UserTransaction.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.journal</span>=<span class="string">disk # Name of the journal. Can be &#x27;disk&#x27;, &#x27;null&#x27;, or a class name.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.log-part1-filename</span>=<span class="string">btm1.tlog # Name of the first fragment of the journal.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.log-part2-filename</span>=<span class="string">btm2.tlog # Name of the second fragment of the journal.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.max-log-size-in-mb</span>=<span class="string">2 # Maximum size in megabytes of the journal fragments.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.resource-configuration-filename</span>= <span class="string"># ResourceLoader configuration file name.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.server-id</span>= <span class="string"># ASCII ID that must uniquely identify this TM instance. Defaults to the machine&#x27;s IP address.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.skip-corrupted-logs</span>=<span class="string">false # Skip corrupted transactions log entries.</span></span><br><span class="line"><span class="meta">spring.jta.bitronix.properties.warn-about-zero-resource-transaction</span>=<span class="string">true # Whether to log a warning for transactions executed without a single enlisted resource.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EMBEDDED MONGODB (EmbeddedMongoProperties)</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.features</span>=<span class="string">sync_delay # Comma-separated list of features to enable.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.database-dir</span>= <span class="string"># Directory used for data storage.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.oplog-size</span>= <span class="string"># Maximum size of the oplog.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.storage.repl-set-name</span>= <span class="string"># Name of the replica set.</span></span><br><span class="line"><span class="meta">spring.mongodb.embedded.version</span>=<span class="string">3.5.5 # Version of Mongo to use.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REDIS (RedisProperties)</span></span><br><span class="line"><span class="meta">spring.redis.cluster.max-redirects</span>= <span class="string"># Maximum number of redirects to follow when executing commands across the cluster.</span></span><br><span class="line"><span class="meta">spring.redis.cluster.nodes</span>= <span class="string"># Comma-separated list of &quot;host:port&quot; pairs to bootstrap from.</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0 # Database index used by the connection factory.</span></span><br><span class="line"><span class="meta">spring.redis.url</span>= <span class="string"># Connection URL. Overrides host, port, and password. User is ignored. Example: redis://user:password@example.com:6379</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost # Redis server host.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">8 # Maximum number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-idle</span>=<span class="string">8 # Maximum number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms # Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">8 # Maximum number of connections that can be allocated by the pool at a given time. Use a negative value for no limit.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8 # Maximum number of &quot;idle&quot; connections in the pool. Use a negative value to indicate an unlimited number of idle connections.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1ms # Maximum amount of time a connection allocation should block before throwing an exception when the pool is exhausted. Use a negative value to block indefinitely.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0 # Target for the minimum number of idle connections to maintain in the pool. This setting only has an effect if it is positive.</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.shutdown-timeout</span>=<span class="string">100ms # Shutdown timeout.</span></span><br><span class="line"><span class="meta">spring.redis.password</span>= <span class="string"># Login password of the redis server.</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379 # Redis server port.</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.master</span>= <span class="string"># Name of the Redis server.</span></span><br><span class="line"><span class="meta">spring.redis.sentinel.nodes</span>= <span class="string"># Comma-separated list of &quot;host:port&quot; pairs.</span></span><br><span class="line"><span class="meta">spring.redis.ssl</span>=<span class="string">false # Whether to enable SSL support.</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>= <span class="string"># Connection timeout.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TRANSACTION (TransactionProperties)</span></span><br><span class="line"><span class="meta">spring.transaction.default-timeout</span>= <span class="string"># Default transaction timeout. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.transaction.rollback-on-commit-failure</span>= <span class="string"># Whether to roll back on commit failures.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># INTEGRATION PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ACTIVEMQ (ActiveMQProperties)</span></span><br><span class="line"><span class="meta">spring.activemq.broker-url</span>= <span class="string"># URL of the ActiveMQ broker. Auto-generated by default.</span></span><br><span class="line"><span class="meta">spring.activemq.close-timeout</span>=<span class="string">15s # Time to wait before considering a close complete.</span></span><br><span class="line"><span class="meta">spring.activemq.in-memory</span>=<span class="string">true # Whether the default broker URL should be in memory. Ignored if an explicit broker has been specified.</span></span><br><span class="line"><span class="meta">spring.activemq.non-blocking-redelivery</span>=<span class="string">false # Whether to stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order is not preserved when this is enabled.</span></span><br><span class="line"><span class="meta">spring.activemq.password</span>= <span class="string"># Login password of the broker.</span></span><br><span class="line"><span class="meta">spring.activemq.send-timeout</span>=<span class="string">0ms # Time to wait on message sends for a response. Set it to 0 to wait forever.</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>= <span class="string"># Login user of the broker.</span></span><br><span class="line"><span class="meta">spring.activemq.packages.trust-all</span>= <span class="string"># Whether to trust all packages.</span></span><br><span class="line"><span class="meta">spring.activemq.packages.trusted</span>= <span class="string"># Comma-separated list of specific packages to trust (when not trusting all packages).</span></span><br><span class="line"><span class="meta">spring.activemq.pool.block-if-full</span>=<span class="string">true # Whether to block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.block-if-full-timeout</span>=<span class="string">-1ms # Blocking period before throwing an exception if the pool is still full.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">false # Whether a JmsPoolConnectionFactory should be created, instead of a regular ConnectionFactory.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.idle-timeout</span>=<span class="string">30s # Connection idle timeout.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">1 # Maximum number of pooled connections.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-sessions-per-connection</span>=<span class="string">500 # Maximum number of pooled sessions per connection in the pool.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.time-between-expiration-check</span>=<span class="string">-1ms # Time to sleep between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.</span></span><br><span class="line"><span class="meta">spring.activemq.pool.use-anonymous-producers</span>=<span class="string">true # Whether to use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARTEMIS (ArtemisProperties)</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.cluster-password</span>= <span class="string"># Cluster password. Randomly generated on startup by default.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.data-directory</span>= <span class="string"># Journal file directory. Not necessary if persistence is turned off.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.enabled</span>=<span class="string">true # Whether to enable embedded mode if the Artemis server APIs are available.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.persistent</span>=<span class="string">false # Whether to enable persistent store.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.queues</span>= <span class="string"># Comma-separated list of queues to create on startup.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.server-id</span>= <span class="string"># Server ID. By default, an auto-incremented counter is used.</span></span><br><span class="line"><span class="meta">spring.artemis.embedded.topics</span>= <span class="string"># Comma-separated list of topics to create on startup.</span></span><br><span class="line"><span class="meta">spring.artemis.host</span>=<span class="string">localhost # Artemis broker host.</span></span><br><span class="line"><span class="meta">spring.artemis.mode</span>= <span class="string"># Artemis deployment mode, auto-detected by default.</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>= <span class="string"># Login password of the broker.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.block-if-full</span>=<span class="string">true # Whether to block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.block-if-full-timeout</span>=<span class="string">-1ms # Blocking period before throwing an exception if the pool is still full.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.enabled</span>=<span class="string">false # Whether a JmsPoolConnectionFactory should be created, instead of a regular ConnectionFactory.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.idle-timeout</span>=<span class="string">30s # Connection idle timeout.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-connections</span>=<span class="string">1 # Maximum number of pooled connections.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-sessions-per-connection</span>=<span class="string">500 # Maximum number of pooled sessions per connection in the pool.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.time-between-expiration-check</span>=<span class="string">-1ms # Time to sleep between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.</span></span><br><span class="line"><span class="meta">spring.artemis.pool.use-anonymous-producers</span>=<span class="string">true # Whether to use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.</span></span><br><span class="line"><span class="meta">spring.artemis.port</span>=<span class="string">61616 # Artemis broker port.</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>= <span class="string"># Login user of the broker.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING BATCH (BatchProperties)</span></span><br><span class="line"><span class="meta">spring.batch.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.batch.job.enabled</span>=<span class="string">true # Execute all Spring Batch jobs in the context on startup.</span></span><br><span class="line"><span class="meta">spring.batch.job.names</span>= <span class="string"># Comma-separated list of job names to execute on startup (for instance, `job1,job2`). By default, all Jobs found in the context are executed.</span></span><br><span class="line"><span class="meta">spring.batch.schema</span>=<span class="string">classpath:org/springframework/batch/core/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"><span class="meta">spring.batch.table-prefix</span>= <span class="string"># Table prefix for all the batch meta-data tables.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SPRING INTEGRATION (IntegrationProperties)</span></span><br><span class="line"><span class="meta">spring.integration.jdbc.initialize-schema</span>=<span class="string">embedded # Database schema initialization mode.</span></span><br><span class="line"><span class="meta">spring.integration.jdbc.schema</span>=<span class="string">classpath:org/springframework/integration/jdbc/schema-@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JMS (JmsProperties)</span></span><br><span class="line"><span class="meta">spring.jms.cache.consumers</span>=<span class="string">false # Whether to cache message consumers.</span></span><br><span class="line"><span class="meta">spring.jms.cache.enabled</span>=<span class="string">true # Whether to cache sessions.</span></span><br><span class="line"><span class="meta">spring.jms.cache.producers</span>=<span class="string">true # Whether to cache message producers.</span></span><br><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">1 # Size of the session cache (per JMS Session type).</span></span><br><span class="line"><span class="meta">spring.jms.jndi-name</span>= <span class="string"># Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.</span></span><br><span class="line"><span class="meta">spring.jms.listener.acknowledge-mode</span>= <span class="string"># Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.</span></span><br><span class="line"><span class="meta">spring.jms.listener.auto-startup</span>=<span class="string">true # Start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.jms.listener.concurrency</span>= <span class="string"># Minimum number of concurrent consumers.</span></span><br><span class="line"><span class="meta">spring.jms.listener.max-concurrency</span>= <span class="string"># Maximum number of concurrent consumers.</span></span><br><span class="line"><span class="meta">spring.jms.pub-sub-domain</span>=<span class="string">false # Whether the default destination type is topic.</span></span><br><span class="line"><span class="meta">spring.jms.template.default-destination</span>= <span class="string"># Default destination to use on send and receive operations that do not have a destination parameter.</span></span><br><span class="line"><span class="meta">spring.jms.template.delivery-delay</span>= <span class="string"># Delivery delay to use for send calls.</span></span><br><span class="line"><span class="meta">spring.jms.template.delivery-mode</span>= <span class="string"># Delivery mode. Enables QoS (Quality of Service) when set.</span></span><br><span class="line"><span class="meta">spring.jms.template.priority</span>= <span class="string"># Priority of a message when sending. Enables QoS (Quality of Service) when set.</span></span><br><span class="line"><span class="meta">spring.jms.template.qos-enabled</span>= <span class="string"># Whether to enable explicit QoS (Quality of Service) when sending a message.</span></span><br><span class="line"><span class="meta">spring.jms.template.receive-timeout</span>= <span class="string"># Timeout to use for receive calls.</span></span><br><span class="line"><span class="meta">spring.jms.template.time-to-live</span>= <span class="string"># Time-to-live of a message when sending. Enables QoS (Quality of Service) when set.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># APACHE KAFKA (KafkaProperties)</span></span><br><span class="line"><span class="meta">spring.kafka.admin.client-id</span>= <span class="string"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.fail-fast</span>=<span class="string">false # Whether to fail fast if the broker is not available on startup.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties.*</span>= <span class="string"># Additional admin-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.key-store-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.key-store-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.protocol</span>= <span class="string"># SSL protocol to use.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.trust-store-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.trust-store-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.admin.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden.</span></span><br><span class="line"><span class="meta">spring.kafka.client-id</span>= <span class="string"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-commit-interval</span>= <span class="string"># Frequency with which the consumer offsets are auto-committed to Kafka if &#x27;enable.auto.commit&#x27; is set to true.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.auto-offset-reset</span>= <span class="string"># What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.client-id</span>= <span class="string"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.enable-auto-commit</span>= <span class="string"># Whether the consumer&#x27;s offset is periodically committed in the background.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.fetch-max-wait</span>= <span class="string"># Maximum amount of time the server blocks before answering the fetch request if there isn&#x27;t sufficient data to immediately satisfy the requirement given by &quot;fetch-min-size&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.fetch-min-size</span>= <span class="string"># Minimum amount of data the server should return for a fetch request.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>= <span class="string"># Unique string that identifies the consumer group to which this consumer belongs.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.heartbeat-interval</span>= <span class="string"># Expected time between heartbeats to the consumer coordinator.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.key-deserializer</span>= <span class="string"># Deserializer class for keys.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.max-poll-records</span>= <span class="string"># Maximum number of records returned in a single call to poll().</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties.*</span>= <span class="string"># Additional consumer-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.key-store-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.key-store-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.protocol</span>= <span class="string"># SSL protocol to use.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.trust-store-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.trust-store-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>= <span class="string"># Deserializer class for values.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.control-flag</span>=<span class="string">required # Control flag for login configuration.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.enabled</span>=<span class="string">false # Whether to enable JAAS configuration.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.login-module</span>=<span class="string">com.sun.security.auth.module.Krb5LoginModule # Login module.</span></span><br><span class="line"><span class="meta">spring.kafka.jaas.options</span>= <span class="string"># Additional JAAS options.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-count</span>= <span class="string"># Number of records between offset commits when ackMode is &quot;COUNT&quot; or &quot;COUNT_TIME&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-mode</span>= <span class="string"># Listener AckMode. See the spring-kafka documentation.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-time</span>= <span class="string"># Time between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.client-id</span>= <span class="string"># Prefix for the listener&#x27;s consumer client.id property.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.concurrency</span>= <span class="string"># Number of threads to run in the listener containers.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.idle-event-interval</span>= <span class="string"># Time between publishing idle consumer events (no data received).</span></span><br><span class="line"><span class="meta">spring.kafka.listener.log-container-config</span>= <span class="string"># Whether to log the container configuration during initialization (INFO level).</span></span><br><span class="line"><span class="meta">spring.kafka.listener.monitor-interval</span>= <span class="string"># Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.no-poll-threshold</span>= <span class="string"># Multiplier applied to &quot;pollTimeout&quot; to determine if a consumer is non-responsive.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.poll-timeout</span>= <span class="string"># Timeout to use when polling the consumer.</span></span><br><span class="line"><span class="meta">spring.kafka.listener.type</span>=<span class="string">single # Listener type.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.acks</span>= <span class="string"># Number of acknowledgments the producer requires the leader to have received before considering a request complete.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.batch-size</span>= <span class="string"># Default batch size.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.buffer-memory</span>= <span class="string"># Total memory size the producer can use to buffer records waiting to be sent to the server.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.client-id</span>= <span class="string"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.compression-type</span>= <span class="string"># Compression type for all data generated by the producer.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.key-serializer</span>= <span class="string"># Serializer class for keys.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties.*</span>= <span class="string"># Additional producer-specific properties used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.retries</span>= <span class="string"># When greater than zero, enables retrying of failed sends.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.key-store-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.key-store-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.protocol</span>= <span class="string"># SSL protocol to use.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.trust-store-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.trust-store-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.transaction-id-prefix</span>= <span class="string"># When non empty, enables transaction support for producer.</span></span><br><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>= <span class="string"># Serializer class for values.</span></span><br><span class="line"><span class="meta">spring.kafka.properties.*</span>= <span class="string"># Additional properties, common to producers and consumers, used to configure the client.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.key-store-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.key-store-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.protocol</span>= <span class="string"># SSL protocol to use.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.trust-store-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.trust-store-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.application-id</span>= <span class="string"># Kafka streams application.id property; default spring.application.name.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.auto-startup</span>=<span class="string">true # Whether or not to auto-start the streams factory bean.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.bootstrap-servers</span>= <span class="string"># Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.cache-max-size-buffering</span>= <span class="string"># Maximum memory size to be used for buffering across all threads.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.client-id</span>= <span class="string"># ID to pass to the server when making requests. Used for server-side logging.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.properties.*</span>= <span class="string"># Additional Kafka properties used to configure the streams.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.replication-factor</span>= <span class="string"># The replication factor for change log topics and repartition topics created by the stream processing application.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.key-password</span>= <span class="string"># Password of the private key in the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.key-store-location</span>= <span class="string"># Location of the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.key-store-password</span>= <span class="string"># Store password for the key store file.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.protocol</span>= <span class="string"># SSL protocol to use.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.trust-store-location</span>= <span class="string"># Location of the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.trust-store-password</span>= <span class="string"># Store password for the trust store file.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"><span class="meta">spring.kafka.streams.state-dir</span>= <span class="string"># Directory location for the state store.</span></span><br><span class="line"><span class="meta">spring.kafka.template.default-topic</span>= <span class="string"># Default topic to which messages are sent.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RABBIT (RabbitProperties)</span></span><br><span class="line"><span class="meta">spring.rabbitmq.addresses</span>= <span class="string"># Comma-separated list of addresses to which the client should connect.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.channel.checkout-timeout</span>= <span class="string"># Duration to wait to obtain a channel if the cache size has been reached.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.channel.size</span>= <span class="string"># Number of channels to retain in the cache.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.connection.mode</span>=<span class="string">channel # Connection factory cache mode.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.cache.connection.size</span>= <span class="string"># Number of connections to cache.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.connection-timeout</span>= <span class="string"># Connection timeout. Set it to zero to wait forever.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.dynamic</span>=<span class="string">true # Whether to create an AmqpAdmin bean.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost # RabbitMQ host.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.acknowledge-mode</span>= <span class="string"># Acknowledge mode of container.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.auto-startup</span>=<span class="string">true # Whether to start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.consumers-per-queue</span>= <span class="string"># Number of consumers per queue.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.default-requeue-rejected</span>= <span class="string"># Whether rejected deliveries are re-queued by default.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.idle-event-interval</span>= <span class="string"># How often idle container events should be published.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.missing-queues-fatal</span>=<span class="string">false # Whether to fail if the queues declared by the container are not available on the broker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.prefetch</span>= <span class="string"># Maximum number of unacknowledged messages that can be outstanding at each consumer.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.enabled</span>=<span class="string">false # Whether publishing retries are enabled.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.initial-interval</span>=<span class="string">1000ms # Duration between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.max-interval</span>=<span class="string">10000ms # Maximum duration between attempts.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.multiplier</span>=<span class="string">1 # Multiplier to apply to the previous retry interval.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.direct.retry.stateless</span>=<span class="string">true # Whether retries are stateless or stateful.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>= <span class="string"># Acknowledge mode of container.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.auto-startup</span>=<span class="string">true # Whether to start the container automatically on startup.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.concurrency</span>= <span class="string"># Minimum number of listener invoker threads.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.default-requeue-rejected</span>= <span class="string"># Whether rejected deliveries are re-queued by default.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.idle-event-interval</span>= <span class="string"># How often idle container events should be published.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.max-concurrency</span>= <span class="string"># Maximum number of listener invoker threads.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.missing-queues-fatal</span>=<span class="string">true # Whether to fail if the queues declared by the container are not available on the broker and/or whether to stop the container if one or more queues are deleted at runtime.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.prefetch</span>= <span class="string"># Maximum number of unacknowledged messages that can be outstanding at each consumer.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">false # Whether publishing retries are enabled.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.initial-interval</span>=<span class="string">1000ms # Duration between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.max-interval</span>=<span class="string">10000ms # Maximum duration between attempts.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.multiplier</span>=<span class="string">1 # Multiplier to apply to the previous retry interval.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.stateless</span>=<span class="string">true # Whether retries are stateless or stateful.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.transaction-size</span>= <span class="string"># Number of messages to be processed between acks when the acknowledge mode is AUTO. If larger than prefetch, prefetch will be increased to this value.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.type</span>=<span class="string">simple # Listener container type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest # Login to authenticate against the broker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672 # RabbitMQ port.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false # Whether to enable publisher confirms.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">false # Whether to enable publisher returns.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.requested-heartbeat</span>= <span class="string"># Requested heartbeat timeout; zero for none. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.algorithm</span>= <span class="string"># SSL algorithm to use. By default, configured by the Rabbit client library.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.enabled</span>=<span class="string">false # Whether to enable SSL support.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.key-store-type</span>=<span class="string">PKCS12 # Key store type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.trust-store-type</span>=<span class="string">JKS # Trust store type.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.validate-server-certificate</span>=<span class="string">true # Whether to enable server side certificate validation.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.ssl.verify-hostname</span>=<span class="string">true # Whether to enable hostname verification.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.default-receive-queue</span>= <span class="string"># Name of the default queue to receive messages from when none is specified explicitly.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.exchange</span>= <span class="string"># Name of the default exchange to use for send operations.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.mandatory</span>= <span class="string"># Whether to enable mandatory messages.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.receive-timeout</span>= <span class="string"># Timeout for `receive()` operations.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.reply-timeout</span>= <span class="string"># Timeout for `sendAndReceive()` operations.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">false # Whether publishing retries are enabled.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">1000ms # Duration between the first and second attempt to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-attempts</span>=<span class="string">3 # Maximum number of attempts to deliver a message.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.max-interval</span>=<span class="string">10000ms # Maximum duration between attempts.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.multiplier</span>=<span class="string">1 # Multiplier to apply to the previous retry interval.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.routing-key</span>= <span class="string"># Value of a default routing key to use for send operations.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest # Login user to authenticate to the broker.</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>= <span class="string"># Virtual host to use when connecting to the broker.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># ACTUATOR PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MANAGEMENT HTTP SERVER (ManagementServerProperties)</span></span><br><span class="line"><span class="meta">management.server.add-application-context-header</span>=<span class="string">false # Add the &quot;X-Application-Context&quot; HTTP header in each response.</span></span><br><span class="line"><span class="meta">management.server.address</span>= <span class="string"># Network address to which the management endpoints should bind. Requires a custom management.server.port.</span></span><br><span class="line"><span class="meta">management.server.port</span>= <span class="string"># Management endpoint HTTP port (uses the same port as the application by default). Configure a different port to use management-specific SSL.</span></span><br><span class="line"><span class="meta">management.server.servlet.context-path</span>= <span class="string"># Management endpoint context-path (for instance, `/management`). Requires a custom management.server.port.</span></span><br><span class="line"><span class="meta">management.server.ssl.ciphers</span>= <span class="string"># Supported SSL ciphers.</span></span><br><span class="line"><span class="meta">management.server.ssl.client-auth</span>= <span class="string"># Client authentication mode.</span></span><br><span class="line"><span class="meta">management.server.ssl.enabled</span>=<span class="string">true # Whether to enable SSL support.</span></span><br><span class="line"><span class="meta">management.server.ssl.enabled-protocols</span>= <span class="string"># Enabled SSL protocols.</span></span><br><span class="line"><span class="meta">management.server.ssl.key-alias</span>= <span class="string"># Alias that identifies the key in the key store.</span></span><br><span class="line"><span class="meta">management.server.ssl.key-password</span>= <span class="string"># Password used to access the key in the key store.</span></span><br><span class="line"><span class="meta">management.server.ssl.key-store</span>= <span class="string"># Path to the key store that holds the SSL certificate (typically a jks file).</span></span><br><span class="line"><span class="meta">management.server.ssl.key-store-password</span>= <span class="string"># Password used to access the key store.</span></span><br><span class="line"><span class="meta">management.server.ssl.key-store-provider</span>= <span class="string"># Provider for the key store.</span></span><br><span class="line"><span class="meta">management.server.ssl.key-store-type</span>= <span class="string"># Type of the key store.</span></span><br><span class="line"><span class="meta">management.server.ssl.protocol</span>=<span class="string">TLS # SSL protocol to use.</span></span><br><span class="line"><span class="meta">management.server.ssl.trust-store</span>= <span class="string"># Trust store that holds SSL certificates.</span></span><br><span class="line"><span class="meta">management.server.ssl.trust-store-password</span>= <span class="string"># Password used to access the trust store.</span></span><br><span class="line"><span class="meta">management.server.ssl.trust-store-provider</span>= <span class="string"># Provider for the trust store.</span></span><br><span class="line"><span class="meta">management.server.ssl.trust-store-type</span>= <span class="string"># Type of the trust store.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CLOUDFOUNDRY</span></span><br><span class="line"><span class="meta">management.cloudfoundry.enabled</span>=<span class="string">true # Whether to enable extended Cloud Foundry actuator endpoints.</span></span><br><span class="line"><span class="meta">management.cloudfoundry.skip-ssl-validation</span>=<span class="string">false # Whether to skip SSL verification for Cloud Foundry actuator endpoint security calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS GENERAL CONFIGURATION</span></span><br><span class="line"><span class="meta">management.endpoints.enabled-by-default</span>= <span class="string"># Whether to enable or disable all endpoints by default.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS JMX CONFIGURATION (JmxEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.domain</span>=<span class="string">org.springframework.boot # Endpoints JMX domain name. Fallback to &#x27;spring.jmx.default-domain&#x27; if set.</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.exposure.include</span>=<span class="string">* # Endpoint IDs that should be included or &#x27;*&#x27; for all.</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.exposure.exclude</span>= <span class="string"># Endpoint IDs that should be excluded or &#x27;*&#x27; for all.</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.static-names</span>= <span class="string"># Additional static properties to append to all ObjectNames of MBeans representing Endpoints.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS WEB CONFIGURATION (WebEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">health,info # Endpoint IDs that should be included or &#x27;*&#x27; for all.</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>= <span class="string"># Endpoint IDs that should be excluded or &#x27;*&#x27; for all.</span></span><br><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/actuator # Base path for Web endpoints. Relative to server.servlet.context-path or management.server.servlet.context-path if management.server.port is configured.</span></span><br><span class="line"><span class="meta">management.endpoints.web.path-mapping</span>= <span class="string"># Mapping between endpoint IDs and the path that should expose them.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENDPOINTS CORS CONFIGURATION (CorsEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allow-credentials</span>= <span class="string"># Whether credentials are supported. When not set, credentials are not supported.</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allowed-headers</span>= <span class="string"># Comma-separated list of headers to allow in a request. &#x27;*&#x27; allows all headers.</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allowed-methods</span>= <span class="string"># Comma-separated list of methods to allow. &#x27;*&#x27; allows all methods. When not set, defaults to GET.</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.allowed-origins</span>= <span class="string"># Comma-separated list of origins to allow. &#x27;*&#x27; allows all origins. When not set, CORS support is disabled.</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.exposed-headers</span>= <span class="string"># Comma-separated list of headers to include in a response.</span></span><br><span class="line"><span class="meta">management.endpoints.web.cors.max-age</span>=<span class="string">1800s # How long the response from a pre-flight request can be cached by clients. If a duration suffix is not specified, seconds will be used.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AUDIT EVENTS ENDPOINT (AuditEventsEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.auditevents.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.auditevents.enabled</span>=<span class="string">true # Whether to enable the auditevents endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BEANS ENDPOINT (BeansEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.beans.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.beans.enabled</span>=<span class="string">true # Whether to enable the beans endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CACHES ENDPOINT (CachesEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.caches.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.caches.enabled</span>=<span class="string">true # Whether to enable the caches endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CONDITIONS REPORT ENDPOINT (ConditionsReportEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.conditions.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.conditions.enabled</span>=<span class="string">true # Whether to enable the conditions endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CONFIGURATION PROPERTIES REPORT ENDPOINT (ConfigurationPropertiesReportEndpoint, ConfigurationPropertiesReportEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoint.configprops.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.configprops.enabled</span>=<span class="string">true # Whether to enable the configprops endpoint.</span></span><br><span class="line"><span class="meta">management.endpoint.configprops.keys-to-sanitize</span>=<span class="string">password,secret,key,token,.*credentials.*,vcap_services,sun.java.command # Keys that should be sanitized. Keys can be simple strings that the property ends with or regular expressions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ENVIRONMENT ENDPOINT (EnvironmentEndpoint, EnvironmentEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoint.env.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.env.enabled</span>=<span class="string">true # Whether to enable the env endpoint.</span></span><br><span class="line"><span class="meta">management.endpoint.env.keys-to-sanitize</span>=<span class="string">password,secret,key,token,.*credentials.*,vcap_services,sun.java.command # Keys that should be sanitized. Keys can be simple strings that the property ends with or regular expressions.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FLYWAY ENDPOINT (FlywayEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.flyway.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.flyway.enabled</span>=<span class="string">true # Whether to enable the flyway endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEALTH ENDPOINT (HealthEndpoint, HealthEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoint.health.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.health.enabled</span>=<span class="string">true # Whether to enable the health endpoint.</span></span><br><span class="line"><span class="meta">management.endpoint.health.roles</span>= <span class="string"># Roles used to determine whether or not a user is authorized to be shown details. When empty, all authenticated users are authorized.</span></span><br><span class="line"><span class="meta">management.endpoint.health.show-details</span>=<span class="string">never # When to show full health details.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEAP DUMP ENDPOINT (HeapDumpWebEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.heapdump.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.heapdump.enabled</span>=<span class="string">true # Whether to enable the heapdump endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP TRACE ENDPOINT (HttpTraceEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.httptrace.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.httptrace.enabled</span>=<span class="string">true # Whether to enable the httptrace endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO ENDPOINT (InfoEndpoint)</span></span><br><span class="line"><span class="attr">info</span>= <span class="string"># Arbitrary properties to add to the info endpoint.</span></span><br><span class="line"><span class="meta">management.endpoint.info.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.info.enabled</span>=<span class="string">true # Whether to enable the info endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INTEGRATION GRAPH ENDPOINT (IntegrationGraphEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.integrationgraph.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.integrationgraph.enabled</span>=<span class="string">true # Whether to enable the integrationgraph endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JOLOKIA ENDPOINT (JolokiaProperties)</span></span><br><span class="line"><span class="meta">management.endpoint.jolokia.config.*</span>= <span class="string"># Jolokia settings. Refer to the documentation of Jolokia for more details.</span></span><br><span class="line"><span class="meta">management.endpoint.jolokia.enabled</span>=<span class="string">true # Whether to enable the jolokia endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LIQUIBASE ENDPOINT (LiquibaseEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.liquibase.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.liquibase.enabled</span>=<span class="string">true # Whether to enable the liquibase endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOG FILE ENDPOINT (LogFileWebEndpoint, LogFileWebEndpointProperties)</span></span><br><span class="line"><span class="meta">management.endpoint.logfile.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.logfile.enabled</span>=<span class="string">true # Whether to enable the logfile endpoint.</span></span><br><span class="line"><span class="meta">management.endpoint.logfile.external-file</span>= <span class="string"># External Logfile to be accessed. Can be used if the logfile is written by output redirect and not by the logging system itself.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LOGGERS ENDPOINT (LoggersEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.loggers.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.loggers.enabled</span>=<span class="string">true # Whether to enable the loggers endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REQUEST MAPPING ENDPOINT  (MappingsEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.mappings.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.mappings.enabled</span>=<span class="string">true # Whether to enable the mappings endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METRICS ENDPOINT (MetricsEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.metrics.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.metrics.enabled</span>=<span class="string">true # Whether to enable the metrics endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PROMETHEUS ENDPOINT (PrometheusScrapeEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.prometheus.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.prometheus.enabled</span>=<span class="string">true # Whether to enable the prometheus endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SCHEDULED TASKS ENDPOINT (ScheduledTasksEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.scheduledtasks.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.scheduledtasks.enabled</span>=<span class="string">true # Whether to enable the scheduledtasks endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SESSIONS ENDPOINT (SessionsEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.sessions.enabled</span>=<span class="string">true # Whether to enable the sessions endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SHUTDOWN ENDPOINT (ShutdownEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.shutdown.enabled</span>=<span class="string">false # Whether to enable the shutdown endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># THREAD DUMP ENDPOINT (ThreadDumpEndpoint)</span></span><br><span class="line"><span class="meta">management.endpoint.threaddump.cache.time-to-live</span>=<span class="string">0ms # Maximum time that a response can be cached.</span></span><br><span class="line"><span class="meta">management.endpoint.threaddump.enabled</span>=<span class="string">true # Whether to enable the threaddump endpoint.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HEALTH INDICATORS</span></span><br><span class="line"><span class="meta">management.health.db.enabled</span>=<span class="string">true # Whether to enable database health check.</span></span><br><span class="line"><span class="meta">management.health.cassandra.enabled</span>=<span class="string">true # Whether to enable Cassandra health check.</span></span><br><span class="line"><span class="meta">management.health.couchbase.enabled</span>=<span class="string">true # Whether to enable Couchbase health check.</span></span><br><span class="line"><span class="meta">management.health.defaults.enabled</span>=<span class="string">true # Whether to enable default health indicators.</span></span><br><span class="line"><span class="meta">management.health.diskspace.enabled</span>=<span class="string">true # Whether to enable disk space health check.</span></span><br><span class="line"><span class="meta">management.health.diskspace.path</span>= <span class="string"># Path used to compute the available disk space.</span></span><br><span class="line"><span class="meta">management.health.diskspace.threshold</span>=<span class="string">10MB # Minimum disk space that should be available.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.enabled</span>=<span class="string">true # Whether to enable Elasticsearch health check.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.indices</span>= <span class="string"># Comma-separated index names.</span></span><br><span class="line"><span class="meta">management.health.elasticsearch.response-timeout</span>=<span class="string">100ms # Time to wait for a response from the cluster.</span></span><br><span class="line"><span class="meta">management.health.influxdb.enabled</span>=<span class="string">true # Whether to enable InfluxDB health check.</span></span><br><span class="line"><span class="meta">management.health.jms.enabled</span>=<span class="string">true # Whether to enable JMS health check.</span></span><br><span class="line"><span class="meta">management.health.ldap.enabled</span>=<span class="string">true # Whether to enable LDAP health check.</span></span><br><span class="line"><span class="meta">management.health.mail.enabled</span>=<span class="string">true # Whether to enable Mail health check.</span></span><br><span class="line"><span class="meta">management.health.mongo.enabled</span>=<span class="string">true # Whether to enable MongoDB health check.</span></span><br><span class="line"><span class="meta">management.health.neo4j.enabled</span>=<span class="string">true # Whether to enable Neo4j health check.</span></span><br><span class="line"><span class="meta">management.health.rabbit.enabled</span>=<span class="string">true # Whether to enable RabbitMQ health check.</span></span><br><span class="line"><span class="meta">management.health.redis.enabled</span>=<span class="string">true # Whether to enable Redis health check.</span></span><br><span class="line"><span class="meta">management.health.solr.enabled</span>=<span class="string">true # Whether to enable Solr health check.</span></span><br><span class="line"><span class="meta">management.health.status.http-mapping</span>= <span class="string"># Mapping of health statuses to HTTP status codes. By default, registered health statuses map to sensible defaults (for example, UP maps to 200).</span></span><br><span class="line"><span class="meta">management.health.status.order</span>=<span class="string">DOWN,OUT_OF_SERVICE,UP,UNKNOWN # Comma-separated list of health statuses in order of severity.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTP TRACING (HttpTraceProperties)</span></span><br><span class="line"><span class="meta">management.trace.http.enabled</span>=<span class="string">true # Whether to enable HTTP request-response tracing.</span></span><br><span class="line"><span class="meta">management.trace.http.include</span>=<span class="string">request-headers,response-headers,cookies,errors # Items to be included in the trace.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO CONTRIBUTORS (InfoContributorProperties)</span></span><br><span class="line"><span class="meta">management.info.build.enabled</span>=<span class="string">true # Whether to enable build info.</span></span><br><span class="line"><span class="meta">management.info.defaults.enabled</span>=<span class="string">true # Whether to enable default info contributors.</span></span><br><span class="line"><span class="meta">management.info.env.enabled</span>=<span class="string">true # Whether to enable environment info.</span></span><br><span class="line"><span class="meta">management.info.git.enabled</span>=<span class="string">true # Whether to enable git info.</span></span><br><span class="line"><span class="meta">management.info.git.mode</span>=<span class="string">simple # Mode to use to expose git information.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># METRICS</span></span><br><span class="line"><span class="meta">management.metrics.distribution.maximum-expected-value.*</span>= <span class="string"># Maximum value that meter IDs starting-with the specified name are expected to observe.</span></span><br><span class="line"><span class="meta">management.metrics.distribution.minimum-expected-value.*</span>= <span class="string"># Minimum value that meter IDs starting-with the specified name are expected to observe.</span></span><br><span class="line"><span class="meta">management.metrics.distribution.percentiles.*</span>= <span class="string"># Specific computed non-aggregable percentiles to ship to the backend for meter IDs starting-with the specified name.</span></span><br><span class="line"><span class="meta">management.metrics.distribution.percentiles-histogram.*</span>= <span class="string"># Whether meter IDs starting with the specified name should publish percentile histograms.</span></span><br><span class="line"><span class="meta">management.metrics.distribution.sla.*</span>= <span class="string"># Specific SLA boundaries for meter IDs starting-with the specified name. The longest match wins.</span></span><br><span class="line"><span class="meta">management.metrics.enable.*</span>= <span class="string"># Whether meter IDs starting-with the specified name should be enabled. The longest match wins, the key `all` can also be used to configure all meters.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.api-token</span>= <span class="string"># AppOptics API token.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.batch-size</span>=<span class="string">500 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.connect-timeout</span>=<span class="string">5s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.host-tag</span>=<span class="string">instance # Tag that will be mapped to &quot;@host&quot; when shipping metrics to AppOptics.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.appoptics.uri</span>=<span class="string">https://api.appoptics.com/v1/measurements # URI to ship metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.config-refresh-frequency</span>=<span class="string">10s # Frequency for refreshing config settings from the LWC service.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.config-time-to-live</span>=<span class="string">150s # Time to live for subscriptions from the LWC service.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.config-uri</span>=<span class="string">http://localhost:7101/lwc/api/v1/expressions/local-dev # URI for the Atlas LWC endpoint to retrieve current subscriptions.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.eval-uri</span>=<span class="string">http://localhost:7101/lwc/api/v1/evaluate # URI for the Atlas LWC endpoint to evaluate the data for a subscription.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.lwc-enabled</span>=<span class="string">false # Whether to enable streaming to Atlas LWC.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.meter-time-to-live</span>=<span class="string">15m # Time to live for meters that do not have any activity. After this period the meter will be considered expired and will not get reported.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.atlas.uri</span>=<span class="string">http://localhost:7101/api/v1/publish # URI of the Atlas server.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.api-key</span>= <span class="string"># Datadog API key.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.application-key</span>= <span class="string"># Datadog application key. Not strictly required, but improves the Datadog experience by sending meter descriptions, types, and base units to Datadog.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.descriptions</span>=<span class="string">true # Whether to publish descriptions metadata to Datadog. Turn this off to minimize the amount of metadata sent.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.host-tag</span>=<span class="string">instance # Tag that will be mapped to &quot;host&quot; when shipping metrics to Datadog.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.datadog.uri</span>=<span class="string">https://app.datadoghq.com # URI to ship metrics to. If you need to publish metrics to an internal proxy en-route to Datadog, you can define the location of the proxy with this.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.api-token</span>= <span class="string"># Dynatrace authentication token.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.device-id</span>= <span class="string"># ID of the custom device that is exporting metrics to Dynatrace.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.technology-type</span>=<span class="string">java # Technology type for exported metrics. Used to group metrics under a logical technology name in the Dynatrace UI.</span></span><br><span class="line"><span class="meta">management.metrics.export.dynatrace.uri</span>= <span class="string"># URI to ship metrics to. Should be used for SaaS, self managed instances or to en-route through an internal proxy.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.auto-create-index</span>=<span class="string">true # Whether to create the index automatically if it does not exist.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.host</span>=<span class="string">http://localhost:9200 # Host to export metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.index</span>=<span class="string">metrics # Index to export metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.index-date-format</span>=<span class="string">yyyy-MM # Index date format used for rolling indices. Appended to the index name, preceded by a &#x27;-&#x27;.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.password</span>= <span class="string"># Login password of the Elastic server.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.timestamp-field-name</span>=<span class="string">@timestamp # Name of the timestamp field.</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.user-name</span>= <span class="string"># Login user of the Elastic server.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.addressing-mode</span>=<span class="string">multicast # UDP addressing mode, either unicast or multicast.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.duration-units</span>=<span class="string">milliseconds # Base time unit used to report durations.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.enabled</span>=<span class="string">true # Whether exporting of metrics to Ganglia is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.host</span>=<span class="string">localhost # Host of the Ganglia server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.port</span>=<span class="string">8649 # Port of the Ganglia server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.protocol-version</span>=<span class="string">3.1 # Ganglia protocol version. Must be either 3.1 or 3.0.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.rate-units</span>=<span class="string">seconds # Base time unit used to report rates.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.ganglia.time-to-live</span>=<span class="string">1 # Time to live for metrics on Ganglia. Set the multi-cast Time-To-Live to be one greater than the number of hops (routers) between the hosts.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.duration-units</span>=<span class="string">milliseconds # Base time unit used to report durations.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.enabled</span>=<span class="string">true # Whether exporting of metrics to Graphite is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.host</span>=<span class="string">localhost # Host of the Graphite server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.port</span>=<span class="string">2004 # Port of the Graphite server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.protocol</span>=<span class="string">pickled # Protocol to use while shipping data to Graphite.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.rate-units</span>=<span class="string">seconds # Base time unit used to report rates.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.graphite.tags-as-prefix</span>= <span class="string"># For the default naming convention, turn the specified tag keys into part of the metric prefix.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.api-token</span>= <span class="string"># Humio API token.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.connect-timeout</span>=<span class="string">5s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.repository</span>=<span class="string">sandbox # Name of the repository to publish metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.tags.*</span>= <span class="string"># Humio tags describing the data source in which metrics will be stored. Humio tags are a distinct concept from Micrometer&#x27;s tags. Micrometer&#x27;s tags are used to divide metrics along dimensional boundaries.</span></span><br><span class="line"><span class="meta">management.metrics.export.humio.uri</span>=<span class="string">https://cloud.humio.com # URI to ship metrics to. If you need to publish metrics to an internal proxy en-route to Humio, you can define the location of the proxy with this.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.auto-create-db</span>=<span class="string">true # Whether to create the Influx database if it does not exist before attempting to publish metrics to it.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.compressed</span>=<span class="string">true # Whether to enable GZIP compression of metrics batches published to Influx.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.consistency</span>=<span class="string">one # Write consistency for each point.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.db</span>=<span class="string">mydb # Tag that will be mapped to &quot;host&quot; when shipping metrics to Influx.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.password</span>= <span class="string"># Login password of the Influx server.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.retention-duration</span>= <span class="string"># Time period for which Influx should retain data in the current database.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.retention-shard-duration</span>= <span class="string"># Time range covered by a shard group.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.retention-policy</span>= <span class="string"># Retention policy to use (Influx writes to the DEFAULT retention policy if one is not specified).</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.retention-replication-factor</span>= <span class="string"># How many copies of the data are stored in the cluster.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.uri</span>=<span class="string">http://localhost:8086 # URI of the Influx server.</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.user-name</span>= <span class="string"># Login user of the Influx server.</span></span><br><span class="line"><span class="meta">management.metrics.export.jmx.domain</span>=<span class="string">metrics # Metrics JMX domain name.</span></span><br><span class="line"><span class="meta">management.metrics.export.jmx.enabled</span>=<span class="string">true # Whether exporting of metrics to JMX is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.jmx.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.password</span>= <span class="string"># Login password of the KairosDB server.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.uri</span>= <span class="string">localhost:8080/api/v1/datapoints # URI of the KairosDB server.</span></span><br><span class="line"><span class="meta">management.metrics.export.kairos.user-name</span>= <span class="string"># Login user of the KairosDB server.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.account-id</span>= <span class="string"># New Relic account ID.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.api-key</span>= <span class="string"># New Relic API key.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.newrelic.uri</span>=<span class="string">https://insights-collector.newrelic.com # URI to ship metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.descriptions</span>=<span class="string">true # Whether to enable publishing descriptions as part of the scrape payload to Prometheus. Turn this off to minimize the amount of data sent on each scrape.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.enabled</span>=<span class="string">true # Whether exporting of metrics to Prometheus is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.base-url</span>=<span class="string">localhost:9091 # Base URL for the Pushgateway.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.enabled</span>=<span class="string">false # Enable publishing via a Prometheus Pushgateway.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.grouping-key</span>= <span class="string"># Grouping key for the pushed metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.job</span>= <span class="string"># Job identifier for this application instance.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.push-rate</span>=<span class="string">1m # Frequency with which to push metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.prometheus.pushgateway.shutdown-operation</span>= <span class="string"># Operation that should be performed on shutdown.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.access-token</span>= <span class="string"># SignalFX access token.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.source</span>= <span class="string"># Uniquely identifies the app instance that is publishing metrics to SignalFx. Defaults to the local host name.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.step</span>=<span class="string">10s # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.signalfx.uri</span>=<span class="string">https://ingest.signalfx.com # URI to ship metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.export.simple.enabled</span>=<span class="string">true # Whether, in the absence of any other exporter, exporting of metrics to an in-memory backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.simple.mode</span>=<span class="string">cumulative # Counting mode.</span></span><br><span class="line"><span class="meta">management.metrics.export.simple.step</span>=<span class="string">1m # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.enabled</span>=<span class="string">true # Whether exporting of metrics to StatsD is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.flavor</span>=<span class="string">datadog # StatsD line protocol to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.host</span>=<span class="string">localhost # Host of the StatsD server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.max-packet-length</span>=<span class="string">1400 # Total length of a single payload should be kept within your network&#x27;s MTU.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.polling-frequency</span>=<span class="string">10s # How often gauges will be polled. When a gauge is polled, its value is recalculated and if the value has changed (or publishUnchangedMeters is true), it is sent to the StatsD server.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.port</span>=<span class="string">8125 # Port of the StatsD server to receive exported metrics.</span></span><br><span class="line"><span class="meta">management.metrics.export.statsd.publish-unchanged-meters</span>=<span class="string">true # Whether to send unchanged meters to the StatsD server.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.api-token</span>= <span class="string"># API token used when publishing metrics directly to the Wavefront API host.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.batch-size</span>=<span class="string">10000 # Number of measurements per request to use for this backend. If more measurements are found, then multiple requests will be made.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.connect-timeout</span>=<span class="string">1s # Connection timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.enabled</span>=<span class="string">true # Whether exporting of metrics to this backend is enabled.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.global-prefix</span>= <span class="string"># Global prefix to separate metrics originating from this app&#x27;s white box instrumentation from those originating from other Wavefront integrations when viewed in the Wavefront UI.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.num-threads</span>=<span class="string">2 # Number of threads to use with the metrics publishing scheduler.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.read-timeout</span>=<span class="string">10s # Read timeout for requests to this backend.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.source</span>= <span class="string"># Unique identifier for the app instance that is the source of metrics being published to Wavefront. Defaults to the local host name.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.step</span>=<span class="string">10s # Step size (i.e. reporting frequency) to use.</span></span><br><span class="line"><span class="meta">management.metrics.export.wavefront.uri</span>=<span class="string">https://longboard.wavefront.com # URI to ship metrics to.</span></span><br><span class="line"><span class="meta">management.metrics.use-global-registry</span>=<span class="string">true # Whether auto-configured MeterRegistry implementations should be bound to the global static registry on Metrics.</span></span><br><span class="line"><span class="meta">management.metrics.tags.*</span>= <span class="string"># Common tags that are applied to every meter.</span></span><br><span class="line"><span class="meta">management.metrics.web.client.max-uri-tags</span>=<span class="string">100 # Maximum number of unique URI tag values allowed. After the max number of tag values is reached, metrics with additional tag values are denied by filter.</span></span><br><span class="line"><span class="meta">management.metrics.web.client.requests-metric-name</span>=<span class="string">http.client.requests # Name of the metric for sent requests.</span></span><br><span class="line"><span class="meta">management.metrics.web.server.auto-time-requests</span>=<span class="string">true # Whether requests handled by Spring MVC, WebFlux or Jersey should be automatically timed.</span></span><br><span class="line"><span class="meta">management.metrics.web.server.max-uri-tags</span>=<span class="string">100 # Maximum number of unique URI tag values allowed. After the max number of tag values is reached, metrics with additional tag values are denied by filter.</span></span><br><span class="line"><span class="meta">management.metrics.web.server.requests-metric-name</span>=<span class="string">http.server.requests # Name of the metric for received requests.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># DEVTOOLS PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DEVTOOLS (DevToolsProperties)</span></span><br><span class="line"><span class="meta">spring.devtools.add-properties</span>=<span class="string">true # Whether to enable development property defaults.</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.enabled</span>=<span class="string">true # Whether to enable a livereload.com-compatible server.</span></span><br><span class="line"><span class="meta">spring.devtools.livereload.port</span>=<span class="string">35729 # Server port.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-exclude</span>= <span class="string"># Additional patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-paths</span>= <span class="string"># Additional paths to watch for changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.enabled</span>=<span class="string">true # Whether to enable automatic restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.exclude</span>=<span class="string">META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties,META-INF/build-info.properties # Patterns that should be excluded from triggering a full restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.log-condition-evaluation-delta</span>=<span class="string">true # Whether to log the condition evaluation delta upon restart.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.poll-interval</span>=<span class="string">1s # Amount of time to wait between polling for classpath changes.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.quiet-period</span>=<span class="string">400ms # Amount of quiet time required without any classpath changes before a restart is triggered.</span></span><br><span class="line"><span class="meta">spring.devtools.restart.trigger-file</span>= <span class="string"># Name of a specific file that, when changed, triggers the restart check. If not specified, any classpath file change triggers the restart.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># REMOTE DEVTOOLS (RemoteDevToolsProperties)</span></span><br><span class="line"><span class="meta">spring.devtools.remote.context-path</span>=<span class="string">/.~~spring-boot!~ # Context path used to handle the remote connection.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.proxy.host</span>= <span class="string"># The host of the proxy to use to connect to the remote application.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.proxy.port</span>= <span class="string"># The port of the proxy to use to connect to the remote application.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.restart.enabled</span>=<span class="string">true # Whether to enable remote restart.</span></span><br><span class="line"><span class="meta">spring.devtools.remote.secret</span>= <span class="string"># A shared secret required to establish a connection (required to enable remote support).</span></span><br><span class="line"><span class="meta">spring.devtools.remote.secret-header-name</span>=<span class="string">X-AUTH-TOKEN # HTTP header used to transfer the shared secret.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"><span class="comment"># TESTING PROPERTIES</span></span><br><span class="line"><span class="comment"># ----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.test.database.replace</span>=<span class="string">any # Type of existing DataSource to replace.</span></span><br><span class="line"><span class="meta">spring.test.mockmvc.print</span>=<span class="string">default # MVC Print option.</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>Properties</tag>
      </tags>
  </entry>
</search>
